<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>霁月荒馆</title>
  
  <subtitle>以今日之我与昨日之我战</subtitle>
  <link href="https://blog.xuwei.fun/atom.xml" rel="self"/>
  
  <link href="https://blog.xuwei.fun/"/>
  <updated>2024-04-07T16:52:10.910Z</updated>
  <id>https://blog.xuwei.fun/</id>
  
  <author>
    <name>Kino</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>量化投资从零到一（其一）</title>
    <link href="https://blog.xuwei.fun/2024/02/25/invest01/"/>
    <id>https://blog.xuwei.fun/2024/02/25/invest01/</id>
    <published>2024-02-25T14:30:00.000Z</published>
    <updated>2024-04-07T16:52:10.910Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>过去7年的证券交易经验，在一些交易行为上有了很大的提升，但是人的情绪却始终是无法控制的。<br>要真正做到”Make emotion work for you instead of against you.”，靠Kino的意志力基本不现实，所以2024最重要的一件事，还是将交易系统做出来，不能抱着完美主义的想法，而是从0到1，做一个不care编码质量的交易系统，能work就行。（这大概也是这几年社畜的收获之一：能忍受烂工程了）</p><p>在主观的交易行为上，要始终牢记“市场永远不缺赚钱的机会”（当然啦，市场也永远不缺亏钱的机会），其实这句话反应到具体的交易行为上基本等价于“做好仓位管理”+“谨慎进场，快速离场”。但区别在于，后者是指导行为的话语，而行为还是强烈被个人情绪左右，前者是控制情绪的话语，控制了情绪就控制了一切行为。</p><p>这样一回顾，自己运气其实还真不错，2021之前资金量很少，盈亏没有感觉，2022年是永远满仓永远热泪盈眶，没被爆头…2023真正开始严控风险，躲过了很多股票的腰斩甚至膝盖斩的单边下跌，而这些之前可能都是半仓甚至满仓。</p><p>（Fight！</p><span id="more"></span><h2 id="1-市场调研"><a href="#1-市场调研" class="headerlink" title="1. 市场调研"></a>1. 市场调研</h2><p>首先需要结合自身经验与准入门槛，做好市场调研。</p><ul><li>自身经验: 需要选择自身较为熟悉的市场, 对该市场的交易工具、交易规范、交易风险等有充分了解，最好是在此之前已经有交易经验的市场。</li><li>准入门槛: 不同市场的准入资格各不相同, 比如美股的量化交易已经非常成熟，在已有交易经验的基础上, 准入门槛几乎为0, 而A股就是另一番景象了。</li></ul><p>首先Kino从自身经验出发, 将范围框定在美股、港股、A股三个市场, 下面分别调研三个证券交易市场的准入门槛。</p><h3 id="1-1-美国证券市场"><a href="#1-1-美国证券市场" class="headerlink" title="1.1 美国证券市场"></a>1.1 美国证券市场</h3><p>针对美国证券市场, 只要有基础交易资格, 那么大陆客户常用的券商app(富途、老虎、盈透等)基本都有对应的交易API。<br>针对美股量化交易资格, 就简化成了如何获得美股基础交易资格?<br>对于中国大陆客户来说, 核心需要解决的问题有两个:</p><ul><li>合法券商开户</li><li>资金出入境</li></ul><p>券商开户原本是个比较简单的事, 早期只要下载富途、老虎app, 按照引导填写信息即可, 但由于监管原因, 此类跨境券商被打上了不合规的标签, 因此此类券商均逐步关闭了境内开户通道。<br>以Kino用的富途为例, 2022年12月31日起停止为中国境内投资者提供开户服务, 2023年5月19日起暂停为中国境内用户提供服务。这就增加了美股的开户和交易门槛，至于当下环境怎么能够进行美股开户，需要自寻出路了，Kino也并无研究。</p><p>资金出入境的难度一直以来倒是没什么大变化, 在</p><p>拥有了可以进行美股交易的券商账户, 且可以方便的进行资金出入后, 就可以正常进行美股交易了。</p><p>要想进一步做量化交易, 并没有额外门槛, 只是需要一些额外的软件环境而已, 仍以富途为例, 参考官方的<a href="https://openapi.futunn.com/futu-api-doc/trade/trade.html">API文档</a>, 逐步开始就行。</p><p>富途所需的软件下载链接如下:</p><pre class="line-numbers language-none"><code class="language-none">OpenD-Windows: https:&#x2F;&#x2F;www.futunn.com&#x2F;download&#x2F;fetch-lasted-link?name&#x3D;opend-windowsOpenD-macOS: https:&#x2F;&#x2F;www.futunn.com&#x2F;download&#x2F;fetch-lasted-link?name&#x3D;opend-macosOpenD-Ubuntu: https:&#x2F;&#x2F;www.futunn.com&#x2F;download&#x2F;fetch-lasted-link?name&#x3D;opend-ubuntuOpenD-CentOS: https:&#x2F;&#x2F;www.futunn.com&#x2F;download&#x2F;fetch-lasted-link?name&#x3D;opend-centos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-香港证券市场"><a href="#1-2-香港证券市场" class="headerlink" title="1.2 香港证券市场"></a>1.2 香港证券市场</h3><p>对于Kino来说, 香港证券市场, 和美国交易市场几乎完全相同, 都是富途开户, 利用富途API即可。</p><p>但对于其他人来说, 现在直接香港开户不太方便, 没有其他路径的情况下, 可能需要考虑走港股通的路径, 这种路径下, 对个人量化投资者可能就没有那么友好了。</p><h3 id="1-3-内地证券市场"><a href="#1-3-内地证券市场" class="headerlink" title="1.3 内地证券市场"></a>1.3 内地证券市场</h3><p>内地证券市场, 由于发展时间相对来说还是较短, 且独特体制下对于证券交易的监管, 也别有一番思路, 因此A股的量化交易, 实际上是有点门槛的, 对个人投资者尤甚。至少目前没有任何一家券商直接有官方文档, 简明扼要地提供交易API, 让人可以快速接入。</p><p>针对A股个人量化交易, 目前有几种方案:</p><ul><li>easytrader: 本质上是模拟按键… 既然官方不提供API, 但是各券商总是会提供交易软件的. 基于这个思路, 就有人开发了easytrader, 计算机上安装券商软件后, 在easytrader里编写策略, 真正交易时easytrader模拟调用券商软件的按键功能, 完成交易。</li><li>API破解: 从技术视角来看, 只要是网络通信, 用wireshark抓包, 分析接口数据和格式, 理论上总是能破解券商的交易API的, 然后自己编写策略直接调用。</li><li>Ptrade&#x2F;QMT: 这两个软件是由第三方的企业开发，券商采购接入其交易系统，提供给满足条件的个人投资者使用。Ptrade是由恒生电子开发，而QMT则由迅投开发，二者均支持python语言。Ptrade和QMT还是有很大的区别，其中一个是Ptrade是运行在券商服务器，个人用户只是在软件上面编写程序，最后程序是加密上传到券商服务器，然后在券商服务器进行运算，获取行情，下单。而QMT则是在本地电脑上运行，QMT从券商服务器或者迅投服务器拉取行情到本地，然后你的程序进行分析，下单，把下单指令再发到券商服务器。</li></ul><p>考虑到easytrader、API破解 不稳定、不合法，建议不要使用这些方式。<br>对ptrade和qmt进行调研后, 发现目前部分券商对这些资格的申请门槛较低, 网上找个对应券商的理财顾问, 按照要求开户即可。</p><h3 id="1-4-调研小结"><a href="#1-4-调研小结" class="headerlink" title="1.4 调研小结"></a>1.4 调研小结</h3><p>对Kino而言, 美股&#x2F;港股&#x2F;A股 各有优劣。<br>美股&#x2F;港股 量化交易准入门槛较低, 直接利用富途API就可以正常交易了, 但是美股&#x2F;港股 交易水平有限, 一直在亏损, 从未盈利, 且富途的交易合规性, 仍有变数。<br>A股 交易水平 尚可, 至少还是盈利水平, 但是交易准入门槛较高, 且特殊体制下针对量化的监管也存在不确定性, 很可能某天一纸令下就不能量化交易了。</p><p>因此还是尽量这三个市场都支持, 减少风险。美股&#x2F;港股 使用富途的API，A股使用国金的QMT。</p><h2 id="2-实施路径"><a href="#2-实施路径" class="headerlink" title="2. 实施路径"></a>2. 实施路径</h2><h3 id="2-1-资格申请"><a href="#2-1-资格申请" class="headerlink" title="2.1 资格申请"></a>2.1 资格申请</h3><p>富途是有存量账号的, 按照富途官方API文档开发即可。<br>A股QMT的资格, Kino找了国金的人, 按照流程申请了QMT资格, 收到邮件, 下载应用, 开始着手开发!</p><h3 id="2-2-技术选型"><a href="#2-2-技术选型" class="headerlink" title="2.2 技术选型"></a>2.2 技术选型</h3><p>技术选型上, 考虑到目前的开发经验和服务方限制, 使用Java+SpringBoot做工程化实践框架, 使用Python+FastAPI对接 QMT 的接口能力, 也就是用FastAPI将QMT包装一层, 通过接口暴露。数据存储使用PostgreSQL。</p><p>QMT只提供了Python包确实是一件很痛苦的事, 但是作为卑微的使用方, 只能有啥用啥, 先兼容着…</p><h3 id="2-3-架构设计"><a href="#2-3-架构设计" class="headerlink" title="2.3 架构设计"></a>2.3 架构设计</h3><p>从技术视角来看, 只要理解了证券交易的业务, 架构设计上基本都是大同小异。为了便于实现, 目前尽量简化, 至于更细节的地方, 未来有时间再说吧。<br>大体上如下图, 初始阶段核心需要做的是行情和交易:</p><p><img src="/images/invest/invest01_01.png" alt="架构设计图"></p><p>对于初学者, 稍微需要花点时间理解的地方, 是API网关层和SDK包.<br>只要能够理解miniQMT其实完全相当于富途的openD, 迅投的python包, 实际上就是富途的SDK, 在项目中就可以对不同平台进行抽象建模。</p><h3 id="2-4-项目命名"><a href="#2-4-项目命名" class="headerlink" title="2.4 项目命名"></a>2.4 项目命名</h3><p>命名是研发遇到的第一件最痛苦的事…<br>好在这个项目已经想了5年之久了, 命名是早就想好的, 就叫plutus, 而plutus的含义, 其实很直白: 普路托斯, 古希腊神话中的财富之神。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>从0到1很简单: 申请资格 -&gt; 搭建环境 -&gt; 认真阅读接口文档 -&gt; 开发测试<br>但是工作的经验告诉Kino, 难的从来都不是从0到1, 从0到1说出去很好听, 但当你真的要为自己的资金负责时, 到1是远远不够的…</p><p>PS: 如果有感兴趣的, 可以私聊, 代码仓库可以共享, 正好还可以共同开发. 毕竟代码是负债, 数据是资产, 做好各自的账号数据隔离就行.</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><p><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="">[1]</span></a></sup> Anonymous. “迅投知识库.” ThinkTrader, January 1, 2018. <a href="https://dict.thinktrader.net/">https://dict.thinktrader.net/</a>.<br><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="">[2]</span></a></sup> Anonymous. “富途API” Futu, April 4, 2024. <a href="https://openapi.futunn.com/futu-api-doc/">https://openapi.futunn.com/futu-api-doc/</a><br><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="">[3]</span></a></sup> Anonymous. “FastAPI” tiangolo, April 5, 2024. <a href="https://fastapi.tiangolo.com/zh/tutorial/">https://fastapi.tiangolo.com/zh/tutorial/</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h2&gt;&lt;p&gt;过去7年的证券交易经验，在一些交易行为上有了很大的提升，但是人的情绪却始终是无法控制的。&lt;br&gt;要真正做到”Make emotion work for you instead of against you.”，靠Kino的意志力基本不现实，所以2024最重要的一件事，还是将交易系统做出来，不能抱着完美主义的想法，而是从0到1，做一个不care编码质量的交易系统，能work就行。（这大概也是这几年社畜的收获之一：能忍受烂工程了）&lt;/p&gt;
&lt;p&gt;在主观的交易行为上，要始终牢记“市场永远不缺赚钱的机会”（当然啦，市场也永远不缺亏钱的机会），其实这句话反应到具体的交易行为上基本等价于“做好仓位管理”+“谨慎进场，快速离场”。但区别在于，后者是指导行为的话语，而行为还是强烈被个人情绪左右，前者是控制情绪的话语，控制了情绪就控制了一切行为。&lt;/p&gt;
&lt;p&gt;这样一回顾，自己运气其实还真不错，2021之前资金量很少，盈亏没有感觉，2022年是永远满仓永远热泪盈眶，没被爆头…2023真正开始严控风险，躲过了很多股票的腰斩甚至膝盖斩的单边下跌，而这些之前可能都是半仓甚至满仓。&lt;/p&gt;
&lt;p&gt;（Fight！&lt;/p&gt;</summary>
    
    
    
    <category term="technology" scheme="https://blog.xuwei.fun/categories/technology/"/>
    
    <category term="finance" scheme="https://blog.xuwei.fun/categories/technology/finance/"/>
    
    
    <category term="finance" scheme="https://blog.xuwei.fun/tags/finance/"/>
    
    <category term="invest" scheme="https://blog.xuwei.fun/tags/invest/"/>
    
  </entry>
  
  <entry>
    <title>关于支付的一切-其二（现代支付基础）</title>
    <link href="https://blog.xuwei.fun/2023/05/02/allAboutPayment02/"/>
    <id>https://blog.xuwei.fun/2023/05/02/allAboutPayment02/</id>
    <published>2023-05-02T08:51:00.000Z</published>
    <updated>2023-05-03T02:34:30.702Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>通过上一篇的讲解，我们大概了解了货币的发展历史，和现代信用货币的本质，但是既然当下的信用货币就是一个符号，就是转移债务债权的工具，具体到一笔交易中，如何进行货币的转移也就是支付，货币在各类机构中如何流转，这其中又有哪些基础知识。这一篇我们就来聊聊这些。</p><h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h2><h3 id="1-1-支付过程"><a href="#1-1-支付过程" class="headerlink" title="1.1 支付过程"></a>1.1 支付过程</h3><p>目前，支付过程的划分主要遵循国际清算银行( Bank for International Settlements, BIS)支付结算委员会(Payment and Settlement Systems, CPSS)的划分方法：将支付处理划分为三个标准化过程，即交易过程(transaction)、清算过程(clearing)、结算过程(settlement)。清算、结算又都包含在 交易后处理中(Post-trade processing)。</p><ul><li><p><input disabled="" type="checkbox"> 交易过程：包括支付的产生、确认和发送，特别是对交易有关各方的身份的确认、对支付工具的确认以及对支付能力的确认。</p></li><li><p><input disabled="" type="checkbox"> 清算过程：包含了收付款人金融机构之间交换支付工具以及计算金融机构之间待结算的债权，支付工具的交换也包含交易撮合、交易清分、数据收集等。</p></li><li><p><input disabled="" type="checkbox"> 结算过程：该过程是完成债权最终转移的过程，包括收集待结算的债权并进行完整性检验、保证结算资金具有可用性、结清金融结构之间的债权债务以及记录和通知各方。</p><p>支付过程是一个完整的过程，或者说，支付过程应该具有完整性。各个国家的相关部门，特别是中央银行和商业银行，为了保证支付交易的完整性，一般会关注用法律或法规的形式来保障交易中支付的安全性和完整性，也会使用技术和业务标准来规范支付过程。</p></li></ul><blockquote><p>小贴士：<br>  交易，又称贸易、交换、互市，是买卖双方对有价物品及服务进行互通有无的行为。可以是以货币为交易媒介的过程，也可以是以物易物，例如一只黄牛交换三只猪。</p></blockquote><blockquote><p>小贴士：清算结算之概念混淆<br>  清算(clearing)和结算(settlement)在国际上的定义如上所述，比较清晰，但是在中国境内，清算、结算经常混用，清算或者结算经常包含了clearing、settlement两个过程的含义，而据《支付清算理论与实务》所述，出现这种情况的原因，可能与如下事实有关：按照中国金融界传统习惯，一般将中央银行为其他商业银行提供的支付相关的服务称为“清算”，而将商业银行为企事业和个人客户提供的支付服务称为“银行结算”，简称“结算”，即中国金融界传统上是按照支付服务的层次进行划分的“清算”、“结算”，而国际上是按照支付功能定义的clearing、settlement。<br>  国内的这种定义理论上不严谨，且存在各种混淆的用法，因此实际使用中，还是建议使用国际标准定义，但由于现存的各类书籍、文档等资源，已经有很多混淆的用法，因此了解背后的原因，有利于在查阅资源时，不被误导。且当前的支付系统中，也有部分“清分”、“清偿”的说法，这种对应的比较明确，“清分”就是clearing，“清偿”就是settlement。</p></blockquote><p>  回顾历史，结算机构的出现是理所当然的，银行持有客户账户，在账户间进行最终债务债权的转移确认，是天然的结算机构，但是纯清算机构出现的就相对较晚，此外兼具清算、结算功能的机构也广泛存在，如代理银行(correspondent bank)。<strong>区别纯清算机构有个简单的方法，纯清算机构不持有其成员机构的账户，而持有客户的结算账户是结算银行或结算机构的必要条件之一。</strong></p><h3 id="1-2-支付分类"><a href="#1-2-支付分类" class="headerlink" title="1.2 支付分类"></a>1.2 支付分类</h3><p>按照支付方向，支付可以分为借记支付和贷记支付：</p><ul><li><input disabled="" type="checkbox"> 贷记支付：如果支付的发起方是付款方，称为贷记支付</li><li><input disabled="" type="checkbox"> 借记支付：如果支付的发起方是收款方，称为借记支付</li></ul><p>一般来说，贷记支付支持实时支付、支付风险小、支付时效高。而借记支付一般需要将支付工具返回签发银行，签发银行对支付工具的真伪和资金的的可用性进行验证，因此借记支付一般存在时延，并且存在一定的支付风险，比如空头支票问题。</p><p>按照清算模式，支付可以分为实时支付与延时支付：</p><ul><li><input disabled="" type="checkbox"> 实时支付：指对每一笔支付即时发送、逐笔核算、实时清算和实时结算。</li><li><input disabled="" type="checkbox"> 延时支付：也称净额支付，指不需立即结算每一笔原始的支付，而在约定的某一时刻，对所有对原始支付进行轧差计算，支付机构仅对清算后的净值进行结算。清算的时间间隔称为一个清算场次，清算的时间点称为日切或场切。</li></ul><p>实时支付的优点是支付及时、瞬间到账，解决了延时支付可能导致的信用风险问题，解决了在途资金问题，缺点是由于每一笔支付都需要足额的资金头寸，因此流动性需求较大，流动性管理要求较高，相对于延时支付而言，支付成本较高。延时支付的优点是资金占用量小、支付效率高，支持的支付工具种类多，支付成本较低，对支付创新支持程度好，缺点是信用风险高，资金结算存在时延。为了控制延时系统的风险，一般通过法律或协议的形式，预先规定保证金的金额，同时规定在发生损失时，幸存的参与各方承担的损失比例。</p><p>按照支付规模，支付可以分为批发支付与零售支付：</p><ul><li><input disabled="" type="checkbox"> 批发支付(wholesale payment)：通常将为金融机构提供的支付服务称为批发支付。</li><li><input disabled="" type="checkbox"> 零售支付(retail payment)：通常将为企业和个人提供的支付称为零售支付。</li></ul><p>批发支付的特点是金额巨大，风险敏感，零售支付的特点是支付笔数多，支付工具灵活。</p><h3 id="1-3-支付工具"><a href="#1-3-支付工具" class="headerlink" title="1.3 支付工具"></a>1.3 支付工具</h3><p>  支付工具：支票、汇票、本票、汇兑、委托付款、银行卡等。支付工具是传递收付款人支付指令，实现债务债券关系清偿和资金转移的载体，其中的支付指令指付款人或收款人要求其支付服务提供者执行支付交易的命令。简单来说，支付工具是一个载体，其功能是在付款人和收款人之间转移支付的货币资金。<br>  根据介质，可以将支付工具分为纸质票据支付工具和卡基支付工具。</p><ul><li><p><input disabled="" type="checkbox"> 纸质票据：支票、汇票、本票… </p></li><li><p><input disabled="" type="checkbox"> 卡基支付：借记卡、信用卡、预付卡…</p><p>根据支付的贷记、借记方向，可分为借记支付工具、贷记支付工具。</p></li><li><p><input disabled="" type="checkbox"> 借记支付：支票、汇票、借记卡、定期借记…</p></li><li><p><input disabled="" type="checkbox"> 贷记支付：汇兑、托收承付、信用卡、定期贷记…</p></li></ul><p><em>Table 1.1 支付工具示例</em></p><table><thead><tr><th><strong>类别</strong></th><th><strong>名称</strong></th><th><strong>使用范围及特点</strong></th></tr></thead><tbody><tr><td>传统支付工具</td><td>汇兑</td><td>用于商业、政府、银行间及个人消费者异地、同成资金划拨和支付</td></tr><tr><td></td><td>汇票</td><td>用于异地的商业、消费或其他支付</td></tr><tr><td></td><td>支票</td><td>用于全国范围内的商业和个人消费性支付</td></tr><tr><td></td><td>本票</td><td>用于票据交换范围内的商业和个人消费性支付</td></tr><tr><td></td><td>借记卡</td><td>用于全国范围内的商业和个人消费性支付</td></tr><tr><td></td><td>信用卡</td><td>用于全国范围内的商业和个人消费性支付</td></tr><tr><td></td><td>定期贷记</td><td>用于同城或异地的定期支付，如个人工资、保险金发放的支付</td></tr><tr><td></td><td>实时贷记</td><td>用于通存业务、代收付中心发起的实时代付业务等业务</td></tr><tr><td></td><td>托收承付</td><td>用于异地的商业性支付，资金划回收款人时通过支付系统处理</td></tr><tr><td></td><td>委托收款</td><td>主要用于同城和异地的商业性支付，资金划回收款人时通过支付系统处理</td></tr><tr><td></td><td>旅行支票</td><td>未来提供给个人用于异地旅行时的消费性支付</td></tr><tr><td></td><td>定期借记</td><td>用于同城或异地的支付，如房租、水电费、电话费、税款的收取</td></tr><tr><td></td><td>实时借记</td><td>用于通兑业务、代收付中心发起的实时代收业务</td></tr><tr><td></td><td>商业汇票</td><td>通过银行委托收款，资金划回时通过支付系统处理</td></tr><tr><td></td><td>国内信用证</td><td>用于异地商业性支付</td></tr><tr><td></td><td>网银贷记支付</td><td>用于客户或第三方支付服务组织依照客户委托，依托互联网发起的电子支付业务</td></tr><tr><td>新兴支付工具</td><td>电子票据</td><td>用户全国范围内的商业和个人支付</td></tr><tr><td></td><td>储值卡</td><td>用于区域范围内的商业和个人消费性支付</td></tr><tr><td></td><td>行业卡</td><td>用于某行业范围内的商业和个人消费性支付，如公交卡</td></tr><tr><td></td><td>虚拟账户</td><td>用户互联网上交易的支付</td></tr></tbody></table><h3 id="1-4-支付市场"><a href="#1-4-支付市场" class="headerlink" title="1.4 支付市场"></a>1.4 支付市场</h3><p>  支付市场指支付服务提供者和支付服务使用者通过支付工具、支付系统完成支付活动的市场。支付市场的参与者主要包括中央银行、商业银行、清算组织和各种证券保险等金融机构等。支付市场的构成十分复杂，可以由许多不同的市场组成一个庞大的体系，可以细分为大额支付市场、小额支付市场、外币支付市场、证券支付市场等，各个市场可能存在交叉重合，一般情况下，按照支付的规模，支付市场可以划分为批发支付市场和零售支付市场。</p><ul><li><p><input disabled="" type="checkbox"> 批发支付市场的主要提供者是中央银行、各金融市场组织和行业协会等，服务对象为商业银行、证券公司、基金公司、保险公司和其他特许金融机构或组织。</p></li><li><p><input disabled="" type="checkbox"> 零售支付市场的主要提供者是银行类金融机构和其他支付机构，如商业银行、信用社、银行卡收单机构、各种电子货币服务机构，零售市场主要面向企事业单位和个人提供多种支付服务。</p><p>按照其他各类维度还可以划分为 “银间支付市场&#x2F;非银支付市场”、“双边支付市场&#x2F;单边支付市场”、“跨境支付市场&#x2F;境内支付市场”等…</p></li></ul><h3 id="1-5-支付作用"><a href="#1-5-支付作用" class="headerlink" title="1.5 支付作用"></a>1.5 支付作用</h3><p>现代支付系统在经济社会中，有以下重要和独特的作用：</p><ul><li><input disabled="" type="checkbox"> 减少现金使用量，提高<strong>资金使用效率</strong>。比如多边净额清算使用较小的流动货币撬动较大金额的交易、实时支付减少了在途资金的数量。</li><li><input disabled="" type="checkbox"> 节约社会支付成本，提高<strong>支付效率</strong>。</li><li><input disabled="" type="checkbox"> 降低交易风险，提高经济社会抗风险程度。</li><li><input disabled="" type="checkbox"> 密切各金融市场有机联系，畅通货币政策传导。</li><li><input disabled="" type="checkbox"> 支付数据是经济预测、研究和制定各项政策的重要依据。</li></ul><h2 id="2-支付演进"><a href="#2-支付演进" class="headerlink" title="2. 支付演进"></a>2. 支付演进</h2><p>  支付的目的是为了完成交易，支付的媒介是货币，支付是货币转移的一个过程，而随着货币的演进，支付也是在不断演进的。所谓“支付是交易过程的终点、货币流动的起点”。</p><h3 id="2-1-实体货币阶段"><a href="#2-1-实体货币阶段" class="headerlink" title="2.1 实体货币阶段"></a>2.1 实体货币阶段</h3><p>  物物交换时，直接交易无需货币，自然也就没有支付的概念，当货币演进为实体货币时，包括实物货币与信用货币中的实体形式，支付是货币的实体从一方转移到另一方的过程，此时的支付也很简单，一手交货一手交钱，不需要太多复杂的系统，或者称之为“交易即结算”、“支付即结算”。你问眼花看错了，多付少收了怎么办？那就… 看下有没有摄像头、或者求一求交易对手方好了。</p><h3 id="2-2-账户货币阶段"><a href="#2-2-账户货币阶段" class="headerlink" title="2.2 账户货币阶段"></a>2.2 账户货币阶段</h3><p>  当货币开始以账户数字出现时，交易的过程就有了变复杂的可能性，而当支付工具蓬勃发展后，支付真正从量变产生了质变。</p><h4 id="1）支付工具演进：存折-x2F-支票-x2F-银行卡…"><a href="#1）支付工具演进：存折-x2F-支票-x2F-银行卡…" class="headerlink" title="1）支付工具演进：存折&#x2F;支票&#x2F;银行卡…"></a>1）支付工具演进：存折&#x2F;支票&#x2F;银行卡…</h4><p><img src="/images/all_about_payment/all_about_payment02_01.jpg" alt="Passbook" title="存折"><br>  在初始阶段，银行等信用机构对个人主要还是执行存款、贷款的业务，回想一下小时候家里存款，还没有银行卡，存款之后都是拿着存折回去。现在这种形式很少看到了，也许探寻一下农村信用社还可觅得。（什么？你说你是00后根本没听过存折？那Kino只能承认自己老了…）<br>  这种背景下，上一篇所说的各种制度并没有变化，依旧是部分准备金制度，货币依然以数字的形式存在了银行为你开设的账号中，这时的货币也就是债务，银行记录下了欠你的债务数字，存折是一种标准化的、受法律保护的、记录个人对银行债权的小本本。凭借存折，个人能做的就是在某一时间向银行存取现金或者支取原本属于自己的现金。<br>  换言之，早期提供的存折很难用于交易。这时社会上的交易，大部分还是通过现金完成的，包工头给工人发工资时背着一大袋现金，去商店买根冰棍需要带好现金，饭店就餐、酒店住宿全都得带现金，否则就寸步难行。</p><p><img src="/images/all_about_payment/all_about_payment02_02.jpg" alt="Cheque" title="支票"><br>  小额交易如此尚可，几百万的现金包工头体力尚可，还能背得动，可是既然个人存款就是银行的数字，难道就没有什么方法，不需要背着现金到处跑，就可以完成支付吗？当然有，现金之外的支付工具——支票出现了，付款方在银行A有存款，签发一张100的支票，持票人就可以凭此票去银行B取现或者转账了，相当于银行B替银行A垫付了100，而银行A和B之间的债权债务关系，可以后续再处理，这样一来就不用背着现金到处跑了。这就是早期的纸质票据支付工具。<br><img src="/images/all_about_payment/all_about_payment02_03.jpg" alt="PrivateBanking" title="借记卡"><br><img src="/images/all_about_payment/all_about_payment02_04.jpg" alt="BankCard" title="信用卡"><br>   但是支票这类纸质票据，也只有在频率较低的集中性支付场景中能够带来便利，去小卖部买个东西，还要开支票，这当然是不现实的，所以后来又进一步出现了银行卡、移动支付等更为便捷的支付工具。<br>  至于银行A和B之间的债务债权关系的处理，就涉及了现代支付的清算清偿过程。</p><h4 id="2）清算清偿演进：手工联行-x2F-电子联行-x2F-央行大小额…"><a href="#2）清算清偿演进：手工联行-x2F-电子联行-x2F-央行大小额…" class="headerlink" title="2）清算清偿演进：手工联行&#x2F;电子联行&#x2F;央行大小额…"></a>2）清算清偿演进：手工联行&#x2F;电子联行&#x2F;央行大小额…</h4><p><img src="/images/all_about_payment/all_about_payment02_05.png" alt="手工联行工作流程" title="手工联行工作流程"><br><img src="/images/all_about_payment/all_about_payment02_06.png" alt="联行报单" title="联行报单"><br><img src="/images/all_about_payment/all_about_payment02_07.jpg" alt="委托收款凭证（回单）" title="委托收款凭证（回单）"></p><p>  银行A&#x2F;B之间一天产生了很多债权债务关系，假设只有上面100的支票，这时B行垫付的钱还没有收到，需要通知A行这笔业务，但是怎么通知呢？B行需要手动填制联行报单，作为收款行需要转送委托收款凭证、提供收款依据，而途径就是邮寄或电报，A行收到凭证后，进行确认后才能做最终结算。如何结算又是个问题，由于支票是收款方发起的借记业务，实际上是需要A行打款给B行，但是这笔资金怎么真实到账？一种方法是，运钞车从A运送到B，这笔钱在途中根本无法使用，估计这就是“在途资金”最形象的解释了。</p><p><img src="/images/all_about_payment/all_about_payment02_08.png"></p><p>  这种方式当然不方便，另一种方法就是A、B互开往来户，A在B行开户存个10000，B在A行开户存个10000，这部分钱就叫备付金，每天结束后，业务人员算清点完借记、贷记支付金额，轧差之后就知道是A、B间的账到底怎么记录了。而无论怎么哪种方式，总有一部分资金在核对过程中无法使用，也就是“在途资金”，据相关文档，平均在途时间需要5天，部分甚至高达10天以上。而如果考虑到除了A&#x2F;B之间，还有A&#x2F;C、B&#x2F;C等无数银行组合，手工联行业务必然会越来越难以为继<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="许成军. “与金融电子化同行——全国电子联行系统(EIS)建设始末.” 金融电子化 10(2019):3.">[1]</span></a></sup>。</p><p><img src="/images/all_about_payment/all_about_payment02_09.png" alt="image.png"><br><img src="/images/all_about_payment/all_about_payment02_10.jpg" alt="image.png"></p><p>  为了解决手工联行的种种问题，一种直观的解决方法就是将“联行报单、委托收款凭证、收款依据”等凭证电子化，这样就来到了“电子联行”的时代。从这个命名也可以看出，“电子联行”的核心是将“手工联行”升级为电子化，但是本质的体系机构没有太大改变，仍然是商业银行与商业银行之间相互清结算，如果有N个银行，两两之间的组合关系就是 <code>N*(N-1)/2</code> 种，系统的复杂度并没有简化。</p><p><img src="/images/all_about_payment/all_about_payment02_11.png"></p><p>  联行模式如此复杂，不禁让人思考，该怎么彻底解决问题呢？回忆起“关于支付的一切-其一”中提到过央行的“发行的银行、银行的银行、政府的银行”三个银行的说法，才发现早期央行并没有承担太多“银行的银行”这一角色的职责，因此想要彻底解决问题，就需要央行出手，建立一套中心系统，设定一套标准规则，商业银行之间可以不再互开账户，而都是在一个中心系统开设账户，所有银行之间的支付指令也过中心系统，最后由中心系统做清算结算。这就是后来出现的集中清算机构、央行的大小额支付系统等，一系列系统合在一起组成了中国现代化支付系统（CNAPS），央行终于承担了这个中间人的角色。相关的系统建设，主要集中在央行的直属机构“中国人民银行清算总中心”和“中国金融电子化公司”，级别上应该等同于央行省分行<sup id="fnref:21"><a href="#fn:21" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="中国人民银行办公厅. “中国人民银行直属机构”中国人民银行, 04 Apr. 2023, [http://www.pbc.gov.cn/rmyh/105226/105442/index.html#%E7%9B%B4%E5%B1%9E%E6%9C%BA%E6%9E%84](http://www.pbc.gov.cn/rmyh/105226/105442/index.html#%E7%9B%B4%E5%B1%9E%E6%9C%BA%E6%9E%84).">[21]</span></a></sup>。</p><blockquote><p>小贴士：一百元的人民币纸币重量为1.15g，一百万的人民币重量大概为11.5kg。<br><img src="/images/all_about_payment/all_about_payment02_12.jpg" alt="millionRmb.jpg"></p></blockquote><blockquote><p>小贴士：划回是持票人开户银行接到付款人开户银行寄来的联行报单和委托收款凭证或拍来的电报，应按照委托收款的款项划回手续处理。分邮寄和电报划回两种，由收款人选用。前者是以邮寄方式由收款人开户银行向付款人开户银行转送委托收款凭证、提供收款依据的方式‚后者则是以电报方式由收款人开户银行向付款人开户银行转送委托收款凭证‚提供收款依据的方式。</p></blockquote><h3 id="2-3-相应系统演进"><a href="#2-3-相应系统演进" class="headerlink" title="2.3 相应系统演进"></a>2.3 相应系统演进</h3><p>  不难看出，支付的演进过程，是围绕着让交易<code>**更简单、更高效、更安全**</code>来进行的。而作为底层基础设施的支付系统，也一定会伴随着不同支付工具的出现而不断进化。<br><img src="/images/all_about_payment/all_about_payment02_13.png" alt="image.png"><br>  以支票为例，银行A和B之间需要对支票的金额进行结算，还需要把支票从B送给A，然后再将A的钱运输给B，这样只是将个人的支付复杂性集中到了银行处理，而且如前所述，支票作为借记支付本身风险较高，那如果有人利用信息差伪造支票怎么办？电影 _Catch me if you can _中生动地呈现了伪造支票获利的场景。受到这些限制，中国支票早期基本只在同一城市范围内使用，直到2007年“全国支票影像交换系统”正式建设推广完成，支票这种支付工具变得更加便捷与安全，使用范围更广，具体的系统能力不在此详述。<br>  在零售交易市场，支票还是不够方便，因此又出现了银行卡，为了推进银行卡支付的清算，国内又出现了银联这种清算机构，而其中的支付系统自然也需要新建。<br>  而在电商交易蓬勃发展之际，原有的银行卡支付还是不够便捷，互联网第三方支付工具（如支付宝）应运而生，为了规范第三方支付，后来又出现了网联。<br>  支付系统就是这样不断地演进，最终组成了现在的支付体系。而纵观全球，只要解决的问题是相同的，那么其支付系统的演进也都是类似的。</p><blockquote><p>小贴士：数字货币发展之际，中国人民银行也开始推进另一种支付工具：数字人民币，对应数字支付的 DC&#x2F;EP 系统。</p></blockquote><h2 id="3-账务处理"><a href="#3-账务处理" class="headerlink" title="3. 账务处理"></a>3. 账务处理</h2><p>  当货币演进到账户货币时，账户中的数字变动，反映到账户持有人就是直接的资产变化，如何规范、准确地记账成为现代支付的核心问题，而由记账衍生出的一整套流程，称之为账务，账务的定义为：<code>“账务是指实现会计处理进行原始单证的收集、整理、记载、计算、结报等会计处理的具体事务，它要求规范、准确，保证会计核算、会计监督和会计准则的有效实施。”</code>账务的英文是Accounting，会计的英文是Accounting，当我们谈论账务时，我们也就是在讨论会计。<br>  不夸张的说，现代支付体系的基石就是会计，正如在“关于支付的一切-其一（货币是什么）”中所述，货币发展到账户货币阶段，本质就是主体间的债务债权关系，反映了主体的信用强度，这些都体现在账本的数字上，而支付就是货币的转移过程，如何记账成为重中之重，记账成功，债务债权关系就确立了，等同于支付成功，对于央行来说，记账成功甚至基本等同于货币转移成功。<br>  虽然会计(Accounting)的最核心的要点就是准确的记账，但想要做好这一点并不容易，为了解决这一环节中的各种问题，会计上提出了一系列的工具和方法，而为了深刻理解支付系统的基础，有必要介绍一些会计的基础概念。</p><h3 id="3-1-会计循环"><a href="#3-1-会计循环" class="headerlink" title="3.1 会计循环"></a>3.1 会计循环</h3><p><img src="/images/all_about_payment/all_about_payment02_14.png" alt="会计循环（Accounting Cycle）" title="会计循环（Accounting Cycle）"><br>  了解会计基础的第一点就是认识到会计是具有周期性的，这个周期可以大到一年一次，也可以小到一天一次，在这个周期内，需要一种基于经验主义的流程，保证处理过程的标准化，而这个标准过程就是会计循环。会计循环大致有上图所示的8个步骤，有时合并为7个或者细化为9个，也都是可取的，不影响最终结果就行。</p><ul><li><input disabled="" type="checkbox"> 编审凭证：收集业务原始凭证、交易记录、小票、发票等；</li><li><input disabled="" type="checkbox"> 生成会计凭证：按照财务规范编写会计凭证或者会计分录；</li><li><input disabled="" type="checkbox"> 过账：将凭证记录到账簿的过程；</li><li><input disabled="" type="checkbox"> 试算平衡：对账簿各类账务之间按照一定规则校验借贷是否相等的校验过程；</li><li><input disabled="" type="checkbox"> 调整：如果试算不平衡，那么对有问题的账务进行调整从新试算直到平衡；</li><li><input disabled="" type="checkbox"> 结账：会计周期末，对相关账务进行结转的账务处理，入收入和费用结转到利润科目；</li><li><input disabled="" type="checkbox"> 报表：根据本期总分记账记录，生成各类会计报表。</li></ul><h3 id="3-2-会计凭证"><a href="#3-2-会计凭证" class="headerlink" title="3.2 会计凭证"></a>3.2 会计凭证</h3><ul><li><input disabled="" type="checkbox"> Q：怎么能保证账户里每一笔钱的进出，都有迹可循呢？不会是出纳自己监守自盗呢？</li><li><input disabled="" type="checkbox"> A：使用会计凭证，会计凭证是记录经济业务事项的发生和完成情况，明确经济责任，并作为记账依据的书面证明，是会计资料的重要组成部分。</li></ul><p><img src="/images/all_about_payment/all_about_payment02_15.jpg" alt="PaymentVoucher" title="付款凭证"></p><p><img src="/images/all_about_payment/all_about_payment02_16.jpg" alt="NostroVoucher" title="收款凭证"></p><p><img src="/images/all_about_payment/all_about_payment02_17.jpg" alt="TransferVoucher" title="转账凭证"></p><h3 id="3-3-会计科目"><a href="#3-3-会计科目" class="headerlink" title="3.3 会计科目"></a>3.3 会计科目</h3><p>  而要对每一笔支付过程进行记账，如果毫无分类，只是单纯按照时间顺序依次记在账本中，后续维护、核对会极为复杂，为此有必要对记账进行分类，这些类别就称为会计科目。会计科目有多重要呢？这么说吧，央行发布的“银行会计基本规范指导意见”第十二条：<code>银行应根据国家统一的金融企业会计制度和财政部、中国人民银行制定的统一会计科目，结合本行实际制定会计科目，并报中国人民银行备案。</code><br>  也就是说，银行的会计科目不是你想改就改的，记账的分类就那些，至于企业，通常一级会计科目也是使用国家统一规定的，往下细分可以每个企业自行调整。<br>  在大类上，参考“银行会计基本规范指导意见”第十一条：<code>会计科目分为资产类、负债类、资产负债共同类、所有者权益类、损益类及表外科目。表外科目核算银行表外业务。</code>会计科目表可参考附录7.1。<br>  总而言之，会计科目就是最顶层的设计，确定清楚了账务的分类，定义清楚了会计科目，是任何账务系统的起点。</p><h3 id="3-4-会计账户"><a href="#3-4-会计账户" class="headerlink" title="3.4 会计账户"></a>3.4 会计账户</h3><p>  有了会计科目之后，就可以根据会计科目在账簿中开设账户了，而会计科目就是这个账户的名称，这里的账户具有一定格式，是会计核算的一种专门方法，用作系统、连续的记录各项经济业务的一种手段。</p><ul><li>账户名称：即会计科目</li><li>账户余额：即当期余额</li><li>记账日期：经纪业务发生的时间</li><li>记账摘要：即经纪业务发生的内容摘要</li><li>凭证号码：即账户记录的来源和依据</li><li>变动金额：即增加和减少的金额</li></ul><h3 id="3-5-会计分录"><a href="#3-5-会计分录" class="headerlink" title="3.5 会计分录"></a>3.5 会计分录</h3><p>  还记得之前我们提过的<code>有借必有贷，借贷必相等</code>吗，在对会计账户进行记账的时候，一定是要遵循这个原则的。在会计循环中，也可以看到第二步就是生成 会计凭证&#x2F;会计分录，但是上面没有提到的是，会计分录都是成对出现的，这就是为了符合复式记账的要求<code>有借必有贷，借贷必相等</code>。什么是借，什么是贷，这又涉及到了刚刚会计科目的内容，科目中有资产项、负债项，当资产项增加、负债项减少时，就是借，当资产项减少、负债项增加时，就是贷。<br>  举个简单的例子，公司A 有 10000 的银行存款，付款 2000 给公司B，购买了 价值2000的原材料，那对应的会计分录就是：</p><ul><li><p><input disabled="" type="checkbox"> 贷记 银行存款 2000</p></li><li><p><input disabled="" type="checkbox"> 借记 原材料 2000</p><p>公司A又向公司C借入了2000，对应的会计分录就是：</p></li><li><p><input disabled="" type="checkbox"> 贷记 应付账款 2000</p></li><li><p><input disabled="" type="checkbox"> 借记 银行存款 2000</p><p>问题是，每天无数的交易之后，A如何快速知道现在不同科目下的账务呢？这就可以查看上面提到的会计账户了。</p></li></ul><h3 id="3-6-账套"><a href="#3-6-账套" class="headerlink" title="3.6 账套"></a>3.6 账套</h3><p>  再来考虑实际记账时，一个公司家大业大，子公司遍地开花，这种情况下，甚至每个子公司的经营范围差异过大，二级、三级会计科目都各不相同，自然不能混在一起记账，一定会使用独立的账本。<br>  而账套就是指存放会计核算对象的所有会计业务数据文件的总称，账套中包含的文件有会计科目、记账凭证、会计账簿、会计报表等。这个核算对象可以是企业的一个分部，也可以是整个企业集团。<br>  对于国际化业务来说，此时不仅有多主体的存在，还可能有多币种的存在，针对每个币种也需要有单独的账套。</p><h2 id="4-客户账户"><a href="#4-客户账户" class="headerlink" title="4. 客户账户"></a>4. 客户账户</h2><h3 id="4-1-账户概览"><a href="#4-1-账户概览" class="headerlink" title="4.1 账户概览"></a>4.1 账户概览</h3><p>  如果说会计是理论基础，而账户就是支付系统的实务基础，所有支付系统最底层的设施一定是账户。需要注意的是，这里所谓的账户，是银行、支付机构等，对其服务对象（公司、法人、个体等）开设的具有存款、储值功能的客户账户，一般来说，不做特指的情况下，账户通常都指代客户账户，而非上文所提的会计账户。对于银行来说，面向客户开立的存款余额户，通常属于“吸收存款”科目，属于银行的负债。<strong>而可以“吸收存款”，或者说“吸储”，是银行与第三方支付机构最本质的区别。</strong><br>**  支付作为资金转移过程，必然伴随着资金代表物权等“出账”和“入账”，账户也是支付结算等社会资金活动的起点和终点。**</p><blockquote><p>小贴士：客户账户与会计账户，在现实世界中由不同职能部门的人去管理，而在计算机系统中，也通常由不同的系统模块去承载，只是在具体的技术实现上可以复用。</p></blockquote><h3 id="4-2-账户分类"><a href="#4-2-账户分类" class="headerlink" title="4.2 账户分类"></a>4.2 账户分类</h3><p>账户也可以分为不同的类别，按照客户类型划分：</p><ul><li><input disabled="" type="checkbox"> 对私账户：个人银行结算账户，是指以自然人名义在银行开立的账户，主要用于办理个人转账收付和现金存取。</li><li><input disabled="" type="checkbox"> 对公账户：单位银行结算账户，是指以法人、其他组织（统称单位）名义开立的银行结算账户。按照用途不同，可具体划分为基本存款账户、一般存款账户、专用存款账户和临时存款账户。</li></ul><p>按照账户所属机构划分：</p><ul><li><input disabled="" type="checkbox"> 银行账户：银行账户是金融机构和银行客户之间的财政账户，又称为户口（中国大陆、香港、澳门）、户头（台湾、中国大陆）或口座（台湾、日本）。</li><li><input disabled="" type="checkbox"> 支付账户：支付账户是指获得互联网支付业务许可的支付机构，根据客户的真实意愿为其开立的，用于记录预付交易资金余额、客户凭此发起支付指令、反映交易明细的电子簿记。也分单位支付账户和个人支付账户。</li></ul><p>支付账户虽然在名称、功能、转账流程方面与银行账户非常相似，但是与银行账户有明显不同。</p><ul><li>一是提供账户服务的主体不同。支付账户由支付机构为客户开立。作为与银行的本质区别，支付机构不能吸收存款，因此支付账户内的资金不属于存款，不支付利息。银行账户由银行业金融机构为客户开立，既是结算账户也是存款账户，账户资金属于客户的存款，除用于支付结算外，还具有保值、增值（计息）等功能</li><li>二是账户资金余额的性质和保障机制不同。支付账户余额的本质是预收待付价值，类似于预付费卡中的余额，该余额虽然所有权归属客户却未以客户本人名义存放，而是支付机构以自身名义存放在人民银行备付金账户中，支付机构需要根据客户发起的支付指令调拨资金。</li></ul><p>按照账户自身的资产负债属性划分：</p><ul><li><input disabled="" type="checkbox"> 借记账户：一般意义上的存款账户。</li><li><input disabled="" type="checkbox"> 贷记账户：这已经不是“吸收存款”了，而是“贷款”科目。</li></ul><p>客户账户与内部&#x2F;会计账户一览：</p><blockquote><p>客户账户：</p><ul><li>借记账户</li><li>贷记账户</li></ul></blockquote><p>内部账户：</p><blockquote><ul><li>头寸类：<ul><li>银存账户</li><li>在途账户</li></ul></li><li>待清算：<ul><li>待清算账户</li></ul></li><li>过渡类：<ul><li>待查账户</li><li>待结转账户</li><li>应清算账户</li><li>往来账户</li><li>业务过渡户</li><li>损益账户</li><li>权益账户</li><li>……</li></ul></li></ul></blockquote><blockquote><p>小课堂：关于人民币银行结算账户的管理，央行有专门的《人民币银行结算账户管理办法》，自2003年9月1日起施行。有些人会困惑信用卡是否属于银行结算账户，可以在该办法的第15条中找到答案：<br>  <strong>第十五条</strong> 个人银行结算账户是自然人因投资、消费、结算等而开立的可办理支付结算业务的存款账户。有下列情况的，可以申请开立个人银行结算账户：<br>(一) 使用支票、<strong>信用卡</strong>等信用支付工具的。<br>(二) 办理汇兑、定期借记、定期贷记、借记卡等结算业务的。<br>自然人可根据需要申请开立个人银行结算账户，也可以在已开立的储蓄账户中选择并向开户银行申请确认为个人银行结算账户。</p></blockquote><h3 id="4-3-客户、账户、卡片"><a href="#4-3-客户、账户、卡片" class="headerlink" title="4.3 客户、账户、卡片"></a>4.3 客户、账户、卡片</h3><p>  刚接触支付清算的同学，一个常见的困惑就是客户、账户、卡片的区别，很简单：</p><ul><li><p><input disabled="" type="checkbox"> 客户：自然人在机构的标识</p></li><li><p><input disabled="" type="checkbox"> 账户：归集用卡过程中的资产变动，供机构、客户管理</p></li><li><p><input disabled="" type="checkbox"> 卡片：支付工具&#x2F;支付介质，用以承接客户的消费、信贷等场景，是连接机构、客户、场景的媒介</p><p>对机构而言，同一自然人在机构中通常就是唯一的客户号码，在客户开户过程中，需要做好KYC(Know Your Customer)，而由于产品属性、授信机制等不同，同一客户在同一机构下可能存在多账户，至于卡片，只是一种媒介，一张卡片的消费既有可能影响到多个账户，也可能多个卡片的消费影响同一个账户。<br>举个栗子：小明去某行办了A、B两张信用卡，早饭买了两个包子用A卡支付，中午买了杯咖啡用B卡支付，下午逛街顺便买了辆车用了B卡支付，晚上捐献香火钱用A卡取现100元，在这一天中，最终动了几个账户呢？一般来说，信用卡的账户体系中，买包子和买咖啡 影响的是个人消费账户，买车是单独的汽车分期账户，取现又是单独的现金贷款账户。可以看出，本质上影响账户的不是卡片，而是使用场景。<br>至于卡片上的各种权益，就是一个附属能力，作为客户权益独立进行处理。</p></li></ul><blockquote><p>小贴士：</p><ul><li><input disabled="" type="checkbox"> 对于消费者而言，场景决定账户，对于机构而言，产品决定账户。也就是说，在消费者看来的各个场景，在机构看来一定是会对应到一款产品下。</li><li><input disabled="" type="checkbox"> 授信的最小主体是账户，最大主体是客户。</li></ul></blockquote><h2 id="5-清算结算"><a href="#5-清算结算" class="headerlink" title="5. 清算结算"></a>5. 清算结算</h2><p>  有了各类支付机构，有了账户，剩下的就是复杂支付场景下，如何进行各类机构、个人间的账户清算结算了。<br>  先只考虑纯清算机构（Clearing House）的场景：<br><img src="/images/all_about_payment/all_about_payment02_18.png" alt="image.png"></p><p>  再只考虑纯结算机构的场景：<br>  首先，机构面向客户（个人、企业）的结算相对简单，机构直接修改客户账即可，比较麻烦的是机构之间的结算，机构间的结算方式有几类：</p><ul><li><input disabled="" type="checkbox"> 往来户：类似于上面“清算清偿演进”中提到的手工清算模式。</li><li><input disabled="" type="checkbox"> 代理行：代理行模式是指境外参加银行可以在境内代理行开立人民币同业往来账户，通过境内代理行同境内结算银行之间完成跨境贸易人民币结算资金划拨的方式。在这种方式中，境外参加银行也可以不在港澳人民币清算银行或境内代理行直接开户，而是通过其他已经在港澳人民币清算银行或境内代理行开户的境外参加银行和境内结算银行之间完成跨境贸易人民币结算资金划拨。</li></ul><p><img src="/images/all_about_payment/all_about_payment02_19.png" alt="image.png"></p><p>  最后，如果一个机构既可以清算又可以结算，那么就相当于该机构可以统一处理信息流、资金流，而不需要再与其他机构额外交互。</p><h2 id="6-资金对账"><a href="#6-资金对账" class="headerlink" title="6. 资金对账"></a>6. 资金对账</h2><p>  上面的整个流程走完，好像非常完美，一切都能通了，但是有没有发现其中有一个很严重的缺陷：结算账户在谁那，谁就掌握了最终真实的货币所有权，当所有参与方以为自身实际结算成功时，如果结算机构就是记错账、记假账，该怎么办？<br>  记账需要凭证，对于线下场景，可以回忆一下存取款时柜台开具的票据，这些票据就是记账操作的凭证，后续存款人如果觉得账单有误，可以用这些票据作为凭证去核对。而在数字化时代，这些记账凭证实际上就是每笔交易单据，每笔交易就组成了记账的实际凭证，这些交易可以是实际货物、服务贸易交易，也可以是用户发起的提现、转账操作，除交易单据凭证之外，还有一种类型就是人工记账凭证，比如系统故障了，需要客资运营发起调账，虽然只以技术视角看，直接调用一下记账接口就行呀，但是这样的话，调账也出问题了怎么办？后续连个证据都找不到，也不知道这笔调账是因为什么做的。所以人工调账之前需要先创建一个凭证，后续的调账需要关联此凭证去做。<br>  因此，资金的对账也有几个层级：</p><ul><li><p><input disabled="" type="checkbox"> 账单明细和凭证明细之间的账证核对</p></li><li><p><input disabled="" type="checkbox"> 账账核对：客户账与会计账的核对（账务层与会计层的核对）</p></li><li><p><input disabled="" type="checkbox"> 账表核对：会计账内部的分层核对</p></li><li><p><input disabled="" type="checkbox"> 借方发生额 &#x3D; 贷方发生额</p></li><li><p><input disabled="" type="checkbox"> 借方余额 &#x3D; 贷方余额</p></li><li><p><input disabled="" type="checkbox"> 期初余额 + 发生额 &#x3D; 期末余额</p></li><li><p><input disabled="" type="checkbox"> 子科目累计额 &#x3D; 父科目</p></li><li><p><input disabled="" type="checkbox"> 账实核对：头寸余额与银存账户的核对</p><p>以上看的是一个主体或机构内部的对账场景，有一个问题是：账单是从哪来的？如果是完全是内部业务，只动内部客户账，那么自己生成账单即可，但不得不思考的一个问题是：如何做到机构与机构、机构与主体、主体与主体之间的记账是正确的？不至于某一方记错账，而另一方不知情。因此更多时候，账单是对方机构&#x2F;主体给出来的，通过核对对方的账单和我方的账单，能够保障记账的正确性。<br>而如果机构账单的信息流是一套，真实的内部账户又是一套，和机构做生意的企业又怎么能知道呢？这种情况，只能说从合规监管的角度来看，是一个风险远远远大于收益的选择，已经不再是支付问题，而是一个社会学、法学问题。</p></li></ul><h2 id="7-附录"><a href="#7-附录" class="headerlink" title="7. 附录"></a>7. 附录</h2><h3 id="7-1-会计科目表"><a href="#7-1-会计科目表" class="headerlink" title="7.1 会计科目表"></a>7.1 会计科目表</h3><p>会计科目表一般分类包括：资产类，负债类，共同类，所有者权益类，成本类，损益类等6大类，162个小科目。</p><h4 id="7-1-1-资产类"><a href="#7-1-1-资产类" class="headerlink" title="7.1.1 资产类"></a>7.1.1 资产类</h4><table><thead><tr><th><strong>序号</strong></th><th><strong>编号</strong></th><th><strong>会计科目名称</strong></th><th><strong>会计科目适用范围</strong></th><th><strong>序号</strong></th><th><strong>编号</strong></th><th><strong>会计科目名称</strong></th><th><strong>会计科目适用范围</strong></th></tr></thead><tbody><tr><td>1</td><td>1001</td><td>库存现金</td><td></td><td>38</td><td>1431</td><td>周转材料</td><td>建造承包商专用</td></tr><tr><td>2</td><td>1002</td><td>银行存款</td><td></td><td>39</td><td>1441</td><td>贵金属</td><td>银行专用</td></tr><tr><td>3</td><td>1003</td><td>存放中央银行款项</td><td>银行专用</td><td>40</td><td>1442</td><td>抵债资产</td><td>金融共用</td></tr><tr><td>4</td><td>1011</td><td>存放同业</td><td>银行专用</td><td>41</td><td>1451</td><td>损余物资</td><td>保险专用</td></tr><tr><td>5</td><td>1015</td><td>其它货币基金</td><td></td><td>42</td><td>1461</td><td>存货跌价准备</td><td></td></tr><tr><td>6</td><td>1021</td><td>结算备付金</td><td>证券专用</td><td>43</td><td>1501</td><td>待摊费用</td><td></td></tr><tr><td>7</td><td>1031</td><td>存出保证金</td><td>金融共用</td><td>44</td><td>1511</td><td>独立账户资产</td><td>保险专用</td></tr><tr><td>8</td><td>1051</td><td>拆出资金</td><td>金融共用</td><td>45</td><td>1521</td><td>持有至到期投资</td><td></td></tr><tr><td>9</td><td>1101</td><td>交易性金融资产</td><td></td><td>46</td><td>1522</td><td>持有至到期投资减值准备</td><td></td></tr><tr><td>10</td><td>1111</td><td>买入返售金融资产</td><td>金融共用</td><td>47</td><td>1523</td><td>可供出售金融资产</td><td></td></tr><tr><td>11</td><td>1121</td><td>应收票据</td><td></td><td>48</td><td>1524</td><td>长期股权投资</td><td></td></tr><tr><td>12</td><td>1122</td><td>应收账款</td><td></td><td>49</td><td>1525</td><td>长期股权投资减值准备</td><td></td></tr><tr><td>13</td><td>1123</td><td>预付账款</td><td></td><td>50</td><td>1526</td><td>投资性房地产</td><td></td></tr><tr><td>14</td><td>1131</td><td>应收股利</td><td></td><td>51</td><td>1531</td><td>长期应收款</td><td></td></tr><tr><td>15</td><td>1132</td><td>应收利息</td><td></td><td>52</td><td>1541</td><td>未实现融资收益</td><td></td></tr><tr><td>16</td><td>1211</td><td>应收保护储金</td><td>保险专用</td><td>53</td><td>1551</td><td>存出资本保证金</td><td>保险专用</td></tr><tr><td>17</td><td>1221</td><td>应收代位追偿款</td><td>保险专用</td><td>54</td><td>1601</td><td>固定资产</td><td></td></tr><tr><td>18</td><td>1222</td><td>应收分保账款</td><td>保险专用</td><td>55</td><td>1602</td><td>累计折旧</td><td></td></tr><tr><td>19</td><td>1223</td><td>应收分保未到期责任准备金</td><td>保险专用</td><td>56</td><td>1603</td><td>固定资产减值准备</td><td></td></tr><tr><td>20</td><td>1224</td><td>应收分保保险责任准备金</td><td>保险专用</td><td>57</td><td>1604</td><td>在建工程</td><td></td></tr><tr><td>21</td><td>1231</td><td>其它应收款</td><td></td><td>58</td><td>1605</td><td>工程物资</td><td></td></tr><tr><td>22</td><td>1241</td><td>坏账准备</td><td></td><td>59</td><td>1606</td><td>固定资产清理</td><td></td></tr><tr><td>23</td><td>1251</td><td>贴现资产</td><td>银行专用</td><td>60</td><td>1611</td><td>融资租赁资产</td><td>租赁专用</td></tr><tr><td>24</td><td>1301</td><td>贷款</td><td>银行和保险共用</td><td>61</td><td>1612</td><td>未担保余值</td><td>租赁专用</td></tr><tr><td>25</td><td>1302</td><td>贷款损失准备</td><td>银行和保险共用</td><td>62</td><td>1621</td><td>生产性生物资产</td><td>农业专用</td></tr><tr><td>26</td><td>1311</td><td>代理兑付证券</td><td>银行和保险共用</td><td>63</td><td>1622</td><td>生产性生物资产累计折旧</td><td>农业专用</td></tr><tr><td>27</td><td>1321</td><td>代理业务资产</td><td></td><td>64</td><td>1623</td><td>公益性生物资产</td><td>农业专用</td></tr><tr><td>28</td><td>1401</td><td>材料采购</td><td></td><td>65</td><td>1631</td><td>油气资产</td><td>石油天然气开采专用</td></tr><tr><td>29</td><td>1402</td><td>在途物资</td><td></td><td>66</td><td>1632</td><td>累计折耗</td><td>石油天然气开采专用</td></tr><tr><td>30</td><td>1403</td><td>原材料</td><td></td><td>67</td><td>1701</td><td>无形资产</td><td></td></tr><tr><td>31</td><td>1404</td><td>材料成本差异</td><td></td><td>68</td><td>1702</td><td>累计摊销</td><td></td></tr><tr><td>32</td><td>1406</td><td>库存商品</td><td></td><td>69</td><td>1703</td><td>无形资产减值准备</td><td></td></tr><tr><td>33</td><td>1407</td><td>发出商品</td><td></td><td>70</td><td>1711</td><td>商誉</td><td></td></tr><tr><td>34</td><td>1410</td><td>商品进销差价</td><td></td><td>71</td><td>1801</td><td>长期待摊费用</td><td></td></tr><tr><td>35</td><td>1411</td><td>委托加工物资</td><td></td><td>72</td><td>1811</td><td>递延所得资产</td><td></td></tr><tr><td>36</td><td>1412</td><td>包装物及低值易耗品</td><td></td><td>73</td><td>1901</td><td>待处理财产损益</td><td></td></tr><tr><td>37</td><td>1421</td><td>消耗性物物资产</td><td>农业专用</td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="7-1-2-负债类"><a href="#7-1-2-负债类" class="headerlink" title="7.1.2 负债类"></a>7.1.2 负债类</h4><table><thead><tr><th><strong>序号</strong></th><th><strong>编号</strong></th><th><strong>会计科目名称</strong></th><th><strong>会计科目适用范围</strong></th><th><strong>序号</strong></th><th><strong>编号</strong></th><th><strong>会计科目名称</strong></th><th><strong>会计科目适用范围</strong></th></tr></thead><tbody><tr><td>74</td><td>2001</td><td>短期借款</td><td></td><td>92</td><td>2261</td><td>应付分保账款</td><td>保险专用</td></tr><tr><td>75</td><td>2002</td><td>存入保证金</td><td>金融共用</td><td>93</td><td>2311</td><td>代理买卖证券款</td><td>证券专用</td></tr><tr><td>76</td><td>2003</td><td>拆入资金</td><td>金融共用</td><td>94</td><td>2312</td><td>代理承销证券款</td><td>证券和银行共用</td></tr><tr><td>77</td><td>2004</td><td>向中央银行借款</td><td>银行专用</td><td>95</td><td>2313</td><td>代理兑付证券款</td><td>证券和银行共用</td></tr><tr><td>78</td><td>2011</td><td>同业存放</td><td>银行专用</td><td>96</td><td>2314</td><td>代理业务负债</td><td></td></tr><tr><td>79</td><td>2012</td><td>吸收存款</td><td>银行专用</td><td>97</td><td>2401</td><td>预提费用</td><td></td></tr><tr><td>80</td><td>2021</td><td>贴现负债</td><td>银行专用</td><td>98</td><td>2411</td><td>预计负债</td><td></td></tr><tr><td>81</td><td>2101</td><td>交易性金融负债</td><td></td><td>99</td><td>2501</td><td>递延收益</td><td></td></tr><tr><td>82</td><td>2111</td><td>专出回购金融资产款</td><td>金融共用</td><td>100</td><td>2601</td><td>长期借款</td><td></td></tr><tr><td>83</td><td>2201</td><td>应付票据</td><td></td><td>101</td><td>2602</td><td>长期债券</td><td></td></tr><tr><td>84</td><td>2202</td><td>应付账款</td><td></td><td>102</td><td>2701</td><td>未到期责任准备金</td><td>保险专用</td></tr><tr><td>85</td><td>2205</td><td>预收账款</td><td></td><td>103</td><td>2702</td><td>保险责任准备金</td><td>保险专用</td></tr><tr><td>86</td><td>2211</td><td>应付职工薪酬</td><td></td><td>104</td><td>2711</td><td>保户储金</td><td>保险专用</td></tr><tr><td>87</td><td>2221</td><td>应交税费</td><td></td><td>105</td><td>2721</td><td>独立账户负债</td><td>保险专用</td></tr><tr><td>88</td><td>2231</td><td>应付股利</td><td></td><td>106</td><td>2801</td><td>长期应付款</td><td></td></tr><tr><td>89</td><td>2232</td><td>应付利息</td><td></td><td>107</td><td>2802</td><td>未确认融资费用</td><td></td></tr><tr><td>90</td><td>2241</td><td>其他应付款</td><td></td><td>108</td><td>2811</td><td>专项应付款</td><td></td></tr><tr><td>91</td><td>2251</td><td>应付保户红利</td><td>保险专用</td><td>109</td><td>2901</td><td>递延所得税负债</td><td></td></tr></tbody></table><h4 id="7-1-3-共同类"><a href="#7-1-3-共同类" class="headerlink" title="7.1.3 共同类"></a>7.1.3 共同类</h4><table><thead><tr><th><strong>序号</strong></th><th><strong>编号</strong></th><th><strong>会计科目名称</strong></th><th><strong>会计科目适用范围</strong></th><th><strong>序号</strong></th><th><strong>编号</strong></th><th><strong>会计科目名称</strong></th><th><strong>会计科目适用范围</strong></th></tr></thead><tbody><tr><td>110</td><td>3001</td><td>清算资金往来</td><td>银行专用</td><td>113</td><td>3201</td><td>套期工具</td><td></td></tr><tr><td>111</td><td>3002</td><td>外汇买卖</td><td>金融共用</td><td>114</td><td>3202</td><td>被套期项目</td><td></td></tr><tr><td>112</td><td>3101</td><td>衍生工具</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="7-1-4-所有者权益类"><a href="#7-1-4-所有者权益类" class="headerlink" title="7.1.4 所有者权益类"></a>7.1.4 所有者权益类</h4><table><thead><tr><th><strong>序号</strong></th><th><strong>编号</strong></th><th><strong>会计科目名称</strong></th><th><strong>会计科目适用范围</strong></th><th><strong>序号</strong></th><th><strong>编号</strong></th><th><strong>会计科目名称</strong></th><th><strong>会计科目适用范围</strong></th></tr></thead><tbody><tr><td>115</td><td>4001</td><td>实收资本</td><td></td><td>119</td><td>4103</td><td>本年利润</td><td></td></tr><tr><td>116</td><td>4002</td><td>资本公积</td><td></td><td>120</td><td>4104</td><td>利润分配</td><td></td></tr><tr><td>117</td><td>4101</td><td>盈余公积</td><td></td><td>121</td><td>4201</td><td>库存股</td><td></td></tr><tr><td>118</td><td>4102</td><td>一般风险准备</td><td>金融共用</td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="7-1-5-成本类"><a href="#7-1-5-成本类" class="headerlink" title="7.1.5 成本类"></a>7.1.5 成本类</h4><table><thead><tr><th><strong>序号</strong></th><th><strong>编号</strong></th><th><strong>会计科目名称</strong></th><th><strong>会计科目适用范围</strong></th><th><strong>序号</strong></th><th><strong>编号</strong></th><th><strong>会计科目名称</strong></th><th><strong>会计科目适用范围</strong></th></tr></thead><tbody><tr><td>122</td><td>5001</td><td>生产成本</td><td></td><td>126</td><td>5401</td><td>工程施工</td><td>建造承包商专用</td></tr><tr><td>123</td><td>5101</td><td>制造费用</td><td></td><td>127</td><td>5402</td><td>工程结算</td><td>建造承包商专用</td></tr><tr><td>124</td><td>5201</td><td>劳务成本</td><td></td><td>128</td><td>5403</td><td>机械作业</td><td>建造承包商专用</td></tr><tr><td>125</td><td>5301</td><td>研发支出</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="7-1-6-损益类"><a href="#7-1-6-损益类" class="headerlink" title="7.1.6 损益类"></a>7.1.6 损益类</h4><table><thead><tr><th><strong>序号</strong></th><th><strong>编号</strong></th><th><strong>会计科目名称</strong></th><th><strong>会计科目适用范围</strong></th><th><strong>序号</strong></th><th><strong>编号</strong></th><th><strong>会计科目名称</strong></th><th><strong>会计科目适用范围</strong></th></tr></thead><tbody><tr><td>129</td><td>6001</td><td>主营业务收入</td><td></td><td>146</td><td>6411</td><td>利息支出</td><td>金融共用</td></tr><tr><td>130</td><td>6011</td><td>利息收入</td><td>金融共用</td><td>147</td><td>6421</td><td>手续费支出</td><td>金融共用</td></tr><tr><td>131</td><td>6021</td><td>手续费收入</td><td>金融共用</td><td>148</td><td>6501</td><td>提取未到期责任准备金</td><td>保险专用</td></tr><tr><td>132</td><td>6031</td><td>保费收入</td><td>保险专用</td><td>149</td><td>6502</td><td>撮保险责任准备金</td><td>保险专用</td></tr><tr><td>133</td><td>6032</td><td>分保费收入</td><td>保险专用</td><td>150</td><td>6511</td><td>赔付支出</td><td>保险专用</td></tr><tr><td>135</td><td>6041</td><td>租赁收入</td><td>租赁专用</td><td>151</td><td>6521</td><td>保户红利支出</td><td>保险专用</td></tr><tr><td>135</td><td>6051</td><td>其他业务收入</td><td></td><td>152</td><td>6531</td><td>退保金</td><td>保险专用</td></tr><tr><td>136</td><td>6061</td><td>汇兑损益</td><td>金融专用</td><td>153</td><td>6541</td><td>分出保费</td><td>保险专用</td></tr><tr><td>137</td><td>6101</td><td>公允价值变动损益</td><td></td><td>154</td><td>6542</td><td>分保费用</td><td>保险专用</td></tr><tr><td>138</td><td>6111</td><td>投资收益</td><td></td><td>155</td><td>6601</td><td>销售费用</td><td></td></tr><tr><td>139</td><td>6201</td><td>摊回保险责任准备金</td><td>保险专用</td><td>156</td><td>6602</td><td>管理费用</td><td></td></tr><tr><td>140</td><td>6202</td><td>摊回赔付支出</td><td>保险专用</td><td>157</td><td>6603</td><td>财务费用</td><td></td></tr><tr><td>141</td><td>6203</td><td>摊回分保费用</td><td>保险专用</td><td>158</td><td>6604</td><td>勘探费用</td><td></td></tr><tr><td>142</td><td>6301</td><td>营业外收入</td><td></td><td>159</td><td>6701</td><td>资产减值损失</td><td></td></tr><tr><td>143</td><td>6401</td><td>主营业务成本</td><td></td><td>160</td><td>6711</td><td>营业外支出</td><td></td></tr><tr><td>144</td><td>6402</td><td>其它业务成本</td><td></td><td>161</td><td>6801</td><td>所得税</td><td></td></tr><tr><td>145</td><td>6405</td><td>营业税金及附加</td><td></td><td>162</td><td>6901</td><td>以前年度损益调整</td><td></td></tr></tbody></table><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">许成军. “与金融电子化同行——全国电子联行系统(EIS)建设始末.” 金融电子化 10(2019):3.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedian. “支票.” <em>Wikipedia</em>, Wikimedia Foundation, 26 Mar. 2022, <a href="https://zh.m.wikipedia.org/zh-hans/%E6%94%AF%E7%A5%A8">https://zh.m.wikipedia.org/zh-hans/%E6%94%AF%E7%A5%A8</a>.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedian. “弗兰克·阿巴内尔.” Wikipedia, Wikimedia Foundation, 19 Apr. 2022, <a href="https://zh.m.wikipedia.org/zh-hans/%E5%BC%97%E5%85%B0%E5%85%8B%C2%B7%E9%98%BF%E5%B7%B4%E5%86%85%E5%B0%94">https://zh.m.wikipedia.org/zh-hans/%E5%BC%97%E5%85%B0%E5%85%8B%C2%B7%E9%98%BF%E5%B7%B4%E5%86%85%E5%B0%94</a><a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">佚名 . “伪造、变造金融票证罪有哪些构成条件？.” 中国人大网, 19 Apr. 2002, <a href="http://www.npc.gov.cn/zgrdw/npc/flsyywd/flwd/2002-04/19/content_293377.htm.">http://www.npc.gov.cn/zgrdw/npc/flsyywd/flwd/2002-04/19/content_293377.htm.</a><a href="#fnref:4" rev="footnote">↩</a></span></li><li id="fn:5"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">佚名 . “人民银行建成支票影像交换系统支票可全国通用.” <em>中国政府网</em>, 9 July 2007, <a href="http://www.gov.cn/govweb/fwxx/sh/2007-07/09/content_677450.htm">http://www.gov.cn/govweb/fwxx/sh/2007-07/09/content_677450.htm</a>.<a href="#fnref:5" rev="footnote">↩</a></span></li><li id="fn:6"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">佚名 . “会计要素、会计科目、会计账户、会计账簿之间有何关系？.” 中国人民银行, 3 Sept. 2014, <a href="http://tianjin.pbc.gov.cn/fzhtianjin/2927296/113906/2742116/index.html">http://tianjin.pbc.gov.cn/fzhtianjin/2927296/113906/2742116/index.html.</a><a href="#fnref:6" rev="footnote">↩</a></span></li><li id="fn:7"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">佚名 . “中国人民银行会计核算监督办法.” 中国人民银行, 4 Aug. 2011, <a href="http://www.pbc.gov.cn/kuaijicaiwusi/145920/145974/2853889/index.html">http://www.pbc.gov.cn/kuaijicaiwusi/145920/145974/2853889/index.html.</a><a href="#fnref:7" rev="footnote">↩</a></span></li><li id="fn:8"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">佚名 . “中国人民银行会计基本制度.” 中国人民银行, 15 Dec. 2005, <a href="http://www.pbc.gov.cn/kuaijicaiwusi/145920/145974/2827666/index.html">http://www.pbc.gov.cn/kuaijicaiwusi/145920/145974/2827666/index.html.</a><a href="#fnref:8" rev="footnote">↩</a></span></li><li id="fn:9"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">BIS. “Payment, Clearing and Settlement Systems in the CPSS Countries - Volume 1.” <em>The Bank for International Settlements</em>, 2 Sept. 2011, <a href="https://www.bis.org/cpmi/publ/d97.htm">https://www.bis.org/cpmi/publ/d97.htm</a>.<a href="#fnref:9" rev="footnote">↩</a></span></li><li id="fn:10"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">陈晓光. “支付产品必懂的会计基础及如何应用” 人人都是产品经理, 6 Apr. 2021, <a href="https://www.woshipm.com/pd/4440125.html">https://www.woshipm.com/pd/4440125.html</a>.<a href="#fnref:10" rev="footnote">↩</a></span></li><li id="fn:11"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">陈晓光. “账务核心设计方法” 人人都是产品经理, 6 Sept. 2021, <a href="https://www.woshipm.com/pd/5124144.html">https://www.woshipm.com/pd/5124144.html</a>.<a href="#fnref:11" rev="footnote">↩</a></span></li><li id="fn:12"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">佚名. “中国人民银行机构设置” 中国人民银行, 23 Sep. 2022, <a href="http://www.pbc.gov.cn/rmyh/105226/105442/index.html">http://www.pbc.gov.cn/rmyh/105226/105442/index.html</a>.<a href="#fnref:12" rev="footnote">↩</a></span></li><li id="fn:13"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">佚名. “收款凭证” 人大经济论坛, 31 Aug. 2009, <a href="http://wiki.pinggu.org/index.php?doc-innerlink-%E6%94%B6%E6%AC%BE%E5%87%AD%E8%AF%81">http://wiki.pinggu.org/index.php?doc-innerlink-%E6%94%B6%E6%AC%BE%E5%87%AD%E8%AF%81</a>.<a href="#fnref:13" rev="footnote">↩</a></span></li><li id="fn:14"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">14.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">佚名. “付款凭证” 人大经济论坛, 31 Aug. 2009, <a href="http://wiki.pinggu.org/index.php?doc-innerlink-%E4%BB%98%E6%AC%BE%E5%87%AD%E8%AF%81">http://wiki.pinggu.org/index.php?doc-innerlink-%E4%BB%98%E6%AC%BE%E5%87%AD%E8%AF%81</a>.<a href="#fnref:14" rev="footnote">↩</a></span></li><li id="fn:15"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">15.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">佚名. “转账凭证” 人大经济论坛, 31 Aug. 2009, <a href="http://wiki.pinggu.org/index.php?doc-innerlink-%E8%BD%AC%E8%B4%A6%E5%87%AD%E8%AF%81">http://wiki.pinggu.org/index.php?doc-innerlink-%E8%BD%AC%E8%B4%A6%E5%87%AD%E8%AF%81</a>.<a href="#fnref:15" rev="footnote">↩</a></span></li><li id="fn:16"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">16.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">丁元霖. “<a href="http://www.caidao8.com/library/view/250110007007002.htm">银行会计</a>” 立信会计出版社, 2014.<a href="#fnref:16" rev="footnote">↩</a></span></li><li id="fn:17"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">17.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">佚名. “What is the Accounting Cycle: A Step by Step Guide” CommunityTax, 02 Nov. 2021, <a href="https://www.communitytax.com/what-is-the-accounting-cycle-a-step-by-step-guide/">https://www.communitytax.com/what-is-the-accounting-cycle-a-step-by-step-guide/</a>.<a href="#fnref:17" rev="footnote">↩</a></span></li><li id="fn:18"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">18.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Schmidt, Marty. “Complete the Accounting Cycle in 5 Steps, Input to Output Reports.” Business Case Website, 8 Nov. 2022, <a href="https://www.business-case-analysis.com/accounting-cycle.html.">https://www.business-case-analysis.com/accounting-cycle.html.</a><a href="#fnref:18" rev="footnote">↩</a></span></li><li id="fn:19"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">19.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">陈晓光. “账户系统设计从入门到精通” 人人都是产品经理, 23 Mar. 2021, <a href="https://www.woshipm.com/pd/4420513.html">https://www.woshipm.com/pd/4420513.html</a>.<a href="#fnref:19" rev="footnote">↩</a></span></li><li id="fn:20"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">20.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">支付技术那些事. “全国电子联行系统EIS|支付（四）” 知乎, 4 May. 2019, <a href="https://zhuanlan.zhihu.com/p/64624337">https://zhuanlan.zhihu.com/p/64624337</a>.<a href="#fnref:20" rev="footnote">↩</a></span></li><li id="fn:21"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">21.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">中国人民银行办公厅. “中国人民银行直属机构”中国人民银行, 04 Apr. 2023, <a href="http://www.pbc.gov.cn/rmyh/105226/105442/index.html#%E7%9B%B4%E5%B1%9E%E6%9C%BA%E6%9E%84">http://www.pbc.gov.cn/rmyh/105226/105442/index.html#%E7%9B%B4%E5%B1%9E%E6%9C%BA%E6%9E%84</a>.<a href="#fnref:21" rev="footnote">↩</a></span></li><li id="fn:22"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">22.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">周小川. “人民币银行结算账户管理办法” 中国人民银行, 10 Apr. 2003, <a href="http://www.gov.cn/gongbao/content/2003/content_62368.htm">http://www.gov.cn/gongbao/content/2003/content_62368.htm</a>.<a href="#fnref:22" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h2&gt;&lt;p&gt;通过上一篇的讲解，我们大概了解了货币的发展历史，和现代信用货币的本质，但是既然当下的信用货币就是一个符号，就是转移债务债</summary>
      
    
    
    
    <category term="technology" scheme="https://blog.xuwei.fun/categories/technology/"/>
    
    <category term="finance" scheme="https://blog.xuwei.fun/categories/technology/finance/"/>
    
    
    <category term="finance" scheme="https://blog.xuwei.fun/tags/finance/"/>
    
    <category term="payment" scheme="https://blog.xuwei.fun/tags/payment/"/>
    
    <category term="money" scheme="https://blog.xuwei.fun/tags/money/"/>
    
  </entry>
  
  <entry>
    <title>关于支付的一切-其一（货币是什么）</title>
    <link href="https://blog.xuwei.fun/2022/07/18/allAboutPayment01/"/>
    <id>https://blog.xuwei.fun/2022/07/18/allAboutPayment01/</id>
    <published>2022-07-18T12:44:00.000Z</published>
    <updated>2022-07-18T13:35:59.504Z</updated>
    
    <content type="html"><![CDATA[<div class="note green icon-padding modern"><i class="note-icon fas fa-cube"></i><p>Gold is money, everything else is credit. —— J.P. Morgan</p></div><h2 id="0-Intro"><a href="#0-Intro" class="headerlink" title="0. Intro"></a>0. Intro</h2><p>J.P. Morgan在1912年说过的这句话，听者并不知所谓，初次听到总是会感觉很nb。但只有当你对现代支付体系的本质足够了解，才会理解这句话的精髓，同时也能够对很多经济现象 知其所以然 了，比如你会理解08年时总理说的“信心比黄金更重要”，也能够理解比特币究竟解决了什么问题？央行降准释放流动性的本质是什么？M0、M1、M2是个什么玩意？甚至你会反驳J.P. Morgan：黄金也不过是信用。</p><p>所以“关于支付的一切”为何开篇就开始讨论信用？信用真的如此重要吗？要回答这个问题，首先需要回答另一个看似常识的问题：“货币是什么”？</p><p>解答这个问题，不妨就让我们回顾一下历史。</p><p><img src="/images/all_about_payment/all_about_payment01_01.png" alt="Evolution of Money"></p><span id="more"></span><h2 id="1-Bartering"><a href="#1-Bartering" class="headerlink" title="1. Bartering"></a>1. Bartering</h2><p>早期人类的氏族社会制度下，人类之间还完全靠着血缘关系维系，一个氏族中，分工明确，有人负责耕种、有人负责打猎，氏族内部的生存保障，靠互帮互助实现，不同氏族之间的物品交换，抢就对了，此时的人类更像是中级动物，还未能称得上是高级动物。</p><p>而随着组织进化，开始出现了私有财产，不同个体之间出现了供需错配，这就产生了易物的诉求，你有一头生猪，今天只想吃苹果，我有一个苹果，今天只想骑猪玩，正好互相交换，这就是最早解决供需错配的方法：以物易物（Bartering）。这种最古老的方式，也是生命力最长久的模式，乃至于千万年以后的 AD 2022年的春天，在中国的上海还出现了大规模的以物易物的交易方式。</p><p>采用“以物易物”这种方式进行交易有一个最大的优点：一手交货、一手…还是交货，如果按照参考DvP(Delivery versus Payment)、PvP(Payment versus Payment)的概念，大概就是可以缩写成GvG(Goods versus Goods)吧。面对面的、即时的、可靠的交易，交易双方在交换的一瞬间，就达成了交易，只是这一优点，在商品交换规模扩大后，效率就极端低下了，原因是很显然的：想要解决 不同时间、多人参与 的 供需错配，不同商品的运输难度还可能差异巨大，只靠以物易物是不可行的。<strong>物物交换的这种需求匹配，在经济学中被称为 双方需求耦合(Double Coincidence of Wants, DCW)。</strong></p><h2 id="2-Money"><a href="#2-Money" class="headerlink" title="2. Money"></a>2. Money</h2><h3 id="2-1-Universal-Equivalent"><a href="#2-1-Universal-Equivalent" class="headerlink" title="2.1 Universal Equivalent"></a>2.1 Universal Equivalent</h3><p>解决上述问题的一个直观想法，就是引入一个中间物品，即一般等价物(Universal Equivalent)，比如贝壳，A、B两个原始人不再直接以物易物，而是各自持有一定数量的贝壳，A给B10个贝壳，交换得到B的苹果，而B可以用其中8个贝壳，在冬天时交换C的红薯，而如果C攒够了100个贝壳，A就愿意换给他一头生猪！如此往复，物品交易的成本大大降低，持有小贝壳，就持有了等价物品的交易权，这里的贝壳，就可以称之为“货币”，也是最早期的货币形式之一。</p><p>一般等价物，可以降低交换中双边需求耦合产生的交易摩擦，也就是说，货币作为交易媒介，可以克服双方需求耦合导致的交换低效率的问题。</p><p><img src="/images/all_about_payment/all_about_payment01_02.png" alt="Cost of bartering and money"></p><div class="note green icon-padding modern"><i class="note-icon fas fa-cube"></i><p>小课堂：物物交换的优势临界点。<br>假设有N个交易者，每人有一个需要交易的商品，如果使用物物交换，每个交易中作为图的一个顶点，则充分无摩擦的物物交换就是一个完全图，如果每次交易的成本（也就是图的边）为常数C1，那么物物交换的总成本为：F(B) &#x3D; C1 * N * (N-1) &#x2F; 2<br>假设相同条件下，采用货币来进行交换，每次交易的成本为 C2，则货币交换总成本为 F(M) &#x3D; 2 * N * C2<br>无特殊商品的情况下，为简化考虑，假设C1&#x3D;C2，那么令 F(B) &#x3D; F(M)，则 N &#x3D; 5。也就是说，大概5个商品以内，物物交换可能更方便，超过5个商品，使用货币交换成本就更低了。虽然这种计算过于理想化，简化了很多条件，但与实际生活中的感受还是基本相符的，现实生活中超过个位数的物物交换基本不可能，更多时候，也就是2个物品交换而已。</p></div><p>有了货币，就可以开始定义支付了，准确来说，支付是社会经济活动中引起的货币资金转移的活动。</p><div class="note blue icon-padding modern"><i class="note-icon fas fa-cube"></i><p>小贴士：经济活动中，通常伴随着信息、商品和资金的流动和转移，也即 信息流、物流、资金流，商品的空间转移属于物流范畴，而资金从付款者向收款者的转移过程就是资金流，这也就是支付的范畴。</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-cube"></i><p>小贴士：没有货币就没有支付，而没有支付功能的货币也无法称之为货币。支付为实现商品的交换提供服务，并促进了商品的生产与交换。</p></div><h3 id="2-2-Forms-of-money"><a href="#2-2-Forms-of-money" class="headerlink" title="2.2 Forms of money"></a>2.2 Forms of money</h3><p>货币在发展过程中，其形式也不是一成不变的，大体来说，货币可分为实物货币和信用货币两类（也可按实物货币、账户货币来分类）。图2.2给出了货币形式的分类。</p><p><img src="/images/all_about_payment/all_about_payment01_03.png" alt="Category of Money"></p><h4 id="2-2-1-实物货币"><a href="#2-2-1-实物货币" class="headerlink" title="2.2.1 实物货币"></a>2.2.1 实物货币</h4><p>在刚刚的例子中，使用了贝壳作为货币，实际在历史上，牲畜、盐、贝壳、烟草、干鱼丁、砂糖、兽皮、铁等都曾充当过货币的角色，实物货币在解决问题的同时，也都有些缺陷，例如：</p><ul><li>不利于储藏</li><li>不利于携带</li><li>不利于分割</li><li>……</li></ul><p>天然可以解决上述问题的就是金属，金属货币具有“价值稳定、易于分割、易于保存、便于携带…”的特点，所以世界各地在历史上都曾选择过金属作为货币形式，因此才有马克思说的“金银天然不是货币，但货币天然是金银(Gold and silver are not by nature money, but money consists by its nature of gold and silver)”。但金属货币也有其缺点：</p><ul><li>体积较大不便于携带与运输</li><li>使用过程磨损导致价值损耗</li><li>供给速度有限导致通货紧缩</li><li>……</li></ul><p>其中最严重的问题，就是“供给速度有限导致通货紧缩”这点，可以参考 三千年东西方兴衰金融史[3] 中关于“钱荒”的故事，简单来说就是制造金属货币需要探矿、采矿、铸币，本身具有一定的难度，货币的供应量跟不上社会经济发展的速度，从而导致货币不足。<br>这里需要解释一下的是，货币增加并不就是坏事、也并不就等同于通货膨胀，再看下小课堂。</p><div class="note green icon-padding modern"><i class="note-icon fas fa-cube"></i><p>小课堂：从理论上来说，通货膨胀是在纸币流通的条件下，流通的货币超过实际需要量而引起的货币贬值、物价持续而普遍上涨的经济现象。货币发行数量上升，不一定使物价上升，因为可能尚未投入消费，或是被更多的商品（服务）生产或科技进步所抵消。<br>换句话说，要意识到在人类历史上，拉长时间线来看，社会财富是在不断增加的、经济是在不断发展的，在不发生重大自然灾害和战争人祸等特殊情况时，商品和服务总量基本是稳步增加的，而通过科学技术的进步，带来了数次爆发性的增长。<br>社会财富增加的本质原因是人口的增加（劳动力的增加）和科技的进步（生产效率的提高）。</p><ul><li>场景思考：设想初始时间T，人口P，此时社会财富存量为S，假设人口的出生死亡恰好平衡，年均生产的商品服务也恰好等于消费，没有结余。那么理论上M年后，社会财富存量仍为S，要打破这种平衡，要么提高劳动人口数量（通过提高生育率、降低死亡率、推迟退休年龄等），要么就是提高生产效率（科学技术、知识水平、分工协作等）。而在人类生育意愿降低、平均寿命逼近上限、自然资源有限的前提下，劳动人口数量渐趋平稳，甚至于部分地区会逐渐下降，那么就只能依赖于科学技术的进步提高生产效率，因此得出“科学技术是第一生产力”的结论也顺理成章了。</li></ul></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-cube"></i><p>小贴士：技术革新才能带来的生产力的释放，否则就只能靠人口增加增加生产力，而这到一定阶段只会陷入内卷的环境中。</p></div><h4 id="2-2-2-信用货币"><a href="#2-2-2-信用货币" class="headerlink" title="2.2.2 信用货币"></a>2.2.2 信用货币</h4><p>回到金属货币的两个问题上来，So，怎么办呢？为了解决问题于是有了信用货币。</p><ul><li>金属货币（不足值）。既然金属货币尤其是金银，受限于矿产资源，那么可以在铸币过程中增加其他成分，这样就可以缓解货币供给压力了，这种不足值的货币慢慢驱逐了原来的足值货币，产生了“劣币驱除良币”的现象，也称为“格雷欣法则（Gresham’s Law）”<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedian. “劣币驱除良币.” Wikipedia, Wikimedia Foundation, 7 June 2022, https://zh.wikipedia.org/zh-cn/%E5%8A%A3%E5%B9%A3%E9%A9%85%E9%80%90%E8%89%AF%E5%B9%A3. ">[6]</span></a></sup>。</li><li>可兑换纸币。无论足值与否，金属货币的携带不便、容易损耗的缺点仍然没有克服，既然金属货币不足值也能正常执行货币职能，那么索性直接不用金属货币，改用其他材料呢？这就诞生了纸币，纸币本身也可以有区分，其中一类就是可兑换纸币，即 国家或银行以一定量的金属货币储备，发行本身没有价值的纸币，并宣布在任何时候任何地点，无条件地保证按纸币上记载的货币数额兑换相应的金属货币。</li><li>不兑换纸币。相比可兑换纸币，不兑换纸币是指由政府发行的不能兑换成金币的纸币，其完全失去了内在的使用价值和价值，而仅仅是一个观念上的符号，但仍保留着它所具有的数量特性，其购买力源自于国家的权威和信用，只要这种权威和信用不遭到质疑，国家就可以根据自己的意志来决定货币的发行量。</li><li>账户货币。账户货币也称为存款货币，是随着专营货币的银行机构的出现而广泛使用的。账户货币是完全非实物的形式，体现为银行账户的数字记录。</li></ul><div class="note green icon-padding modern"><i class="note-icon fas fa-cube"></i><p><strong>小课堂：纸币开始，货币已经完全失去内在价值，只是作为交易媒介、信用载体而存在，而其信用完全取决于货币发行方，通常是中央政府。到此，可以初步理解 J.P.Morgan 的观点了。而且到了这一阶段，货币也已经不能再称作是一般等价物(Universal Equivalent)了，而只是衡量 信用&#x2F;债务的一种工具。</strong></p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-cube"></i><p>小贴士：中国宋、元时期开始使用纸币，到明朝倒退回白银等金属货币，就是因为无法解决中央信用问题。</p></div><h4 id="2-2-3-小结"><a href="#2-2-3-小结" class="headerlink" title="2.2.3 小结"></a>2.2.3 小结</h4><ul><li>信用货币取代实物货币是一个必然事件，主要是由于实物货币的流通有两个难以克服的矛盾：<ul><li>一是实物的产量受到自然条件的约束，缺乏供给弹性</li><li>二是实物货币兼具商品与货币两种属性，实物货币的商品属性与货币属性之间的矛盾会干扰货币的稳定性</li></ul></li><li>信用货币取代实物货币是一个量变到质变的过程</li><li>银行账户货币成为主要的信用货币形式</li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-cube"></i><p>小贴士：从本质上来说，货币就是信用，实物货币与信用货币的区别仅仅在于这种信用是内在的还是外在的。实物货币之所以被接受，根本原因是因为人们相信它提供了一种购买力的信用，只是这种信用的担保主体是直接的实物货币本身，因为实物本身就具有价值。而货币形态逐渐发展，信用的担保主体更多地来自于外在的权威，最终完全由外在信用确保货币的购买力。在这一发展过程中，中央银行信用和商业银行信用逐渐成为主要的外在信用形式。<strong>到此，可以反驳J.P. Morgan了：黄金也不过是信用。</strong></p></div><h2 id="3-Credit-Creation"><a href="#3-Credit-Creation" class="headerlink" title="3. Credit Creation"></a>3. Credit Creation</h2><p>如上所述，目前世界各地的流通货币基本就是纸币和账户货币，本质上都是信用，那么有必要解释一下现代银行最基本的<code>部分准备金制度(Fractional Reserve System)</code>，与<code>信用创造(Credit Creation)</code>的过程，了解这些之后再去看J.P. Morgan的话，也许又是另一种感慨。<sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="khanacademy, khan academy. “Money Creation in a Fractional Reserve System.” YouTube, YouTube, 12 Mar. 2018, https://www.youtube.com/watch?v=gd8B-zrMSYk. ">[8]</span></a></sup><br>下面我们先用一个较为不求甚解的流程了解下信用创造的过程：</p><ul><li>Stage 1: 某一居民 A1 通过劳动获得了一笔1000元的收入，但是拿到的是纸币，为了方便使用决定将其存入商业银行B。此时纸币转移给了商业银行B，商业银行B有1000元的资产，同时小本本上也记下一笔账，对 A1 有1000元的负债，在 A1 有需要来支取时，需要归还给 A1。</li><li>Stage 2: 另一居民 A2 响应全民创业的号召，想要开家奶茶店，却身无分文，于是 商业银行B 将1000元借给了 A2。此时纸币转移给了 A2，商业银行有对 A2 的应收 1000元，A2需要到期归还该债务。</li><li>Stage 3: A2拿到1000元后，发现房租就要1000元，直接将1000元给了房东A3，此时A2获取了房屋的使用权，纸币转移给了A3。</li><li>Stage 4: A3资产太多，1000元根本没处花，于是又将1000元存进了商业银行B。此时纸币又转移给了商业银行B，但此时商业银行B的资产端除了1000元纸币，还有对A2的应收1000元，同时有对A1、A3的负债端。</li><li>……</li></ul><p>按照上面的流程，我们会发现，这样商业银行B岂不是可以无限循环放贷，同时A1、A2、A3、A4… 都觉得自己有1000元，这些信用就是凭空创造出来的，这也就是最简单的Credit Creation过程。<code>对商业银行不做监管的场景下，信用完全是由商业银行自身提供的。</code></p><p>当然，按照上面的过程，一旦有大于等于两个人同时向商业银行B取款，B实际上是拿不出那么多钱出来的，这也就是所谓的挤兑风险。<br>可以看出来，让商业银行B无限制的吸收存款并放贷，其风险是巨大的，因此出现了准备金制度(Reserve System)，简单来说就是，商业银行B每吸收1000元存款，就需要将这1000元上缴中央银行，这样商业银行就无法利用储户存款进行放贷了，也就不怕挤兑风险了，这个例子中商业银行将1000元完全上缴，因此称之为全额准备金制度(Full Reserve System)，商业银行也因此失去了放贷空间。</p><div class="note green icon-padding modern"><i class="note-icon fas fa-cube"></i><p>小课堂：中央银行是发行的银行、银行的银行、政府的银行。</p><ul><li>发行的银行。是指国家赋予中央银行集中与垄断货币发行的特权，中央银行是国家唯一的货币发行机构。</li><li>银行的银行。是指作为国家的金融管理机构，中央银行在整个金融体系中居于领导地位，并与商业银行和其他金融机构进行存、放、汇等业务上的往来。</li><li>政府的银行。是指中央银行代表国家贯彻执行货币金融政策，代为管理政府财政收支以及为政府提供各种金融服务。</li></ul></div><p>与全额准备金制度相对应的是部分准备金制度(Fractional Reserve System)，即商业银行吸收存款后，留下一部份作为准备金，把其余的资金全部贷出的制度。还是假设初始吸储1000元，按照10%的准备金制度，那么理论上商业银行最终能吸收的存款总额是：<code>Sum = 1000 + 1000 * (1-0.1) + 1000 * (1-0.1)^2 + ... + 1000 * (1-0.1)^n</code>，<code>n</code>趋于无穷大时，按照等比数列的求和公式得到：<code>Sum = 1000/0.1</code>。也就是说，按照部分准备金制度，给定初始信用 <code>C</code>，存款准备金比率为 <code>r</code>，那么理论上可以创造出的信用上限是 <code>C/r</code>。当然，实际中由于货币面值是离散而非连续的，银行也不可能无限次的放贷吸储，因此理论上限永远不可能达到。</p><p>在上面的最简单的推演过程中，默认了一个事实，那就是市场本身就有货币存在，至于最开始的钱，到底是怎么出现的尚不理解，难度是央行开动印钞机然后发给居民的吗？可是生活了这么久，好像没有遇到过发钱这种好事呀？而实际上这个疑问，可以通过<a href="http://www.pbc.gov.cn/diaochatongjisi/resource/cms/2022/06/2022061416000759028.htm">央行的资产负债表</a>推演出来，由于央行的发出去的钱（也就是信用）就是其负债，所以央行的负债简单概括就是信用，而分析其资产端，就可以明白钱是怎么产生的了。</p><p><img src="/images/all_about_payment/all_about_payment01_04.png" alt="Assets of Central Bank"></p><p>首先给出一种理想状态，假设国家有一个初始的理想状态，政府职能完整，各类机构健全，居民拥有初始生产资料，但唯一不存在的就是货币，也就是说，所有机构、企业、个人都没有任何货币存在。然后我们来依次推演：</p><ul><li>Stage 1: 小明在做外贸生意，将产品卖给了美国人，收到了美元 10000$</li><li>Stage 2: 小明找境内某银行B进行兑换，B通过外汇交易系统，总之最终找央行换了67000￥，而这67000￥就存在于小明的账户中，而1000$就是央行的资产，而相应的就是央行负债端端货币发行也多了67000¥，此时央行就已经完成了货币的发行，只是没有纸币而已。</li><li>Stage 3: 如果小明此时找银行B取款，那么就需要央行发动印钞机印出来67000￥最终给到小明</li><li>Stage 4: 小明再将67000￥存入银行B，那么实际上就回到了上面信用创造的过程，货币就此流通了起来</li></ul><p>在上面的推演中，可以看到Stage 3和Stage 4其实可以不存在，也就是说纸币本身并不需要真的印出来才能说钱印了出来（术语就是央行发行了货币），这也更加说明了：<code>账户货币是完全非实物的形式，体现为银行账户的数字记录。</code></p><p>以上是外汇资产进入央行的资产负债表，创造出信用的过程，其他资产也是相同，当某一项资产进入到了央行的资产端，要么减少另一项资产，要么增加负债而信用&#x2F;货币就是央行的负债，也就是说，央行的所谓印钞过程，就是央行产生负债的过程，也就是央行的信用创造过程。虽然央行创造了本币信用，但是资产端的外汇、货币黄金等倒也不是凭空产生的，是有实际价值的。而实际上还有更极端的形式，政府和央行联手，凭空造钱投放到市场中。<br>2020年年初新冠肺炎疫情席卷全球，海外主要经济体纷纷推出了大量经济刺激计划，且采取了央行直接购买国债的形式<sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="何琼 . 当前央行不宜通过购买国债投放基础货币, 中国金融新闻网, 17 June 2021, https://www.financialnews.com.cn/gc/ch/202106/t20210617_221193.html. ">[9]</span></a></sup>，我们不妨就以央行直接购买国债的形式，来说说政府和央行是怎么联手凭空造钱的。  </p><ul><li>Stage 1: 中央政府想要给公务员发工资、还想建设公共设施，而此时政府账号余额是0，该怎么办呢？</li><li>Stage 2: 于是中央政府找到央行，打印了面值10000元的欠条，告诉央行这就是10000元的国债，然后央行就印了10000元给中央政府。</li><li>Stage 3: 政府拿到这钱，该发工资发工资、该建楼就建楼，分分钟花完了，而这钱一旦花出去，实际上就流通到市场中了，再结合部分准备金制度的信用创造，就可以创造更多的流动性。</li><li>Stage 4: 政府的欠条到期也是要还的，政府当然也有方法赚钱，收税、卖地、收租… 总有一款适合。</li><li>Stage 5: 如果欠条到期了实在还不起怎么办？可以再打张欠条啊，借新还旧还不简单？</li></ul><p>从上面的过程可以看出来，央行直接购买国债的情况下，就是在变相直接印钱，而且这些钱背后并不像外汇、黄金一样有实物资产的担保，所谓的资产就是政府的欠条，这看起来似乎就是，政府信用换取了央行信用，央行信用就是货币… Kino觉得这两种货币发行方式的区别可以归纳为：先进行生产活动再创造货币 和 先创造货币再进行生产活动的区别。<br>正是因为央行出手直接购买国债印钱太过轻松，所以各国政府在2020疫情期间以此手段刺激经济， 而同样因为这种方式很可能造成严重通货膨胀等后果，截至目前国内也一直没有采取这种方法<sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="何琼 . 当前央行不宜通过购买国债投放基础货币, 中国金融新闻网, 17 June 2021, https://www.financialnews.com.cn/gc/ch/202106/t20210617_221193.html. ">[9]</span></a></sup>。那国内央行资产中的对政府债权又是从哪来的呢？关于这个也简单推演下，顺便说下央行资产中其他债务债权的来源。</p><div class="note blue icon-padding modern"><i class="note-icon fas fa-cube"></i><p>小贴士：《中国人民银行法》规定：中国人民银行不得对政府透支，不得直接认购、包销国债和其他政府债权。</p></div><ul><li>Stage 1: 商业银行通过各类方式（参考小贴士）吸收了居民存款10000￥，由于部分准备金制度，假设准备金率是10%的情况，那么商业银行至少要将其中 1000￥交给央行，但是需要注意的是，央行也是银行，虽然央行能印钱、能监管商业银行要求其必须交这1000￥，但是这1000￥不是商业银行赠送给央行的，而是商业银行在央行的存款，而这存款就体现在了央行负债中的<code>对其他存款性公司存款</code>。当然啦，最低1000￥，商业银行完全可以选择多出2000￥，直接存3000￥到央行，那么其中1000￥就是<code>存款准备金</code>，剩下2000￥就称为<code>超额准备金</code>或 <code>备付金</code>。值得注意的一点是，商业银行每存1000¥时，央行负债中<code>对其他存款性公司存款</code>就多1000¥，而货币发行就减少1000¥，因为实际上是央行回收了原始发行的 1000¥ 的欠条，将其变成了对商业银行的1000¥的欠条。</li><li>Stage 2: 政府钱不够用需要发债，于是印了一些欠条让商业银行代销或包销，最终这些欠条一部分在商业银行的资产中，一部分在个人手中，假设商业银行手中有价值2000￥的政府欠条（国债）</li><li>Stage 3: 由于政府信用较好，国债风险较低，央行也可以购买商业银行手中的2000￥的国债，如此一来，央行的资产中就出现了<code>对政府债权</code>，而央行出的这2000￥从哪来呢？总不能也直接印钱加到负债上吧，那和直接下场购买就没区别了，于是央行选择出售实际资产，也就是外汇、黄金等。</li><li>Stage 4: 而还有一些<code>对其他存款性公司债权</code>，这些是央行通过实施货币政策工具，在二级市场操作后，所形成的对其他存款性公司（包括商业银行、政策性银行、和信用社等可以吸收存款的金融机构）债权。央行在此科目进行货币投放的主要渠道包括逆回购(Reverse-repurchase Agreement)、再贷款(Re-lending)、再贴现(Rediscount)、中期借贷便利(Medium-term Lending Facility, MLF)和抵押补充贷款(Pledged Supplementary Lending, PSL)等。这些临时工具，可以短期扩张信用。</li></ul><div class="note blue icon-padding modern"><i class="note-icon fas fa-cube"></i><p>小贴士：一定要牢记，居民存款并不一定就是居民拿着人民币去银行存款才会产生，还有各种其他方式，比如：</p><ul><li>赚到外汇之后找银行兑换，直接进入到居民的存款账户</li><li>政府发债从央行拿到钱后，直接发钱到居民的工资账户<br>……</li></ul></div><p>说了这么多，让我们来看一看媒体中经常会出现的“央行降准释放流动性”、M0、M1、M2、扩表、缩表是个什么玩意？</p><ul><li>央行降准释放流动性：这个现在很容易理解了，就是前面所述的，存款准备金率调低，而根据之前的公式，可以得到每降低<code>Δr</code>的存款准备金率，理论上释放的流动性是<code>C/r - C/(r-Δr)</code>。</li><li>扩表：央行扩张资产负债表的过程。如上述例子中，通过吸收外汇、央行直接买国债等方式，央行的资产、负债同时扩张，即谓之扩表。</li><li>缩表：央行缩小资产负债表的过程。与扩表相反。</li><li>M0: 就是现钞(Cash)，也就是居民和企业手中的现钞。之所以M0单独统计，是因为这部分在银行体系之外自由流通，最灵活。</li><li>M1: 又叫“狭义货币”，由流通于银行体系以外的现钞（M0）和银行的活期存款构成。其中活期存款由于随时可以变现（提取），所以流动性和购买力不亚于现钞。</li><li>M2: 又叫“广义货币”，由流通于银行体系之外的现钞加上活期存款（M2），再加上定期存款、储蓄存款等构成。M2是货币家族的老大，包括了一切可能成为现实购买力的货币形式。定期存款、储蓄存款等不能直接变现，所以不能立即转变成现实的购买力，但经过一定的时间和手续后，也能够转变为购买力，因此，它们又叫做“准货币”。</li></ul><p>而最常见的M2，本质上就是受存款准备金率和储蓄率影响的，而储蓄率又和存款利息相关，因此调节存款准备金率和存款利息是调控广义货币最重要的方式。不妨来看一些极端情况：</p><ul><li>假设准备金率100%，央行发行了10¥的货币，全部流通到居民手中，此时M0是10¥，居民又100%地存进商业银行的活期，那么商业银行需要将这10¥全部存进央行，这个时候，央行的<code>货币发行</code>变成了0，<code>对其他存款性公司存款</code>变成了10¥，M0变成了0，M1、M2变成了10¥，而如果用户是做的定期存款，则M0、M1都是0，M2是10¥。</li><li>其他条件不变时，在10%的部分准备金率下，商业银行至少需要在央行存1¥，那么央行的货币发行变成了9，<code>对其他存款性公司存款</code>变成1¥，商业银行将剩下9贷出去，再吸储再贷，如此取极限情况下，这样M0趋于0，<code>对其他存款性公司存款</code>变成10¥，居民都是活期存款时，M1&#x3D;M2&#x3D;10&#x2F;0.1&#x3D;100，定期存款时，M1&#x3D;M0&#x3D;0，M2&#x3D;100。而通过调节存款利息，就可以调节定活存款比例了。</li></ul><p>通过极端情况推演，可以看到央行资产负债表不变的情况下，央行的货币发行+对其他存款性公司存款理应不变，而货币发行转化的越多，就相当于商业银行从现钞中吸收存款越多，转化为M1、M2的基数也越多。</p><h2 id="4-Cryptocurrency"><a href="#4-Cryptocurrency" class="headerlink" title="4. Cryptocurrency"></a>4. Cryptocurrency</h2><p>关于加密货币，目前的种类太多，有一些到底有没有货币属性在其中也让人存疑，所以暂且只考虑BTC，深入BTC的技术原理也很复杂，这里只探讨其货币属性背后，与传统信用货币的区别。</p><p>在前面的介绍中，Kino刻意弱化了资产、负债、借、贷、债务、债权的一些概念，直接拿来使用了，但是当下的货币&#x2F;信用，已经离不开这些基本的会计概念，而如果想了解BTC的本质，还是不得不了解这些概念的，完整的了解还是建议去系统地看书，建议阅读下 <code>世界上最简单的会计书</code><sup id="fnref:11"><a href="#fn:11" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="达雷尔.穆利斯. 世界上最简单的会计书. 机械工业出版社, 2013.">[11]</span></a></sup>，这里就先简单介绍下。</p><p>关于资产负债、借贷关系，最核心的两条原理(基于复式记账)是：</p><p align="center">资产 = 负债 + 所有者权益</p><p align="center">有借必有贷，借贷必相等</p><p>资产就是房子、车子、票子，以及各类欠条（即债权），而负债就是你欠别人的，剩下的就是所有者权益。而作为一个严谨的人，你决定统计你名下的所有资产、负债，记录下所有的资产负债变动，列下所有资产负债形成了资产负债表，统计所有变动形成了会计分录，为了统计变动需要对加加减减，为了沟通方便对这些加减起了个名字，资产增加、负债减少称之为借，资产减少、负债增加称之为贷。</p><p>如前所述，传统的账户货币，其信用来自于银行，你去存款、贷款，也都是银行在记账，个人可以记账也可以不记，记录了也没有法律效力。Kino去银行存了1万亿，银行有了1万亿的票子（本质就是对央行的债权）作为资产，同时记了一笔对Kino的1万亿的负债。某天去取钱时，银行不认这笔账，不愿意还了，Kino能做的是什么呢？只能寻求法律途径，用法律的武器捍卫自己的权益，但是钱是实实在在的没了，法律之所以能保护，因为银行有账本(ledger)，以及银行的银行央行有账本(ledger)，有没有发现，在现代信用货币体系中，这个账本(ledger)是重中之重，如果账本没了，这个钱就是不存在了，而有效合法的账本存在于一个中心节点（银行）的手中。到此，对信用货币的不信任也顺理成章了，BTC出现的时候，宣称的就是解决数字时代的账户货币的这个问题，货币本身就带有账本信息，每次交易都将这笔账记在货币本身，而且只有所有参与者中超过半数通过才能顺利交易，这其实就是简单版本的理解BTC的方法，这也是为何有人将BTC称为分布式账本的原因，本质就是在解决信用货币的账本的中心化信用问题。而至于更加BTC实现层面的细节，怎么发出第一枚BTC，挖矿又是什么，就请读者自行了解了。</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Azaraf, Dudu. “History of Pre-Bitcoin Money: Barter &amp; Banknotes.” Coinmama Blog, 29 June 2022, https://www.coinmama.com/blog/a-history-of-money-from-barter-to-banknotes-to-bitcoin/.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Krichene, Noureddine &amp; Ghassan, Hassan B., 2017. &quot;The Preeminence of Gold and Silver as Money,&quot; MPRA Paper 85798, University Library of Munich, Germany.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">殷剑峰 . “三千年东西方兴衰金融史.” NIFD 官方网站, 26 May 2021, http://www.nifd.cn/ResearchComment/Details/2748.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">佚名 . “什么是通货膨胀？.” 国家统计局, 10 June 2011, http://www.stats.gov.cn/ztjc/tjzs/zjcpi/201106/t20110610_71467.html.<a href="#fnref:4" rev="footnote">↩</a></span></li><li id="fn:5"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedian. “通货膨胀.” Wikipedia, Wikimedia Foundation, 13 June 2022, https://zh.wikipedia.org/wiki/%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80.<a href="#fnref:5" rev="footnote">↩</a></span></li><li id="fn:6"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedian. “劣币驱除良币.” Wikipedia, Wikimedia Foundation, 7 June 2022, https://zh.wikipedia.org/zh-cn/%E5%8A%A3%E5%B9%A3%E9%A9%85%E9%80%90%E8%89%AF%E5%B9%A3.<a href="#fnref:6" rev="footnote">↩</a></span></li><li id="fn:7"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Bridgewater, Ray Dalio. “How the Economic Machine Works.” YouTube, YouTube, 22 Sept. 2013, https://www.youtube.com/watch?v=PHe0bXAIuk0.<a href="#fnref:7" rev="footnote">↩</a></span></li><li id="fn:8"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">khanacademy, khan academy. “Money Creation in a Fractional Reserve System.” YouTube, YouTube, 12 Mar. 2018, https://www.youtube.com/watch?v=gd8B-zrMSYk.<a href="#fnref:8" rev="footnote">↩</a></span></li><li id="fn:9"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">何琼 . 当前央行不宜通过购买国债投放基础货币, 中国金融新闻网, 17 June 2021, https://www.financialnews.com.cn/gc/ch/202106/t20210617_221193.html.<a href="#fnref:9" rev="footnote">↩</a></span></li><li id="fn:10"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">李扬, 张晓晶, and 常欣. 中国国家资产负债表2020. 中国社会科学出版社, 2020.<a href="#fnref:10" rev="footnote">↩</a></span></li><li id="fn:11"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">达雷尔.穆利斯. 世界上最简单的会计书. 机械工业出版社, 2013.<a href="#fnref:11" rev="footnote">↩</a></span></li><li id="fn:12"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">中国人民银行办公厅 . “2018年以来金融机构平均法定存款准备金率变动情况.” 中国人民银行, 13 July 2022, http://www.pbc.gov.cn/rmyh/4027845/index.html.<a href="#fnref:12" rev="footnote">↩</a></span></li><li id="fn:13"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">温铁军. “建国初期共产党如何迅速而标本兼治地解决了民国的通货膨胀？.” 观察者网, 11 Oct. 2019, https://www.guancha.cn/WenTieJun/2019_10_11_520825_s.shtml.<a href="#fnref:13" rev="footnote">↩</a></span></li><li id="fn:14"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">14.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">唐智 . “聊聊数据.” 知乎专栏, 13 July 2022, https://www.zhihu.com/column/c_1040255824488312832.<a href="#fnref:14" rev="footnote">↩</a></span></li><li id="fn:15"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">15.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">赵建 . “央行上缴1万亿利润：怎么赚的？如何记账？有何影响？.” 新浪网, 9 Mar. 2022, https://finance.sina.com.cn/money/bank/bank_hydt/2022-03-09/doc-imcwipih7418462.shtml.<a href="#fnref:15" rev="footnote">↩</a></span></li><li id="fn:16"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">16.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">佚名 . “什么是流通中的现金(M0).” 中国人民银行, 银川中心支行, 26 Dec. 2013, http://yinchuan.pbc.gov.cn/yinchuan/120050/2678592/index.html.<a href="#fnref:16" rev="footnote">↩</a></span></li><li id="fn:17"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">17.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">佚名 . “货币供应量三兄弟M0/M1/M2” 中国人民银行, 合肥中心支行, 30 Apr. 2014, http://hefei.pbc.gov.cn/hefei/2927537/122429/2499986/index.html.<a href="#fnref:17" rev="footnote">↩</a></span></li><li id="fn:18"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">18.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">佚名 . “各国的M0/M1/M2所代表的含义是一样的吗？” 中国人民银行, 合肥中心支行, 30 Mar. 2014, http://hefei.pbc.gov.cn/hefei/2927537/122429/2546785/index.html.<a href="#fnref:18" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;note green icon-padding modern&quot;&gt;&lt;i class=&quot;note-icon fas fa-cube&quot;&gt;&lt;/i&gt;&lt;p&gt;Gold is money, everything else is credit. —— J.P. Morgan&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;0-Intro&quot;&gt;&lt;a href=&quot;#0-Intro&quot; class=&quot;headerlink&quot; title=&quot;0. Intro&quot;&gt;&lt;/a&gt;0. Intro&lt;/h2&gt;&lt;p&gt;J.P. Morgan在1912年说过的这句话，听者并不知所谓，初次听到总是会感觉很nb。但只有当你对现代支付体系的本质足够了解，才会理解这句话的精髓，同时也能够对很多经济现象 知其所以然 了，比如你会理解08年时总理说的“信心比黄金更重要”，也能够理解比特币究竟解决了什么问题？央行降准释放流动性的本质是什么？M0、M1、M2是个什么玩意？甚至你会反驳J.P. Morgan：黄金也不过是信用。&lt;/p&gt;
&lt;p&gt;所以“关于支付的一切”为何开篇就开始讨论信用？信用真的如此重要吗？要回答这个问题，首先需要回答另一个看似常识的问题：“货币是什么”？&lt;/p&gt;
&lt;p&gt;解答这个问题，不妨就让我们回顾一下历史。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/all_about_payment/all_about_payment01_01.png&quot; alt=&quot;Evolution of Money&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="technology" scheme="https://blog.xuwei.fun/categories/technology/"/>
    
    <category term="finance" scheme="https://blog.xuwei.fun/categories/technology/finance/"/>
    
    
    <category term="finance" scheme="https://blog.xuwei.fun/tags/finance/"/>
    
    <category term="payment" scheme="https://blog.xuwei.fun/tags/payment/"/>
    
    <category term="money" scheme="https://blog.xuwei.fun/tags/money/"/>
    
  </entry>
  
  <entry>
    <title>以禅之名(In the Name of Zen)其一 —— 序言篇</title>
    <link href="https://blog.xuwei.fun/2022/05/04/inTheNameOfZen01/"/>
    <id>https://blog.xuwei.fun/2022/05/04/inTheNameOfZen01/</id>
    <published>2022-05-04T10:27:58.000Z</published>
    <updated>2022-05-04T12:13:28.235Z</updated>
    
    <content type="html"><![CDATA[<div class="note green icon-padding modern"><i class="note-icon fas fa-cube"></i><p>The unexamined life is not worth living. —— Socrates</p></div><h2 id="一、楔子"><a href="#一、楔子" class="headerlink" title="一、楔子"></a>一、楔子</h2><p>苏格拉底曾说：“未经审视的人生是不值得过的”。Kino倒不完全赞同，如果一个人能够不需要审视自己的人生、不需要思考人生是否值得，就顺利地度过了一生，哲学家眼中仅此而已的活着，其实已经是超越大多数人的幸运了。如果一个社会，大多数人都可以如此度过一生，那必然是盛世才有的光景。可惜的是，这样的幸运在历史长河中，又能有多久呢？我甚至怀疑，千万年的历史长河中，真的有一人曾如此幸运过吗？总是有一些突如其来的事件，闯入你的生活，逼迫你去思考：“我是谁？我从哪里来？要到哪里去？”只是大多数情况，我们求而不得，便在事件淡去之后，又重投红尘，罢了罢了，何须思考，还是随着社会的大浪潮，读书、工作、恋爱、结婚、生子、死亡。随波逐流总是轻松的，思考才是最深刻的痛苦，“人生如果不想随波逐流，就等于是场豪赌，失败的人不胜枚举，成功的人寥寥无几”。大多数人总是会有一瞬的审视人生，但如果在此基础上加一个修饰语“持续”，情愿去持续审视自我人生的，究竟是哲学家还是疯子呢？</p><p>并不意外，Kino也曾间歇性地思考“人生的意义”究竟是什么，但也总是浅尝辄止，直到多年前经历过一些事之后，在反反复复地内心冲突之后，最终选择了反思，如顿悟一般，持续地开始思考“人生的意义”，阅读了一堆社科书籍之后，问了自己十万个为什么之后，终于给了自己一个回答，而这份回答，虽不敢说是标准答案，却依然想要输出呈现，若各位看客读过之后，能从中有所收获，自是最好不过，若只是浪费了时间，还请多多体谅。</p><p>不过输出的冲动，转化为实际的行动，又是另一回事了，知难行易才是现实。冲动是一直存在的，可相关的话题如此宏大，随便写上几千字倒不是问题，但完美主义者又总是幻想系统化的输出，如何构建这个系统，每个部分的内容、目录，甚至是整个系列的标题，这些都怎么去定，想不明白的话，是无法下笔的。但是有些事，总是要先开始做，才能被迫前进，不能等到被困乞力马扎罗濒死之时，才开始如此追忆：<mark class="hl-label blue">那些积攒下来的，想留到更有把握时再写的东西，现在再也无法写下来了。也不用忍受写作的挫败了。也许你根本就不会把它们写出来，这就是为什么你要把它们扔在一边，迟迟不肯动笔。但现在，他永远都不会知道答案了。</mark> </p><p>既然已经决定了去做，按照一个程序猿的思维，首先最重要的就是命名了。So，为何选在了“以禅之名”作为系列文章的标题？何又为“禅”？“禅”虽源自禅宗，但在此并不包含禅宗的任何文化、思想、修行等，Kino只是借用“禅”来指代一切真理，在《道德经》中是老子追求的“道”，在《禅与摩托车维修艺术》中，是波西格(Pirsig)追求的“良质(Quality)”，在《悉达多》中，是悉达多追寻一生的“阿特曼(Atman)”。因此，“以禅之名”系列，不过是一根会思考的芦苇，借用了“禅”的名义，来探讨自我追寻之路中的些许所思所想，仅此而已。</p><h2 id="二、概述"><a href="#二、概述" class="headerlink" title="二、概述"></a>二、概述</h2><p>这里Kino想先简单介绍下“以禅之名”会涉及的基本内容，这些内容间的内在逻辑又是什么？</p><p>首先，要强调的一点是，虽然“以禅之名”听起来似乎是哲学乃至玄学，但不同于常见的哲学思辨、宗教信仰作品，Kino想做的是依靠逻辑思辨、理性推导，从底层开始逐步构建出上层结构，再基于构建的体系，讨论对一些具体的哲学概念、社会结构的看法。</p><p>那么，从底层开始构建，这个底层元素究竟是什么呢？这里选取的是“基因”，基于自我复制的能力和系统的涌现(Emergence)，演化出来了更高层的生命，再经过自然选择，逐步演化，最终出现了一种独特的生命存在，那就是人类。人类虽然超越了其他生命的存在，可以思考人生，可以反思自我，但同时人类仍然不过是一种生命形式，在统计学意义上人类的部分本性永不改变。人类的诸多个体，在这种人性的指引下，又基于生存的需要，最终以血缘关系、社会契约等为纽带，开始构建早期的社会群体，而正如历史告诉我们的，随着时间的流逝，社会形态也在逐步演化，从氏族到国家，国家也在不断地进化，甚至于共产主义开始讨论的是阶级消灭，则国家不存在。除却国家的组织形式之外，现代社会充满了各种组织形式，同时又因为互联网的发展，网络上又涌现出了很多信息时代才有的新现象，这些背后的本质还是人性和系统的涌现。而当个体置身于这种大时代之中时，如何在社会机器和自我追求中平衡，如何妥善地处理人生意义感的缺失，这些都会在系列文章中，穿插涉及。</p><p>总结一下，就是“始于自私的基因，显为人性的弱点，终成社会性动物”。以此作为分析的基本框架，在此框架基础上，再额外拓展去考虑基因以下的更底层的元素，去见识一下宇宙的广袤。同时，再尝试用“基因-&gt;个体-&gt;群体”的基础框架去推演当今个体与社会的部分现象。希望所有人都能够视野彻底放开，不再局限于自身的爱与恨，不再沉溺于痛苦与烦恼，有“一切有为法，如梦幻泡影”的豁达，能够享受人生、感受快乐。</p><h2 id="三、目录"><a href="#三、目录" class="headerlink" title="三、目录"></a>三、目录</h2><p><img src="/images/in_the_name_of_zen/itnoz01_01.png" alt="content"></p><h2 id="四、推荐"><a href="#四、推荐" class="headerlink" title="四、推荐"></a>四、推荐</h2><p>阅读不是为了逃避，而是为了找到自我。So，如果你也在寻找自我、寻找意义，但又不想看阅读太多的话，Kino觉得可以先读以下几本书尝试一下：</p><ul><li>自私的基因</li><li>社会性动物</li><li>社会契约论</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note green icon-padding modern&quot;&gt;&lt;i class=&quot;note-icon fas fa-cube&quot;&gt;&lt;/i&gt;&lt;p&gt;The unexamined life is not worth living. —— Socrates&lt;/p&gt;</summary>
      
    
    
    
    <category term="philosophy" scheme="https://blog.xuwei.fun/categories/philosophy/"/>
    
    <category term="zen" scheme="https://blog.xuwei.fun/categories/philosophy/zen/"/>
    
    
    <category term="philosophy" scheme="https://blog.xuwei.fun/tags/philosophy/"/>
    
    <category term="zen" scheme="https://blog.xuwei.fun/tags/zen/"/>
    
  </entry>
  
  <entry>
    <title>衍生品笔记五 —— 期货市场</title>
    <link href="https://blog.xuwei.fun/2021/10/08/derivatives05/"/>
    <id>https://blog.xuwei.fun/2021/10/08/derivatives05/</id>
    <published>2021-10-08T14:40:14.000Z</published>
    <updated>2022-02-20T14:48:01.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于远期交易、互换交易，基本都是场外交易，通常都是专业的外汇交易员才会接触这些，对于个人投资&#x2F;投机者来说，接触的可能性较小。因此还是先从期货、期权学起，再到远期、互换比较合理。</p><span id="more"></span><h2 id="1-期货市场"><a href="#1-期货市场" class="headerlink" title="1. 期货市场"></a>1. 期货市场</h2><p>期货市场有一些基本制度:</p><ul><li>交易所: 规避违约风险(default)</li><li>标准化: 促进流动性(liquidity)</li><li>保证金: 增加杠杆(leverage)</li><li>daily settlement: 每日无负债结算, 也可称为mark to market(逐日盯市). 当保证金不足时，会收到Margin Call(追加保证金通知)，提醒需要追加现金或现金等价物(通常就是国债)</li><li>delivery: 交割制度是期货市场和现货市场的连结，期货在趋于交割日时，价格会收敛到现货价格，否则就会存在套利机会<ul><li>physical delivery: 实物交割。商品期货等</li><li>cash settlement: 现金交割。指数期货等</li><li>有些特殊标的既可以实物交割，也可现金交割，取决于市场。比如国债期货、欧洲美元&#x2F;离岸美元(Euro dollar)期货等</li></ul></li><li>position limit: 防止操纵市场。头寸限制也取决于交易类型，套期保值头寸限制的数值较大</li><li>large investor report: 大户报告. 认定的大户，进入交割月后需要报告实际资产状况</li><li>风险准备金: 用于违约后的赔偿</li></ul><blockquote><p>交易所中有hedger(套期保值者)、speculator(投机者)，引入投机者是为了提供对手方、提供流动性</p></blockquote><blockquote><p>欧洲美元期货：其标的资产是本金为100万美元，3个月后到期的欧洲美元定期存款。由于最终是现金交割，除去本金，本质上标的资产是利率。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="CME Group. “Eurodollar Overview.” Futures & Options Trading for Risk Management - CME Group, 8 Oct. 2021, https://www.cmegroup.com/markets/interest-rates/stirs/eurodollar.html.">[1]</span></a></sup></p></blockquote><h2 id="2-期货合约"><a href="#2-期货合约" class="headerlink" title="2. 期货合约"></a>2. 期货合约</h2><p>合约要素(参考国内市场):</p><ul><li>合约名称(Contract Name)</li><li>基础资产(Underlying Assets)</li><li>交易单位(Contract Size)</li><li>报价单位(Price Quotation)</li><li>最小变动价位(Minimum Price Fluctuation)</li><li>涨跌停板幅度(Daily Price Limit)</li><li>合约月份(Contract Months)</li><li>交易时间(Trading Hours)</li><li>最后交易日(Last Trading Day)</li><li>交割日期(Delivery Period)</li><li>交割品级(Grade and Quality Specifications)</li><li>交割地点(Delivery Venue)</li><li>交割单位(Delivery Size)</li><li>最低交易保证金(Minimum Trade Margin)</li><li>交割方式(Settlement Method)</li><li>交易代码(Contract Code)</li><li>上市交易场所(Exchange)</li></ul><h2 id="3-期货术语"><a href="#3-期货术语" class="headerlink" title="3. 期货术语"></a>3. 期货术语</h2><ul><li>contango: 期货溢价，即期货升水、现货贴水. 期货价格近底远高</li><li>backwadation: 现货溢价，即现货升水、期货贴水. 期货价格近高远底</li><li>basis: 基差，即现货-期货的价格，但是期货要取最近月的期货合约</li><li>open interest: 未平仓合约总量</li><li>volume of trading: 交易量</li></ul><blockquote><p>对于非利率期货来说，在供求关系基本平衡的情况下，远月合约由于存货持有成本的存在，所以会比近月合约价格更高.<br><strong>然而利率期货恰好反过来，因为利率期货报价是反向的，也因此使价格反向了</strong></p></blockquote><h2 id="4-期货监管"><a href="#4-期货监管" class="headerlink" title="4. 期货监管"></a>4. 期货监管</h2><p>一委一行两会:</p><ul><li>国务院金融稳定发展委员会</li><li>中国人民银行</li><li>中国银行保险监督管理委员会</li><li>中国证券监督管理委员会</li></ul><p>证监会下有期货监管部，负责监管期货交易所，期货交易所有:</p><ul><li>大连商品交易所</li><li>上海期货交易所</li><li>郑州商品交易所</li><li>中国金融期货交易所(公司制，原始注册资本为5亿元人民币，分别由大连商品交易所、上海期货交易所、上海证券交易所、深圳证券交易所和郑州商品交易所等五家机构各出资1亿元)</li></ul><p>交易所监管其会员，交易所的会员有期货经纪公司 和 自营会员</p><h2 id="5-套期保值"><a href="#5-套期保值" class="headerlink" title="5. 套期保值"></a>5. 套期保值</h2><blockquote><p>套期保值是指把期货市场当作转移价格风险的场所，利用期货合约作为将来在现货市场上买卖商品的临时替代物，对其现在买进准备以后售出商品或对将来需要买进商品的价格进行保险的交易活动。<br>套期保值实际上是现货市场和期货市场的双向下注.<br>对于inventory一方来说，需要规避存货价格下跌的风险，而对于demand一方来说，需要规避存货价格上涨的风险</p></blockquote><ul><li>Long hedge(多头套期保值): 在期货市场的初始头寸是long，就是long hedge</li><li>Short hedge(空头套期保值): 在期货市场的初始头寸是short，就是short hedge</li></ul><h2 id="6-金融期货"><a href="#6-金融期货" class="headerlink" title="6. 金融期货"></a>6. 金融期货</h2><p>外汇期货、利率期货、股指期货(是虚拟金融工具, 天然现金结算)等，外汇期货、股指期货比较简单，下面说的都是利率期货相关内容。</p><ul><li>day count conventions: 国债、企业债、货币市场工具的计息日计算方法都不尽相同，实际交易时需要关注</li><li>discount rate: 折现率</li><li>quoted price: 报价</li><li>cash price: 全价，即包含利息的价格，也是dirty price &#x3D; quoted price + accrued interest</li><li>clean price: 净价</li></ul><p>对于T-note, T-bond来说，现货和期货市场都采用净价报价方式，<strong>而T-bill比较特殊，现货市场采用折现率报价，期货市场可能是反向，比如Eurodollar，报价方式是100-参考利率如LIBOR，联邦基金的拆借利率也类似</strong></p><blockquote><p>T-bond的交割标的有一篮子债券，根据与标准券(例如每半年付息一次，到期收益率和票面利率都是6%)相比制定转换因子，交割时不同债券做相应的转换</p></blockquote><blockquote><ul><li>记账式附息国债: 没有实物形态的票券，以电脑记账形式记录债权，通过无纸化方式发行和交易</li><li>凭证式储蓄国债: 通过银行系统发行，券面上不印制票面金额，为非标准格式，根据认购者的认购额填写实际的缴款金额，以“储蓄国债（凭证式）收款凭证”记录债权</li></ul></blockquote><blockquote><p>Eurodollar Futures的具体合约规则可参考<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="CME Group. “Eurodollar Futures Contract Specs.” Futures &amp; Options Trading for Risk Management, 10 Oct. 2021, https://www.cmegroup.com/markets/interest-rates/stirs/eurodollar.contractSpecs.html.">[7]</span></a></sup></p></blockquote><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">CME Group. “Eurodollar Overview.” Futures &amp; Options Trading for Risk Management - CME Group, 8 Oct. 2021, https://www.cmegroup.com/markets/interest-rates/stirs/eurodollar.html.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Hedge (finance)” Wikipedia, Wikimedia Foundation, 6 Sept. 2021, https://en.wikipedia.org/wiki/Hedge_(finance)<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">资本小论 . “深度研究：关于商品价格波动、对商品顶底的解读.” 雪球, 23 Nov. 2020, https://xueqiu.com/1212782157/163967872.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">资本小论 . “Contango结构下商品的套利分析.” 雪球, 1 Dec. 2020, https://xueqiu.com/1212782157/164656709.<a href="#fnref:4" rev="footnote">↩</a></span></li><li id="fn:5"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">资本小论 . “商品期货在 Back 结构下的套利分析.” Longbridge, 12 Jan. 2021, https://longbridgeapp.com/en/topics/624239.<a href="#fnref:5" rev="footnote">↩</a></span></li><li id="fn:6"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Eurodollar” Wikipedia, Wikimedia Foundation, 7 July. 2021, https://en.wikipedia.org/wiki/Eurodollar<a href="#fnref:6" rev="footnote">↩</a></span></li><li id="fn:7"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">CME Group. “Eurodollar Futures Contract Specs.” Futures &amp; Options Trading for Risk Management, 10 Oct. 2021, https://www.cmegroup.com/markets/interest-rates/stirs/eurodollar.contractSpecs.html.<a href="#fnref:7" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于远期交易、互换交易，基本都是场外交易，通常都是专业的外汇交易员才会接触这些，对于个人投资&amp;#x2F;投机者来说，接触的可能性较小。因此还是先从期货、期权学起，再到远期、互换比较合理。&lt;/p&gt;</summary>
    
    
    
    <category term="technology" scheme="https://blog.xuwei.fun/categories/technology/"/>
    
    <category term="finance" scheme="https://blog.xuwei.fun/categories/technology/finance/"/>
    
    
    <category term="finance" scheme="https://blog.xuwei.fun/tags/finance/"/>
    
    <category term="invest" scheme="https://blog.xuwei.fun/tags/invest/"/>
    
    <category term="derivatives" scheme="https://blog.xuwei.fun/tags/derivatives/"/>
    
    <category term="futures" scheme="https://blog.xuwei.fun/tags/futures/"/>
    
  </entry>
  
  <entry>
    <title>衍生品笔记四 —— 互换</title>
    <link href="https://blog.xuwei.fun/2021/10/07/derivatives04/"/>
    <id>https://blog.xuwei.fun/2021/10/07/derivatives04/</id>
    <published>2021-10-07T10:33:22.000Z</published>
    <updated>2022-02-20T14:48:05.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面已经介绍了远期、期货、期权，最后再来简单介绍下互换。</p><span id="more"></span><h2 id="1-互换-Swap"><a href="#1-互换-Swap" class="headerlink" title="1. 互换(Swap)"></a>1. 互换(Swap)</h2><p>互换，通常也被称为掉期交易，在Wikipedia上给出的定义是:<br>A swap, in finance, is an agreement between two counterparties to exchange financial instruments or cashflows or payments for a certain time. The instruments can be almost anything but most swaps involve cash based on a notional principal amount.<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. “Swap (Finance).” Wikipedia, Wikimedia Foundation, 6 Sept. 2021, https://en.wikipedia.org/wiki/Swap_(finance).">[1]</span></a></sup></p><p>简单点来看，互换其实也就是顾名思义: 指交易双方约定在未来某一期限相互交换各自持有的金融工具、现金流、支付款项的协议，通常这些金融工具都是基于名义本金的现金流<br>而根据国际清算银行(BIS)的定义，金融掉期是交易双方在一定期间内，掉期不同标的物之现金流的协议。</p><h2 id="2-利率互换-x2F-利率掉期"><a href="#2-利率互换-x2F-利率掉期" class="headerlink" title="2. 利率互换&#x2F;利率掉期"></a>2. 利率互换&#x2F;利率掉期</h2><p>利率掉期的基本交易型态为固定利率与浮动利率(Fixed-Floating Swap)的掉期，亦称为Plain Vanilla IRS，市场上尚有牵涉不同浮动利率指标间的掉期，如基差掉期(Basis Swap)等，完全视交易双方对利率指标之选择，较常见的浮动利率指标为LIBOR。<br>通常，将支付Fixed rate一方视为Payer，另一方视为Receiver<br>对人民币的浮动利率而言，目前人民币利率互换浮动端利率包括最优贷款利率(LPR)、人民银行定期存贷款利率、Shibor利率(隔夜、3个月品种)、银行间7天回购定盘利率(FR007)四大类。其中LPR就是2020年调整之后的房贷利率</p><blockquote><p>对于资产项和负债项来说，期待的利率趋势其实是不同的<br>利率互换，最终计算的是基于名义本金的利率差额</p></blockquote><h2 id="3-外汇互换"><a href="#3-外汇互换" class="headerlink" title="3. 外汇互换"></a>3. 外汇互换</h2><p>外汇互换（又称外汇掉期）是结合外汇现货及远期交易的一种合约，合约双方约定某一日期按即期汇率交换一定数额的外汇，然后在未来某一日期，按约定的汇率(即远期汇率)以相等金额再交换回来。实际上，合约双方是各自获得交换回来的货币一定时间的使用权。外汇互换的条件，反映了合约双方对所交换的两种货币的汇率走势及各自对利率的看法。外汇互换以远期点数的方式报价，除了可用来锁定在未来某一时点交换货币的汇率外，亦可作为对即期与远期汇率间的异常差距进行套利的手段。</p><blockquote><p>外汇互换，开始和结束的一期需要互换本金，但是除开始之外的其他期，还需要支出和收入利息</p></blockquote><p>一笔外汇互换交易的现金流状况，图中左侧为USD，右侧为GBP:<br><img src="/images/derivatives/derivatives04_01.jpg" alt="cash_flows"></p><p>可以看出，这笔交易相当于借出USD，借入GBP，因此利息收入是USD，利息支出是GBP</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Swap (Finance).” Wikipedia, Wikimedia Foundation, 6 Sept. 2021, https://en.wikipedia.org/wiki/Swap_(finance).<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “利率掉期交易.” Wikipedia, Wikimedia Foundation, 20 Sept. 2021, https://zh.wikipedia.org/wiki/利率掉期交易.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Currency Swap.” Wikipedia, Wikimedia Foundation, 4 Aug. 2021, https://en.wikipedia.org/wiki/Currency_swap.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Unknown. “外汇互换” MBA智库百科, 28 Dec. 2009, https://wiki.mbalib.com/wiki/外汇互换<a href="#fnref:4" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前面已经介绍了远期、期货、期权，最后再来简单介绍下互换。&lt;/p&gt;</summary>
    
    
    
    <category term="technology" scheme="https://blog.xuwei.fun/categories/technology/"/>
    
    <category term="finance" scheme="https://blog.xuwei.fun/categories/technology/finance/"/>
    
    
    <category term="finance" scheme="https://blog.xuwei.fun/tags/finance/"/>
    
    <category term="invest" scheme="https://blog.xuwei.fun/tags/invest/"/>
    
    <category term="derivatives" scheme="https://blog.xuwei.fun/tags/derivatives/"/>
    
    <category term="swap" scheme="https://blog.xuwei.fun/tags/swap/"/>
    
  </entry>
  
  <entry>
    <title>衍生品笔记三 —— 期货期权</title>
    <link href="https://blog.xuwei.fun/2021/10/06/derivatives03/"/>
    <id>https://blog.xuwei.fun/2021/10/06/derivatives03/</id>
    <published>2021-10-06T13:27:04.000Z</published>
    <updated>2022-02-20T14:48:10.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="/2021/10/04/derivatives02/">衍生品笔记二</a>中，说起期货和远期的差别，实际上就是场内、场外的区别。除了期货，期权也是场内交易的，但是期权和期货的关系，ummm，就像老婆和老婆饼的关系一样。<br>本次先简单学习下期货、期权的一些概念。</p><span id="more"></span><h2 id="1-期货合约"><a href="#1-期货合约" class="headerlink" title="1. 期货合约"></a>1. 期货合约</h2><p>概念上近似远期协议，约定在未来某一时刻以某一价格交割某一标的资产。<br>区别是期货合约是场内交易的，因此是一个标准化的合约，由交易所做出履约保证</p><p>全球各地可以进行期货交易的交易所:</p><ul><li>Chicago Board of Trade</li><li>Chicago Mercantile Exchange</li><li>LIFFE (London)</li><li>Eurex (Europe)</li><li>BM&amp;F (Sao Paulo, Brazil)</li><li>TIFFE (Tokyo)</li><li>上海期货交易所</li><li>郑州商品交易所</li><li>大连商品交易所</li><li>中国金融期货交易所</li><li>上海国际能源交易中心</li><li>……</li></ul><p>期货合约要素</p><h2 id="2-期权合约"><a href="#2-期权合约" class="headerlink" title="2. 期权合约"></a>2. 期权合约</h2><p>Options 核心是权利，交易的是权利，为了交易权利所付出的金钱称为premium(权利金).<br>期权是非对称交易，期权的买方拥有权利没有义务，期权的卖方有义务无权利.<br>期权的多头是买入权利，空头是卖出权利，但是买入卖出的权利又可分为看涨(call)&#x2F;看跌(put)两类</p><ul><li>call: 看涨期权(call option)又称认购期权，买进期权，买方期权，买权，延买期权，或“敲进”，是指期权的购买者拥有在期权合约有效期内按执行价格买进一定数量标的物的权利。看涨期权是这样一种合约: 它给合约持有者（即买方）按照约定的价格从对手手中购买特定数量之特定交易标的物的权利。</li><li>put: 看跌期权(put option)又称认沽期权，看跌期权则与看涨期权正好相反，它赋予了持有者在未来以确定的价格，也就是行权价格卖出的权利，所以看跌期权的持有者会希望标的资产价格的下跌幅度越大越好。</li></ul><p>在到期日(Expiration Date)买入&#x2F;卖出的价格就是 settle price，也就是行权价格&#x2F;执行价格…<br>而根据权利行权时间的区别，又可分为欧式期权(European Options)和美式期权(American Options)</p><ul><li>欧式期权: 只能在到期日行权</li><li>美式期权: 可以在成交后有效期内任何一天行权</li></ul><p>期权的优势是可以通过对冲平仓免除履约责任.</p><p>期权交易的概念上还算容易理解，就是交易权利嘛，期权卖方赚的就是时间权利金。但是怎么给权利定价呢？股票X票面价值100$，总不能直接就收100$的权利金吧，那铁定没人买啊。期权的价格和标的资产的价格通常差距是很大的，如图所示:<br><img src="/images/derivatives/derivatives03_01.jpg" alt="ge_options"></p><p>那么究竟怎么给期权定价？实际上期权定价的数学模型都比较复杂，比如常见的有:</p><ul><li>Black-Scholes Option Pricing Model</li><li>Black–Scholes–Merton model</li></ul><p>期权在行权前，也可以在场内互相交易，而由于标的物的价格变化，导致期权有虚值、实值、平值的区别，期权的成交价也会变化。具体这些概念，得单开一文再说，否则会陷入概念循环地狱。</p><p>全球各地可以进行期权交易的交易所:</p><ul><li>Chicago Board Options Exchange</li><li>American Stock Exchange</li><li>Philadelphia Stock Exchange</li><li>Pacific Exchange</li><li>LIFFE (London)</li><li>Eurex (Europe)</li><li>……</li></ul><blockquote><p>Q: 那么中国大陆境内有没有期权交易呢?<br>A: 也是有的. 沪深300ETF和上证50ETF</p></blockquote><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Futures Contract.” Wikipedia, Wikimedia Foundation, 6 Oct. 2021, https://en.wikipedia.org/wiki/Futures_contract.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">- 合约名称(Contract Name)- 基础资产(Underlying Assets)- 交易单位(Contract Size)- 报价单位(Price Quotation)- 最小变动价位(Minimum Price Fluctuation)- 涨跌停板幅度(Daily Price Limit)- 合约月份(Contract Months)- 交易时间(Trading Hours)- 最后交易日(Last Trading Day)- 交割日期(Delivery Period)- 交割品级(Grade and Quality Specifications)- 交割地点(Delivery Venue)- 交割单位(Delivery Size)- 最低交易保证金(Minimum Trade Margin)- 交割方式(Settlement Method)- 交易代码(Contract Code)- 上市交易场所(Exchange)<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">中国证券监督管理委员会. “期货合约要素.” 中国证券监督管理委员会, 26 Feb. 2020, http://www.csrc.gov.cn/pub/zjhpublic/zjh/202002/P020200228535813027616.pdf.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Black–Scholes model” Wikipedia, Wikimedia Foundation, 17 Sep. 2021, https://en.wikipedia.org/wiki/Black%E2%80%93Scholes_model.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Unknown. “Black-Scholes期权定价模型.” MBA智库百科, 9 Apr. 2008, https://wiki.mbalib.com/wiki/Black-Scholes期权定价模型.<a href="#fnref:4" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;/2021/10/04/derivatives02/&quot;&gt;衍生品笔记二&lt;/a&gt;中，说起期货和远期的差别，实际上就是场内、场外的区别。除了期货，期权也是场内交易的，但是期权和期货的关系，ummm，就像老婆和老婆饼的关系一样。&lt;br&gt;本次先简单学习下期货、期权的一些概念。&lt;/p&gt;</summary>
    
    
    
    <category term="technology" scheme="https://blog.xuwei.fun/categories/technology/"/>
    
    <category term="finance" scheme="https://blog.xuwei.fun/categories/technology/finance/"/>
    
    
    <category term="finance" scheme="https://blog.xuwei.fun/tags/finance/"/>
    
    <category term="invest" scheme="https://blog.xuwei.fun/tags/invest/"/>
    
    <category term="derivatives" scheme="https://blog.xuwei.fun/tags/derivatives/"/>
    
    <category term="futures" scheme="https://blog.xuwei.fun/tags/futures/"/>
    
    <category term="options" scheme="https://blog.xuwei.fun/tags/options/"/>
    
  </entry>
  
  <entry>
    <title>衍生品笔记二 —— 远期</title>
    <link href="https://blog.xuwei.fun/2021/10/04/derivatives02/"/>
    <id>https://blog.xuwei.fun/2021/10/04/derivatives02/</id>
    <published>2021-10-04T02:00:00.000Z</published>
    <updated>2022-02-20T14:48:15.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正如在<a href="/2021/10/03/derivatives01/">衍生品笔记一</a>提到的开篇提到的猪肉期货，上下游企业都可以通过期货交易来套期保值，远期的出现也是相同的目的，远期和期货本质的区别，其实只是场内还是场外的区别。期货是场内交易，合约标准化，信用风险也由交易所承担了，而远期是场外交易，协议怎么定可以一事一议，只要交易双方都认可就行。<br>从另一方面来说，也就是远期定义的要素更少，那就从远期先看起。<br>世界范围来看，远期交易中比例最大的标的是汇率、利率。</p><span id="more"></span><h2 id="1-远期汇率-外汇远期"><a href="#1-远期汇率-外汇远期" class="headerlink" title="1. 远期汇率(外汇远期)"></a>1. 远期汇率(外汇远期)</h2><p>根据时间不同，同一标的也会有多个远期合约<br>由于外汇交易中，是以货币换货币，所以需要设定一种货币为商品，另一种为计价货币<br>明确了商品方、计价方，才能够判断多空双方</p><ul><li>多头(long position): 买方</li><li>空头(short position): 卖方</li></ul><p>对于非管制货币来说，由于可以自动兑换，通常做直接远期交易(Outright forward)即可满足需求，在约定的时间以约定价格买卖货币。<br>但是对于管制货币，因为无法直接交易，所以有了NDF(Non-deliverable forward)，不交割本金，只交割计价货币的差额</p><blockquote><p>NDF: 首先要明确一点的是，NDF实际上并不做货币兑换，这更类似于一个赌博协议。以CNY&#x2F;USD为例，假设A预计3个月后会收到一笔 10000 CNY的收入，但是需要换成美金，由于CNY&#x2F;USD没法自由兑换，因此A和做市商做了一笔NDF交易。由于NDF不交割本金，实际上三个月后10000CNY的收入还是在A的账户里，需要A自行将人民币兑换出境，而A和做市商之间只需要就现货汇率计算出损益，进行最终交割即可。<br>为方便计算，假设CNY&#x2F;USD 的三个月远期汇率为 10，也就是说A预期是三个月后以汇率10兑换出境，获得1000USD，而实际上三个月后，CNY&#x2F;USD的现货可能是:</p><ul><li>10。那恰好，A和做市商之间损益为0</li><li>20。那实际上A现在将10000 CNY兑换出境后只能得到500 USD，和预期相比少了500USD，这500USD就由做市商来弥补，因为最终只交割这500USD，不交割本金，所以才是NDF</li><li>5。那实际上A现在将10000 CNY兑换出境后能得到2000 USD，和预期相比多了1000USD，这1000USD就由A来补偿给做市商，因为最终只交割这1000USD，不交割本金，所以才是NDF</li></ul></blockquote><h2 id="2-远期利率-Forward-rate"><a href="#2-远期利率-Forward-rate" class="headerlink" title="2. 远期利率(Forward rate)"></a>2. 远期利率(Forward rate)</h2><p>与远期利率相对应的有如下利率:</p><ul><li>即期利率(Spot rate): 当前时间点上零息债券的到期收益率</li><li>短期利率(Short rate): 既定区间内的收益率</li></ul><p>远期利率则是指隐含在给定的即期利率之中，从未来的某一时点到另一时点的利率。也就是未来的短期利率。<br>1×2远期利率，即表示1个月之后开始的期限1个月的远期利率；2×4远期利率，则表示2个月之后开始的期限为2个月的远期利率。</p><p>contracted rate(合同利率): 远期利率协议签订时合同上所定的利率.<br>reference rate(参考利率): 通常用于确定各种金融合同、贷款、基于账户的产品和金融工具（包括衍生工具和票据）的应付金额及其价值。</p><p>参考利率有</p><blockquote><p>2017年英国金融行为监管局（FCA）宣布，2021年底后将不再强制要求报价行报出LIBOR。这意味着LIBOR将退出市场。</p></blockquote><p>最终损益就是名义本金与合同利率和参考利率的差额的乘积</p><h2 id="3-远期结售汇"><a href="#3-远期结售汇" class="headerlink" title="3. 远期结售汇"></a>3. 远期结售汇</h2><p>对于中国大陆市场来说，由于CNY不能自由兑换，因此人民币有远期结售汇业务，而由于远期结售汇是个人、企业和银行间的交易，非银间交易，因此不被称为外汇远期</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Non-Deliverable Forward.” Wikipedia, Wikimedia Foundation, 24 May 2021, https://en.wikipedia.org/wiki/Non-deliverable_forward.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">- LIBOR(London Interbank Offered Rate)- SHIBOR(Shanghai Interbank Offered Rate)- ......<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Forward Rate Agreement.” Wikipedia, Wikimedia Foundation, 1 Oct. 2021, https://en.wikipedia.org/wiki/Forward_rate_agreement.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedinas. “Reference rate” Wikipedia, Wikimedia Foundation, 1 May. 2018, https://en.wikipedia.org/wiki/Reference_rate.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Unknown. “Forwards in the Debt Markets.” Ebrary, 1 Oct. 2021, https://ebrary.net/788/economics/forwards_debt_markets.<a href="#fnref:4" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;正如在&lt;a href=&quot;/2021/10/03/derivatives01/&quot;&gt;衍生品笔记一&lt;/a&gt;提到的开篇提到的猪肉期货，上下游企业都可以通过期货交易来套期保值，远期的出现也是相同的目的，远期和期货本质的区别，其实只是场内还是场外的区别。期货是场内交易，合约标准化，信用风险也由交易所承担了，而远期是场外交易，协议怎么定可以一事一议，只要交易双方都认可就行。&lt;br&gt;从另一方面来说，也就是远期定义的要素更少，那就从远期先看起。&lt;br&gt;世界范围来看，远期交易中比例最大的标的是汇率、利率。&lt;/p&gt;</summary>
    
    
    
    <category term="technology" scheme="https://blog.xuwei.fun/categories/technology/"/>
    
    <category term="finance" scheme="https://blog.xuwei.fun/categories/technology/finance/"/>
    
    
    <category term="finance" scheme="https://blog.xuwei.fun/tags/finance/"/>
    
    <category term="invest" scheme="https://blog.xuwei.fun/tags/invest/"/>
    
    <category term="derivatives" scheme="https://blog.xuwei.fun/tags/derivatives/"/>
    
    <category term="forward" scheme="https://blog.xuwei.fun/tags/forward/"/>
    
  </entry>
  
  <entry>
    <title>衍生品笔记一 —— 概述</title>
    <link href="https://blog.xuwei.fun/2021/10/03/derivatives01/"/>
    <id>https://blog.xuwei.fun/2021/10/03/derivatives01/</id>
    <published>2021-10-03T09:53:26.000Z</published>
    <updated>2022-02-20T14:48:17.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自2018年开始的非洲猪瘟，直到2020年底终于基本在大陆消失了，而在猪瘟这几年里，猪肉价格水涨船高，一度接近牛肉价格，而2021年开始，猪肉价格又开始一路下跌，猪周期终于还是来了，如何才能规避猪肉价格的风险呢？2021年初大连商品交易所（简称大商所）设立的生猪期货又是什么？这对猪肉价格有影响吗？Kino就从简单介绍2021年刚设立的生猪期货合约开始谈起。<br>首先期货的标准定义是<strong>由期货交易所统一制定的、规定在将来某一特定的时间和地点交割一定数量和质量标的物的标准化合约。</strong>那么通过大商所的官网，可以查看到<a href="http://www.dce.com.cn/dalianshangpin/sspz/sz/hyygz30/6264142/index.html">生猪期货合约</a>的具体规则，目前生猪合约月份有1、3、5、7、9、11月份，那以Kino写这篇文章时的2021.10.03为例，此时实际上可以开仓的标的就有生猪期货2111、生猪期货2201、生猪期货2203等，生猪期货的最后交易日为合约月份倒数第4个交易日，也就是说如果现在持有生猪期货2203一手16吨，2022.03.28日是最后交易日，2022.03.28之后还持有该标的，就进入了交割日，需要进行生猪的活体实物交割，简单点来说就是需要去指定的仓库真的领回16吨生猪。<br>那么生猪期货合约对于猪肉养殖公司，例如牧原、温氏等，有什么作用呢？其核心就是风险管理，既然猪肉周期价格变化大，那就可以通过期货合同，提前锁定未来的价格，对冲风险。而下游的猪肉产品制作企业如双汇等，也可以通过期货合约提前锁定价格，如此一来，原本2022.01的猪肉价格对于上下游企业来说，都是不确定的，现在都相对确定了，也就可以据此保证自身产品价格的相对稳定。<br>除却生猪期货，基本国内目前的农产品期货、大宗商品期货等，也都是这样的作用，而期货就是金融衍生品中最常见的一种，So除了期货，还有哪些衍生品呢？衍生品的定义究竟是什么呢？<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="黄小玉,于源,王林, and 崔岱虎. 生猪期货合约及规则设计介绍. 中国期货, 1(2012):20-28.">[1]</span></a></sup></p><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-衍生品概念"><a href="#1-1-衍生品概念" class="headerlink" title="1.1 衍生品概念"></a>1.1 衍生品概念</h3><p>In finance, a derivative is a contract that derives its value from the performance of an underlying entity.<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. “Derivative (Finance).” Wikipedia, Wikimedia Foundation, 17 Sept. 2021, https://en.wikipedia.org/wiki/Derivative_(finance). ">[2]</span></a></sup><br>衍生品，根据其字面含义，就是从一个基础标的 的表现衍生出价值的一个合约&#x2F;协议。一般有三个要素:</p><ul><li>基础标的</li><li>双方&#x2F;多方 交易对手</li><li>协议&#x2F;合约</li></ul><h3 id="1-2-衍生品作用"><a href="#1-2-衍生品作用" class="headerlink" title="1.2 衍生品作用"></a>1.2 衍生品作用</h3><p>衍生品的作用主要有:</p><ul><li>风险管理&#x2F;对冲(Risk Management&#x2F;Hedging)</li><li>投机(Speculation)</li><li>套利(Arbitrage)</li></ul><blockquote><p>虽然衍生品早期是为了风险管理，但是任何工具只要有流动性就可以作为投机或套利的工具</p></blockquote><h3 id="1-3-衍生品分类"><a href="#1-3-衍生品分类" class="headerlink" title="1.3 衍生品分类"></a>1.3 衍生品分类</h3><p>四大类:</p><ul><li>Future Contracts(期货合约)</li><li>Forward Agreements(远期协议)</li><li>Swaps Agreements(互换协议)</li><li>Options Contracts(期权合约)</li></ul><blockquote><p>Contracts是标准化的，可在交易所或OTC交易，Agreements多在OTC交易. 目前OTC交易占比远大于场内交易</p></blockquote><p>还有其他一些比较特别的衍生品:</p><ul><li>Credit derivatives, 比如信用违约互换(credit default swap，CDS)</li><li>Weather derivatives</li><li>Emission (CO2) derivatives</li><li>Economic derivatives</li></ul><p>实际衍生品标的中，占最大市场份额的其实是利率(interest)相关的</p><h3 id="1-4-衍生品市场"><a href="#1-4-衍生品市场" class="headerlink" title="1.4 衍生品市场"></a>1.4 衍生品市场</h3><ul><li>Exchange trades(场内交易): 交易所作为CCP，可以规避对手风险&#x2F;违约风险</li><li>Over-the-counter(场外交易): 参与者主要是商业银行、投行、基金公司、社保基金、保险公司… 中国内地又以银间交易占比最大</li></ul><p>场外 -&gt; Chicago Board of Trade(CBOT,1840) -&gt; New York Mercantile Exchange(NYMEX, 1882) -&gt; Chicago Mercantile Exchange(CME,1972) -&gt; Chicago Board Options Exchange(CBOE,1973)<br>1972年布雷顿森林体系崩溃后，汇率开始剧烈波动，也因此，期货从早期的农产品等实物商品为标的，开始引入外汇期货(Exchange rate futures)，以外汇等基础金融工具作为标的，当然再往后期货发展越来越繁荣，还引入了股指等虚拟金融工具为标的。</p><blockquote><p>虚拟金融工具的特点之一，就是需要有乘数</p></blockquote><h3 id="1-5-衍生品业务"><a href="#1-5-衍生品业务" class="headerlink" title="1.5 衍生品业务"></a>1.5 衍生品业务</h3><p>现实中，究竟哪些公司会有衍生品业务的需求呢？<br>终端用户有以下业务需求:</p><ul><li>跨国巨头需要控制外汇风险，因此需要外汇衍生品</li><li>交通运输公司受油价影响，因此需要原油衍生品</li><li>购买大额存款、债券的基金等受利率波动影响，因此需要利率衍生品</li><li>个人投资者想要通过衍生品投机</li><li>…</li></ul><p>金融平台自身的业务需求:</p><ul><li>大型商业银行、保险公司等天然需要管理金融工具的风险</li><li>做市商控制存货风险</li></ul><h2 id="2-衍生品的标志性事件"><a href="#2-衍生品的标志性事件" class="headerlink" title="2. 衍生品的标志性事件"></a>2. 衍生品的标志性事件</h2><ul><li>Orange county: <a href="https://www.nytimes.com/1994/12/08/business/orange-county-s-bankruptcy-the-overview-orange-county-crisis-jolts-bond-market.html">https://www.nytimes.com/1994/12/08/business/orange-county-s-bankruptcy-the-overview-orange-county-crisis-jolts-bond-market.html</a></li><li>Amaranth: <a href="http://www.p5w.net/futures/llyj/200703/t811915.htm">http://www.p5w.net/futures/llyj/200703/t811915.htm</a></li><li>Nick Leeson: <a href="https://wiki.mbalib.com/wiki/%E5%B0%BC%E5%85%8B%C2%B7%E6%9D%8E%E6%A3%AE">https://wiki.mbalib.com/wiki/%E5%B0%BC%E5%85%8B%C2%B7%E6%9D%8E%E6%A3%AE</a></li><li>国储铜事件: <a href="https://baike.baidu.com/item/%E5%9B%BD%E5%82%A8%E9%93%9C%E4%BA%8B%E4%BB%B6/6104457">https://baike.baidu.com/item/%E5%9B%BD%E5%82%A8%E9%93%9C%E4%BA%8B%E4%BB%B6/6104457</a></li><li>中航油事件: <a href="http://www.people.com.cn/GB/jingji/8215/41815/index.html">http://www.people.com.cn/GB/jingji/8215/41815/index.html</a></li></ul><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">黄小玉,于源,王林, and 崔岱虎. 生猪期货合约及规则设计介绍. 中国期货, 1(2012):20-28.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Derivative (Finance).” Wikipedia, Wikimedia Foundation, 17 Sept. 2021, https://en.wikipedia.org/wiki/Derivative_(finance).<a href="#fnref:2" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;自2018年开始的非洲猪瘟，直到2020年底终于基本在大陆消失了，而在猪瘟这几年里，猪肉价格水涨船高，一度接近牛肉价格，而2021年开始，猪肉价格又开始一路下跌，猪周期终于还是来了，如何才能规避猪肉价格的风险呢？2021年初大连商品交易所（简称大商所）设立的生猪期货又是什么？这对猪肉价格有影响吗？Kino就从简单介绍2021年刚设立的生猪期货合约开始谈起。&lt;br&gt;首先期货的标准定义是&lt;strong&gt;由期货交易所统一制定的、规定在将来某一特定的时间和地点交割一定数量和质量标的物的标准化合约。&lt;/strong&gt;那么通过大商所的官网，可以查看到&lt;a href=&quot;http://www.dce.com.cn/dalianshangpin/sspz/sz/hyygz30/6264142/index.html&quot;&gt;生猪期货合约&lt;/a&gt;的具体规则，目前生猪合约月份有1、3、5、7、9、11月份，那以Kino写这篇文章时的2021.10.03为例，此时实际上可以开仓的标的就有生猪期货2111、生猪期货2201、生猪期货2203等，生猪期货的最后交易日为合约月份倒数第4个交易日，也就是说如果现在持有生猪期货2203一手16吨，2022.03.28日是最后交易日，2022.03.28之后还持有该标的，就进入了交割日，需要进行生猪的活体实物交割，简单点来说就是需要去指定的仓库真的领回16吨生猪。&lt;br&gt;那么生猪期货合约对于猪肉养殖公司，例如牧原、温氏等，有什么作用呢？其核心就是风险管理，既然猪肉周期价格变化大，那就可以通过期货合同，提前锁定未来的价格，对冲风险。而下游的猪肉产品制作企业如双汇等，也可以通过期货合约提前锁定价格，如此一来，原本2022.01的猪肉价格对于上下游企业来说，都是不确定的，现在都相对确定了，也就可以据此保证自身产品价格的相对稳定。&lt;br&gt;除却生猪期货，基本国内目前的农产品期货、大宗商品期货等，也都是这样的作用，而期货就是金融衍生品中最常见的一种，So除了期货，还有哪些衍生品呢？衍生品的定义究竟是什么呢？&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;黄小玉,于源,王林, and 崔岱虎. 生猪期货合约及规则设计介绍. 中国期货, 1(2012):20-28.
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="technology" scheme="https://blog.xuwei.fun/categories/technology/"/>
    
    <category term="finance" scheme="https://blog.xuwei.fun/categories/technology/finance/"/>
    
    
    <category term="finance" scheme="https://blog.xuwei.fun/tags/finance/"/>
    
    <category term="invest" scheme="https://blog.xuwei.fun/tags/invest/"/>
    
    <category term="derivatives" scheme="https://blog.xuwei.fun/tags/derivatives/"/>
    
  </entry>
  
  <entry>
    <title>计算机科学从0到1(Part 2)</title>
    <link href="https://blog.xuwei.fun/2021/03/01/csFromZeroToOne02/"/>
    <id>https://blog.xuwei.fun/2021/03/01/csFromZeroToOne02/</id>
    <published>2021-03-01T09:00:00.000Z</published>
    <updated>2021-03-07T11:58:32.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机的数据表示及实现"><a href="#计算机的数据表示及实现" class="headerlink" title="计算机的数据表示及实现"></a>计算机的数据表示及实现</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机的数据表示及实现&quot;&gt;&lt;a href=&quot;#计算机的数据表示及实现&quot; class=&quot;headerlink&quot; title=&quot;计算机的数据表示及实现&quot;&gt;&lt;/a&gt;计算机的数据表示及实现&lt;/h1&gt;&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;</summary>
      
    
    
    
    <category term="science" scheme="https://blog.xuwei.fun/categories/science/"/>
    
    <category term="cs" scheme="https://blog.xuwei.fun/categories/science/cs/"/>
    
    
    <category term="cs" scheme="https://blog.xuwei.fun/tags/cs/"/>
    
    <category term="computer science" scheme="https://blog.xuwei.fun/tags/computer-science/"/>
    
  </entry>
  
  <entry>
    <title>计算机科学从0到1(Part 1)</title>
    <link href="https://blog.xuwei.fun/2020/11/22/csFromZeroToOne01/"/>
    <id>https://blog.xuwei.fun/2020/11/22/csFromZeroToOne01/</id>
    <published>2020-11-22T10:55:11.000Z</published>
    <updated>2022-07-18T12:52:13.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机的发展历史"><a href="#计算机的发展历史" class="headerlink" title="计算机的发展历史"></a>计算机的发展历史</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>电子计算机(Computer)可以说是当代社会最重要的工具, 没有之一。<br>就拿人的基本需求——衣食住行来说, 随便举个栗子。</p><ul><li>衣: 电商平台</li><li>食: 外卖平台</li><li>住: 租售平台</li><li>行: 自动驾驶</li></ul><p>可以看出当代社会已经无法离开互联网了, 而每一个互联网服务的背后, 都是一台又一台的计算机在处理数据、提供服务。<br>那么, 计算机的历史, 到底该从何说起呢?</p><span id="more"></span><h2 id="二、计算机历史"><a href="#二、计算机历史" class="headerlink" title="二、计算机历史"></a>二、计算机历史</h2><h3 id="2-1-Calculating-Tool"><a href="#2-1-Calculating-Tool" class="headerlink" title="2.1 Calculating Tool"></a>2.1 Calculating Tool</h3><p>计算机, 顾名思义, 首先是一种计算工具, 而最早的计算工具, 可以追溯到何时呢?</p><ul><li>Abacus(算盘)：2500 BCE(before common era)发明于两河流域</li><li>Astrolabe(星盘)</li><li>Slide rule(算尺)</li><li>…</li></ul><h3 id="2-2-Computer"><a href="#2-2-Computer" class="headerlink" title="2.2 Computer"></a>2.2 Computer</h3><p>计算机的英文单词Computer, 实际于1613年第一次出现，那时该词还只是表示一种职业.<br>或者我们是不是可以说, 人变成了一种计算工具?</p><h3 id="2-3-Stepped-reckoner-莱布尼茨乘法器"><a href="#2-3-Stepped-reckoner-莱布尼茨乘法器" class="headerlink" title="2.3 Stepped reckoner(莱布尼茨乘法器)"></a>2.3 Stepped reckoner(莱布尼茨乘法器)</h3><p>1694年Gottfried Leibniz(没错, 就是那个莱布尼茨)发明了Stepped reckoner.<br>这种机器可以做加减乘除四则运算, 而且支持16位结果的显示和8位数的输入<br><img src="/images/cs_from_zero_to_one/csfzto01_02_01.jpg" alt="stepped_reckoner"></p><h3 id="2-4-Difference-Engine-差分机"><a href="#2-4-Difference-Engine-差分机" class="headerlink" title="2.4 Difference Engine(差分机)"></a>2.4 Difference Engine(差分机)</h3><p>Charles Babbage于1822年提出差分机, 简单来说, 差分机就是一台多项式求值机, 只要将欲求多项式方程的前3个初始值输入到机器里, 机器每运转一轮, 就能产生出一个值来。<br>Charles Babbage于1849设计了Difference Engine No. 2(差分机二号), 这台机器可以进行相当复杂的数学计算，具有31位的精度。<br>这些机器在Babbage生前, 都没有真正地彻底地完成, 只完成了一部分。直到1985年时，伦敦科学博物馆按照Babbage的图纸, 才打造了一台完整的差分机2号, 这台巨大的手摇智能机械计算机, 长3.35米, 高2.13米, 有4000多个零件, 重2.5吨。<br><img src="/images/cs_from_zero_to_one/csfzto01_02_02.jpg" alt="difference_engine"></p><h3 id="2-5-Analytical-Engine-分析机"><a href="#2-5-Analytical-Engine-分析机" class="headerlink" title="2.5 Analytical Engine(分析机)"></a>2.5 Analytical Engine(分析机)</h3><p>Charles Babbage在制作差分机的基础上, 于1837提出了分析机的模型。<br>分析机能用多项式展开的方法计算对数和三角函数, 具体的计算过程则是用打孔卡片输入, 完成类似汇编语言的程序指令。正是因为这种开创性的思想, 虽然Babbage最终没有完成该机器, 只是提出了机器模型, 却仍然被认为是计算机之父。<br><img src="/images/cs_from_zero_to_one/csfzto01_02_03.jpg" alt="analytical_engine"></p><p>而分析机历史上的另一关键人物则是Ada Lovelace, 她于1843为Babbage的分析机模型编写了假想程序，也因此被认为是世界上第一个程序员.</p><blockquote><p>在1842年与1843年期间, Ada花了9个月的时间翻译意大利数学家Luigi Menabrea讲述Charles Babbage计算机分析机的论文。在译文后面, 她增加了许多注记, 详细说明用该机器计算伯努利数的方法, 被认为是世界上第一个计算机程序。因此, Ada也被认为是世界上第一位程序员</p></blockquote><blockquote><p>PS: 著名的逆向软件IDA Pro的图标, 也是以Ada为原型</p></blockquote><p>还有些值得一提的点就是, 上面提到的这些人物中, Luigi Menabrea是第7任意大利首相, Ada是诗人拜伦的女儿…</p><h3 id="2-6-Tabulating-machine-穿孔制表机"><a href="#2-6-Tabulating-machine-穿孔制表机" class="headerlink" title="2.6 Tabulating machine(穿孔制表机)"></a>2.6 Tabulating machine(穿孔制表机)</h3><p>从1790年开始, 美国每十年进行一次人口普查, 由于人口越来越多, 1880年开始的第10次人口普查, 历时8年才完成, 为了能够更高效的统计人口, 美国政府向社会招标寻求更高效的方式, 最终Herman Hollerith脱颖而出。<br>1888年, Herman Hollerith设计完成了穿孔制表机，用于1890年的美国人口普查。<br>后来, Herman Hollerith成立了相关制表机公司，却因经营不善, 1911年与另外3家公司合并成立CTR公司(Computing-Tabulating-Recording Company), 1924年, CTR更名为International Business Machines Corporation, 缩写就是IBM。制表机公司作为其子公司继续运营到1933年。<br><img src="/images/cs_from_zero_to_one/csfzto01_02_04.jpg" alt="tabulating_machine"></p><p>想要了解更多穿孔制表机的历史, 可以参考<em>制表机：穿孔时代的到来</em><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="逸之. “制表机：穿孔时代的到来,” November 10, 2019. https://www.jianshu.com/p/49f23b77dced. ">[2]</span></a></sup> 这篇文章</p><h3 id="2-7-Harvard-Mark-I"><a href="#2-7-Harvard-Mark-I" class="headerlink" title="2.7 Harvard Mark I"></a>2.7 Harvard Mark I</h3><p>在整个计算机的历史中, 经常能见到IBM的身影, 其中便有这台Harvard Mark I。<br>Harvard Mark I其实是使用者哈佛大学为该计算机起的名字, 设计生产者IBM称这台计算机为Automatic Sequence Controlled Calculator(ASCC)。<br>该计算机是1944年IBM为二战同盟国制造的计算机, 是世界上最大的计算机, 也是世界上第一台实现顺序控制的自动数字计算机。<br>Harvard Mark I主要供海军舰船局(Bureau of Ships)用于计算弹道和编制射击表, 也曾在曼哈顿计划中计算有关原子弹的问题。<br>而之所以这台计算机体积如此庞大, 是因为该计算机的基本组件是继电器(Relays), 用电磁控制的机械结构, 而不是后来的电子计算机.<br><img src="/images/cs_from_zero_to_one/csfzto01_02_05.jpg" alt="havard_mark_i"></p><blockquote><p>现代计算机大多用冯诺依曼架构, 而这台计算机用的哈佛架构, 即将程序指令存储和数据存储分开的结构。(哈佛架构这个名字的来源, 应该也不言自明了…</p></blockquote><h3 id="2-8-Harvard-Mark-II"><a href="#2-8-Harvard-Mark-II" class="headerlink" title="2.8 Harvard Mark II"></a>2.8 Harvard Mark II</h3><p>在Harvard Mark I之后, Howard H. Aiken主持了Harvard Mark II的制造, 并于1947年完成, 因此也被称作Aiken Relay Calculator<br>关于Harvard Mark II的最重要的一个趣事就是: 1945年9月9日, Harvard Mark II出现故障, Grace Hopper经过一天的检查, 发现是继电器中有一只死飞蛾，这也是术语 Bug 的起源。<br><img src="/images/cs_from_zero_to_one/csfzto01_02_06.jpg" alt="havard_mark_ii"></p><p>而关于Grace Hopper此人, 却是有更多故事了.</p><blockquote><p>Grace Hopper发明了世界上第一个编译器——A-0 系统; 还是COBOL之母; 于1985年11月升职为海军少将, 是美国第一个到达这个官阶的女性。</p></blockquote><p><img src="/images/cs_from_zero_to_one/csfzto01_02_07.jpg" alt="grace_hopper"></p><h3 id="2-9-Thermionic-valve-x2F-Vacuum-tube-热电子管-x2F-真空管"><a href="#2-9-Thermionic-valve-x2F-Vacuum-tube-热电子管-x2F-真空管" class="headerlink" title="2.9 Thermionic valve&#x2F;Vacuum tube(热电子管&#x2F;真空管)"></a>2.9 Thermionic valve&#x2F;Vacuum tube(热电子管&#x2F;真空管)</h3><p>刚刚说到, 1945年, 二战时期的Harvard Mark计算机竟然还是电磁机械结构的, 难道是电子计算机所需要的基本元件, 一直还没有发明出来吗?<br>其实不是这样的, John Ambrose Fleming于1904年就发明出了世界上第一个真空管。<br>真空管(Vacuum tube)其实概念上很宽泛, 可以泛指二极、三极、多极真空管, 而 Fleming 发明的真空管只允许电流单向流动, 是真空二极管。<br>实际上任何只允许电流单向流动的电子部件，都叫做二极管, 真空管只是第一次实现了实用的小型的二极管。<br><img src="/images/cs_from_zero_to_one/csfzto01_02_08.jpg" alt="thermionic_valve"></p><h3 id="2-10-Triode-vacuum-x2F-Audion-三极管"><a href="#2-10-Triode-vacuum-x2F-Audion-三极管" class="headerlink" title="2.10 Triode vacuum&#x2F;Audion(三极管)"></a>2.10 Triode vacuum&#x2F;Audion(三极管)</h3><p>1906年Lee de Forest在Thermionic valve基础上加入了控制电极，制作了三极管。<br>而Lee de Forest也因此被誉为是电子学之父<br><img src="/images/cs_from_zero_to_one/csfzto01_02_09.jpg" alt="triode_vacuum"></p><h3 id="2-11-Colossus-Mark-1"><a href="#2-11-Colossus-Mark-1" class="headerlink" title="2.11 Colossus Mark 1"></a>2.11 Colossus Mark 1</h3><p>既然二极、三极真空管早就发明出来了, 为何到20世纪40年代制作的计算机还有电磁机械结构?<br>其中一个原因就是使用真空管制作计算机成本太高, 一直到40年代, 真空管的成本终于下降。<br>顺其自然地, 1943年12月, 在Tommy Flowers的主导下, 第一台使用真空管制作的计算机Colossum Mark 1制作完成了, 也被认为是<strong>第一台可编程的电子计算机</strong>。这个时间点诞生的计算机, 显然都是为二战服务的, Colossum Mark 1就被放置在Bletchley Park, 用于破解德军的加密报文。<br>说到Bletchley Park(布莱切利园), 它在二战期间, 是英国政府进行密码解读的主要地点, 比如Enigma密码机等。2012年, ITV还出品过一部英剧 <em>The Bletchley Circle (布莱切利四人组)</em>, 剧中的主人公便是二战时曾在Bletchely Park工作过的人员。(不过该剧本身却是平平无奇, 并不推荐…)<br><img src="/images/cs_from_zero_to_one/csfzto01_02_10.jpg" alt="colossum_mark_i"></p><h3 id="2-12-ENIAC"><a href="#2-12-ENIAC" class="headerlink" title="2.12 ENIAC"></a>2.12 ENIAC</h3><p>Colossus Mark 1及后来的一系列Colossus Mark计算机, 虽然可以说是可编程的电子计算机, 但实际是, 内部具有特定的程序片段, 再通过人工调整开关和插头的组合, 实现不同程序片段的组合, 完成不同的功能, 最重要的是, 它不是图灵完备的, 因此也称不上是可编程的, 只能说是是可组合的。<br>第一台可编程的电子计算机, 1946年在宾夕法尼亚大学完成，也就是计算机教材中最常提到的ENIAC, ENIAC是<strong>第一台真正的通用可编程电子计算机(General Purpose Programmable Electronic Computer)</strong>, 它是图灵完备的, 虽然在操作上, ENIAC也还是通过机械式的plugboard(插线板)实现不同的程序, 但是在本质上发生了变化。<br><img src="/images/cs_from_zero_to_one/csfzto01_02_11.jpg" alt="eniac"></p><h3 id="2-13-Transistor-晶体管"><a href="#2-13-Transistor-晶体管" class="headerlink" title="2.13 Transistor(晶体管)"></a>2.13 Transistor(晶体管)</h3><p>基于真空三极管的计算机, 虽然实现了电子化, 但体积还是过大, 从上面每一代计算机的图片上也可以看出。直到1947年，贝尔实验室的John Bardeen、Walter Brattain和William Shockley发明了晶体管(Transistor), 自此之后, 计算机的体积迅速下降，三位也因此共同获得了1956年的物理学诺贝尔奖。<br><img src="/images/cs_from_zero_to_one/csfzto01_02_12.jpg" alt="transistor"></p><p>不过大概是大师总是有点脾性的，三人间的关系并没有维持长久，发明了晶体管后不久，三人小团队便因种种矛盾分崩离析。实际上，1947年Bardeen和Brattain在发表第一个以锗半导体做成的点接触晶体管过程中，申请的专利竟然都没写小组长Shockley的名字，Shockley得知之后十分Shock…一怒之下，一个月后也以自己的名义提出了使用P-N结面制作接面晶体管的方法（其实也是他本人对自己的工作一直做了保密工作，可真是同组异梦呢…）</p><p>不过在晶体管以外，这三人单独拿出来，也都有一些有趣的小故事可说，就借此说些题外话叭。</p><blockquote><p>也许你知道中国第一个诺贝尔奖获得者是谁, 但是你知道第一位出生在中国的诺贝尔奖获得者是谁吗?<br>没错, 就是三人组中的Brattain, Brattain于1902年2月10日出生于中国厦门, 也就成为了第一位出生在中国的诺贝尔奖得主<br>你知道谁是第一位两次获得诺贝尔物理学奖的人吗?<br>竟然又是三人组中的一员?! Bardeen因BCS理论对超导电性做出了合理解释，因此获得了1972年的诺贝尔物理学奖，是第一位两次获得诺贝尔物理学奖的人，也是截止本文写作时间(就算作2020年12月31)，唯一一位两次获得诺贝尔物理学奖的人<br>AMD, Intel 乃至 硅谷的一系列公司有什么共性吗? 或者说硅谷为何成为了硅谷呢?<br>总算得说到Shockley了, Shockley和贝尔实验室分道扬镳后，来到美国西海岸即加州，创建了肖克利半导体实验室(Shockley Semiconductor Laboratory)，为了公司的发展，他特意从东部召来八位年轻人(Julius Blank, Victor Grinich, Eugene Kleiner, Jean Hoerni, Jay Last, Gordon Moore, Robert Noyce and Sheldon Roberts)。要知道当初美国的技术中心还在西部，这八位年轻人完全是被Shockley的科学声誉吸引过来的。可是无奈Shockley的确没有管理才能，最终这八位无奈出走，创办了自己的公司Fairchild Semiconductor(飞兆半导体&#x2F;仙童半导体)，获得了成功，且至今仍存活着，而从Fairchild中走出的其他人，又创办了National Semiconductor、AMD、Intel等知名公司，最终造就了硅谷传奇。甚至这八人中，有被称为“硅谷市长”的Robert Noyce，有提出摩尔定律的Gordon Moore…还有很多细节可以看看文章<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Martin Groeger. Shockley Semiconductor,” July 8, 2000. http://www.silicon-valley-story.de/sv/shockley.html.">[3]</span></a></sup>和文章<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedian. “硅谷,” January 27, 2021. https://zh.wikipedia.org/zh-cn/%E7%A1%85%E8%B0%B7.">[4]</span></a></sup></p></blockquote><h3 id="2-14-TRADIC"><a href="#2-14-TRADIC" class="headerlink" title="2.14 TRADIC"></a>2.14 TRADIC</h3><p>转回正题，有了晶体管之后，晶体管计算机的出现也就顺理成章了。<br>1954年，美国贝尔实验室研制成功第一台使用晶体管线路的计算机TRADIC，装有800个晶体管。不出例外的，TRADIC也被用于军事用途，主要是海军雷达系统中。<br><img src="/images/cs_from_zero_to_one/csfzto01_02_13.jpg" alt="tradic"></p><h3 id="2-15-IBM-608"><a href="#2-15-IBM-608" class="headerlink" title="2.15 IBM 608"></a>2.15 IBM 608</h3><p>虽然TRADIC总算用上了晶体管，虽然在此之前，发明了那么多的计算机，但却还没有出现一款可以让普通人接触的计算机，都是用于军方、政府等机构，甚至于都没有很好的量产，给每台研制成功的计算机起名，大概就是基于这种背景叭。<br>终于到了1957年，IBM发布了IBM 608，第一个完全晶体管构建且可以在市面上买到的电子计算机。它有3000个晶体管，每秒能执行4500次加法，80次左右的乘除法。自此，计算机算是开启了商用化的道路。<br><img src="/images/cs_from_zero_to_one/csfzto01_02_14.jpg" alt="ibm608"></p><h3 id="2-16-Integrated-Circuits"><a href="#2-16-Integrated-Circuits" class="headerlink" title="2.16 Integrated Circuits"></a>2.16 Integrated Circuits</h3><p>当所有技术都已经成熟，物理学难题逐一解决，工程师剩下的追求就是将计算机越做越小，而计算机越来越小的发展历史其实就是集成电路的发展历史。</p><ul><li>1903年，Albert Hanson发明了Printed Circuit Boards(PCBs)</li><li>1958年, Jack Kilby发明了第一个germanium IC.</li><li>1958年，Jay W. Lathrop &amp; James R. Nall发明了光刻技术</li><li>1959年，Robert Noyce(也就是上文提到的“硅谷市长”)发明了第一个silicon IC，也因此被称为father of modern ICs.</li><li>1965年，Gordon Moore提出了摩尔定律</li><li>1968年，Robert Noyce &amp; Gordon Moor创建了Intel</li><li>1971年, Faggin完成了Intel 4004  Microprocessor，是Intel第一款推出的微处理器，也是全球第一款商用微处理器</li><li>1970s，VLSI(Very Large Scale Integration) Software技术也开始了大规模的发展，最终，让我们现在看到的10nm、7nm等技术成为现实</li></ul><h3 id="2-17-Non-volatile-Memory"><a href="#2-17-Non-volatile-Memory" class="headerlink" title="2.17 Non-volatile Memory"></a>2.17 Non-volatile Memory</h3><p>计算机世界中，最重要的就是数据，计算机处理的是信息，而这些信息全部都是用数据来表示的，那么如何来存储这些数据，也是个必然需要解决的问题，在计算机的发展历程里，存储工具也在不停的更新换代。</p><ul><li>在计算机发展早期，数据是用Punch cards或者Paper tape存储的</li><li>1944年，J. Presper Eckert发明了Delay Line Memory</li><li>1940s, Jay Forrester发明了Magnetic Core Memory</li><li>1950s, J. Presper Eckert &amp; John Mauchly在UNIVAC计算机中使用了Magnetic Tape</li><li>1950s，除了Magnetic Tape，同时也有计算机使用Magnetic Drum Memory，而这一技术实际上是Gustav Tauschek在1932发明的</li><li>1956年，IBM 305 RAMAC成为第一个使用了Hard disk drives的电脑</li><li>1972年，RAM Integrated Circuits发明，成为Flash和SSD的技术基础</li></ul><h3 id="2-18-Program"><a href="#2-18-Program" class="headerlink" title="2.18 Program"></a>2.18 Program</h3><p>计算机的发展，除了硬件的推动，软件的发展也是必不可少的一部分，编程语言在计算机硬件发展之初也就随之诞生了。除了最原始的二进制式的指令编制方法，编程语言的发展也是一直与时俱进的。简单罗列下各个时代的编程语言的发展。</p><ul><li>1947年，Kathleen Booth发明了汇编语言</li><li>1952年，Grace Hopper发明了Arithmetic Language Version 0, 算是世界上第一个高级编程语言，同时创造了第一个编译器</li><li>1957年，John Backus发明了Fortran，用在IBM</li><li>1959年，在Grace Hopper的建议下，研发了COBOL(Common Business-Oriented Language)，实现了上层编程语言的统一, 不同机器不同的编译器</li><li>1960s，诞生的有Algol, Lisp, Basic</li><li>1970s，Pascal, C, Smalltalk等被发明</li><li>1980s，C++, Objective-C, Perl</li><li>1990s，Python, Ruby, Java</li><li>2000s，Swift, C#, Go……</li></ul><h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><p>以上所有计算机的发展历程，最终被Kino做成了一张图，仅供参考。<br><img src="/images/cs_from_zero_to_one/csfzto01_03_01.jpg" alt="summary"></p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedian. “电子计算机,” November 8, 2020. https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">逸之. “制表机：穿孔时代的到来,” November 10, 2019. https://www.jianshu.com/p/49f23b77dced.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Martin Groeger. Shockley Semiconductor,” July 8, 2000. http://www.silicon-valley-story.de/sv/shockley.html.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedian. “硅谷,” January 27, 2021. https://zh.wikipedia.org/zh-cn/%E7%A1%85%E8%B0%B7.<a href="#fnref:4" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;计算机的发展历史&quot;&gt;&lt;a href=&quot;#计算机的发展历史&quot; class=&quot;headerlink&quot; title=&quot;计算机的发展历史&quot;&gt;&lt;/a&gt;计算机的发展历史&lt;/h1&gt;&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;电子计算机(Computer)可以说是当代社会最重要的工具, 没有之一。&lt;br&gt;就拿人的基本需求——衣食住行来说, 随便举个栗子。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;衣: 电商平台&lt;/li&gt;
&lt;li&gt;食: 外卖平台&lt;/li&gt;
&lt;li&gt;住: 租售平台&lt;/li&gt;
&lt;li&gt;行: 自动驾驶&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看出当代社会已经无法离开互联网了, 而每一个互联网服务的背后, 都是一台又一台的计算机在处理数据、提供服务。&lt;br&gt;那么, 计算机的历史, 到底该从何说起呢?&lt;/p&gt;</summary>
    
    
    
    <category term="science" scheme="https://blog.xuwei.fun/categories/science/"/>
    
    <category term="cs" scheme="https://blog.xuwei.fun/categories/science/cs/"/>
    
    
    <category term="cs" scheme="https://blog.xuwei.fun/tags/cs/"/>
    
    <category term="computer science" scheme="https://blog.xuwei.fun/tags/computer-science/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记十二</title>
    <link href="https://blog.xuwei.fun/2020/09/13/reading12/"/>
    <id>https://blog.xuwei.fun/2020/09/13/reading12/</id>
    <published>2020-09-13T15:51:33.000Z</published>
    <updated>2020-09-20T05:22:57.873Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>《罪与罚》杂谈.<br>转录Kino在微信读书上关于《罪与罚》的笔记.</p><span id="more"></span><h3 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h3><p>看完全书后，过了一遍陀思妥耶夫斯基的生平，发现小说有时还是需要结合作者经历来看。陀神在写“罪与罚”之前，一直患有癫痫-&gt;父亲去世-&gt;当过中尉-&gt;因革命被捕-&gt;被流放到西伯利亚-&gt;服役期间开始笃信宗教-&gt;妻兄逝世-&gt;赌博欠债，而在“罪与罚”中，这一切都呈现了出来，且大多是赋在了主人公拉斯柯尔尼科夫身上。将陀神的经历代入作品后，我甚至会怀疑陀神是否也曾想过自己是更特别的存在，想通过自己的手代替法律执行正义，也会怀疑陀神是否也曾想过自杀。</p><p>既然小说中的原型来源于自己的生活，那么多精彩的心理描写也就不难理解了，我相信小说中的主人公有多挣扎，陀神也就有过同样的挣扎，经历越多的读者也就越能产生共鸣(产生共鸣越多的读者大概越不幸吧)。能将如此多的心理活动生动准确地描写出来，能将读者的注意力迅速抓住，能将种种情节在主线中穿插自如，能将前期的处处伏笔完整收回，虽然陀神以心理描写而闻名，却显然不限于此。</p><p>“罪与罚”中最让我印象深刻的是描写斯维德里盖洛夫寻求自杀的那几节，让我莫名相信自杀者的心里状态就该如此，于反复中坚定，再无被挽救的可能。</p><p>陀神很残忍，“罪与罚”中的底层人大多都被生活蹂躏，没有一丝光明的希望；陀神也心系幻想，拉斯柯尔尼科夫一家获得了一笔意外的财富，拉斯柯尔尼科夫还有个一直愿意帮助他的朋友拉祖米欣，拉斯柯尔尼科夫的心灵最终在服役期间获得了救赎。拉斯柯尔尼科夫虽然经历坎坷，不幸中也还有着诸多幸运。</p><p>可是，书中那些已经死去的小人物呢？他们再也没有未来了。那些住在公寓套间里的底层穷人呢？他们还有希望吗？</p><p>群租在大城市套间中的我们又如何在一片压力中寻求自由与救赎呢？该怎样寻找自己的生存价值呢？不过还好，我们还算幸运，既然还有这一小片幸运的云，就努力生活下去吧，暂且不做无谓的思辩，就如陀神所说: “生活已经代替了思辨，因此思想意识必须完全另起炉灶。”</p><h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h3><p><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="">[1]</span></a></sup> <a href="https://book.douban.com/subject/30438790/">罪与罚</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;《罪与罚》杂谈.&lt;br&gt;转录Kino在微信读书上关于《罪与罚》的笔记.&lt;/p&gt;</summary>
    
    
    
    <category term="life" scheme="https://blog.xuwei.fun/categories/life/"/>
    
    <category term="reading" scheme="https://blog.xuwei.fun/categories/life/reading/"/>
    
    
    <category term="陀思妥耶夫斯基" scheme="https://blog.xuwei.fun/tags/%E9%99%80%E6%80%9D%E5%A6%A5%E8%80%B6%E5%A4%AB%E6%96%AF%E5%9F%BA/"/>
    
    <category term="罪与罚" scheme="https://blog.xuwei.fun/tags/%E7%BD%AA%E4%B8%8E%E7%BD%9A/"/>
    
  </entry>
  
  <entry>
    <title>从一个Emoji字符说起</title>
    <link href="https://blog.xuwei.fun/2020/09/07/characterset/"/>
    <id>https://blog.xuwei.fun/2020/09/07/characterset/</id>
    <published>2020-09-07T14:22:22.000Z</published>
    <updated>2022-05-04T12:09:43.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在和朋友聊天时，突然无话可说，屏幕前的你该如何是好呢? 很多时候屏幕前的我们，都会想到发个表情，然后彼此心照不宣地沉默。如果你用的是windows 10的新版本，按下 <code>winkey + period</code> （即windows图标和英文句点按钮），就会有如下的弹出框。</p><p><img src="/images/character_set/image_1_1.png" alt="image_1_1.png"></p><p align="center">图1.1</p><p>反复斟酌、几度纠结之后，你选择了这样一个表情：😤。将鼠标停留在这个表情上几秒，可以看到提示文字：“傲慢”。如果你用的是andriod、ios，在输入法中仔细搜寻，一定也可以发现这样一个表情。</p><p>如果哪里都找不到，也没关系，直接将这个表情复制，粘贴到微信聊天框中，回车，成功地将这个表情发了出去。在对方沉默不语的时间里，你点开了微信对话框里的表情，却发现怎么也找不着这个傲慢的表情?！但是这个表情的确正确地显示了呀?这是怎么回事呢?“微信连不存在的表情都支持，太厉害了叭！”也许你会发出这样的感慨。也有可能你会嗤之以鼻：“不过是显示了一张图片而已”。不过，这真的是图片吗? 且听我缓缓道来。</p><span id="more"></span><p><a name="29Um5"></a></p><h2 id="二、Emoji的前世今生"><a href="#二、Emoji的前世今生" class="headerlink" title="二、Emoji的前世今生"></a>二、Emoji的前世今生</h2><p>上面的表情，其实是个emoji字符。emoji这个词，互联网时代的人当然都不会陌生。但是刚刚的表述，又说它是表情，又说它是字符，似乎将表情和字符混为一谈了，这是怎么回事呢?其实准确来说，emoji应该称为“表情字符”，其本质还是一个字符，只是个用来象征表情的字符罢了。一个emoji字符，和一个字母、一个汉字，没有什么本质的不同，或者想象一下，对于一个不懂汉字的人来说，汉字看起来也许也就像一个个表情呢~ 当然啦，表情也可以用图片表示，至于计算机上区别字符和图片的根本因素是什么，稍后再论，这里先说下emoji出现的历史。</p><p>Emoji用日语表示就是「絵文字」，平假名为「えもじ」，1999年，由株式会社NTT DoCoMo的iMode服务团队开发，在12×12格的方格纸上以简单的图案描绘出人的各种表情及生活事物，再把它们对应成字符数据，NTT公司的这一发明意在提供一种在画面尺寸和通信量受限的情况下，让用户们通过视觉顺利进行交流的方式。</p><p>Emoji诞生之初，就得到了年轻人的追捧，到了2004年左右它已经被全日本所接受。2009年emoji被收录进Unicode编码，成为了世界标准的通用字符，2012年智能手机中加入了对emoji的支持，2014年提出了“世界Emoji日(World Emoji Day)”，2015年《牛津词典》的年度词汇是😂，2016年起，纽约现代美术馆（MoMA）将NTT DoCoMo的iMode中提供的第一版176个emoji纳入永久收藏。如今，emoji已经成为了iOS、Android、Mac OS及Windows中默认支持的表情符号。</p><blockquote><p>关于世界Emoji日，是在每年的7月17日，因为提出了World Emoji Day, 因此各个平台上表示日历的Emoji也都展示的是7月17日，📅<a href="https://emojipedia.org/calendar/">Calendar Emoji</a>，还有一个专门的World Emoji Day网站：<a href="https://worldemojiday.com/">点我试试</a></p></blockquote><p>iMode的开发负责人是栗田穣崇(Shigetaka Kurita)，也是他设计了最早版本的emoji，引用一句栗田先生后来的回忆分析：</p><blockquote><p>“在以数字信息互动为主的手机世界中，仅用文字来沟通的话，容易产生理解上的误会，因此有必要附加上感情语气，因此emoji的登场有其符合时代刚需的必然性”</p></blockquote><p><img src="/images/character_set/image_2_1.jpg" alt="image_2_1.jpg"></p><p align="center">图2.1</p><p>一个没有接触过编程的人，应该也能看懂上面大部分的内容，唯一可能有疑惑的大概是： <strong>2009年emoji被收录进Unicode编码</strong>。这个Unicode编码又是个什么玩意呢? 开头说的计算机上区别字符和图片的根本因素是什么呢?</p><h2 id="三、字符集和字符编码"><a href="#三、字符集和字符编码" class="headerlink" title="三、字符集和字符编码"></a>三、字符集和字符编码</h2><p>说起字符集，首先不得不扯一些语言学和计算机的基础。</p><h3 id="3-1-语言学简介"><a href="#3-1-语言学简介" class="headerlink" title="3.1 语言学简介"></a>3.1 语言学简介</h3><p>每个文化都有自己的语言体系，每种语言大致都会包含 发音系统、书写系统、语法系统 等几大方面。发音系统的基本单位是音素(phoneme)，书写系统的基本单位是字素(grapheme)，语法系统的基本单位是语素(morpheme)。</p><ul><li>小学时，我们学的声母表、韵母表，里面的每个音，就可以认为是普通话的音素，英文的音标就可以当作是英文的音素。</li><li>中文的字素有两种看法了，一种认为汉字可以按照偏旁部首的拆分，每个偏旁部首作为一个字素，比如“河”，可以认为是“氵”和“可”两个字素（李玲璞先生就持这种看法），另一种看法则认为每个汉字作为一个字素。而在英文等拉丁语族中, 字素其实并没有特别确切的概念, 不同的论文中可能使用的是不同的概念.</li><li>中文的语素通常就是对应着单个汉字，而英文的语素可能就会复杂点，例如really, 可以看作是 real 和 -ly 两个语素，这种区别主要是因为中文不通过词语形变来表达语法，只通过语法词汇来区分语法，比如“的”、“了”等。</li></ul><p>当然啦，回到字符集上来，这里面与字符集关系最密切的显然是字素，那么文字、字符、字素，这些有区别吗?为什么要发明这么多名词?！太难了…</p><p>1）先说“文字”</p><blockquote><p>文字是记录语言的视觉符号系统，是人类社会运用语言相当长时间以后出现的文化现象。</p></blockquote><p>也就是说，文字是个宏观的概念。语言的发展都是先有发音后有文字的，文字的出现是一种必然，同样作为信息的载体，文字显然比声音更容易保存，这也是为什么历史上知识都是通过文字流传下来的。即使是互联网时代来临，多媒体技术诞生，文字载体相对于音频载体，信息密度也是高到不知道哪里去了，音视频种的信息冗余太大，利于传播，但并不利于保存，如今一门语言如果没有文字，慢慢也就会被淘汰了吧。</p><p>2）再说“字符”（Character）</p><p>字符这个概念在英语和汉语种很容易，一个字母、一个汉字就是一个字符，如果给个概念，大概是：拥有实际语义的最小文字单位。但这其实并不严谨，还引入了更为模糊的语义概念。我觉得，简单一点可以理解成，字符就是一门语言的文字中，可以独立有意义的最小单位，它并不是一个特别严谨的概念。只是在计算机科学中，字符的概念有特殊的地位，接着往下看, 暂且按下不表。</p><p>3）后说“字素”（Grapheme）</p><p>正如前面所述, 中文的字素概念有两种学派, 拉丁语族的字素也分类不明确, 所以实际上, 很难严格意义上给字素一个具体的概念进行分类. 只能模糊地给出“字素是书写系统的最小功能单位”, 但是具体这个单位该细分到什么程度, 标准并不统一. 那为何还需要提到这个概念, 一切都是因为, 和字符一样, 在计算机科学中, 字素这个概念被赋予了特殊的意义, 而具体意义是什么, 一直往下看, 你就可以看到.</p><blockquote><p>后续行文中, 在未涉及到字素概念前, 可以暂且先认为一个字符就是一个英文字符、一个汉字、一个符号</p></blockquote><h3 id="3-2-计算机科学简介"><a href="#3-2-计算机科学简介" class="headerlink" title="3.2 计算机科学简介"></a>3.2 计算机科学简介</h3><p>学过编程的人都知道，计算机程序中，一切数据的最终形态，其实都是二进制。</p><p><img src="/images/character_set/image_3_1.png" alt="image_3_1.png"></p><p align="center">图3.1</p><p>也就是说，此时此刻呈现在你眼前的所有信息，你耳中听到的音乐，在计算机中全都是 010101010101 这样的存在。</p><blockquote><p>世界上有10种人，懂10进制的，和不懂10进制的。——鲁迅</p></blockquote><p>那么文字自然也是如此，每个有独立语言的国家，在计算机诞生之初，便需要考虑如何表示和存储字符了。即如何将本国语言中的每个文字，对应到一个二进制数中，而这种一一对应的规则，我们就可以将其称为字符集。</p><blockquote><p>在计算机世界中，二进制虽然可以区分到每一位，但实际的读取和写入，最小都是1个字节(byte)，1个字节包含8位二进制。</p></blockquote><h3 id="3-3-（编码）字符集"><a href="#3-3-（编码）字符集" class="headerlink" title="3.3 （编码）字符集"></a>3.3 （编码）字符集</h3><p>在说字符集之前，先厘清几个概念。 而这些概念中，我们经常将编码字符集和字符集混为一谈，倒也不太影响理解，因此这里也就不那么严谨，理解万岁！！</p><blockquote><ul><li>字符集&#x2F;字符库(Character set&#x2F;Character repertoire)：被一种或多种语言使用的字符的集合。也就是说，字符集告诉了我们，一门语言中，到底有多少个字符，每个字符是什么。</li><li>编码字符集(Coded character set)：每个字符对应一个独一无二的数字的集合。即将字符集和数字一一对应的集合。</li><li>码点(Code point)：编码字符集中的任一个合法数字，称之为码点。</li><li>编码空间(Code space)：包含所有码点的整数范围。</li><li>编码单位(Code unit)：用来编码字符集中每个字符的二进制序列。</li></ul></blockquote><p>对于计算机的诞生国美国来说，很简单，只需要考虑26个英文字母及其大小写，再加上阿拉伯数字、标点符号和一些特殊的控制字符，字符集的容量只要128够了。因此美帝标准协会制定了一个标准，用来表示英文世界中需要用到的所有字符，这个标准就是ASCII(American Standard Code for Information Interchange)。128个数，用二进制来表示，7位也就够了，一个字节绰绰有余。</p><p><img src="/images/character_set/image_3_2.gif" alt="image_3_2"></p><p align="center">图3.2</p>    <p>但是渐渐地，欧洲国家也开始有了计算机，它们使用更多的字符，因此将一个字节中没有使用的最高位也用上了，制定了一套Extended ASCII Codes.</p><p><img src="/images/character_set/image_3_3.gif" alt="image_3_3"></p><p align="center">图3.3</p><p>后来亚洲国家也开始使用计算机，汉字需要制定一套标准字符集，因此中国国家标准总局逐步制定了GB2312、GBK、GB13000、GB18030的标准字符集。日语也需要一套字符集，于是日本政府就逐步制定了JIS X 0201–1976、JIS X 0208–1990、JIS X 0212–1990、JIS X 0213–2000等标准字符集。</p><p>这样一直下去，问题就来了，不同国家之间没有沟通，同样一个数字，用汉语的编码字符集解读是正常的，用日语编码字符集就会出错。为了解决这个问题，各国之间也想约定一个世界统一的文字字符集标准，这就诞生了 Unicode。</p><p>Unicode目前使用了0(0x0000)<del>1114111(0x10FFFF)的编码范围，也就是说，当前Unicode的编码空间(Code Space)是0</del>0x10FFFF，之所以说是“当前”，是因为Unicode本身也是在不断发展的，早期Unicode的Code Space只用了0~65535(0xFFFF)的范围，只是随着发展，Unicode标准委员会的人才发现，原来还有各种各样隐藏在世界各处的字符，当然需要加进来！这就导致BMP的范围不够用了，只好扩展Unicode的范围，只是，实际扩展到1114111(0x10FFFF)之后，委员会的人又发现，这么多字符不可能用得完呀！不用又觉得浪费，不如加一些不太正常的语言文字吧，这就包含了文章开头提到的Emoji表情字符。</p><p>Unicode范围如此之大，当然就会想要将它划分成几大块，方便分类，也更容易理解，Unicode标准将这种分片叫做平面(Plane)。最早使用的 0~0xFFFF，就是 基本多语言平面(BMP, Basic Multilingual Plane) 的范围。</p><p><img src="/images/character_set/image_3_4.png" alt="image_3_4"></p><p align="center">图3.4</p>    <p>Unicode总共划分了17个平面，每个平面65536个编码空间，总共正好是 65536*17&#x3D;1114112&#x3D;0x10FFFF+1</p><p><img src="/images/character_set/image_3_5.png" alt="image_3_5"></p><p align="center">图3.5</p><p>所有的Unicode字符都可以在 <a href="https://unicode-table.com/en">这里</a> 看到。 <strong>值得注意的是，哪怕Unicode的编码空间大到用不完，却也不包含任何商标，比如Windows和Apple的注册商标等</strong>，这也是为何 文章开头只能用 winkey 来指代windows的按钮，却无法找到合适的字符。</p><h3 id="3-4-字符编码"><a href="#3-4-字符编码" class="headerlink" title="3.4 字符编码"></a>3.4 字符编码</h3><p>Unicode字符集，在概念上只是编码字符集，它本身只指定了每个数字对应哪个字符，但在计算机中，这个数字究竟存储成什么样的二进制，却没有指定一个统一的标准。Unicode字符集的字符编码方式，就是UTF(Unicode Transformation Format)系列。</p><h4 id="3-4-1-UTF-32"><a href="#3-4-1-UTF-32" class="headerlink" title="3.4.1 UTF-32"></a>3.4.1 UTF-32</h4><p>UTF-32就是用32位(也就是4个字节)来存储一个Unicode字符集中的一个字符，UTF-32的值，正好对应Unicode字符集中字符的码点(Code point)值。<br>比如：</p><ul><li>😤的码点值为 <code>128548(0x1F624)</code>，那么对应的UTF-32编码也就是 <code>0x1F624</code>，在计算机中存储的二进制形态就是： <code>00000000 00000001 11110110 00100100</code> </li><li>“梦”的码点值是 <code>0x68A6</code>，用UTF-32存储在计算机中就是： <code>00000000 00000000 01101000 10100110</code> </li><li>“S”的码点是 <code>0x0053</code>，用UTF-32存储就是： <code>00000000 00000000 00000000 01010011</code></li></ul><p> </p><p><strong>UTF-32编码在实际中是没有被使用的</strong></p><h4 id="3-4-2-UTF-16"><a href="#3-4-2-UTF-16" class="headerlink" title="3.4.2 UTF-16"></a>3.4.2 UTF-16</h4><p>相信你已经发现UTF-32的问题所在了，那就是大多数字符都不需要用到32位，最多也就是24位（3个字节），所有字符都用UTF-32编码太浪费，而且Unicode标准刚制定时，也就只有BMP范围，BMP范围的字符，两个字节就刚好够了，因此有UTF-16的编码格式。在BMP平面上的字符，其UTF-16的编码，和UTF-32一样，也就是字符对应的码点值。</p><p>比如：</p><ul><li>“梦”的码点值是 <code>0x68A6</code>，用UTF-16存储就是： <code>01101000 10100110</code></li><li>“S”的码点是 <code>0x0053</code>，用UTF-16存储就是： <code>00000000 01010011</code></li></ul><p>但是这样就出现了一个问题，那些后来追加的字符集，码点值大于 0xFFFF 的，该怎么用 UTF-16 表示呢? 比如😤。而且这种表示方法，还不能影响已有的UTF-16编码的字符数据，这可怎么办?</p><p>没办法，为了照顾很多采用UTF-16的系统、软件，Unicode规定了BMP平面中的 0xD800~0xDFFF 为 <strong>surrogates</strong> 字符，在图3.5中也可以看到，Unicode规定这部分码点值，不能用来表示任何字符。实际上，这部分还可被分为两部分，0xD800~0xDBFF，称为 high surrogates，0xDC00~0xDFFF，称为 low surrogates。</p><p>这样的话，对于一个大于0xFFFF的值，如果想用UTF-16编码，就可以用32位4个字节表示，high surrogate + low surrogate 拼成一个surrogate pair就行，这样在程序读到两个字节时，如果判断它是 surrogate，那么就认为它不是正常字符，需要和另一个surrogate拼接起来才行，组成另一个字符。例如：</p><ul><li>😤的码点值为 <code>0x1F624</code>，那么对应的UTF-16的surrogate pair也就是 <code>0xD83D + 0xDE24</code>，二进制就是： <code>11011000 01011101 11011110 00100100</code></li></ul><p><strong>不难算出，Surrogate pair总共能表示 1024*1024&#x3D;1048576&#x3D;0x100000个字符，所以UTF-16总共可以编码0x100000+0xFFFF&#x3D;0x10FFFF个字符，这也是为什么当前Unicode字符集的上限是这么大的原因，也影响了接下来我们要说的UTF-8的上限范围。</strong></p><h4 id="3-4-3-UTF-8"><a href="#3-4-3-UTF-8" class="headerlink" title="3.4.3 UTF-8"></a>3.4.3 UTF-8</h4><p>更进一步，对于英语国家的人来说，总觉得一个字节八位就足够了呀，用两位也觉得浪费空间，但对于其他国家比如中国来说，一个字节又肯定不够，这便引出了一种变长的编码格式UTF-8。引一张Wiki上的图来说明UTF-8的编码规范。</p><p><img src="/images/character_set/image_3_6.png" alt="image_3_6"></p><p align="center">图3.6</p><p>例如：</p><ul><li>“S”的码点是 <code>0x0053</code>，用UTF-8存储就是： <code>01010011</code></li><li>“µ”的码点是 <code>0x00B5</code>, 用UTF-8存储就是： <code>11000010 10110101</code></li><li>“梦”的码点值是 <code>0x68A6</code>，用UTF-8存储就是： <code>11100110 10100010 1010 0110</code></li><li>😤的码点值为 <code>0x1F624</code>，用UTF-8存储就是：<code>11110000 10011111 10011000 10100100</code></li></ul><p> </p><p>如果我们算一下四字节的UTF-8实际能表示的范围，会发现理论上应该能表示到 <code>0x1FFFFF</code> ，但是实际上却限制了上限为 <code>0x10FFFF</code> ，这就是上节所述的UTF-16的上限，既然编码空间足够大，目前看来总是够用的，那为了兼容UTF-16，就先这样规定吧。（RFC3629的标准如此规定了上限，大概就是这样想的吧）。</p><p>关于UTF-8，还有一些比较有意思的现象，比如在早期Windows中， <strong>当你在 windows 的记事本里新建一个文件，输入”联通”两个字之后，保存，关闭，然后再次打开，你会发现这两个字已经消失了，代之的是几个乱码</strong> ，这是由于GBK编码和UTF-8编码的识别错误导致的，可以动手搜一搜相应字节码分析一下，然后再看<sup id="fnref:17"><a href="#fn:17" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="infocodez. “【转载】随便说说字符集和编码.” 博客园, 27 Sept. 2017, www.cnblogs.com/infocodez/p/7600459.html. ">[17]</span></a></sup>这篇文章，验证下自己的分析是否正确。</p><h3 id="3-5-大端小端"><a href="#3-5-大端小端" class="headerlink" title="3.5 大端小端"></a>3.5 大端小端</h3><p>Danny Cohen在论文 <sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Cohen, Danny. “ON HOLY WARS AND A PLEA FOR PEACE.” IETF, 1 Apr. 1980, www.ietf.org/rfc/ien/ien137.txt. ">[13]</span></a></sup> 中提出了大端小端的说法，想要结束字节序(Endianness)的“战争”，自那以后，在程序员眼中，大端小端不再是《格列佛游记》的名词，而是字节序的专属名词了。在介绍UTF-32、UTF-16、UTF-8三种编码方式时，我们都没有考虑大端小端的问题，细心的读者可能已经意识到这个问题了，在此我们再简单介绍下。</p><blockquote><p>大端(Big Endian): 将一个多位数的高位放在较小的地址处，低位放在较大的地址处<br>小端(Little Endian): 将一个多位数的低位放在较小的地址处，高位放在较大的地址处</p></blockquote><p>直接拿Wiki上的示例说明， <code>0x0A0B0C0D</code> 这个32位的整数，大小端分别如下：</p><p><img src="/images/character_set/image_3_7_1.png" alt="image_3_7_1"> <img src="/images/character_set/image_3_7_2.png" alt="image_3_7_2"></p><p align="center">图3.7</p><p>我们还是以😤为例，在UTF-32中编码为： <code>0x0001F624</code>，大端小端分别如图。</p><p><img src="/images/character_set/image_3_8.png" alt="image_3_8"></p><p align="center">图3.8</p><p>在UTF-16中编码为： <code>0xD83DDE24</code> ，大端小端分别如图。</p><p><img src="/images/character_set/image_3_9.png" alt="image_3_9"></p><p align="center">图3.9</p><p>看到这里，屏幕前的你，是不是都自信满满地准备自己画出UTF-8的大端小端了? <strong>不过对不起，UTF-8是不需要区分大端小端的</strong>。倒回去看UTF-8的编码标准，我们会发现，UTF-8的最小处理单位是单字节，而不是像UTF-16和UTF-32的多字节。也就是说：</p><ul><li>对于UTF-32，程序需要一次读取4个字节，然后计算这四个字节的实际值，如果字节序不同，会导致结果不同</li><li>对于UTF-16，程序需要一次读取2个字节，然后计算这两个字节的实际值，如果字节序不同，结果也会不同</li><li><strong>但是对于UTF-8来说，程序一次只会读取1个字节，程序需要通过每个字节的字节头去决定是否需要继续读取下一个字节，既然一次只读取一个字节，自然不会受大小端的影响。</strong></li></ul><p> </p><p>😤用UTF-8编码是 <code>0xF09F98A4</code>，那么实际上，计算机永远会先读取 <code>F0</code> ，然后判断还需要读取接下来的三个字节，就依次读取 <code>9F</code> 、<code>98</code> 、 <code>A4</code>，然后将四个字节组合计算得出实际表示的值。计算机总共读取了四次，而不是一次读取了 4个字节。实际在计算机内存中，存储总是如图。</p><p><img src="/images/character_set/image_3_10.png" alt="image_3_10"></p><p align="center">图3.10</p><h3 id="3-6-BOM-byte-order-mark"><a href="#3-6-BOM-byte-order-mark" class="headerlink" title="3.6 BOM(byte order mark)"></a>3.6 BOM(byte order mark)</h3><p>既然字节序对计算机读取字符有很大的影响，那么对于一个文本文件，知道它实际存储的数据是大端还是小端就很重要了。为了实现这个目的，使用BOM来标记一个文本文件的开头，从而区分该文件是大端还是小端存储的。BOM本质上也还是个字符，只不过是个特殊的字符，在UTF-16的文本文件中，BOM就是 <code>0xFEFF</code> ，这时，计算机程序首先读取文本文件的前两个字节，通过判断高低地址的实际值，就可以判断是大端还是小端了。 <strong>0xFEFF这个字符实际上被称为ZERO WIDTH NO-BREAK SPACE字符，之所以用这个字符，是因为根据UTF-8编码标准，UTF-8不可能出现0xFE或者0xFF开头的字符，因此不会和UTF-8产生混淆。</strong> </p><p><img src="/images/character_set/image_3_11.png" alt="image_3_11"></p><p align="center">图3.11</p>    <p>对于UTF-32来说，虽然实际上没人用，但是字节序标准还是有的，用 <code>0x0000FEFF</code> 四个字节表示。</p><p>对于UTF-8来说，由于其自身的字节就有字节头标志，也不区分大小端，其实并不需要BOM，但是在早期Windows系统中，默认用记事本编辑时，用UTF-8保存也会默认加个BOM头，具体是 <code>0xEFBBBF</code> 。这时，实际上这个BOM并不是标志字节序的，而是标志编码方式，即该文件是用UTF-8编码的，仅此而已。</p><p>而这个BOM带来了各种巨坑的问题，不限于：</p><blockquote><ul><li>gcc会报告源码文件开头有无法识别的字符</li><li>Linux的shell脚本无法运行： <code>Shell:  #!/bin/sh: No such file or directory</code> </li><li>早期一些比较坑的教程会教人用记事本学Java，然后用 javac 编译，这时会报“错误：非法字符：blablabla”，但是却不在教程中说明这一点。（之所以记得这件事，是因为直到研究生期间还有人问过这种问题…</li><li>其他一系列知名不知名软件读取配置文件的坑…</li><li>…</li></ul></blockquote><p><strong>但是，竟然还有反向操作的，举一个自己曾经遇到的坑，知名音乐播放软件Foobar 2000，在读取 .cue 文件时，必须是 UTF-8 With BOM，曾经强迫症把所有 .cue 文件改成了 UTF-8 Without BOM，结果Foobar 2000全部无法识别…</strong> </p><p>其他还有一些不常见的BOM如下。</p><p><img src="/images/character_set/image_3_12.png" alt="image_3_12"></p><p align="center">图3.12</p><h3 id="3-7-Unicode控制字符"><a href="#3-7-Unicode控制字符" class="headerlink" title="3.7 Unicode控制字符"></a>3.7 Unicode控制字符</h3><p>上面说到了UTF-16和UTF-32用 <code>0xFEFF</code> 作为BOM字符，这个字符实际上是不可见的，主要用于标志字节序。在编码字符集中, 这种特殊码位的字符，一般可以叫做“控制字符”(Control character,Non-printable character)，即“用于控制文本解释或者显示，而不可见或不占空间的Unicode字符”。<br>而在Unicode的一般性分类中, 控制字符大多都归属于 Other(C) 这个大类. Other(C)大类下又分:</p><ul><li>Cc(Other, control), 共有65个, 而且这个数量永远都不会再变</li><li>Cf(Other, format), 共有161个, 这是Unicode 13.0中的数量, 以后可能会再变</li><li>Cs(Other, surrogate), 共有2048个, 永远都不会再变</li><li>Co(Other, private use), 共有137468个, 永远都不会再变</li><li>Cn(Other, not assigned), 还未分配的保留字符</li></ul><p>这其中, 严格意义上来说, 只有Cc是控制类型的字符, 但是广义上或者口语化中所说的控制字符, 其实也包含了格式化类型的字符, 这就包括了Cf, 以及另一个和Other(C)平行的大类 Separator(Z)中的字符.<br><strong>简单来说, 广义上将Control Type和Format Type的字符都作为控制字符来表达, 也没什么问题</strong><br>对广义上的控制字符细分如下.</p><h4 id="3-7-1-ISO-6429控制字符-C0与C1控制字符"><a href="#3-7-1-ISO-6429控制字符-C0与C1控制字符" class="headerlink" title="3.7.1 ISO 6429控制字符(C0与C1控制字符)"></a>3.7.1 ISO 6429控制字符(C0与C1控制字符)</h4><p>控制字符U+0000‐U+001F 与U+007F来自ASCII。此外，ISO 8859字符集定义了U+0080‐U+009F。二者都定义在ISO 6429中，常被称为C0与C1控制字符。</p><p>大部分这些字符在Unicode文本处理中没有明确作用。字符<code>U+0000 &lt;control-0000&gt; ，NUL、U+0009 &lt;control-0009&gt; ，HT、U+000A &lt;control-000A&gt; ，LF、U+000D &lt;control-000D&gt; ，CR、U+0085 &lt;control-0085&gt; ，NEL</code>常用于格式化字符。</p><p><strong>这65个字符就是所有Cc类别的字符</strong></p><h4 id="3-7-2-Unicode引入的分隔符"><a href="#3-7-2-Unicode引入的分隔符" class="headerlink" title="3.7.2 Unicode引入的分隔符"></a>3.7.2 Unicode引入的分隔符</h4><p>为了简化几种换行字符，Unicode引入了它自己的分隔符来格式化文本：</p><ul><li>U+2028 line separator ，HTML： <code>&amp;#8232;</code>，LSEP</li><li>U+2029 paragraph separator ，HTML： <code>&amp;#8233;</code>，PSEP</li></ul><p><strong>这就是Separator(Z)大类中仅有的两个Format Type的字符了</strong><br><strong>因此, 剩下的所有细分类别, 其实全是Cf类别的字符, 包括了开始所说的<code>0xFEFF</code></strong></p><h4 id="3-7-3-语言标记"><a href="#3-7-3-语言标记" class="headerlink" title="3.7.3 语言标记"></a>3.7.3 语言标记</h4><p>不予叙述，可参考<sup id="fnref:18"><a href="#fn:18" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. “Unicode控制字符.” Wikipedia, Wikimedia Foundation, 28 July 2020, zh.wikipedia.org/wiki/Unicode控制字符.">[18]</span></a></sup>的说明。</p><h4 id="3-7-4-行间标注"><a href="#3-7-4-行间标注" class="headerlink" title="3.7.4 行间标注"></a>3.7.4 行间标注</h4><p>3个格式化字符用于支持旁注标记（U+FFF9、U+FFFA、U+FFFB）。</p><blockquote><p>所谓旁注标记（ruby character），又称注音标示、加注音、Ruby字符、ruby或rubi，是一种表意文字的音标印刷方式，广泛地运用于日文及中文。一般这些字是放于表意文字的上方或右边，作为文字的拼音或注解。</p></blockquote><p>了解过HTML5的童鞋也许知道HTML5引入了 <code>&lt;ruby&gt;</code> 标签，也是同样的意思，（我之所以知道，是因为我的主页也用了嘛！~不过主页也是模仿前端大神的网页做的啦）</p><p><img src="/images/character_set/image_3_13.png" alt="image_3_13"></p><p align="center">图3.13</p><h4 id="3-7-5-双向文本控制"><a href="#3-7-5-双向文本控制" class="headerlink" title="3.7.5 双向文本控制"></a>3.7.5 双向文本控制</h4><p>英文、中文的印刷作品，基本都是从左向右，自上而下的，但并不是所有语言的印刷品都是如此，比如日语就是自右向左的，中国古代的书籍也是。</p><p>Unicode本身是支持从左到右、从右到左，或者其混合排版，而不需要任何特殊字符。但考虑到为了处理一些特殊情形，Unicode还是定义了12个字符<code>（U+061C、U+200E、U+200F、U+202A、U+202B、U+202C、U+202D、U+202E、U+2066、U+2067、U+2068、U+2069）</code>以帮助控制嵌入式双向文本的顺序，最大可以有125层深。</p><p>这个到底是干嘛用的，主要还是因为世界上有阿拉伯语这种存在。。。<br>比如“阿拉伯字母”这五个字的阿拉伯语写法，就是：</p><blockquote><p>أَبْجَدِيَّة عَرَبِيَّة‎</p></blockquote><p>说实话我不知道屏幕前的你看到的实际上是什么样的字符串… 对照下图看看..</p><p><img src="/images/character_set/image_3_14.png" alt="image_3_14"></p><p align="center">图3.14</p><p>而如果我在IDEA的编辑器中，赋值这行字符串为字面量，就会显示成下图，甚至影响了我的光标显示。。。</p><p><img src="/images/character_set/image_3_15.png" alt="image_3_15"></p><p align="center">图3.15</p><p>这其中，虽然那个<code>\u200E</code>的 <code>\</code> 已经位置错误，还是可以看出就是刚刚提到的Unicode定义的12个双向文本控制字符中的一个。实际上它的作用就是控制“从左至右书写标记”，而<code>\u200F</code>是“从右至左书写标记”<br>这就就是阿拉伯语的其中一个特殊之处：<strong>从右向左书写</strong>。(虽然日语、中国古籍，也都是从右向左，但只是排版概念上从右向左，而且还是竖着写的呀)。<br>阿拉伯语的这个特性带来了一个问题，如果在一行阿拉伯文字里，我写了一个英文单词，那该怎么办，nice 岂不是要显示成 ecin，于是就需要对一行文本内的某些文字再单独进行方向控制，那如果单词里再嵌套个阿拉伯字母呢，阿拉伯字母间再嵌套中文…… 如此套娃无穷尽也，因此Unicode规定了最大的嵌套深度是125层。</p><blockquote><p>笔者按: 一个阿拉伯语撑起了字符串处理Bug的半边天…</p></blockquote><h4 id="3-7-6-异体字选择器"><a href="#3-7-6-异体字选择器" class="headerlink" title="3.7.6 异体字选择器"></a>3.7.6 异体字选择器</h4><p>异体字的具体说明可参考<sup id="fnref:19"><a href="#fn:19" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. “異體字選擇器.” Wikipedia, Wikimedia Foundation, 4 Sept. 2020, zh.wikipedia.org/wiki/異體字選擇器.">[19]</span></a></sup>. 简单来说，就是一种语言中，某一个字有两种写法，但是意义完全相同，因此当初编码时，没有将其区分开，但在实际使用中，可能在用于人名等专有名词时，还是需要进行区分的，因此提供了“异体字选择器”这种控制字符。</p><h4 id="3-7-7-控制字符的图片"><a href="#3-7-7-控制字符的图片" class="headerlink" title="3.7.7 控制字符的图片"></a>3.7.7 控制字符的图片</h4><p>不予叙述。</p><h3 id="3-8-组合字符-Combining-Character"><a href="#3-8-组合字符-Combining-Character" class="headerlink" title="3.8 组合字符(Combining Character)"></a>3.8 组合字符(Combining Character)</h3><h4 id="3-8-1-组合标记-Combining-Marks"><a href="#3-8-1-组合标记-Combining-Marks" class="headerlink" title="3.8.1 组合标记(Combining Marks)"></a>3.8.1 组合标记(Combining Marks)</h4><p>上面在说控制字符时，有一类所谓的行间标记提到了“旁注标记”，在汉字上方标注拼音，可以称之为“旁注标记”。那对于某些欧洲语言来说，可以在字母上方加一些变音符号，实质上就表示成了另一个不同的字符，但它又是在原字符基础上变化的，如果每种变化都算作一个新字符，那即使是Unicode，可能也装不下这些排列组合的数量，因此出现了附加组合标记的组合字符。如Wiki的图<sup id="fnref:20"><a href="#fn:20" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. “組合字符.” Wikipedia, Wikimedia Foundation, 30 May 2019, zh.wikipedia.org/wiki/組合字符. ">[20]</span></a></sup>。</p><p><img src="/images/character_set/image_3_16.png" alt="image_3_16"></p><p align="center">图3.16</p><p>在统一码中，用于欧洲语言和国际音标的组合用附加符号为〈U+0300–U+036F〉。上图的字符 y̌ 就可以表示成： <code>\u0079\u030C</code> ， <code>\u0079</code> 就是 <code>y</code> ， <code>\u030C</code> 就是变音符号’̌。</p><p>说到这里, 不得不提的就是在中二时期网络上流行的越界文字(Zalgo text), 其本质就是对组合字符的叠加, 因为Unicode没有规定组合字符必须是实际存在的字符, 那实际上我们可以叠加变音符号, 从而使得字符越界. 如果我们组合这样一个字符”\u0079\u030C\u030C\u030C\u030C\u030C\u030C\u030C”, 实际就是:</p><blockquote><p>y̌̌̌̌̌̌̌</p></blockquote><h4 id="3-8-2-Grapheme-和-Grapheme-Cluster"><a href="#3-8-2-Grapheme-和-Grapheme-Cluster" class="headerlink" title="3.8.2 Grapheme 和 Grapheme Cluster"></a>3.8.2 Grapheme 和 Grapheme Cluster</h4><p>不过，你以为Unicode的组合字符序列到此就结束了吗? まだまだだね<br>关于组合字符序列, Unicode官网给出了一些FAQ<sup id="fnref:32"><a href="#fn:32" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Unicode Consortium. (2020, September 19). Characters and Combining Marks. Retrieved September 19, 2020, from http://unicode.org/faq/char_combmark.html">[32]</span></a></sup>. 在这些Q&amp;A中, 有一个问题:</p><blockquote><p>Q: So is a combining character sequence the same as a “character”?</p></blockquote><p>终于, 我们还是逃避不了这个问题, 究竟什么是字符? 组合字符还是传统意义上的”字符”吗? 怎么在概念上区分它们呢? 最终, 我们引入了字素(grapheme), 那个在语言学简介中提了之后, 一直没有出现的名词.</p><p>在程序员的眼中, 一个字符一般指一个Unicode的Code point, 但对于终端用户来说, 将字符等价于字素(grapheme), 是更加直观的, 字素的概念始终是不变的: <strong>a minimally distinctive unit of writing in the context of a particular writing system</strong>. 只不过之前无法具体细分字素的范围, 现在我们终于有工具能够确切描述字素的范围了.<br>在Unicode世界中, 一个字素至少包含一个Code point, 包含组合标记、控制字符等的多个组合字符序列也可作为一个字素. 这样, 至少在Unicode中, 我们将字素的最小范围限定到了一个Code point, 不会有比一个Code point范围更小的字素了!<br>事实上, Unicode引入的字素(grapheme)概念, 也可以称为用户感知字符(user-perceived character), 不仅可以在基础字符上附加组合字符, 用来形成新的字素, 也可以通过控制字符(如方向控制等)来形成新的字素.</p><p>字素的集合, 就可以统一称为 Grapheme Cluster, 或者通俗一点: user-perceived characters</p><p>So… Why? 为什么要划分这么细, 规定这么多细节, 直接认为 y̌ 就是两个字符, 不搞其他一些幺蛾子, 难道不香吗?<br>Unicode在TR29的技术报告里<sup id="fnref:30"><a href="#fn:30" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Davis, Mark, and Christopher Chapman. Unicode Text Segmentation. 19 Feb. 2020, unicode.org/reports/tr29/. ">[30]</span></a></sup>，给出了一段话:</p><blockquote><p>Grapheme cluster boundaries are important for collation, regular expressions, UI interactions, segmentation for vertical text, identification of boundaries for first-letter styling, and counting “character” positions within text. Word boundaries, line boundaries, and sentence boundaries should not occur within a grapheme cluster: in other words, a grapheme cluster should be an atomic unit with respect to the process of determining these other boundaries.</p></blockquote><p>我给大家画个重点，就是: <strong>grapheme cluster应该作为一个原子性的整体看待, 至少不能在在一个grapheme cluster中间出现换行符、单词分隔符、连字符等破坏性字符吧，那既然有这些限制，识别grapheme cluster的边界就十分有必要了, 这样才能更好的做字符排序、正则匹配、UI交互等字符串(实际上现在该叫字素串)处理工作</strong></p><blockquote><p><strong>总结一下: 可以认为字素是在Code point&#x2F;Character之上的一种更高一层的抽象.</strong></p></blockquote><p>在tr29中，还提到了三类不同的grapheme clusters: legacy grapheme clusters, extended grapheme clusters, tailored grapheme clusters. 具体的概念我也不翻译了，因为…水平不够. 就截几张图, 大概感受一下.</p><p><img src="/images/character_set/image_3_17.png" alt="image_3_17"></p><p align="center">图3.17</p><p>好的，我知道其实你根本不想看，那就略过，我们继续。</p><h4 id="3-8-3-Unicode等价-Unicode-equivalence-及正规化-Normalization"><a href="#3-8-3-Unicode等价-Unicode-equivalence-及正规化-Normalization" class="headerlink" title="3.8.3 Unicode等价(Unicode equivalence)及正规化(Normalization)"></a>3.8.3 Unicode等价(Unicode equivalence)及正规化(Normalization)</h4><p>上面说完了字素, 又引入了另一个问题, 那就是:<br>带变音的拉丁字素等，使用广泛，以及占坑较早，因此，早早地就作为一个个的单独码点在Unicode种有一个码(keng)位了，而后来Unicode又规定了组合字符，这样，同一个字素就有可能有两种编码方式。比如“Å”，既可以是 <code>\u00c5</code> ，也可以是 <code>\u0041\u030A</code> 表示，可以在<a href="https://apps.timwhitlock.info/unicode/inspect">这个网站</a> 试试。这就引入了另一个话题，Unicode equivalence和Normalization，即判断两个字符&#x2F;素串相等时，是否需要考虑这种等价情况，如果需要考虑这种意义上的等价，那么就需要对字符&#x2F;素串先进行正规化(Normalization)，再进行比较。</p><blockquote><p>正规化即将彼此等价的序列转成同一列序, Unicode提供了两种等价概念：标准等价(canonically equivalent)和兼容等价(compatible). 两者的具体概念参考<sup id="fnref:22"><a href="#fn:22" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. “Unicode Equivalence.” Wikipedia, Wikimedia Foundation, 7 Aug. 2020, en.wikipedia.org/wiki/Unicode_equivalence. ">[22]</span></a></sup>. 标准等价的一个示例就是 Å<code>\u00c5</code>和 Å<code>\u0041\u030A</code>, 兼容等价的一个示例就是 ﬀ<code>\ufb00</code> 和 ff<code>\u0066\u0066</code></p></blockquote><p>为了进行正规化, 自然会有两种想法:</p><ul><li>一种是分解(Decomposition): 即将字素串中所有单个字素分解为等价的组合字符.</li><li>一种是组合(Composition): 即将字素串中所有分解后的组合重组为单个字素.</li></ul><p>结合标准等价和兼容等价的概念, 正规形式自然可以分为四种:</p><table><thead><tr><th align="center">正规形式</th><th align="center">转换算法</th></tr></thead><tbody><tr><td align="center">NFD,Normalization Form Canonical Decomposition</td><td align="center">以标准等价方式来分解</td></tr><tr><td align="center">NFC,Normalization Form Canonical Composition</td><td align="center">以标准等价方式来分解，然后以标准等价重组之</td></tr><tr><td align="center">NFKD,Normalization Form Compatibility Decomposition</td><td align="center">以兼容等价方式来分解</td></tr><tr><td align="center">NFKC,Normalization Form Compatibility Composition</td><td align="center">以兼容等价方式来分解，然后以标准等价重组之</td></tr></tbody></table><p>好了, 等价就说到这. 以及, 后续我们还是使用字符串这个名词, 这一小段使用字素串, 主要是为了加深对字素的印象.</p><h3 id="3-9-特殊的组合字符"><a href="#3-9-特殊的组合字符" class="headerlink" title="3.9 特殊的组合字符"></a>3.9 特殊的组合字符</h3><p>在Unicode的兼容性等价示例中, 以 ﬀ<code>\ufb00</code> 为例进行了说明. 这个字符和 两个f的组合 ff<code>\u0066\u0066</code> 具体是什么关系呢?<br>实际上<code>\ufb00</code>是一个连体字&#x2F;合体字.</p><blockquote><p>在西方字体排印学中将多于一个字母合成一个字形就是连体字, 经过演变、长时间流行后，一些连体字组合就直接变成了一个单个字符, 拥有自己独立的形式了.</p></blockquote><p>说到连字, 其实和排版系统有所牵连, 就不细述概念了, 举个例子.<br>在VS Code中可以在配置中<code>&quot;editor.fontLigatures&quot;: true</code>, 这样设置之后, 如果在VS Code中连着打出&gt;和&#x3D;, 其实就会显示成≥<br>但这是编辑器自己处理的连字效果, 有没有办法强行使一些本来没有连字效果的字符组合产生连字效果, 或者强行使一些有连字效果的字符组合取消连字效果呢? 答案是肯定的. Unicode的Cf字符中, 有以下两个字符.</p><ul><li>零宽度连字符(zero-width joiner, zwj)U+200D: 用于阿拉伯文等文字中，使不会发生连字的字符间产生连字效果</li><li>零宽度断字符(zero-width non-joiner, zwnj)U+200C: 用于阿拉伯文、德文等文字中，阻止会发生连字的字符间的连字效果</li></ul><p>zwnj的例子大多都和语言相关, 阿拉伯语、德语一类的, 示例也很复杂.<br>但是zwj就很特殊, 除了阿拉伯语这种特殊语言, 还记得我们文章的开头说了什么吗? 没错, 就是 Emoji!</p><p>zwj对Emoji也有效, 本来Emoji就是个设计简单表达心情的表情符号，但随着使用越来越广泛，刮起了一阵“中立表情(Neutral Emojis)”的风，即有男性表情，那就得有对应的女性，有白种人，那就得有黄种人、黑种人，家庭可以是异性恋，那就得有同性恋，有儿子，也得有女儿。如果每种都是单独的字符表示，那Unicode可能也装不下，而且已有的Emoji也不能复用, 因此就想到了用zwj来组合相关Emoji, 形成新的Emoji。</p><p>最典型的一个例子：👨‍👨‍👦‍👦这个家庭的Emoji，实际上是由四个Emoji组合而成，表示两个爸爸和两个儿子一家： <code>\uD83D\uDC68\u200D\uD83D\DC68\u200D\D83D\DC66\u200D\D83D\uDC66</code></p><p>每个字符间用特殊字符 <code>\u200D</code>(zero width joiner) 连接起来. 总共占用了22个字节，每个表情成分是四个字节，而每个控制字符只占用两个字节。</p><h2 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h2><p>已经说了这么多，相信诸位也已经知道了emoji究竟是什么，回到文章开头前言处，微信为何能显示😤这个表情，也不言自明了。</p><p>读到这里，你长输一口气：“终于要结束了！”。抱歉，其实还没完。。。</p><p>既然emoji就是一个字符，那么在计算机程序中，对它的操作、存储，也自然是和普通字符没什么差别，本质就是字符的编码问题。那这是不是意味着，在互联网程序中，凡是可以输入字符的地方，其实也就可以输入emoji、乃至所有unicode字符呢? 最差也就是某些古老的客户端没法正确展示嘛！真是如此，还是说服务器端有必要对unicode字符做一些限制呢? 答案是肯定的，在很多情况下，的确要对字符进行限制。这样做的原因有很多，这里列举以下几个原因，进行说明。</p><h3 id="4-1-数据库不支持"><a href="#4-1-数据库不支持" class="headerlink" title="4.1 数据库不支持"></a>4.1 数据库不支持</h3><p>这主要就是MySQL的坑了，MySQL 5.5.3版本之前，设置的所谓utf-8格式，其实只支持三个字节长度的utf-8，不支持四字节长度。之后的版本才支持四字节长度，而为了兼容以前的版本，指定表结构、字段类型为utf-8，其实还是只支持三字节的utf8mb3，只有显示指定utf8mb4，才是支持四字节的utf-8.</p><p>不过这也不能把锅全甩给MySQL，谁让MySQL支持UTF-8太早了呢，根据Wiki<sup id="fnref:25"><a href="#fn:25" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. “UTF-8.” Wikipedia, Wikimedia Foundation, 20 Aug. 2020, zh.wikipedia.org/wiki/UTF-8. ">[25]</span></a></sup>所述。</p><blockquote><p>这是由于MySQL在4.1版本开始支持UTF-8编码（当时参考UTF-8草案版本为RFC 2279）时，为2003年，并且在同年9月限制了其实现的UTF-8编码的空间占用最多为3字节，而UTF-8正式形成标准化文档（RFC 3629）是其之后。限制UTF-8编码实现的编码空间占用一般被认为是考虑到数据库文件设计的兼容性和读取最优化，但实际上并没有达到目的，而且在UTF-8编码开始出现需要存入非基本多文种平面的Unicode字符（例如emoji字符）时导致无法存入（由于3字节的实现只能存入基本多文种平面内的字符）。直到2010年在5.5版本推出“utf8mb4”来代替、“utf8”重命名为“utf8mb3”并调整“utf8”为“utf8mb3”的别名，并不建议使用旧“utf8”编码，以此修正遗留问题。</p></blockquote><h3 id="4-2-打印机不支持"><a href="#4-2-打印机不支持" class="headerlink" title="4.2 打印机不支持"></a>4.2 打印机不支持</h3><p>也许你的数据库，你的程序都可以正常的存储、展示Unicode字符，但是对那些需要将字符打印出来的场景，还需要考虑打印机等硬件的限制，有些打印机并不具备打印复杂Unicode字符的能力。</p><h3 id="4-3-安全原因"><a href="#4-3-安全原因" class="headerlink" title="4.3 安全原因"></a>4.3 安全原因</h3><p>安全是个不容忽视的原因，大到苹果、腾讯，也多次在unicode字符上翻车。</p><p>列举一下我还记得的一些相关Bug：</p><ul><li><a href="https://yq.aliyun.com/articles/202488">iOS漏洞：发送短信即可令任意苹果手机重启</a> </li><li><a href="https://zhuanlan.zhihu.com/p/136328290">iOS 现重大漏洞，神秘字符可让 iPhone 死机！</a></li><li><a href="https://www.zhihu.com/question/43621727/answer/548216936">微信「你女朋友撤回了一条消息还亲了你一口」是怎么实现的（微信已经修复了这个bug）？</a></li><li><a href="https://www.sohu.com/a/289091005_120085857">“我给男神发了7条隐藏微信消息，结果他向我表白了！” </a></li></ul><p>后面两个微信的bug其实都和我们之前提到的Unicode的“双向控制字符”有关，而又因为方向控制通常用在阿拉伯语中，因此这些漏洞的利用都利用了阿拉伯字符.<br>苹果的漏洞都没有披露具体细节，原因也只能靠网友自己去猜，蛤乎上偶尔能搜到。这里给出几个链接，感兴趣可以看看. <a href="https://www.zhihu.com/question/21568134?rf=21568497">点我</a> ，<a href="https://www.zhihu.com/question/390280089">还有我</a>，<a href="https://www.guokr.com/question/496989/">还有我</a> </p><h2 id="五、字体与排版"><a href="#五、字体与排版" class="headerlink" title="五、字体与排版"></a>五、字体与排版</h2><p>回到文章开头的另一个问题，“😤这个表情真的是图片吗?”，也许你会回答，当然不是啦，现在知道了，它就是个字符，和汉字一样。一个整数就可以表示了，而图片需要用专门的图片格式，BMP、GIF或者JPG等。那么你有没有想过，你是怎么看到这个表情的呢? 不是图形眼睛怎么能看到呢?</p><p>这就要扯到字体上去了，这块不是本文重点，但还是在最后顺带一提。</p><p>虽然字符本质上几个字节就编码完成了，可以看作和整数一一对应，但是想要将这个字符渲染出来，就是另一套体系，图形学的体系。换字体强迫症者，也许在网上寻找过各种各样的字体进行尝试，下载一个 <code>.ttf</code> 文件，然后双击安装，就拥有了一种新字体。</p><p>将一个二进制代表的字符转化为人眼可见的图形，大概的流程就是这样的。</p><p><img src="/images/character_set/image_5_1.png" alt="image_5_1.png"></p><p align="center">图5.1</p><p>不过这块了解不多，也没有查阅太多资料，可能不太准确. 如有错误恳请指出。</p><p>参考<sup id="fnref:33"><a href="#fn:33" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Hosken, M., &amp; Gaultney, V. (2003, September 5). Guidelines for Writing System Support: Technical Details: Smart Rendering: Part 1. Retrieved September 20, 2020, from https://scripts.sil.org/cms/scripts/page.php?site_id=nrsi">[33]</span></a></sup>, 可以给出稍微细节点的渲染流程, 如图5.2所示.</p><p><img src="/images/character_set/image_5_2.png" alt="image_5_2.png"></p><p align="center">图5.2</p><p>还有一点就是： <strong>现有的TTF和OTF格式，单个字体文件都只能支持65535个字符，因此想要用一个字体文件涵盖所有的Unicode字符是不可能的</strong> </p><p>在计算机的文字处理领域，除了底层的编码、字体，还要考虑对字符如何进行排版，而这又是另一个复杂而又宏大的话题了<sup id="fnref:33"><a href="#fn:33" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Hosken, M., &amp; Gaultney, V. (2003, September 5). Guidelines for Writing System Support: Technical Details: Smart Rendering: Part 1. Retrieved September 20, 2020, from https://scripts.sil.org/cms/scripts/page.php?site_id=nrsi">[33]</span></a></sup>。就此打住，有机会再研究~</p><h2 id="六、Q-amp-A"><a href="#六、Q-amp-A" class="headerlink" title="六、Q&amp;A"></a>六、Q&amp;A</h2><p>好了，说了这么多理论，问几个问题，看你是否都能答对。<br>以下涉及编程语言的部分, Java 版本为 Java 11, Python 版本为 Python 3.8.2, Go 版本为 Go 1.13.8<br>主要还是以Java为主</p><h3 id="6-1-“😤”在不同的编程语言中的length是多少"><a href="#6-1-“😤”在不同的编程语言中的length是多少" class="headerlink" title="6.1 “😤”在不同的编程语言中的length是多少?"></a>6.1 “😤”在不同的编程语言中的length是多少?</h3><p>通常, 编程语言中 字符串的 length 表示了该字符串的字符数量.<br>从理论上来说, 长度应该为1, 否则会很麻烦.<br>就像早期MySQL中认为汉字是2个字符长度, 英文字母是1个字符长度, 那么编程时, 就需要程序员自己计算实际使用的长度, 防止超出varchar(n)的长度范围. 因为不方便, 而且也不符合字符的实际定义, 后续MySQL就改了.<br>但是各个编程语言又是怎么处理的呢? 是否所有语言所谓的字符就是真正的字符呢?</p><h4 id="6-1-1-Java的表现"><a href="#6-1-1-Java的表现" class="headerlink" title="6.1.1 Java的表现"></a>6.1.1 Java的表现</h4><p>先来看Java</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"😤"</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">2</span><span class="token number">2</span><span class="token number">4</span><span class="token number">128548</span><span class="token number">56868</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上, Java认为字符串的长度是2.<br>Java 8之前, Java中的String, 内部存储结构就是char数组, 每个char都是一个UTF-16字符, 所以String的长度就是UTF-16字符的数量.<br>在Java 9之后, 虽然Java的String内部存储改用了 byte 数组, 但实际目的只是为了减少字符串占用的存储空间, 并不是彻底地改变了Java String中char的定义. 通过String的<a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/lang/String.java">源码</a> 可以看到当前String中核心的几个属性是:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span> coder<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token constant">COMPACT_STRINGS</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果COMPACT_STRINGS是false, 那么本质上和JDK 8没有区别, 每个char都是一个UTF-16, 占两个字节.<br>默认COMPACT_STRINGS是true, 此时, String的存储有两种可能的形式, 通过coder区分, coder为0时表示LATIN1, 为1时表示UTF16. LATIN1实际上就是ISO-8859-1字符集, 即如果一个String的只包含了ISO-8859-1字符集的字符, 那么coder&#x3D;0, 一个字符用一个byte存储即可, 而出现该字符集之外的字符, coder&#x3D;1, 一个字符用两个byte存储, 即UTF-16的编码方式. 查看String中的<code>coder()</code>和<code>isLatin1()</code>方法, 也可看出是COMPACT_STRINGS和coder共同决定了字符串的编码方式.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">byte</span> <span class="token function">coder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token constant">COMPACT_STRINGS</span> <span class="token operator">?</span> coder <span class="token operator">:</span> <span class="token constant">UTF16</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isLatin1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token constant">COMPACT_STRINGS</span> <span class="token operator">&amp;&amp;</span> coder <span class="token operator">==</span> <span class="token constant">LATIN1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想修改COMPACT_STRINGS的值, 可以指定JVM参数<code>-XX:-CompactStrings</code></p><p>总结一下其实就是, Java中, 如果字符串是<code>isLatin1</code>的, 那么字符串长度就是字节数, 否则, 就是字节数&#x2F;2, 至于这两个字节是否真的能表示一个字符, Java表示无所谓.<br>所以这个复杂的组合字符 👨‍👨‍👦‍👦 在Java中的length实际上就是11</p><p>可以说, 由于历史原因, Java原生的String在计算长度时, 并不是很好, 甚至可以说有点坑.</p><h4 id="6-1-2-Javascript的表现"><a href="#6-1-2-Javascript的表现" class="headerlink" title="6.1.2 Javascript的表现"></a>6.1.2 Javascript的表现</h4><p>再看下Javascript</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"😤"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">2</span><span class="token number">128548</span><span class="token number">56868</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>毕竟前面带了Java, 难怪表现基本一致…</p><h4 id="6-1-3-Python的表现"><a href="#6-1-3-Python的表现" class="headerlink" title="6.1.3 Python的表现"></a>6.1.3 Python的表现</h4><p>那Python 3上表现又是如何呢?</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">s <span class="token operator">=</span> <span class="token string">"😤"</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># print(ord(s[1]))   # 会抛异常</span><span class="token number">1</span><span class="token number">128548</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>终于有一个表现符合我们预期的编程语言了, 可喜可贺.<br>如果考虑组合字符呢?</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">combiningCharacter <span class="token operator">=</span> <span class="token string">"\u0079\u030C"</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>combiningCharacter<span class="token punctuation">)</span><span class="token punctuation">)</span>combiningCharacters <span class="token operator">=</span> <span class="token string">"👨‍👨‍👦‍👦"</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>combiningCharacters<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">2</span><span class="token number">7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以组合字符, 无论是附加组合标记的, 还是用零宽连字符连接的, 还是被认为是单个字符组成的, 统计的长度也是单个字符的数量, 即Code Point的数量</p><h4 id="6-1-4-Go的表现"><a href="#6-1-4-Go的表现" class="headerlink" title="6.1.4 Go的表现"></a>6.1.4 Go的表现</h4><p>最近风头正盛的Go语言呢?</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">s <span class="token operator">:=</span> <span class="token string">"😤"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%x "</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%+q\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token number">4</span><span class="token number">240</span>f0 9f <span class="token number">98</span> a4<span class="token string">"\U0001f624"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不科学呀, 怎么和其他语言都不一样呢?<br>直接看Go语言的一篇官方博客<sup id="fnref:31"><a href="#fn:31" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Pike, R. (2013, October 23). Strings, bytes, runes and characters in Go. Retrieved September 19, 2020, from https://blog.golang.org/strings">[31]</span></a></sup>, <a href="https://blog.golang.org/strings">Strings, bytes, runes and characters in Go</a><br>这篇博客阐述了Go中关于String的几个关键点.</p><ul><li>Go中字符串实际上就等价于一个字节流, 访问一个字符串的index位置, 得到的其实就是对应位置的字节.</li><li>Go只存储字节流, 每个字节的值, 可以随便指定, 因此理论上字节流的编码方式可以是任何编码方式. 但是特殊的是字面量(也就是直接在源码中写出来的), 字面量的值转为什么样的字节流, 实际上在书写源码的那一刻就决定了, 源码文件本身是什么编码格式的, 就对应哪种编码的字节流, 由于Go源码只允许UTF-8格式, 实际上Go的字面量对应的字节流就是UTF-8字节流.</li><li>Go没有使用字符&#x2F;character的概念, 而是使用了rune</li></ul><p>博客中也解释了这么设计的原因, 因为 字符(character) 这个概念很难定义, 考虑到组合字符等, 在 计算&#x2F;Computing 中字符的概念很容易引起歧义(也的确如此, 包括这篇文章写的也没那么严谨), 因此Go中没有使用字符这个概念, 取而代之的是rune, 一个rune实际上就等价于一个Unicode中的Code Point, 同时rune实际上就是int32的别名, 这也不难理解, 用整数表示Code Point正好.<br>至于如何迭代string中的rune, Go 提供了 <code>for range</code>语法, 博客示例:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> nihongo <span class="token operator">=</span> <span class="token string">"日本語"</span><span class="token keyword">for</span> index<span class="token punctuation">,</span> runeValue <span class="token operator">:=</span> <span class="token keyword">range</span> nihongo <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#U starts at byte position %d\n"</span><span class="token punctuation">,</span> runeValue<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>U<span class="token operator">+</span><span class="token number">65E5</span> <span class="token char">'日'</span> starts at <span class="token builtin">byte</span> position <span class="token number">0</span>U<span class="token operator">+</span>672C <span class="token char">'本'</span> starts at <span class="token builtin">byte</span> position <span class="token number">3</span>U<span class="token operator">+</span>8A9E <span class="token char">'語'</span> starts at <span class="token builtin">byte</span> position <span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们用<code>for range</code>来迭代组合字符呢?</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> combiningCharacter <span class="token operator">=</span> <span class="token string">"\u0079\u030C"</span><span class="token keyword">for</span> index<span class="token punctuation">,</span> runeValue <span class="token operator">:=</span> <span class="token keyword">range</span> combiningCharacter <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#U starts at byte position %d\n"</span><span class="token punctuation">,</span> runeValue<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> combiningCharacters <span class="token operator">=</span> <span class="token string">"😤👨‍👨‍👦‍👦"</span><span class="token keyword">for</span> index<span class="token punctuation">,</span> runeValue <span class="token operator">:=</span> <span class="token keyword">range</span> combiningCharacters <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#U starts at byte position %d\n"</span><span class="token punctuation">,</span> runeValue<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>U<span class="token operator">+</span><span class="token number">0079</span> <span class="token char">'y'</span> starts at <span class="token builtin">byte</span> position <span class="token number">0</span>U<span class="token operator">+</span>030C <span class="token char">'̌'</span> starts at <span class="token builtin">byte</span> position <span class="token number">1</span>U<span class="token operator">+</span>1F624 <span class="token char">'😤'</span> starts at <span class="token builtin">byte</span> position <span class="token number">0</span>U<span class="token operator">+</span>1F468 <span class="token char">'👨'</span> starts at <span class="token builtin">byte</span> position <span class="token number">4</span>U<span class="token operator">+</span>200D starts at <span class="token builtin">byte</span> position <span class="token number">8</span>U<span class="token operator">+</span>1F468 <span class="token char">'👨'</span> starts at <span class="token builtin">byte</span> position <span class="token number">11</span>U<span class="token operator">+</span>200D starts at <span class="token builtin">byte</span> position <span class="token number">15</span>U<span class="token operator">+</span>1F466 <span class="token char">'👦'</span> starts at <span class="token builtin">byte</span> position <span class="token number">18</span>U<span class="token operator">+</span>200D starts at <span class="token builtin">byte</span> position <span class="token number">22</span>U<span class="token operator">+</span>1F466 <span class="token char">'👦'</span> starts at <span class="token builtin">byte</span> position <span class="token number">25</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是和Python一样的结果.</p><p>现在还剩下一个问题, 如果我不仅仅想在<code>for range</code>中访问rune, 有什么办法直接根据索引访问吗?<br>Go给出的答案是: 语言核心部分不包含该功能, 但是可以使用库. 最常用的就是<code>unicode/utf8</code>了</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> i<span class="token punctuation">,</span> w <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>nihongo<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> w <span class="token punctuation">&#123;</span>  runeValue<span class="token punctuation">,</span> width <span class="token operator">:=</span> utf8<span class="token punctuation">.</span><span class="token function">DecodeRuneInString</span><span class="token punctuation">(</span>nihongo<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#U starts at byte position %d\n"</span><span class="token punctuation">,</span> runeValue<span class="token punctuation">,</span> i<span class="token punctuation">)</span>  w <span class="token operator">=</span> width<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>实际上, 在Unicode的FAQ中<sup id="fnref:32"><a href="#fn:32" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Unicode Consortium. (2020, September 19). Characters and Combining Marks. Retrieved September 19, 2020, from http://unicode.org/faq/char_combmark.html">[32]</span></a></sup>, 也提到了如何统计string中的字符数量, <a href="http://unicode.org/faq/char_combmark.html#7">点我看看</a>, 其中将统计方法归纳总结成了四类: bytes,Code units,Code points,Grapheme clusters</p></blockquote><h3 id="6-2-字符串反转都如何处理"><a href="#6-2-字符串反转都如何处理" class="headerlink" title="6.2 字符串反转都如何处理?"></a>6.2 字符串反转都如何处理?</h3><p>如果只是对bytes反转, 是很简单的, 但很多情况下对终端用户来说, 反转之后的字符串还想能够正常显示的, 因此对于复杂文字来说, 需要以字素为单位切分, 而不仅仅是字符&#x2F;Code point</p><p>按照上一个问题的分析, 可以知道Java一般都是按照Code point切分字符的, 但由于用了UTF-16的编码方式, 超过两字节的Code point就会被统计成两个字符, 那么在反转字符串时, 会如何呢?</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"😤Ly̌L\uD83D\uDC68\u200D\uD83D\uDC68\u200D\uD83D\uDC66\u200D\uD83D\uDC66Ry̌R😤"</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> reverseStr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reverseStr<span class="token punctuation">)</span><span class="token punctuation">;</span>😤<span class="token class-name">Ly</span>̌<span class="token class-name">L</span>👨‍👨‍👦‍👦<span class="token class-name">Ry</span>̌<span class="token class-name">R</span>😤😤<span class="token class-name">R</span>̌yR👦‍👦‍👨‍👨<span class="token class-name">L</span>̌yL😤<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Emoji还是正常的, 会按照Code point切分, 查看源码可以很清晰的看到对Surrogate做了特殊处理. 但是对组合字符就无能为力了</p><p>Python 3应该是一样的表现.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">s <span class="token operator">=</span> <span class="token string">"😤Ly̌L👨‍👨‍👦‍👦Ry̌R😤"</span><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>😤Ly̌L👨‍👨‍👦‍👦Ry̌R😤😤ŘyR👦‍👦‍👨‍👨ĽyL😤<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Javascript原生split再反转, 理论上应该是不行的, 测试了一下也的确不行, 使用Array.from可以解决把一个Emoji的Code point当作两个的问题, 但是对组合字符还是无效的.</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">s <span class="token operator">=</span> <span class="token string">"😤Ly̌L👨‍👨‍👦‍👦Ry̌R😤"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span>😤Ly̌<span class="token constant">L</span>👨‍👨‍👦‍👦Ry̌<span class="token constant">R</span>😤��<span class="token constant">R</span>̌yR��‍��‍��‍��<span class="token constant">L</span>̌yL��😤<span class="token constant">R</span>̌yR👦‍👦‍👨‍👨<span class="token constant">L</span>̌yL😤<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Go还是和之前说的一样, string本质上就是字节流, 所以需要封装对字节的处理, 一个示例.</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token string">"😤Ly̌L👨‍👨‍👦‍👦Ry̌R😤"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">Reverse</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">Reverse</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>  size <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>  buf <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span>  <span class="token keyword">for</span> start <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> start <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token punctuation">&#123;</span>    r<span class="token punctuation">,</span> n <span class="token operator">:=</span> utf8<span class="token punctuation">.</span><span class="token function">DecodeRuneInString</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>start<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    start <span class="token operator">+=</span> n    utf8<span class="token punctuation">.</span><span class="token function">EncodeRune</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span>size<span class="token operator">-</span>start<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>😤Ly̌L👨‍👨‍👦‍👦Ry̌R😤😤ŘyR👦‍👦‍👨‍👨ĽyL😤<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>其实, 这个问题, 本质上还是在界定字节、Code point、字素的概念, 反转函数究竟是按照byte、Code point还是字素去处理字符串, 可以看到, 语言核心类库一般只支持到按照Code point去切分, 想要处理组合字符等特殊的字素, 需要付出更多的努力</strong></p><h3 id="6-3-怎么除去4字节编码的utf-8字符"><a href="#6-3-怎么除去4字节编码的utf-8字符" class="headerlink" title="6.3 怎么除去4字节编码的utf-8字符"></a>6.3 怎么除去4字节编码的utf-8字符</h3><p>由于历史因素, 无法修改MySQL的编码, 这时可能就需要在落库时过滤一遍字符串, 将4字节的utf-8字符去除.<br>对于严格按照Code point切分的语言, 比如python和go, 通过每个字符、rune的长度, 很容易就能判定.</p><p>对于Java这种UTF-16存储的, 我们可以利用一个很简单却很容易被忽略的事实: <strong>UTF-8编码的3字节的字符范围, 就是BMP的范围</strong>, 也就是说, 基本UTF-16范围的字符, 用UTF-8都不超过3字节, 所以只要判断一个字符是否是Surrogate, 移除所有Surrogate, 其实就可以保证不会超过UTF-8的3字节范围.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">removeSurrogate</span><span class="token punctuation">(</span><span class="token class-name">String</span> originStr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token class-name">StringBuilder</span> returnStr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> ch <span class="token operator">:</span> originStr<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">isSurrogate</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      returnStr<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> returnStr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Kawasaki, Tamaki. <em>Emoji（表情符号）是如何诞生并在全世界普及的？</em>. 12 Aug. 2018, www.gov-online.go.jp/eng/publicity/book/hlj/html/201808/201808_12_ch.html.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “World Emoji Day.” <em>Wikipedia</em>, Wikimedia Foundation, 10 Aug. 2020, en.wikipedia.org/wiki/World_Emoji_Day.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">池昌海 . “语言学概论.” 浙江大学-远程教育学院, 16 Dec. 2010, 218.108.57.198/yyxgl1/.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">李玲璞. &quot;汉字学元点理论及相关问题——兼谈汉字认知的若干误区.&quot; 中国文字研究 (2004).<a href="#fnref:4" rev="footnote">↩</a></span></li><li id="fn:5"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Character Encoding.” Wikipedia, Wikimedia Foundation, 25 Aug. 2020, en.wikipedia.org/wiki/Character_encoding.<a href="#fnref:5" rev="footnote">↩</a></span></li><li id="fn:6"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Tero, Paul. “Unicode, UTF8 &amp; Character Sets: The Ultimate Guide.” Smashing Magazine, 6 June 2012, www.smashingmagazine.com/2012/06/all-about-unicode-utf8-character-sets/.<a href="#fnref:6" rev="footnote">↩</a></span></li><li id="fn:7"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Plane (Unicode).” <em>Wikipedia</em>, Wikimedia Foundation, 28 Aug. 2020, en.wikipedia.org/wiki/Plane_(Unicode).<a href="#fnref:7" rev="footnote">↩</a></span></li><li id="fn:8"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Unkown. “Unicode Character Table.” ✔️ ❤️ ★ Unicode Character Table, 6 Sept. 2020, unicode-table.com/en/.<a href="#fnref:8" rev="footnote">↩</a></span></li><li id="fn:9"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">timwhitlock. “Unicode Character Inspector.” <em>apps.timwhitlock.info</em>, 6 Sept. 2020, apps.timwhitlock.info/unicode/inspect.<a href="#fnref:9" rev="footnote">↩</a></span></li><li id="fn:10"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">纤夫张 . “其实你并不懂 Unicode.” 知乎专栏, 31 Dec. 2018, zhuanlan.zhihu.com/p/53714077.<a href="#fnref:10" rev="footnote">↩</a></span></li><li id="fn:11"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “UTF-8.” Wikipedia, Wikimedia Foundation, 5 Sept. 2020, en.wikipedia.org/wiki/UTF-8.<a href="#fnref:11" rev="footnote">↩</a></span></li><li id="fn:12"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">F. Yergeau. “UTF-8, a Transformation Format of ISO 10646.” IETF Tools, 1 Nov. 2003, tools.ietf.org/html/rfc3629.<a href="#fnref:12" rev="footnote">↩</a></span></li><li id="fn:13"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Cohen, Danny. “ON HOLY WARS AND A PLEA FOR PEACE.” IETF, 1 Apr. 1980, www.ietf.org/rfc/ien/ien137.txt.<a href="#fnref:13" rev="footnote">↩</a></span></li><li id="fn:14"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">14.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “字节序.” Wikipedia, Wikimedia Foundation, 18 Aug. 2020, zh.wikipedia.org/wiki/字节序.<a href="#fnref:14" rev="footnote">↩</a></span></li><li id="fn:15"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">15.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Unicode. “Glossary of Unicode Terms.” Glossary, 21 May 2020, unicode.org/glossary/.<a href="#fnref:15" rev="footnote">↩</a></span></li><li id="fn:16"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">16.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “位元組順序記號.” Wikipedia, Wikimedia Foundation, 30 June 2020, zh.wikipedia.org/wiki/位元組順序記號.<a href="#fnref:16" rev="footnote">↩</a></span></li><li id="fn:17"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">17.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">infocodez. “【转载】随便说说字符集和编码.” 博客园, 27 Sept. 2017, www.cnblogs.com/infocodez/p/7600459.html.<a href="#fnref:17" rev="footnote">↩</a></span></li><li id="fn:18"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">18.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Unicode控制字符.” Wikipedia, Wikimedia Foundation, 28 July 2020, zh.wikipedia.org/wiki/Unicode控制字符.<a href="#fnref:18" rev="footnote">↩</a></span></li><li id="fn:19"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">19.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “異體字選擇器.” Wikipedia, Wikimedia Foundation, 4 Sept. 2020, zh.wikipedia.org/wiki/異體字選擇器.<a href="#fnref:19" rev="footnote">↩</a></span></li><li id="fn:20"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">20.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “組合字符.” Wikipedia, Wikimedia Foundation, 30 May 2019, zh.wikipedia.org/wiki/組合字符.<a href="#fnref:20" rev="footnote">↩</a></span></li><li id="fn:21"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">21.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Zachary. “Emoji与Unicode.” Emoji与Unicode · Zablog, 18 Sept. 2017, zablog.me/2017/09/18/emoji/.<a href="#fnref:21" rev="footnote">↩</a></span></li><li id="fn:22"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">22.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Unicode Equivalence.” Wikipedia, Wikimedia Foundation, 7 Aug. 2020, en.wikipedia.org/wiki/Unicode_equivalence.<a href="#fnref:22" rev="footnote">↩</a></span></li><li id="fn:23"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">23.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">deerchao. “基本修养：字符集与编码.” 超越代码, 12 Sept. 2019, deerchao.cn/blog/posts/unicode.html.<a href="#fnref:23" rev="footnote">↩</a></span></li><li id="fn:24"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">24.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">vstinner. “Programming with Unicode.” 4. Unicode - Programming with Unicode, 23 June 2017, unicodebook.readthedocs.io/unicode.html.<a href="#fnref:24" rev="footnote">↩</a></span></li><li id="fn:25"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">25.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “UTF-8.” Wikipedia, Wikimedia Foundation, 20 Aug. 2020, zh.wikipedia.org/wiki/UTF-8.<a href="#fnref:25" rev="footnote">↩</a></span></li><li id="fn:26"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">26.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Cenalulu(卢钧轶) . “十分钟搞清字符集和字符编码.” Cenalulu's Tech Blog, 25 Jan. 2015, cenalulu.github.io/linux/character-encoding/.<a href="#fnref:26" rev="footnote">↩</a></span></li><li id="fn:27"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">27.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Unicode Font.” Wikipedia, Wikimedia Foundation, 13 July 2020, en.wikipedia.org/wiki/Unicode_font.<a href="#fnref:27" rev="footnote">↩</a></span></li><li id="fn:28"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">28.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">DrStrangeLove. “How Are Character Encodings Related to Fonts?” Super User, 15 Nov. 2011, superuser.com/questions/357530/how-are-character-encodings-related-to-fonts.<a href="#fnref:28" rev="footnote">↩</a></span></li><li id="fn:29"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">29.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Belleve. “字符编码与字体的关系是什么？.” 知乎, 27 Apr. 2015, www.zhihu.com/question/29924586.<a href="#fnref:29" rev="footnote">↩</a></span></li><li id="fn:30"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">30.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Davis, Mark, and Christopher Chapman. Unicode Text Segmentation. 19 Feb. 2020, unicode.org/reports/tr29/.<a href="#fnref:30" rev="footnote">↩</a></span></li><li id="fn:31"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">31.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Pike, R. (2013, October 23). Strings, bytes, runes and characters in Go. Retrieved September 19, 2020, from https://blog.golang.org/strings<a href="#fnref:31" rev="footnote">↩</a></span></li><li id="fn:32"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">32.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Unicode Consortium. (2020, September 19). Characters and Combining Marks. Retrieved September 19, 2020, from http://unicode.org/faq/char_combmark.html<a href="#fnref:32" rev="footnote">↩</a></span></li><li id="fn:33"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">33.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Hosken, M., &amp; Gaultney, V. (2003, September 5). Guidelines for Writing System Support: Technical Details: Smart Rendering: Part 1. Retrieved September 20, 2020, from https://scripts.sil.org/cms/scripts/page.php?site_id=nrsi<a href="#fnref:33" rev="footnote">↩</a></span></li><li id="fn:34"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">34.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Unicode Consortium. (2002, October 28). A General Method for Rendering Combining Marks. Retrieved September 20, 2020, from http://www.unicode.org/notes/tn2/<a href="#fnref:34" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;在和朋友聊天时，突然无话可说，屏幕前的你该如何是好呢? 很多时候屏幕前的我们，都会想到发个表情，然后彼此心照不宣地沉默。如果你用的是windows 10的新版本，按下 &lt;code&gt;winkey + period&lt;/code&gt; （即windows图标和英文句点按钮），就会有如下的弹出框。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/character_set/image_1_1.png&quot; alt=&quot;image_1_1.png&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图1.1&lt;/p&gt;

&lt;p&gt;反复斟酌、几度纠结之后，你选择了这样一个表情：😤。将鼠标停留在这个表情上几秒，可以看到提示文字：“傲慢”。如果你用的是andriod、ios，在输入法中仔细搜寻，一定也可以发现这样一个表情。&lt;/p&gt;
&lt;p&gt;如果哪里都找不到，也没关系，直接将这个表情复制，粘贴到微信聊天框中，回车，成功地将这个表情发了出去。在对方沉默不语的时间里，你点开了微信对话框里的表情，却发现怎么也找不着这个傲慢的表情?！但是这个表情的确正确地显示了呀?这是怎么回事呢?“微信连不存在的表情都支持，太厉害了叭！”也许你会发出这样的感慨。也有可能你会嗤之以鼻：“不过是显示了一张图片而已”。不过，这真的是图片吗? 且听我缓缓道来。&lt;/p&gt;</summary>
    
    
    
    <category term="technology" scheme="https://blog.xuwei.fun/categories/technology/"/>
    
    <category term="cs" scheme="https://blog.xuwei.fun/categories/technology/cs/"/>
    
    
    <category term="character set" scheme="https://blog.xuwei.fun/tags/character-set/"/>
    
    <category term="encode" scheme="https://blog.xuwei.fun/tags/encode/"/>
    
    <category term="emoji" scheme="https://blog.xuwei.fun/tags/emoji/"/>
    
  </entry>
  
  <entry>
    <title>日语学习第十一讲</title>
    <link href="https://blog.xuwei.fun/2020/05/04/japanese12/"/>
    <id>https://blog.xuwei.fun/2020/05/04/japanese12/</id>
    <published>2020-05-04T10:08:23.000Z</published>
    <updated>2021-03-07T12:23:01.611Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇介绍了一些实用表达，这一篇聊几句语篇。<br>语篇是在读这本语法教程<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.">[1]</span></a></sup>中了解到的，想想也的确有道理，学习了音素、书写，记忆了单词，学会了语法，知道如何去表达一句话，总还有比一句话更广一点的语法概念的.<br>语篇的概念在该书<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="关春园, 徐宏亮. 多元化视角下的日语研究. 新华出版社, 2015.">[2]</span></a></sup>中也有描述:</p><blockquote><p>普通语言学认为，语言的结构单位自上而下分为五级，即: 词素、词、词组、句子以及大于句子的语言单位。语篇是大于句子的语言单位。在特定语境中，一个句子也可以视为语篇.</p></blockquote><p>专业的日语研究者想要看学术性的语篇研究，这篇”现代日语语篇研究”<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="杜静波. 现代日语语篇研究. Diss.">[3]</span></a></sup>的论文应该值得一看.</p><p>只不过，姑且认为语篇就是文章的一部分的话，那么分析文章、写文章的难点，其实不在于语言本身，无论是中文、英语还是日语，想要写出好文章，逻辑、思想才是最难的~</p><span id="more"></span><h2 id="1-语篇连贯"><a href="#1-语篇连贯" class="headerlink" title="1. 语篇连贯"></a>1. 语篇连贯</h2><p>语篇连贯即:</p><ul><li>语篇内部各部分在意义上是相互联系的</li><li>语篇的衔接形成的语义网络形成一个语义整体</li><li>语篇必须适合情景语境, 在语境中有适当的功能</li></ul><p>日语研究<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="关春园, 徐宏亮. 多元化视角下的日语研究. 新华出版社, 2015.">[2]</span></a></sup>中总结出的语篇连贯概念的四个基本特点有:</p><ul><li>整体性</li><li>分级性</li><li>连接性</li><li>功能性</li></ul><h2 id="2-语篇内部衔接的手段"><a href="#2-语篇内部衔接的手段" class="headerlink" title="2. 语篇内部衔接的手段"></a>2. 语篇内部衔接的手段</h2><p>一般来说有: 指示与词汇衔接、预设、替代与省略、会话含义、话语分析等…<br>学术性的东西，就不搬运太多了~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章提及了下语篇，至此，日语学习系列的主框架也就完结了。剩下的，就是练习、练习、再练习了，直到不用再思考语法这件事.</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">关春园, 徐宏亮. 多元化视角下的日语研究. 新华出版社, 2015.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">杜静波. 现代日语语篇研究. Diss.<a href="#fnref:3" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇介绍了一些实用表达，这一篇聊几句语篇。&lt;br&gt;语篇是在读这本语法教程&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;中了解到的，想想也的确有道理，学习了音素、书写，记忆了单词，学会了语法，知道如何去表达一句话，总还有比一句话更广一点的语法概念的.&lt;br&gt;语篇的概念在该书&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;关春园, 徐宏亮. 多元化视角下的日语研究. 新华出版社, 2015.
&quot;&gt;[2]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;中也有描述:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;普通语言学认为，语言的结构单位自上而下分为五级，即: 词素、词、词组、句子以及大于句子的语言单位。语篇是大于句子的语言单位。在特定语境中，一个句子也可以视为语篇.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;专业的日语研究者想要看学术性的语篇研究，这篇”现代日语语篇研究”&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;杜静波. 现代日语语篇研究. Diss.&quot;&gt;[3]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;的论文应该值得一看.&lt;/p&gt;
&lt;p&gt;只不过，姑且认为语篇就是文章的一部分的话，那么分析文章、写文章的难点，其实不在于语言本身，无论是中文、英语还是日语，想要写出好文章，逻辑、思想才是最难的~&lt;/p&gt;</summary>
    
    
    
    <category term="humanities" scheme="https://blog.xuwei.fun/categories/humanities/"/>
    
    <category term="languages" scheme="https://blog.xuwei.fun/categories/humanities/languages/"/>
    
    
    <category term="japanese" scheme="https://blog.xuwei.fun/tags/japanese/"/>
    
  </entry>
  
  <entry>
    <title>日语学习第十讲</title>
    <link href="https://blog.xuwei.fun/2020/05/03/japanese11/"/>
    <id>https://blog.xuwei.fun/2020/05/03/japanese11/</id>
    <published>2020-05-03T10:58:09.000Z</published>
    <updated>2021-03-07T12:23:07.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇总结了日语句子的分析和改造，这一章主要介绍一些实用表达。<br>实用表达，实际上也就是一些常用助词和动词的学习，包括他们常用的变形形式. 其实也可以说就是惯用语啦. 这一篇很多都是来源于Tae Kim的教程，Tae Kim的教程中语法系统和惯用表达揉在了一起，这里将其讲解惯用表达摘了出来.</p><span id="more"></span><h2 id="1-授受表达"><a href="#1-授受表达" class="headerlink" title="1. 授受表达"></a>1. 授受表达</h2><p>参考了这两篇文章: 文章一<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="“日语语法：授受动词.” 日语语法：授受动词 - 日语入门 - 丫丫日语, 4 Jan. 2015, http://www.yayajp.com/index.php?a=shows&catid=4&id=136.">[1]</span></a></sup>、文章二<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="KIM, TAE. “授受动词.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/favors.html.">[2]</span></a></sup><br>所谓授受表达，即授予和接受，由于在日语文化中，长幼尊卑是非常重要的元素，因此授予的主体不同时，表达也各不相同。</p><h3 id="1-1-やる、あげる、さしあげる"><a href="#1-1-やる、あげる、さしあげる" class="headerlink" title="1.1 やる、あげる、さしあげる"></a>1.1 やる、あげる、さしあげる</h3><p>表示说话者一方给另一方东西时，常用到这三个词.<br>其中:</p><ul><li>「やる」用于上对下或关系密切的同辈之间或者为动植物做某事</li><li>「あげる」用于对等关系</li><li>「さしあげる」是敬语动词，用于下对上，是一种自谦表达。</li></ul><p>例句:</p><ul><li>犬に餌をやった？</li><li>花に水をやる</li><li>あなたは時には妹さんにおこづかいをあげますか</li><li>彼の誕生日に贈り物をあげたいんnです</li><li>恩師に記念品をさしあげます</li></ul><h3 id="1-2-もらう、いただく"><a href="#1-2-もらう、いただく" class="headerlink" title="1.2 もらう、いただく"></a>1.2 もらう、いただく</h3><h4 id="1-2-1-独立使用"><a href="#1-2-1-独立使用" class="headerlink" title="1.2.1 独立使用"></a>1.2.1 独立使用</h4><p>作为一个独立的动词使用时，表示从别人那里接受或得到某东西。「いただく」表示从上司或者长辈处领受某物品时。</p><ul><li>手紙をもらう</li><li>この時計は田中さんからもらったのです</li><li>結構な品物をいただきます</li></ul><h4 id="1-2-2-助词使用"><a href="#1-2-2-助词使用" class="headerlink" title="1.2.2 助词使用"></a>1.2.2 助词使用</h4><p>接在动词连用形之后，以「～てもらう」、「～ていただく」的形式作为补助动词来使用。「～ていただく」是「～てもらう」的谦逊表达。</p><ul><li>私は日本の友達に日本料理を教えてもらった</li></ul><h3 id="1-3-くれる、くださる"><a href="#1-3-くれる、くださる" class="headerlink" title="1.3 くれる、くださる"></a>1.3 くれる、くださる</h3><h4 id="1-3-1-独立使用"><a href="#1-3-1-独立使用" class="headerlink" title="1.3.1 独立使用"></a>1.3.1 独立使用</h4><p>作为一个独立的动词使用时，表示别人给自己或给属于自己一方的人予东西。「くださる」是「くれる」的敬语形式。</p><ul><li>これは友達が妹にくれた本です。</li><li>先生は私に日本の地図をくださいました。</li></ul><h4 id="1-3-2-助词使用"><a href="#1-3-2-助词使用" class="headerlink" title="1.3.2 助词使用"></a>1.3.2 助词使用</h4><p>接在动词连用形之后，以「～てくれる」、「～てくださる」的形式作为补助动词来使用。</p><ul><li>課長がこの地図を貸してくださいました。</li></ul><h3 id="1-4-表达请求"><a href="#1-4-表达请求" class="headerlink" title="1.4 表达请求"></a>1.4 表达请求</h3><h4 id="1-4-1-请求对方帮忙做什么"><a href="#1-4-1-请求对方帮忙做什么" class="headerlink" title="1.4.1 请求对方帮忙做什么"></a>1.4.1 请求对方帮忙做什么</h4><p>用くれる、もらえる表示想请人帮忙，其中「もらえる」是「もらう」的可能型</p><ul><li>千円を貸してくれる？</li><li>千円を貸してもらえる？</li></ul><h4 id="1-4-2-请对方不要作什么"><a href="#1-4-2-请对方不要作什么" class="headerlink" title="1.4.2 请对方不要作什么"></a>1.4.2 请对方不要作什么</h4><p>只要把「で」加到用言否定式后面就可以了。</p><ul><li>全部食べないでくれますか</li><li>高い物を買わないでくれる</li></ul><h3 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h3><p>Tae Kim<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="KIM, TAE. “授受动词.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/favors.html.">[2]</span></a></sup>总结得很好: “从说话者的角度来看，所有给出的东西都是「向上」的，而别人给自己的东西则是「向下」的”，你也可以理解为对方总是高高在上的，说话者一方总是需要尽量表达谦卑，以表示尊敬对方，除非对方足够亲密或者非人等.<br>特别需要说明的是”说话人”，说话者在说出一句话时，总是代表了某一方，无论是他自己还是他人，他意指何方，那么那一方就是谦卑的一方.<br>最后再给个用了多种表达的一个例句:</p><ul><li>突然にかような奇怪な手紙を差し上げる非礼をお許し下さい。</li></ul><h2 id="2-比较表达"><a href="#2-比较表达" class="headerlink" title="2. 比较表达"></a>2. 比较表达</h2><p>又是Tae Kim<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Kim, Tae. “运用「方」和「よる」.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/comparison.html.">[3]</span></a></sup>，这个系列的教程写的确实太好，就拿来主义了，当然还有Wasabi的这个系列<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Admin, Wasabi. “Japanese Comparison: より, ...の方が, and ...で一番.” Wasabi, 24 Sept. 2016, https://www.wasabi-jpn.com/japanese-grammar/japanese-comparison/.">[4]</span></a></sup>，也非常棒.<br>表达比较首先需要有比较的对象: A和B. 当我们想对这两个对象进行比较时，从汉语的角度，我们会说:</p><ul><li>“A比B更…「述語」”</li><li>“和B相比, A更…「述語」”</li><li>“A这样&#x2F;A这一方&#x2F;A这种情况 比 B更…「述語」”</li><li>“和B相比, A这样&#x2F;A这一方&#x2F;A这种情况 更…「述語」”</li></ul><p>我们会发现这些句子中，无论怎么表达，A才是主语，B是作为被比较的一方存在的.<br>考虑到日语和汉语一样基本什么语法成分也都能省略，其实A、B两方也都有可能在表达中被省略. 基于此，我们来看下面的语法。</p><h3 id="2-1-「方」"><a href="#2-1-「方」" class="headerlink" title="2.1 「方」"></a>2.1 「方」</h3><p>「方」就是用来表达 “A这样&#x2F;A这一方&#x2F;A这种情况” 的 “这样&#x2F;这一方&#x2F;这种情况”，通常在句子中都是用「Aの方」，假设上下文明确的情况下，我们省略了B，给出一些例句.</p><ul><li>ボブの方が年上です</li><li>学生じゃない方がいいよ</li></ul><h3 id="2-2-「より」"><a href="#2-2-「より」" class="headerlink" title="2.2 「より」"></a>2.2 「より」</h3><p>相对的，「より」就是用来表达 “与B相比” 中的 “与…相比” 的意思. 同样的，假设可以省略A，给出一些例句.</p><ul><li>仕事がないよりましだよ</li></ul><p>如果把双方都用上，当然也可.</p><ul><li>辛からい方ほうが甘あまいのより好すき</li></ul><p>注:</p><blockquote><ol><li><strong>被「より」粘黏的单词不需要任何时态。</strong></li><li>可以将「より」与疑问词例如「誰」、「何」或「どこ」合用来表示与其他人或其他东西相比最高的意思</li></ol><ul><li>この仕事は誰よりも早くできます</li></ul></blockquote><h3 id="2-3-「と同じくらい」"><a href="#2-3-「と同じくらい」" class="headerlink" title="2.3 「と同じくらい」"></a>2.3 「と同じくらい」</h3><p>这个短语可以用来表达 “A就像和B一样” 这种意思</p><ul><li>小野さんは森さんと同じくらい林檎が好すきです</li></ul><h3 id="2-4-「一番」-x2F-「最も」"><a href="#2-4-「一番」-x2F-「最も」" class="headerlink" title="2.4 「一番」&#x2F;「最も」"></a>2.4 「一番」&#x2F;「最も」</h3><p>这个词用来表达最高级的意思，后者比前者更正式.</p><ul><li>中国は世界で一番人口が多いです</li><li>中国は世界で最も人口が多いです</li></ul><h3 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h3><p>比较的表达并不难，明确比较双方，使用关键的两个词: 「方」和「よる」，就很容易表达</p><h2 id="3-引用表达"><a href="#3-引用表达" class="headerlink" title="3. 引用表达"></a>3. 引用表达</h2><p>这其实是复合句的一种形式，但是引用他人的话这种复合句比较特殊，在之前的复合句中也没有提及，在此补充。<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Kim, Tae. “将关系从句作为宾语.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/actionclause.html.">[5]</span></a></sup></p><h3 id="3-1-直接引用"><a href="#3-1-直接引用" class="headerlink" title="3.1 直接引用"></a>3.1 直接引用</h3><p>直接引用别人的话，最特殊的点在于，虽然是复合的句子，但是被引用的话，其语法表达、时体态，全都保持原封不动就行了，在英语中，直接给引用的句子加个引号就行，中文多了个冒号，共同点就是都是靠标点符号来区分的，而在日语中，额外多了个助词「と」来表达这种情况.</p><ul><li>「今日は授業がない」と先生から聞いたんだけど</li></ul><h3 id="3-2-转述引用"><a href="#3-2-转述引用" class="headerlink" title="3.2 转述引用"></a>3.2 转述引用</h3><p>转述不是逐字逐句的引用，所以不用加引号。和动词「思う」一起用还能用来表达想法，意为”你认为…”，或者和动词「考える」一起用表达你在考虑某事。</p><ul><li>先生から今日は授業がないと聞いたんだけど</li><li>私は、アリスと言います</li><li>レーを食べようと思ったけど、食べる時間がなかった。</li></ul><p>注:</p><blockquote><p><strong>转述引用中，如果所引用的关系从句是名词或者な形容词形成的状态表示的话，必须显式加上表陈述的「だ」</strong></p><ul><li>これは何だと言いましたか。  &#x2F;&#x2F;（他）说这是什么?</li><li>何と言いましたか。          &#x2F;&#x2F;（他）说什么？</li></ul></blockquote><h3 id="3-3-口语版本"><a href="#3-3-口语版本" class="headerlink" title="3.3 口语版本"></a>3.3 口语版本</h3><p>「と」在口语中经常换成「って」来表达，用这种口语版本，可以省略句子的其他部分，靠上下文让对方理解.</p><ul><li>もうお金がないって。</li></ul><p>注: <strong>日常对话中，「って」 还可以用来谈论其他任何事情，大多数时候它是用来代替「は」以提出一个新的话题。</strong></p><ul><li>明日って、雨が降るんだって。</li></ul><h2 id="4-相似性表达"><a href="#4-相似性表达" class="headerlink" title="4. 相似性表达"></a>4. 相似性表达</h2><p>这个Tae Kim已经写得很好了，参考这篇文章<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Kim, Tae. “相似性或传闻.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/similarity.html.">[6]</span></a></sup>即可.<br>介绍了「よう（様）」、「みたい」、「～そう」、「～そうだ」、「～らしい」、「っぽい」六种表达方式，经常看动画其实读起来就有很熟悉的感觉，重点关注其中的活用变化，不赘述.</p><h2 id="5-被覆盖表达"><a href="#5-被覆盖表达" class="headerlink" title="5. 被覆盖表达"></a>5. 被覆盖表达</h2><p>参考Tae Kim的这一节<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Kim, Tae. “被某物所覆盖.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/covered.html.">[7]</span></a></sup>，主要介绍了「だらけ」、「まみれ」、「ずくめ」</p><h2 id="6-意向表达"><a href="#6-意向表达" class="headerlink" title="6. 意向表达"></a>6. 意向表达</h2><p>参考Tae Kim的这一节<sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Kim, Tae. “希望和建议.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/desire.html.">[8]</span></a></sup>和这一节<sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Kim, Tae. “高级意向形.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/volitional2.html.">[9]</span></a></sup>，主要介绍了「たい」、「欲しい」、意向形，以及一些高级用法</p><h2 id="7-常用句型"><a href="#7-常用句型" class="headerlink" title="7. 常用句型"></a>7. 常用句型</h2><p>还有一些其他常用句型，在此列举一些.</p><blockquote><ul><li>～以外の何ものでもない</li><li>～か[否(いな)]か</li><li>～限りだ</li><li>～かたがた</li><li>～ずじまいだ</li></ul></blockquote><h2 id="8-常用短语"><a href="#8-常用短语" class="headerlink" title="8. 常用短语"></a>8. 常用短语</h2><p>有一些常用短语，如果去分析它们的词源或者语法结构的话，会觉得很别扭，像背单词一样把它们背下来，能够做到熟练到张口就来就好了~</p><blockquote><ul><li>こちらこそ</li><li>よろしくお願いします</li><li>いらっしゃいませ</li><li>いただきます</li></ul></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章主要介绍了日语中的一些实用表达，下一篇简单说几句语篇的内容，整个系列也就结束了。</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">“日语语法：授受动词.” 日语语法：授受动词 - 日语入门 - 丫丫日语, 4 Jan. 2015, http://www.yayajp.com/index.php?a=shows&amp;catid=4&amp;id=136.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">KIM, TAE. “授受动词.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/favors.html.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Kim, Tae. “运用「方」和「よる」.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/comparison.html.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Admin, Wasabi. “Japanese Comparison: より, ...の方が, and ...で一番.” Wasabi, 24 Sept. 2016, https://www.wasabi-jpn.com/japanese-grammar/japanese-comparison/.<a href="#fnref:4" rev="footnote">↩</a></span></li><li id="fn:5"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Kim, Tae. “将关系从句作为宾语.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/actionclause.html.<a href="#fnref:5" rev="footnote">↩</a></span></li><li id="fn:6"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Kim, Tae. “相似性或传闻.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/similarity.html.<a href="#fnref:6" rev="footnote">↩</a></span></li><li id="fn:7"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Kim, Tae. “被某物所覆盖.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/covered.html.<a href="#fnref:7" rev="footnote">↩</a></span></li><li id="fn:8"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Kim, Tae. “希望和建议.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/desire.html.<a href="#fnref:8" rev="footnote">↩</a></span></li><li id="fn:9"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Kim, Tae. “高级意向形.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/volitional2.html.<a href="#fnref:9" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇总结了日语句子的分析和改造，这一章主要介绍一些实用表达。&lt;br&gt;实用表达，实际上也就是一些常用助词和动词的学习，包括他们常用的变形形式. 其实也可以说就是惯用语啦. 这一篇很多都是来源于Tae Kim的教程，Tae Kim的教程中语法系统和惯用表达揉在了一起，这里将其讲解惯用表达摘了出来.&lt;/p&gt;</summary>
    
    
    
    <category term="humanities" scheme="https://blog.xuwei.fun/categories/humanities/"/>
    
    <category term="languages" scheme="https://blog.xuwei.fun/categories/humanities/languages/"/>
    
    
    <category term="japanese" scheme="https://blog.xuwei.fun/tags/japanese/"/>
    
  </entry>
  
  <entry>
    <title>日语学习第九讲</title>
    <link href="https://blog.xuwei.fun/2020/05/02/japanese10/"/>
    <id>https://blog.xuwei.fun/2020/05/02/japanese10/</id>
    <published>2020-05-02T11:29:53.000Z</published>
    <updated>2021-03-07T12:23:13.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>距离上一次写日语学习系列已经快两年了，这两年间日语水平并没有什么长进，甚至还在倒退，但却总有一个心结，想要将这个系列完成。<br>好了，话不多说，其实之前的文章内容已经基本涵盖了日语基础语法的各个方面，而这篇文章打算说说日语中一个句子的分析和改造顺序，也算是对前面内容的一个总结。<br>日语的变形，主要体现在用言(动词&#x2F;形容词&#x2F;形容动词)、助动词上，这其中又属动词最为复杂。</p><span id="more"></span><h2 id="1-分析顺序"><a href="#1-分析顺序" class="headerlink" title="1. 分析顺序"></a>1. 分析顺序</h2><h3 id="1-1-说明"><a href="#1-1-说明" class="headerlink" title="1.1 说明"></a>1.1 说明</h3><p>给出一句日语，我们如何分析它用了哪些语法结构呢？</p><ol><li>如果这个句子是由多个句子复合而成的句子，首先将句子拆分，按照2至6的步骤分析单个从句，分析完从句后，将从句看作整个句子的一个成分，用符号代替，再按照2至6的步骤分析主句。需要注意的是，语气和敬意通常都是在主句中表达的，所以从句也不太可能需要分析2和3，还有一点是，如果从句本身是经过活用变形的(如假定型的活用)，先将这种变形去除.</li><li>在讲解语气的文章中提到了语气的种种分类，但实际中，语气大多还是通过特定词语、附加助词和语调的变化来表达的，因此即使一个句子用到了特定的语气，也不会在句子形式上有大的变化，最常见的也只是添加了句尾助词，可以先将助词去掉，简化句子，再做分析.</li><li>之后我们需要区分的是这句话是否是敬语形式，敬语的形式很容易看出来，因此如果用了敬语，那么先将这个句子还原为普通形式.</li><li>在还原为普通形式后，可以继续分析该句是否用到了特殊的”体”，如「ている」这种表示持续体的特殊形式，如果有的话，将特殊的”体”去掉，再次简化句子.</li><li>已经去掉了”体”的变形，之后就是分析简化的句子中，是否还用到了特殊的语态，如果用到了语态，就将其变化形式还原.</li><li>经过以上还原后，剩下的句子就只剩下时和极性的变形了，而时和极性我们通常都是放在一起记忆的，所以也可以一次性将其还原为基本型. 如果硬要分一个顺序，应该是先还原时，再还原极性.</li></ol><h3 id="1-2-示例"><a href="#1-2-示例" class="headerlink" title="1.2 示例"></a>1.2 示例</h3><p>写了这么多，给出几个句子我们分析一下。</p><ol><li><p>人は褒められれば嬉しいものなのです<br>这个句子首先是一个复合句，那么先分析从句: 「人は褒められれば」<br>由于用了假定型，将其还原为 「人は褒められる」<br>可以看出现在这种形式，是用了被动态的，将其还原为「人は褒める」<br>这样从句就分析完毕了，接着分析主句「嬉しいものなのです」<br>可以看出主句只用了敬语的一种比较特殊的形式「な+のです」，直接简化为「嬉しいものだ」</p></li><li><p>勉強をさせられている生徒に教えることは、ザルに水を注ぎ続けるようなもの！<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="“消えた記事？　「勉強する」「させられる」.” 勉強が楽しくなる塾, 5 June 2015, https://shou3.ti-da.net/e7625869.html.">[1]</span></a></sup><br>这个句子也是一个复句，可以当作包孕句处理吧。<br>首先分析前半句，「勉強をさせられている生徒に教えることは」，<br>去掉从句的连接词，句子可以简化为「勉強をさせられている生徒に教える」.<br>而这个从句中还有一个定语从句「勉強をさせられている」，这个句子用了「ている」的”体”表示一种持续的状态，简化后变为「勉強をさせられる」<br>而「勉強をさせられる」又是典型的被役态，还原成最基本的形式就是「勉強をする」<br>这样就可以理解前半句的意思了: “教一直被逼着学习的学生这种事”.<br>再分析后半句，「ザルに水を注ぎ続けるようなもの」，后半句没有用到特殊的变形，只是用了「ようなもの」这种惯用语，表示”像xx一样”</p></li></ol><h2 id="2-改造顺序"><a href="#2-改造顺序" class="headerlink" title="2. 改造顺序"></a>2. 改造顺序</h2><h3 id="2-1-说明"><a href="#2-1-说明" class="headerlink" title="2.1 说明"></a>2.1 说明</h3><p>给定一个句子，如何去分析已经了解了。那在实际语境下，假设我们从最基础的形式出发，需要以什么样的顺序来对这个句子进行变形，从而达到我们想要表达的意思呢？ 其实就是把分析的过程倒过来就行.</p><ol><li>先明确句子的极性和时</li><li>再思考这句话的主体、情态，是否需要用到特殊的语态</li><li>考虑语境下是否有特殊的时间状态，即是否要用到体的变形</li><li>是否需要用敬体，如果需要用敬体的时和体替换原有的时和体</li><li>如果需要特殊语气，就通过助词和语调调整</li><li>单句无法表达时，通过组合句子来表达</li></ol><h3 id="2-2-示例"><a href="#2-2-示例" class="headerlink" title="2.2 示例"></a>2.2 示例</h3><p>平时在看剧时，多分析看到的复杂句是怎么构成的，如果是自己来表达同样的意思，会怎么表达，这样就好啦，具体的示例就不给了，意义也不大~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分析的目的，和语文、英语的拆解句子结构一样，就是熟悉语法。<br>改造的目的，和语文、英语中的造句一样，就是正确熟练地表达。<br>等到不拘于此，不再需要思考如何去理解、如何去说，直接就能阅读和表达时，也就是真正掌握日语语法的时候.<br>本篇文章主要总结了日语中句子的分析和改造顺序，下一篇将介绍日语中的一些实用表达。</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">“消えた記事？　「勉強する」「させられる」.” 勉強が楽しくなる塾, 5 June 2015, https://shou3.ti-da.net/e7625869.html.<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;距离上一次写日语学习系列已经快两年了，这两年间日语水平并没有什么长进，甚至还在倒退，但却总有一个心结，想要将这个系列完成。&lt;br&gt;好了，话不多说，其实之前的文章内容已经基本涵盖了日语基础语法的各个方面，而这篇文章打算说说日语中一个句子的分析和改造顺序，也算是对前面内容的一个总结。&lt;br&gt;日语的变形，主要体现在用言(动词&amp;#x2F;形容词&amp;#x2F;形容动词)、助动词上，这其中又属动词最为复杂。&lt;/p&gt;</summary>
    
    
    
    <category term="humanities" scheme="https://blog.xuwei.fun/categories/humanities/"/>
    
    <category term="languages" scheme="https://blog.xuwei.fun/categories/humanities/languages/"/>
    
    
    <category term="japanese" scheme="https://blog.xuwei.fun/tags/japanese/"/>
    
  </entry>
  
  <entry>
    <title>Metaheuristic algorithm —— Concept</title>
    <link href="https://blog.xuwei.fun/2018/11/19/metaheuristicAlgorithm01/"/>
    <id>https://blog.xuwei.fun/2018/11/19/metaheuristicAlgorithm01/</id>
    <published>2018-11-19T13:21:09.000Z</published>
    <updated>2022-05-04T10:32:12.118Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Kino的课题常需要用到元启发式算法，就在此稍稍总结。<br>元启发式(metaheuristic)，很多时候也被称为智能优化(intelligent optimization)、现代启发式(Modern Heuristic)、智能计算(Intelligent Computation)、自然计算(Natural Computation)等，细分到具体算法有<em>遗传算法</em>、<em>粒子群算法</em>、<em>差分进化算法</em>、<em>蚁群算法</em>等。<br>**元启发式(metaheuristic)*<em>这个词本身可以拆成两部分来看，</em>元(meta)<em>和</em>启发式(heuristic)*，本文主要从这两方面来阐述元启发式的概念，后续文章再介绍各算法的原理、步骤、代码等。</p><span id="more"></span><h3 id="1-Meta"><a href="#1-Meta" class="headerlink" title="1. Meta"></a>1. Meta</h3><p>首先来解释<em>元(meta)<em>，程序员对这个词并不陌生，学习编程语言到某个阶段总会出来一个</em>元编程(metaprogramming)<em>技术，还会经常见到</em>元数据(metadata)<em>等。与顾名思义的一些概念相比，</em>元</em>的概念就有点晦涩了，初次遇见总是一脸诧异，难以理解。<br>感性上来看，<strong>metaXXX</strong>就是相比XXX来说更高级的一种概念&#x2F;理论，是研究超越XXX的存在，玄之又玄，不能理解不是你的错，就像形而上学(metaphysics)一样难以理解。<br>而不去探讨<strong>meta</strong>哲学性质的意义，只考虑其作为前缀(prefix)的情况，根据<em>meta</em>在Wikipedia的相应词条<a href="https://en.wikipedia.org/wiki/Meta">Meta</a><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. (2018, November 12). Meta. Retrieved from https://en.wikipedia.org/wiki/Meta">[1]</span></a></sup>，<strong>meta</strong>大多数时候可以理解为<strong>X about X</strong>，大致翻译为<strong>关于X的X</strong>，这里的<strong>关于</strong>在中文语境里通常用<strong>实现、描述、编写</strong>等动词代替。例如<strong>metadata</strong>就是<strong>data about data</strong>，即描述数据的数据，<strong>metaprogramming</strong>就是<strong>programming about programming</strong>，即<strong>编写程序的程序</strong>，诸如此类。如果有需要，这种概念还可以递归，即添加任意多的<strong>meta</strong>前缀，变身成为<strong>metametameta…<strong>。<br>在此基础上再去看</strong>meta</strong>的中文翻译<strong>元</strong>，就会发现这个翻译其实很巧妙。“元”汉语里有 起源&#x2F;开始(如元旦&#x2F;元始天尊)、基本&#x2F;根本(如元素&#x2F;元气&#x2F;元件) 的意思，完美地涵盖了meta想要表达的意思。然而<strong>元</strong>这个字很少单用，已经融合在最常见的一些词语中，所以当看到用<strong>元</strong>的前缀生造出的词语时，大多数人还是会难以理解。</p><p>这样说完感觉可能还是一片迷茫，就拿上面所说的<em>metadata</em>和<em>metaprogramming</em>作为示例来具体说明。</p><h4 id="1-1-Metadata"><a href="#1-1-Metadata" class="headerlink" title="1.1 Metadata"></a>1.1 Metadata</h4><p>关于Metadata，循序渐进地来举几个栗子。</p><ul><li>填写各类登记表时，通常需要填写姓名、性别、爱好等信息，那么我们填写的信息<strong>Kino、女、睡觉</strong>就是具体需要的data，而<strong>姓名、性别、爱好</strong>这种描述属性的文字，就属于metadata</li><li>对上面的内容稍加扩展，可以认为在进行关系型数据库设计时，我们建立的表结构就可以看作是metadata，而最终记录到表中的内容就是data，而对于K-V数据库来说，也不妨理解为Key是metadata，Value是data，JSON数据自然也可如此理解。</li><li>XML数据格式，XML(Extensible Markup Language)作为一种标记语言(Markup Language)，本就是Metadata一种表现形式。可以把XML的tag和property的key作为metadata，而把content和property的value作为data。HTML作为XML的亲戚，也可以如此理解，而至于HTML中的meta标签，又是将整个HTML文件看作data，这个meta标签里的内容就是用来描述这整个HTML的data也就是metadata了，比如<code>&lt;meta name=&quot;google-site-verification&quot; content=&quot;......&quot; /&gt;</code></li></ul><h4 id="1-2-Metaprogramming"><a href="#1-2-Metaprogramming" class="headerlink" title="1.2 Metaprogramming"></a>1.2 Metaprogramming</h4><p>按照上面的逻辑继续下去，变量声明就是描述变量的类型，难道就是metaprogramming了吗? 显然不会是这么简单的事情。<br>metaprogramming本身还是一个比较宏观的定义，对应到不同编程语言的具体实现上，又各有不同。下面简单叙述几种语言的metaprogramming机制，只要实际使用过其中一种，就不难理解了。</p><ul><li>C++：在C++中，可以利用模板实现元编程，在Effective C++中就有关于模板元编程的讨论</li><li>Java：在Java中，最为人熟知的反射，就可以用来实现元编程</li><li>Python：在Python中，如果一个类继承的不是object而是type，那么它就被成为**元类(metaclass)**，可以用元类来验证、注册子类，这也可以称为元编程</li></ul><p>从上面的例子中总结一下，元编程的实现手段各异，但大多是想解决这几个问题：</p><ul><li>设计中出现的相似内容太多，而这些重复内容存在于类层面，已经不能通过类的抽象来解决了，或者解决起来更为复杂(比如引入过于复杂的设计模式等)，这个时候需要更高一层的抽象来处理问题，解决这个问题的过程就可以称为元编程，Python中的metaclass就是典型的应用</li><li>面向对象程序的设计中，类的定义是在编译期就确定的，运行时动态生成的是实例，如果想要更高一层，在运行时动态生成类，那么这个实现过程就可以称为元编程，Java中的反射是典型的应用</li><li>…</li></ul><p>这也提醒了我们，在使用元编程前需要思考这个问题是否必须使用元编程、使用元编程能否简化实现过程，如果可以再尝试使用，否则就需要谨慎对待。<br><strong>元编程更大程度上是一个概念和思想，而不是一个具体方法和手段</strong></p><h4 id="1-3-Off-topic"><a href="#1-3-Off-topic" class="headerlink" title="1.3 Off topic"></a>1.3 Off topic</h4><p>思维一发散，意识就止不住到处游走，虽然离题万里，但且记录在此吧。</p><blockquote><p>突然想到导师最喜欢提的问题：“你这个效能评估的参数选取标准是什么呢？你怎么证明你这个效能评估的结果是可信的呢？毁伤评估的结果是怎么得来的呢？”似也有点元的意味，而且还可以无限递归，最终变成“评估评估…评估的结果”。如果该项工作有客观的评估标准，评估起来就相对简单可信，如果没有客观标准，靠专家标准或者自己选取的参数标准评估，可信性就大打折扣了，这个时候就可以再追问一句：“你怎么评价你选取的参数是可靠的呢？”。<br>今天刚好看到<a href="https://en.wikipedia.org/wiki/2019_redefinition_of_SI_base_units">新闻</a>，国际单位制的七个基本单位重新进行了定义，都改以宇宙的基本常数为基础定义<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. (2018, November 19). 2019 redefinition of SI base units. Retrieved from https://en.wikipedia.org/wiki/2019_redefinition_of_SI_base_units">[2]</span></a></sup>，于是突然想到，所谓度量系统<strong>Metric System</strong>里的单词<strong>metric</strong>，在词源上是不是和<strong>meta</strong>同源的，毕竟metric是用来衡量一切的标准，有种meta的意味在里面，不过事实到底如何，毫无词源学基础的Kino是无法确定了。<br>似乎更能理解那句不是爱因斯坦的名言“越简单越好，但不要过于简单”，过犹不及，繁简之间如何取舍是个永恒的问题，奥卡姆剃刀并不是万能的，更何况繁简也是相互转化的，就像有时想为了简洁不停地添加meta，最终却导致设计模式的臃肿，反而更复杂了。所谓大道至简，是对还是错，还未可知。但是爱因斯坦真的说过这句：“不应否认任何理论的终极目标都是尽可能让不可削减的基本元素变得更加简单且更少，但也不能放弃对任何一个单一经验数据的充分阐释。”这似乎是个比较恰当的说法。</p></blockquote><h3 id="2-Heuristic"><a href="#2-Heuristic" class="headerlink" title="2. Heuristic"></a>2. Heuristic</h3><p>维基百科也有启发式(Heuristic)的词条<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. (2014, May 25). Heuristic (computer science). Retrieved from https://en.wikipedia.org/wiki/Heuristic_(computer_science)">[3]</span></a></sup>，但实际的定义很简单。<br>启发式算法(Heuristic)算法和精确(Exact)算法相对应，它们的求解对象都是运筹优化类问题。区别在于，对于组合优化等非凸优化问题，用精确算法虽可求出其全局最优解，但计算效率低，有时还是NP问题，规模变大则无法在有限时间内求解，而利用启发式算法，可以提高计算效率，但求得的解可能只是较好的次优解，而不能达到全局最优解。<br>针对一个具体的优化问题，提出一个在计算效率和求解质量间取得均衡的具体算法，这个算法就叫做启发式算法。<br>例如需要求解\(y&#x3D;f(x)\)的最小值，用精确求解可以得到准确值为\(\min{y}&#x3D;22\)，耗时\(t&#x3D;10s\)，而使用启发式算法求得的结果是\(\min{y}&#x3D;22.22\)，但耗时只有\(t&#x3D;3s\)。<br>对于精确求解法，具体包括穷举法、分支定界法、割平面法、动态规划法等，而对于传统的启发式算法，包括构造型方法、局部搜索算法、松弛方法、解空间缩减法等。</p><h3 id="3-Metaheuristic"><a href="#3-Metaheuristic" class="headerlink" title="3. Metaheuristic"></a>3. Metaheuristic</h3><p>综合以上概念，将meta和heuristic结合得到的所谓元启发(metaheuristic)，理论定义上应该是<strong>heuristic about heuristic</strong>，但是这种<strong>实现启发式的启发式</strong>，还是很难直观理解。<br>先回到刚刚说的启发式算法，严格意义上的启发式，是针对某个特定优化问题的，只要是能够取得较好值的算法都可以叫做启发式算法，而元启发，就是给定一套流程&#x2F;方法论，对不同的问题，只要按照该流程设计，就能实现一个针对具体问题的启发式算法，因此把这个抽象的流程称之为元启发。换句话说，启发式是面向问题的(Problem Oriented)，而元启发是面向方法的(Method Oriented)。最常见的比如遗传算法，它只给定了一个标准流程：编码-&gt;初始化-&gt;选择-&gt;交叉-&gt;变异-&gt;…，而针对一个具体的优化问题，需要设计特定的编码方式、选择特定的适应度函数…，如此设计完成的具体算法才是启发式算法。<br><strong>但是、然而、不过</strong>，现在的论文中，大多数时候把元启发和启发式也混着用，在整篇文章中，通常只使用元启发式或启发式其中一个词，所以界限并没有那么分明了，元启发经常被称为启发式、启发式也经常被叫做元启发。<br>元启发也有维基百科页面，<a href="https://en.wikipedia.org/wiki/Metaheuristic">戳这里</a></p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>传统的任务分配、组合优化类等运筹学问题，大多都可以抽象成非凸优化的模型，也是NP问题，无法用传统方法求解，同时这些问题大多缺少或不能统计历史数据，因此也无法使用有监督机器学习等算法，这种情况下使用智能优化算法就非常合适。<br>针对这些运筹学问题，只要能够利用元启发算法的思想设计出合理的启发式算法，从而解决问题，其实就是一个很好的工作，但是现在的研究导向是发论文至上，研究智能优化算法的实验室也不例外，一切以发论文为导向，设计全新的元启发式算法实在困难，于是现在的论文大多还是Problem Oriented，通过说动听的故事阐述问题意义，再找出和之前的问题区别，比如多了一个小小的约束条件，这时就可以命名这个问题为XXXXX，以此说明自己定义了一个新问题，再抽象出该问题的数学模型(大多数时候只是在目标函数或约束条件上做些许修改，太简单没有做的意义，太复杂元启发也难以求解)，然后根据元启发算法的流程设计出完整的算法(在流程中的任一处加一点修改即可称之为改进)，编程实现算法做比较，得出结论;当然Method Oriented也还是有的，刚刚提到的一些小的改动、针对经典的TSP等做算法改进、超多目标优化问题的求解方法等。<br>总之一切为了论文，至于这些论文里的问题是否真的有意义、方法是否真的有创新，谁在乎呢。</p><h3 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h3><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. (2018, November 12). Meta. Retrieved from https://en.wikipedia.org/wiki/Meta<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. (2018, November 19). 2019 redefinition of SI base units. Retrieved from https://en.wikipedia.org/wiki/2019_redefinition_of_SI_base_units<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. (2014, May 25). Heuristic (computer science). Retrieved from https://en.wikipedia.org/wiki/Heuristic_(computer_science)<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. (2018, November 16). Metaheuristic. Retrieved from https://en.wikipedia.org/wiki/Metaheuristic<a href="#fnref:4" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Kino的课题常需要用到元启发式算法，就在此稍稍总结。&lt;br&gt;元启发式(metaheuristic)，很多时候也被称为智能优化(intelligent optimization)、现代启发式(Modern Heuristic)、智能计算(Intelligent Computation)、自然计算(Natural Computation)等，细分到具体算法有&lt;em&gt;遗传算法&lt;/em&gt;、&lt;em&gt;粒子群算法&lt;/em&gt;、&lt;em&gt;差分进化算法&lt;/em&gt;、&lt;em&gt;蚁群算法&lt;/em&gt;等。&lt;br&gt;**元启发式(metaheuristic)*&lt;em&gt;这个词本身可以拆成两部分来看，&lt;/em&gt;元(meta)&lt;em&gt;和&lt;/em&gt;启发式(heuristic)*，本文主要从这两方面来阐述元启发式的概念，后续文章再介绍各算法的原理、步骤、代码等。&lt;/p&gt;</summary>
    
    
    
    <category term="technology" scheme="https://blog.xuwei.fun/categories/technology/"/>
    
    <category term="cs" scheme="https://blog.xuwei.fun/categories/technology/cs/"/>
    
    
    <category term="algorithm" scheme="https://blog.xuwei.fun/tags/algorithm/"/>
    
    <category term="metaheuristic" scheme="https://blog.xuwei.fun/tags/metaheuristic/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Summary 01 — Cycle Detection</title>
    <link href="https://blog.xuwei.fun/2018/10/29/leetcode01/"/>
    <id>https://blog.xuwei.fun/2018/10/29/leetcode01/</id>
    <published>2018-10-29T08:33:40.000Z</published>
    <updated>2022-05-04T10:32:12.132Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前段时间忙于找工作，因而有正大光明的托词和导师说，11月之后再去做课题相关的事情，也就有了一段较为自由的时间。<br>其中诸多准备，免不了在Leetcode上刷题，虽然对于最终的结果来说没有帮助，但刷题过程中遇到了一些解决思路相似的问题，就依次将这些共性问题阐述一遍罢了。<br>本系列的第一篇介绍的是环检测问题，对应的维基百科页面有<a href="https://en.wikipedia.org/wiki/Cycle_detection">Cycle detection</a>。这类问题最常见的求解算法是Floyd Cycle Algorithm&#x2F;Floyd’s Tortoise and Hare，中文名通常为Floyd判圈算法&#x2F;龟兔赛跑算法。</p><span id="more"></span><h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>在计算机科学中，有一类问题称之为<strong>环检测问题</strong>，即对于一个由迭代函数(iterated function)值组成的序列，判断该序列是否有环及环出现的位置。<br>关于什么是迭代函数(iterated function)，严格定义可以查看<a href="https://en.wikipedia.org/wiki/Iterated_function">这里</a>，简单来说就是一个函数\(f\)，其定义域和值域都是集合\(X\)，那么对于某个自变量&#x2F;输入\(a\)，其因变量&#x2F;输出\(b\)也可以作为函数\(f\)的自变量&#x2F;输入，如此给定一个初始值\(x\)，将\(f\)的每一次输出作为下一次的输入，如此重复\(n\)次，就称作函数\(f\)的第\(n\)次迭代。</p><p>对于上述函数\(f\)，如果其集合\(X\)是有限的，那么对于序列:<br>$$<br>S &#x3D; \{x_0, x_1 &#x3D; f(x_0), x_2 &#x3D; f(x_1), \cdots, x_i &#x3D; f(x_{i-1}), \cdots\}<br>$$<br>那么必然会有两个位置\(i\)和\(j\)，且\(i &lt; j\)，其\(x_i &#x3D; x_j\)，一旦出现这种状况，显然在\(j\)位置之后，会重复从\(x_i\)到\(x_{j-1}\)的序列。所谓环检测问题，就是给定\(f\)和\(x_0\)，要求找到\(i\)和\(j\)。<br>当然对于无限集合\(X\)，是有可能不存在环的，这取决于\(f\)和\(x_0\)的共同作用。例如\(f&#x3D;x^2\)，如果\(X\)的范围是复数域，那么\(x_0&#x3D;0,1,-1,e^{\frac{2\pi{}mi}{n}}\)，则有环，否则没有。这里\(m\)的取值范围是整数，\(n\)的取值范围是\({1,2,3,4,6,7,8,12,14,15,16,24,28,30,31,32,\cdots}\)，就不仔细推导了，有兴趣的可以自行推导。</p><h3 id="2-求解算法"><a href="#2-求解算法" class="headerlink" title="2. 求解算法"></a>2. 求解算法</h3><p>对于上述问题，最常见的算法是Floyd’s Tortoise and Hare，其次还有Brent’s algorithm和Gosper’s algorithm等。<br>最直接的想法是记录每次迭代的值，建立一个hash表，这样可以在重复出现时直接定位，但是这种方法空间复杂度太高，故弃。</p><h4 id="2-1-Floyd’s-Tortoise-and-Hare"><a href="#2-1-Floyd’s-Tortoise-and-Hare" class="headerlink" title="2.1 Floyd’s Tortoise and Hare"></a>2.1 Floyd’s Tortoise and Hare</h4><p>对于问题描述中迭代函数组成的序列，如果存在环，那么对于\(i\ge{}\mu\)，则\(x_i &#x3D; x_{i+k\lambda}\)，其中\(\lambda\)是环的长度，\(\mu\)是环的第一个元素出现的位置。<br>基于此，可以推出，\(\exists{}i &#x3D; k\lambda\ge\mu\Longrightarrow{}x_i &#x3D; x_{2i}\)<br>因此，只要设定两个指针\(P1\)和\(P2\)，其中\(P2\)的步长是2，\(P1\)的步长是1，那么就可以找到两个指针指向值相等的位置，反过来说，即只要存在相等值，就存在环，此时可以得出\(\nu &#x3D; P2 - P1 &#x3D; P1 &#x3D; k\lambda\).<br>显然\(x_{\mu{}+\nu} &#x3D; x_{\mu}\)，即\(x_{\nu{}+\mu} &#x3D; x_{\mu}\)，故找到上述位置之后，\(P1\)仍保持原来位置，而\(P2\)放回序列最初位置，此时两个指针的推进步长都设置为1，两指针指向的值再次相等时，就是环开始的位置。找到环开始的位置后，向后迭代找到下一次重复位置，就可以得到环的长度\(\lambda\)了。<br><img src="/images/leetcode01_1.png" alt="img01"></p><h4 id="2-2-Brent’s-algorithm"><a href="#2-2-Brent’s-algorithm" class="headerlink" title="2.2 Brent’s algorithm"></a>2.2 Brent’s algorithm</h4><p>Floyd’s Tortoise and Hare算法很精巧，但是判断环存在、找到环开始位置和确定环长度需要分为三步，Brent’s algorithm效率更高，且只需要两步。<br>Brent’s algorithm也是利用了快慢两个指针的想法，但是它的想法是动态增加步长，加快搜索速度。<br>其基本意图是设立两个指针，尽快让第一个指针到达环内，然后第二个指针以步长1前进，再次相等时走过的步数正好是环的长度\(\lambda\)，具体做法如下。<br>首先，设定两个指针\(P1\)和\(P2\)，\(P2\)第一次先前进\(2^0&#x3D;1\)步，在前进的过程中若始终\(x_{P2}\ne{}x_{P1}\)，则令\(P1 &#x3D; P2\)，然后\(P2\)再前进\(2^1&#x3D;2\)，在前进的过程中若始终\(x_{P2}\ne{}x_{P1}\)，则令\(P1 &#x3D; P2\)，然后\(P2\)再前进\(2^2&#x3D;4\)……<br>如此，直到出现相等的位置，在出现相等位置之前，最后一次\(P2\)前进的步数就是环的长度\(\lambda\)。<br>此时，将\(P1\)放于序列开始位置0，\(P2\)放于\(\lambda\)位置，由于\(x_{\mu} &#x3D; x_{\lambda{}+\mu}\)，故只要让\(P1\)和\(P2\)依次向前前进，等到两者指向值相同时，\(P1\)的位置正好就是环的开始位置。<br><img src="/images/leetcode01_2.png" alt="img02"></p><p>Brent’s algorithm的效率比Floyd’s Tortoise and Hare要高，最差情况是Floyd’s Tortoise and Hare算法。其主要原因是，步长动态增加，速度提高，以及首次找到相同值时，记录了环的长度，而Floyd’s Tortoise and Hare算法首次找到相同值时，并不知道环的长度，只能知道环长度的整数倍。</p><h4 id="2-3-Gosper’s-algorithm"><a href="#2-3-Gosper’s-algorithm" class="headerlink" title="2.3 Gosper’s algorithm"></a>2.3 Gosper’s algorithm</h4><p>Gosper算法可以参考<a href="http://www.inwap.com/pdp10/hbaker/hakmem/flows.html">此处</a>，Kino还没有细看，就不细说了。</p><h3 id="3-相关练习"><a href="#3-相关练习" class="headerlink" title="3. 相关练习"></a>3. 相关练习</h3><p>Leetcode上有以下数题与此相关。</p><h4 id="3-1-Leetcode-141-Linked-List-Cycle"><a href="#3-1-Leetcode-141-Linked-List-Cycle" class="headerlink" title="3.1 Leetcode 141. Linked List Cycle"></a>3.1 Leetcode 141. Linked List Cycle</h4><p><a href="https://leetcode.com/problems/linked-list-cycle">Link</a></p><blockquote><p>Description: Given a linked list, determine if it has a cycle in it.</p></blockquote><p>Floyd’s Tortoise and Hare</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">bool</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ListNode<span class="token operator">*</span> tortoise <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> hare <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>hare <span class="token operator">&amp;&amp;</span> hare<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>tortoise <span class="token operator">==</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      tortoise <span class="token operator">=</span> tortoise<span class="token operator">-></span>next<span class="token punctuation">;</span>      hare <span class="token operator">=</span> hare<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Brent’s algorithm</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">bool</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> current_step <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> limited_step <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> tortoise <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> hare <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>hare <span class="token operator">&amp;&amp;</span> hare<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>tortoise <span class="token operator">==</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>current_step <span class="token operator">==</span> limited_step<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        current_step <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        limited_step <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>        tortoise <span class="token operator">=</span> hare<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      hare <span class="token operator">=</span> hare<span class="token operator">-></span>next<span class="token punctuation">;</span>      current_step<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-Leetcode-142-Linked-List-Cycle-II"><a href="#3-2-Leetcode-142-Linked-List-Cycle-II" class="headerlink" title="3.2 Leetcode 142. Linked List Cycle II"></a>3.2 Leetcode 142. Linked List Cycle II</h4><p><a href="https://leetcode.com/problems/linked-list-cycle-ii">Link</a></p><blockquote><p>Description: Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p></blockquote><p>Floyd’s Tortoise and Hare</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  ListNode <span class="token operator">*</span><span class="token function">detectCycle</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ListNode<span class="token operator">*</span> tortoise <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> hare <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tortoise <span class="token operator">!=</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>hare <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>hare<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      tortoise <span class="token operator">=</span> tortoise<span class="token operator">-></span>next<span class="token punctuation">;</span>      hare <span class="token operator">=</span> hare<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        tortoise <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tortoise <span class="token operator">!=</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      tortoise <span class="token operator">=</span> tortoise<span class="token operator">-></span>next<span class="token punctuation">;</span>      hare <span class="token operator">=</span> hare<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> tortoise<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Brent’s algorithm</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  ListNode <span class="token operator">*</span><span class="token function">detectCycle</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> current_step <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> limited_step <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> tortoise <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> hare <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tortoise <span class="token operator">!=</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>hare <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>hare<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>current_step <span class="token operator">==</span> limited_step<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        current_step <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        limited_step <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>        tortoise <span class="token operator">=</span> hare<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      hare <span class="token operator">=</span> hare<span class="token operator">-></span>next<span class="token punctuation">;</span>      current_step<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        tortoise <span class="token operator">=</span> head<span class="token punctuation">;</span>    hare <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>current_step<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      tortoise <span class="token operator">=</span> tortoise<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>tortoise <span class="token operator">!=</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      tortoise <span class="token operator">=</span> tortoise<span class="token operator">-></span>next<span class="token punctuation">;</span>      hare <span class="token operator">=</span> hare<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> tortoise<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-Leetcode-202-Happy-Number"><a href="#3-3-Leetcode-202-Happy-Number" class="headerlink" title="3.3 Leetcode 202. Happy Number"></a>3.3 Leetcode 202. Happy Number</h4><p><a href="https://leetcode.com/problems/happy-number/">Link</a></p><blockquote><p>Description: Write an algorithm to determine if a number is “happy”.<br>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p></blockquote><p>Floyd’s Tortoise and Hare</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">bool</span> <span class="token function">isHappy</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tortoise <span class="token operator">=</span> <span class="token function">nextNum</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hare <span class="token operator">=</span> <span class="token function">nextNum</span><span class="token punctuation">(</span><span class="token function">nextNum</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tortoise <span class="token operator">!=</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      tortoise <span class="token operator">=</span> <span class="token function">nextNum</span><span class="token punctuation">(</span>tortoise<span class="token punctuation">)</span><span class="token punctuation">;</span>      hare <span class="token operator">=</span> <span class="token function">nextNum</span><span class="token punctuation">(</span><span class="token function">nextNum</span><span class="token punctuation">(</span>hare<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> tortoise <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">nextNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> nxt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> digit <span class="token operator">=</span> n<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>      nxt <span class="token operator">+=</span> digit<span class="token operator">*</span>digit<span class="token punctuation">;</span>      n <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> nxt<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Brent’s algorithm</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">bool</span> <span class="token function">isHappy</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> current_step <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> limited_step <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> tortoise <span class="token operator">=</span> <span class="token function">nextNum</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hare <span class="token operator">=</span> <span class="token function">nextNum</span><span class="token punctuation">(</span><span class="token function">nextNum</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tortoise <span class="token operator">!=</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>current_step <span class="token operator">==</span> limited_step<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        current_step <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        limited_step <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>        tortoise <span class="token operator">=</span> hare<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      hare <span class="token operator">=</span> <span class="token function">nextNum</span><span class="token punctuation">(</span>hare<span class="token punctuation">)</span><span class="token punctuation">;</span>      current_step<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> tortoise <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">nextNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> nxt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> digit <span class="token operator">=</span> n<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>      nxt <span class="token operator">+=</span> digit<span class="token operator">*</span>digit<span class="token punctuation">;</span>      n <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> nxt<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-Leetcode-287-Find-the-Duplicate-Number"><a href="#3-4-Leetcode-287-Find-the-Duplicate-Number" class="headerlink" title="3.4 Leetcode 287. Find the Duplicate Number"></a>3.4 Leetcode 287. Find the Duplicate Number</h4><p><a href="https://leetcode.com/problems/find-the-duplicate-number">Link</a></p><blockquote><p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p></blockquote><p>Floyd’s Tortoise and Hare</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>  vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">int</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">this</span><span class="token operator">-></span>nums <span class="token operator">=</span> nums<span class="token punctuation">;</span>        <span class="token keyword">int</span> tortoise <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hare <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tortoise <span class="token operator">!=</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      tortoise <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>tortoise<span class="token punctuation">)</span><span class="token punctuation">;</span>      hare <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>hare<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        tortoise <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tortoise <span class="token operator">!=</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      tortoise <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>tortoise<span class="token punctuation">)</span><span class="token punctuation">;</span>      hare <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>hare<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> tortoise<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Brent’s algorithm</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>  vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">int</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">this</span><span class="token operator">-></span>nums <span class="token operator">=</span> nums<span class="token punctuation">;</span>        <span class="token keyword">int</span> current_step <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> limited_step <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> tortoise <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hare <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tortoise <span class="token operator">!=</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>current_step <span class="token operator">==</span> limited_step<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        current_step <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        limited_step <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>        tortoise <span class="token operator">=</span> hare<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      hare <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>hare<span class="token punctuation">)</span><span class="token punctuation">;</span>      current_step<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        tortoise <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    hare <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>current_step<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      tortoise <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>tortoise<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>tortoise <span class="token operator">!=</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      tortoise <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>tortoise<span class="token punctuation">)</span><span class="token punctuation">;</span>      hare <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>hare<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> tortoise<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-实际应用"><a href="#4-实际应用" class="headerlink" title="4. 实际应用"></a>4. 实际应用</h3><p>环检测(cycle detection)问题的实际应用有 <em>伪随机数生成器(pseudorandom number generators)强度的度量</em>，比如 <em>线性同余生成器(linear congruential generator)<em>，</em>加密哈希函数的冲突检测</em>，<em>细胞自动机(cellular automaton)的振荡周期配置</em>等</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;前段时间忙于找工作，因而有正大光明的托词和导师说，11月之后再去做课题相关的事情，也就有了一段较为自由的时间。&lt;br&gt;其中诸多准备，免不了在Leetcode上刷题，虽然对于最终的结果来说没有帮助，但刷题过程中遇到了一些解决思路相似的问题，就依次将这些共性问题阐述一遍罢了。&lt;br&gt;本系列的第一篇介绍的是环检测问题，对应的维基百科页面有&lt;a href=&quot;https://en.wikipedia.org/wiki/Cycle_detection&quot;&gt;Cycle detection&lt;/a&gt;。这类问题最常见的求解算法是Floyd Cycle Algorithm&amp;#x2F;Floyd’s Tortoise and Hare，中文名通常为Floyd判圈算法&amp;#x2F;龟兔赛跑算法。&lt;/p&gt;</summary>
    
    
    
    <category term="technology" scheme="https://blog.xuwei.fun/categories/technology/"/>
    
    <category term="cs" scheme="https://blog.xuwei.fun/categories/technology/cs/"/>
    
    
    <category term="algorithm" scheme="https://blog.xuwei.fun/tags/algorithm/"/>
    
    <category term="Cycle Detection" scheme="https://blog.xuwei.fun/tags/Cycle-Detection/"/>
    
    <category term="Floyd Cycle Algorithm" scheme="https://blog.xuwei.fun/tags/Floyd-Cycle-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>日语学习第八讲</title>
    <link href="https://blog.xuwei.fun/2018/06/29/japanese09/"/>
    <id>https://blog.xuwei.fun/2018/06/29/japanese09/</id>
    <published>2018-06-29T13:45:02.000Z</published>
    <updated>2021-03-07T12:23:17.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇介绍了敬语系统，这一章主要介绍日语中的复合句。日语中复句的相关概念在维基百科上有複文<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. 複文. Wikipedia, Wikimedia Foundation, 16 Apr. 2018, ja.wikipedia.org/wiki/複文.">[1]</span></a></sup>和節<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. 節 (文法). Wikipedia, Wikimedia Foundation, 18 Apr. 2018, ja.wikipedia.org/wiki/節_(文法).">[2]</span></a></sup>等。<br>区别简单句和复合句的主要标志是看它主谓关系的次数，主谓关系在语法上仅成立一次的句子叫做单句。反之，句中有两层或两层以上主谓关系的就可成为复合句。简单句与复合句的区别决不是以句子长短、单词多少而定。常常是句子很长的是简单句；句子很短，但具有两层以上主谓关系的都是复合句。</p><span id="more"></span><h2 id="1-分类和结构"><a href="#1-分类和结构" class="headerlink" title="1. 分类和结构"></a>1. 分类和结构</h2><p>根据日语复句<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="henry19931224. 日语复句. 百度文库, 16 Nov. 2011, wenku.baidu.com/view/bfe202d0b14e852458fb5731.html.">[3]</span></a></sup>、试论日语的复合句<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="谢秀忱. 试论日语的复合句. 现代外语 3(1982):33-38.">[4]</span></a></sup>和试论日语复句中从属句节的多层立体结构<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="吴春竹. 试论日语复句中从属句节的多层立体结构. 外语学刊 6(2008):49-52.">[5]</span></a></sup>等文献，可以对日语的分类和结构做出相应总结。<br>日语中存在着大量的复合句，其联系手段都是不相同的。根据联系手段的不同，大致可把日语复合句分为三大类。</p><h3 id="1-1-包孕句"><a href="#1-1-包孕句" class="headerlink" title="1.1 包孕句"></a>1.1 包孕句</h3><p>句子中的主谓宾补定状的某一个成份或者某几个成份是用主谓结构形成的，这样的句子叫包孕句。每一个顶替句子成份的主谓结构，称为从句，所以有“主语从句”“谓语从句”“宾语从句”“定语从句”“补语从句”等。其中“主语从句”“宾语从句”“补语从句”等常是主谓结构＋形式体言の构成。<br>形式体言“こと”“もの”“の”虽然本身没有固定的词意，但可充当句中各种成份，可把它们分别放在主语、宾语、补语等位置上，用来充当句中相应的各种不同的成分，不过必须在形式体言前面有其说明内容的句子或词组，相当于汉语的包孕句的结构。下面是不同的从句类型及相关示例，{}为各种从句内容。</p><h4 id="1-1-1-主语从句"><a href="#1-1-1-主语从句" class="headerlink" title="1.1.1 主语从句"></a>1.1.1 主语从句</h4><p>{魚が泳いでいるのが}見えます。<br>{向こうから来るのが}李さんです。<br>{この問題をどうやって解「と」くか}、分かりますか。<br>{私が買いたいのは}これです。</p><h4 id="1-1-2-谓语从句"><a href="#1-1-2-谓语从句" class="headerlink" title="1.1.2 谓语从句"></a>1.1.2 谓语从句</h4><p>即在句子中做述語成分<br>わが国は{土地が広いです}。<br>山田さんは{中国語が上手です}。<br>私は{息子「むすこ」が二人います}。</p><h4 id="1-1-3-宾语从句"><a href="#1-1-3-宾语从句" class="headerlink" title="1.1.3 宾语从句"></a>1.1.3 宾语从句</h4><p>即在句子中做对象语和目的语成分<br>電車が来たらまず{人が降りるのを}待ちます。<br>教師は{学生が一人一人本を読むのを}聞いています。<br>私は{王さんがどこへ行ったか}知りません。</p><h4 id="1-1-4-状语从句"><a href="#1-1-4-状语从句" class="headerlink" title="1.1.4 状语从句"></a>1.1.4 状语从句</h4><p>即在句子中做连用修饰语成分<br>今回の試験は{頭が痛くなるほど}難しいです。<br>私は{王さんが言ったとおり}やりましたが、成功しませんでした。<br>私たちの生活は{国が発展するにしたがって}良くなっていく。</p><h4 id="1-1-5-定语从句"><a href="#1-1-5-定语从句" class="headerlink" title="1.1.5 定语从句"></a>1.1.5 定语从句</h4><p>即在句子中做连体修饰语成分<br>{私が買いたい}辞書はこの日中辞典です。<br>ここは{私が勉強している}大学です。<br>{私が大学を卒業した}時、姉は25歳でした。</p><h4 id="1-1-6-补语从句"><a href="#1-1-6-补语从句" class="headerlink" title="1.1.6 补语从句"></a>1.1.6 补语从句</h4><p>私はその時まで{日本の映画館は全部指定席だと}思っていたのです。<br>私は{子供たちは立派な将来があると}考える。</p><h3 id="1-2-主从句"><a href="#1-2-主从句" class="headerlink" title="1.2 主从句"></a>1.2 主从句</h3><p>在这类复合句中，分句与分句之间的关系不是平等并列的，而是有主有从的。一般从句在前，独立于主句之外，主句在后，形成两层或两层以上的主谓关系，以各种接续助词、助动词、形式体言或用言的各种活用形、惯用形等作为联系手段，把前后两个不同的分句连结起来。根据不同意义的连接手段，可把主从句分为原因、结果、条件等从句。<br>主句和从句可以各有自己的主语，也可以通用一个主语；不同的主语时一般情况下，从句主语用が，主句主语用は（有违反此规则的时候）；通用主语的情况下，主语用は，其位置在句子的最前面。另外，接续助词与从句连接时，不同的接续助词有不同的活用形要求，请注意。</p><h4 id="1-2-1-状态从句"><a href="#1-2-1-状态从句" class="headerlink" title="1.2.1 状态从句"></a>1.2.1 状态从句</h4><p>表示同时发生的状态，“一边…一边…”<br>私は{テレビを見ながら}食事をする。<br>政府「せいふ」は{都市の発展を促進「そくしん」しつつ}、環境「かんきょう」も改善「かいぜん」していく。</p><h4 id="1-2-2-让步从句"><a href="#1-2-2-让步从句" class="headerlink" title="1.2.2 让步从句"></a>1.2.2 让步从句</h4><p>表示“虽然、即使、要是…就好了”等<br>{雨が降っているが}、訓練は中止しない。<br>{雨が降っても}、訓練は中止しない。<br>{君がもう少し早く来たらよかったのに}、バスはもう出てしまった。<br>{自分がいくらできるとも}、油断は大敵「たいてき」だ。<br>彼は{知っているくせに}、知らない振りをしている。</p><h4 id="1-2-3-条件从句"><a href="#1-2-3-条件从句" class="headerlink" title="1.2.3 条件从句"></a>1.2.3 条件从句</h4><p>日语中存在着一些用各种活用形加上不同的助词、助动词连接起来的条件从句。这种句子的意义，相当于汉语的“只要&#x2F;一旦&#x2F;如果&#x2F;假如…就…”。 归纳起来有四种表现方法。</p><h5 id="1-2-3-1-「と」"><a href="#1-2-3-1-「と」" class="headerlink" title="1.2.3.1 「と」"></a>1.2.3.1 「と」</h5><p>主要表示客观上的事实，客观性较强，表示两种动作相继发生。<br>使用条件语「と」的规则:</p><ul><li>把「と」加到条件后面，再跟上满足了条件会发生的结果: [ 条件 ] + と + [ 结果 ]</li><li>状态表示必须显式声明: [ 状态 ] + だと + [ 结果 ]</li></ul><p>例句:</p><ul><li>学校に行かないと友達と会えないよ</li><li>たくさん食べると太るよ</li></ul><h5 id="1-2-3-2「なら-ば-」"><a href="#1-2-3-2「なら-ば-」" class="headerlink" title="1.2.3.2「なら(ば)」"></a>1.2.3.2「なら(ば)」</h5><p>使用前提条件语「なら」的规则:</p><ul><li>把「なら」加在前提条件后面: [ 假设会发生的前提条件 ] + なら + [ 结果 ]</li><li>不能加表陈述的「だ」</li></ul><p>也可以用「ならば」替代「なら」，两者意思完全一样，但前者让人感觉更正式。<br>例句:</p><ul><li>みんなが行くなら私も行く</li><li>アリスさんが言うなら問題ないよ</li></ul><h5 id="1-2-3-3「ば」"><a href="#1-2-3-3「ば」" class="headerlink" title="1.2.3.3「ば」"></a>1.2.3.3「ば」</h5><p>这种条件语是通用的，它不预设条件，也没有蕴含的意思。<br>「ば」条件语的活用规则如下，注意名词和な形容词的活用规则其实是在活用「である」里面的动词「ある」<br>「ば」的活用规则:</p><ul><li>对动词: [ 一类え形活用词根 ] + 「ば」，即把动词最后假名从 &#x2F;u&#x2F; 段改为同行 &#x2F;e&#x2F; 段，再加上「ば」</li><li>对い形容词以及「ない」结尾的未然形: 把最后的「い」换成「ければ」</li><li>对名词和な形容词: 加「であれば」</li></ul><p>例句:</p><ul><li>友達に会えれば、買い物に行きます</li><li>お金があればいいね</li><li>楽しければ、私も行く</li><li>楽しくなければ、私も行かない</li><li>食べなければ病気になるよ</li></ul><h5 id="1-2-3-4-「たら-ば-」完成时条件语"><a href="#1-2-3-4-「たら-ば-」完成时条件语" class="headerlink" title="1.2.3.4 「たら(ば)」完成时条件语"></a>1.2.3.4 「たら(ば)」完成时条件语</h5><p>「たら」的重点在于满足条件后发生的事，主要用来表示对事物完了的假定。<br>「たら」的活用规则:</p><ul><li>首先把名词、形容词或动词活用为过去形，再加上「ら」</li></ul><p>也可以用「たらば」替代「たら」，类似「ならば」，二者意思完全相同，只是前者感觉更正式。<br>例句:</p><ul><li>暇だったら、遊びに行くよ</li><li>学生だったら、学生割引で買えます</li></ul><h5 id="1-2-3-5-「もし」"><a href="#1-2-3-5-「もし」" class="headerlink" title="1.2.3.5 「もし」"></a>1.2.3.5 「もし」</h5><p>「もし」是条件句中常用的一个副词，用来增加一种对假设条件不确定的语气，可以翻译为“要是，如果”。但是必须搭配上述四种条件句的形式使用，「もし」本身是不能构成条件句的语法形式的。<br>例句:</p><ul><li>もしよかったら、映画を観に行きますか？</li><li>もし時間がないなら、明日でもいいよ。</li></ul><h4 id="1-2-4-原因从句"><a href="#1-2-4-原因从句" class="headerlink" title="1.2.4 原因从句"></a>1.2.4 原因从句</h4><p>表示“因为、由于”等原因，一般有以下联系手段。</p><h5 id="1-2-4-1-から"><a href="#1-2-4-1-から" class="headerlink" title="1.2.4.1 から"></a>1.2.4.1 から</h5><p>[ 原因 ] + から + [ 结果 ]<br>如果原因是字典形名词或な形容词，后面必须加「だ」来显式的表示它是原因，即「( 名词 &#x2F; な形容词 ) だから」。如果忘了在「から」前面加表陈述的「だ」的话，听起来「から」就是「从…」的意思了。<br>如果是在用丁宁语的话，应该把「から」当成普通名词，在后面加「です」。<br>有上下文的时候，原因和结果都可以省略掉。省略原因的时候，必须加上表陈述的「だ」或「です」，所以经常会听到「だから」<br>例句:</p><ul><li>時間がなかったからです</li><li>うん、時間がなかったから</li><li>だからパーティーに行かなかったの？</li><li>天気が悪いから、山へ行くのは止めましょう。</li></ul><h5 id="1-2-4-2-ので"><a href="#1-2-4-2-ので" class="headerlink" title="1.2.4.2 ので"></a>1.2.4.2 ので</h5><p>「ので」基本上跟「から」可以互换使用，除了一些微妙的区别。「から」显式的表明了前面的句子是原因，而「ので」这仅仅是把两个句子连了起来，然后把前一个句子变味了解释的口吻。<br>「ので」听起来口气更柔和，也更礼貌，所以在解释做了失礼之事的原因的时候，人们更倾向于用它而非「から」。<br>总体上来看，在说话者的意志和能动性更强时，使用「から」；如果需要较恭敬的表达，或者是表达判断的理由时，用「ので」较多。<br><strong>「の」前面如果是字典形名词或者な形容词的话，一定要加「な」</strong><br>解释口气的「の」可以简写成「ん」，说话的时候「ので」也可以改成「んで」，因为这样可以省略音节 &#x2F; o &#x2F; 的发音，形成连读。<br>例句:</p><ul><li>時間がなかったのでパーティーに行かなかった</li><li>ちょっと忙しいので、そろそろ失礼します</li><li>私は学生なので、お金がないんです</li><li>なので、友達に会う時間がない</li><li>天気が悪いので、山へ行くのは止めました。</li></ul><h5 id="1-2-4-3-ため"><a href="#1-2-4-3-ため" class="headerlink" title="1.2.4.3 ため"></a>1.2.4.3 ため</h5><p>写成汉字应该是「為」。与「から」和「ので」相比，「ため」是一个能够与对方拉开距离的词语。<br>「から」和「ので」都是传达说话者的意志和判断的表达方式，与此相比，「ため」多用于描述发生的事情。<br>正因为此，「ため」多在新闻和论文中被使用，它能给对方一种严肃感，让人觉得情报的来源很可靠。<br>例句:</p><ul><li>大雨のため一時通行止めとなった</li><li>王さんは風邪を引いたために、会社を休みました。</li></ul><h5 id="1-2-4-4-によって"><a href="#1-2-4-4-によって" class="headerlink" title="1.2.4.4 によって"></a>1.2.4.4 によって</h5><p>「に」在表示对象、方向时通常接的是名词，但在表示目的、目标时既可接名词也可接动词简体。<br>「よって」原形为「よる」，可写做「寄る」、「拠る」、「因る」等，「～によって」這個句型在日文中是常见的，用法很多，主要有以下几种:</p><ul><li>名词 + によって(により&#x2F;によりまして&#x2F;による) + 名词。依据前者的条件及选项取舍的不同，結果、情況、作法也会随之改变的句型表现。「AによってB」A只能置入名詞，作为条件依据，而随着A不同B也會改变，中文意思为「依A的不同而B」。</li><li>名词 + によって(により&#x2F;による) + 名词。表示事物、情況成立或发生的理由以及原因之句型表现。「AによってB」A只能置入名词，表理由、原因，因为A而造成B的场面</li><li>名词 + によって(により&#x2F;による) + 名词。表示方法、手段之句型表现。「AによってB」A只能置入名词，表方法、手段，意即透过或运用A作为手段而来做B，有些人会将它与「～によると」的传闻来源表现搞混，需要注意。</li><li>名词 + によって(により&#x2F;による) + 名词。表示消息、传闻的来源或出处的句型表现。「Aによると～」A只能置入名词，表示消息、传闻的来源，「によると」的結尾常与「～そうだ」、「～ということだ」一起使用。</li></ul><p>例句:</p><ul><li>日本人との付き合いによって日本語の会話を練習している</li></ul><h5 id="1-2-4-5-おかげで"><a href="#1-2-4-5-おかげで" class="headerlink" title="1.2.4.5 おかげで"></a>1.2.4.5 おかげで</h5><p>可以译为“托…的福”。<br>规则:</p><ul><li>名词 + 「の」 + 「おかげで」</li><li>形容词基本形 + 「おかげで」</li><li>形容动词 + 「な」 + 「おかげで」</li><li>动词基本形 + 「おかげで」</li></ul><p>例句:</p><ul><li>あなたのおかげで助かりました</li></ul><h5 id="1-2-4-6-せいで"><a href="#1-2-4-6-せいで" class="headerlink" title="1.2.4.6 せいで"></a>1.2.4.6 せいで</h5><p>名词「せい」的汉字是「所为」，「で」是「です」的中顿形式，可以翻译成“是…的所为”，一般是带来不好的结果。<br>规则:</p><ul><li>名词 + 「の」 + 「せいで」</li><li>形容词基本形 + 「せいで」</li><li>形容动词 + 「な」 + 「せいで」</li><li>动词基本形 + 「せいで」</li></ul><p>例句:</p><ul><li>わがままな母親のせいで、彼女は結婚が遅れた</li></ul><h4 id="1-2-5-结果从句"><a href="#1-2-5-结果从句" class="headerlink" title="1.2.5 结果从句"></a>1.2.5 结果从句</h4><p>日语中存在着这样一种句子结构: “…は…が…からです(だ、である)”。相当于汉语的“事情之所以这样，是由于…的缘故”。表示一种因果关系。<br>结果从句的“から”是作为副助词和“だ、です、である”结合起来，接在动词的连体形后面做谓语，先强调其结果，后叙述原因。<br>也可以用另一种惯用型“…のは…が…ためです”来表示</p><p>例句:</p><ul><li>任务を完成するてとができなかったのは计画が十分ではなかったからだ</li></ul><h4 id="1-2-6-目的从句"><a href="#1-2-6-目的从句" class="headerlink" title="1.2.6 目的从句"></a>1.2.6 目的从句</h4><p>表示行为的目的。<br>一般常用惯用形”…ために”、”…には”，是表示达到某种目的的句子。但这种类型的句子，一般做目的状语较多，因为前后两个事项都属于一个主体——主语，如有两层主谓关系者，可看作目的从句。</p><p>例句:</p><ul><li>私たちは{健康「けんこう」を保つために}、毎日運動をします。</li><li>{友人が早く快復「かいふく」するように}心から祈「いの」ります。</li><li>私は{朝起きるのに}目覚「めざ」ましが必要です。</li></ul><h4 id="1-2-6-方式从句"><a href="#1-2-6-方式从句" class="headerlink" title="1.2.6 方式从句"></a>1.2.6 方式从句</h4><p>日语中有这样一种惯用型: “…ように”、”…とおりに”，而这两者的前后都是一个句子形式，又具有两层主谓关系，我们可以把它统称为方式从句。</p><p>例句:</p><ul><li>レーニンが教えたように、共产党はプロレタリアートの前卫である</li></ul><p>除了表示方式以外，也可以利用 “…ように” 这一形式表示祈使目的。<br>例句:</p><ul><li>みなが気持よく休めるように、私にちが部屋をきれいに掃除している</li></ul><h4 id="1-2-7-时间从句"><a href="#1-2-7-时间从句" class="headerlink" title="1.2.7 时间从句"></a>1.2.7 时间从句</h4><p>在日常生活的语言中，经常会遇到这类惯用型: “…たびに”、”…ときに”、”…あとで(に)”、”…てから”、”…うちに” 。这一类型句子的共同点是都表示时间的含义，相当于汉语的“每逢…声”、“在…时候”、“在…之后” 、“在…之中”的意义。试论日语的复合句[4]中认为，如果在这一类惯用型前后有两个句子，又具有两层主谓关系，和前述其他副句一样，把它作为复合句看待，将其归属为时间从句。 </p><p>例句:</p><ul><li>吴先生の家に行くたびに、彼はいろいろなおもしろい話を聞かせてくれます</li><li>父からはじめ手紙が届いた時、私はとてもうれしかった</li><li>私が外出しためとで(に)、陈君があそびに来た</li><li>彼らは大学に入学してから、まだ日があさい</li></ul><h3 id="1-3-并列句"><a href="#1-3-并列句" class="headerlink" title="1.3 并列句"></a>1.3 并列句</h3><p>句中有2层以上的主谓结构，虽然这些主谓结构有某种语法形式上的联系，但是在意义上是并列的，互不依赖的。并列句中的各自的句子称作分句，前面的分句是以中顿形式，或者用接续助词て、し、が等，以及某些惯用形与后面的分句连接。<br>例句：<br>①“河水很清澈，河底看得很清楚。”<br>川の水が綺麗で、川の底「そこ」がよく見えます。（用形容动词的中顿）<br>②“客人来了，就在那里喝茶；孩子回来了，那个房间就变成了学习室。”<br>人が来ればそこでお茶を飲んで、子供が学校から帰ってくると、その部屋は勉強部屋になる。（用接续助词て）<br>③“有的人显得高兴，有的人显得伤心。”<br>嬉しそうな顔をする人もいるし、悲「かな」しそうな顔をする人もいます。（用接续助词し）<br>④ “即有山，又有海。”<br>山もあれば、海もある。（用惯用形……も……ば、……も）<br>⑤“冬天过去，春天来了”<br>冬が過ぎ、春が来た</p><h3 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h3><p>日语的复合句按照基本结构可以分为三大类，包孕句、主从句和并列句，这三者的从属度是逐渐递减的。在实际中，还可以将三者混合起来，构成更为复杂的句式结构。</p><h2 id="2-复句中的时体"><a href="#2-复句中的时体" class="headerlink" title="2. 复句中的时体"></a>2. 复句中的时体</h2><p>日语复句中的时体和英语不同，没有十分标准的研究，相应文章也较少，论日语从句的时态变化<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="林泽清, and 耿铁珍. 论日语从句的时态变化. 日语学习与研究 2(2000):16-21.">[6]</span></a></sup>和浅析日语复句中的“时”和“体”<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="辛宇峰. 浅析日语复句中的“时”和“体”. 外语与翻译 4(2014):54-55.">[7]</span></a></sup>有一些介绍。<br>一般来说，日语复句的时体的基本原则是，主句的时体，以说话者的视角为基准，从句的时体以主句的时间为基准，但也会考虑到说话者的视角。<br>一般来说:</p><ul><li>如果从句的动作、状态发生在主句之前，那么通常从句都是过去时，有时也反映在体上例如完成体等</li><li>如果从句的动作、状态和主句同时发生，那么通常从句的时和主句相同</li><li>如果从句的动作、状态发生在主句之后，此时考虑主句的时间和整个句子在说话者中的视角，若主句是现在时，那从句也就用现在时即可，若主句是过去时，需要考虑从句的动作、状态在说话者视角中是否仍处于过去时，是则也用过去时，否则现在时。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章主要介绍了日语复合句的内容，下一篇将尝试综合考虑已有内容归纳日语句子的改造顺序。</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. 複文. Wikipedia, Wikimedia Foundation, 16 Apr. 2018, ja.wikipedia.org/wiki/複文.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. 節 (文法). Wikipedia, Wikimedia Foundation, 18 Apr. 2018, ja.wikipedia.org/wiki/節_(文法).<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">henry19931224. 日语复句. 百度文库, 16 Nov. 2011, wenku.baidu.com/view/bfe202d0b14e852458fb5731.html.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">谢秀忱. 试论日语的复合句. 现代外语 3(1982):33-38.<a href="#fnref:4" rev="footnote">↩</a></span></li><li id="fn:5"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">吴春竹. 试论日语复句中从属句节的多层立体结构. 外语学刊 6(2008):49-52.<a href="#fnref:5" rev="footnote">↩</a></span></li><li id="fn:6"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">林泽清, and 耿铁珍. 论日语从句的时态变化. 日语学习与研究 2(2000):16-21.<a href="#fnref:6" rev="footnote">↩</a></span></li><li id="fn:7"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">辛宇峰. 浅析日语复句中的“时”和“体”. 外语与翻译 4(2014):54-55.<a href="#fnref:7" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇介绍了敬语系统，这一章主要介绍日语中的复合句。日语中复句的相关概念在维基百科上有複文&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;Wikipedians. 複文. Wikipedia, Wikimedia Foundation, 16 Apr. 2018, ja.wikipedia.org/wiki/複文.
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;和節&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;Wikipedians. 節 (文法). Wikipedia, Wikimedia Foundation, 18 Apr. 2018, ja.wikipedia.org/wiki/節_(文法).
&quot;&gt;[2]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;等。&lt;br&gt;区别简单句和复合句的主要标志是看它主谓关系的次数，主谓关系在语法上仅成立一次的句子叫做单句。反之，句中有两层或两层以上主谓关系的就可成为复合句。简单句与复合句的区别决不是以句子长短、单词多少而定。常常是句子很长的是简单句；句子很短，但具有两层以上主谓关系的都是复合句。&lt;/p&gt;</summary>
    
    
    
    <category term="humanities" scheme="https://blog.xuwei.fun/categories/humanities/"/>
    
    <category term="languages" scheme="https://blog.xuwei.fun/categories/humanities/languages/"/>
    
    
    <category term="japanese" scheme="https://blog.xuwei.fun/tags/japanese/"/>
    
  </entry>
  
  <entry>
    <title>日语学习第七讲</title>
    <link href="https://blog.xuwei.fun/2018/06/18/japanese08/"/>
    <id>https://blog.xuwei.fun/2018/06/18/japanese08/</id>
    <published>2018-06-18T12:00:35.000Z</published>
    <updated>2021-03-07T12:23:26.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章介绍了日语的语气，这一篇Kino将要讲解日语的敬语系统。<br>日语敬语是日语中用于表达敬意的表达方式，用来表示说话者、说话对象、话中人物之间的社会阶级、亲疏等关系。出席使用日语的许多社交场合必须使用敬语，以表达适当的身份关系和礼貌。<br>现代日语敬语的分类研究<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="姚莉萍. 现代日语敬语的分类研究. 日语学习与研究 3(1996):6-10.">[1]</span></a></sup> 中介绍了几种日语的分类方式，包括以敬意形式进行的分类和待遇表现进行的分类。而现在常用的分类方法还是按照前者进行分类的，一般可分为丁宁语（礼貌语）、尊敬语和谦逊语三大类。有时丁宁语也可以再另分出郑重语和美化语两类敬语。说话人会根据谈话内容以及对象，而使用相关的辞汇或是动词变形。<br>根据相关参考资料如日语语法指南<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Tae, and Pizza. 敬语和动词词根. 日语语法指南 | Learn Japanese, http://res.wokanxing.info/jpgramma/polite.html.">[2]</span></a></sup>、维基百科<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. 日語敬語. Wikipedia, Wikimedia Foundation, 7 June 2018, https://zh.wikipedia.org/wiki/日語敬語.">[3]</span></a></sup>、日语敬语<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="三吉礼子. 日语敬语. 北京大学出版社, 2006.">[4]</span></a></sup>、试论日语敬语现象<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="桑凤平. 试论日语敬语现象. 外语与外语教学 8(2001):21-23.">[5]</span></a></sup>、日语敬语的常见错误分析<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="杜玲莉. 日语敬语的常见错误分析. 东北亚外语研究 6(2004):7-8.">[6]</span></a></sup>对敬体的几大类进行介绍。</p><span id="more"></span><h2 id="1-丁宁语"><a href="#1-丁宁语" class="headerlink" title="1. 丁宁语"></a>1. 丁宁语</h2><p>表示客气、礼貌、文雅、郑重的语言，叫丁宁语，丁宁语是代表说话人礼貌的敬语，代表尊重听话对象。<br>丁宁语反映在句尾，根据句尾的不同，有以下两种情况:</p><h3 id="1-1-句尾是动词"><a href="#1-1-句尾是动词" class="headerlink" title="1.1 句尾是动词"></a>1.1 句尾是动词</h3><p>将动词变为一类い形活用词根，之后再句尾加「ます」。<br>此外，考虑极性和时轴，「ます」形有相应变化:</p><ul><li>肯定现在: 「ます」</li><li>否定现在: 「ません」</li><li>肯定过去: 「ました」</li><li>否定过去: 「ませんでした」</li></ul><h3 id="1-2-句尾是名词、形容词"><a href="#1-2-句尾是名词、形容词" class="headerlink" title="1.2 句尾是名词、形容词"></a>1.2 句尾是名词、形容词</h3><p>句尾若是有「だ」，将「だ」除去，之后在句尾加「です」。<br>考虑极性和时轴，「です」形也有不同变化。</p><p align="center">表1 い形容词结尾</p><table><thead><tr><th align="center"></th><th align="center">口语</th><th align="center">丁宁语</th></tr></thead><tbody><tr><td align="center">肯定现在</td><td align="center">かわいい</td><td align="center">かわいいです</td></tr><tr><td align="center">否定现在</td><td align="center">かわいくない</td><td align="center">かわいくないです</td></tr><tr><td align="center">肯定过去</td><td align="center">かわいかった</td><td align="center">かわいかったです</td></tr><tr><td align="center">否定过去</td><td align="center">かわいくなかった</td><td align="center">かわいくなかったです</td></tr></tbody></table><p align="center">表2 な形容词或名词结尾</p><table><thead><tr><th align="center"></th><th align="center">口语</th><th align="center">丁宁语</th></tr></thead><tbody><tr><td align="center">肯定现在</td><td align="center">静か（だ）</td><td align="center">静かです</td></tr><tr><td align="center">否定现在</td><td align="center">静かじゃない</td><td align="center">静かじゃないです</td></tr><tr><td align="center">肯定过去</td><td align="center">静かだった</td><td align="center"><strong>静かでした</strong></td></tr><tr><td align="center">否定过去</td><td align="center">静かじゃなかった</td><td align="center">静かじゃなかったです</td></tr></tbody></table><h3 id="1-3-否定情况下的另一种表达"><a href="#1-3-否定情况下的另一种表达" class="headerlink" title="1.3 否定情况下的另一种表达"></a>1.3 否定情况下的另一种表达</h3><p>上述否定形的丁宁语不是「官方」的正确活用。更加「正确」的活用形应该是把「ないです」部分改为「ありません」，理由是动词「ある」的丁宁未然形不是「ないです」而是「ありません」。所以，「かわいくない」应该写作「かわいくありません」，「静かじゃない」则应该是「静かじゃありません」。<br>实际上，这种所谓的「官方」用法听起来太过呆板和正式。在日常对话中，大家基本用的都是上述介绍的形式，虽然在用丁宁语写作时应该用更加正式的活用形，但日常说话几乎用不到。</p><h3 id="1-4-特殊词"><a href="#1-4-特殊词" class="headerlink" title="1.4 特殊词"></a>1.4 特殊词</h3><p>有一些词汇的丁宁语版本完全是另外一个词汇，主要有:</p><ul><li>「ある」: 「ござる」，「ござる」总是以「ます」形出现，即「ございます」</li><li>「です」: 「でございます」，其实就是「でござる」的「ます」形活用，从「である」而来，字面意思是「以…的形式存在」</li><li>「いい」: 「よろしい」是更正式的表达方式</li><li>「さん」: 「様」，这个后缀在口语里面不常用到，即使在说尊敬语或谦逊语。不过，写信的时候一般会用到它，即使对方是熟人也一样。还有服务行业例如收银员或服务员通常会称呼客户为「お客様」。当然了，皇族和神灵一定是会用「様」的，例如「神様」</li></ul><h2 id="2-尊敬语"><a href="#2-尊敬语" class="headerlink" title="2. 尊敬语"></a>2. 尊敬语</h2><p>对他人的行为、状态及有关事物等表示敬意的语言，尊敬语代表尊敬话题里施行行为的人。<br>话题提及社会阶级较高的人，例如长辈、师长、上司、客户等，便会使用尊敬语。提及说话人自身的时候，不用尊敬语。</p><h3 id="2-1-动词的尊敬语形式"><a href="#2-1-动词的尊敬语形式" class="headerlink" title="2.1 动词的尊敬语形式"></a>2.1 动词的尊敬语形式</h3><p>对动作主体表示尊敬有四个方法。</p><h4 id="2-1-1-用特殊尊敬语动词"><a href="#2-1-1-用特殊尊敬语动词" class="headerlink" title="2.1.1 用特殊尊敬语动词"></a>2.1.1 用特殊尊敬语动词</h4><p>和一般用语完全不一样。例如动词「する」，尊敬语动词则为「なさる」。动词「話す」，尊敬语动词则为「おっしゃる」。</p><h4 id="2-1-2-使用「お……になる」句型"><a href="#2-1-2-使用「お……になる」句型" class="headerlink" title="2.1.2 使用「お……になる」句型"></a>2.1.2 使用「お……になる」句型</h4><p>一般没有相应尊敬语的动词，也可以换成「一类い形活用词根」，前加「お」、后加「になる」，使之成为尊敬语。例如「読む」，尊敬语可以用「お読みになる」。<br>也可以用「下さい」替代「になる」。当你想用尊敬语动词请别人做什么的时候，这种表达很有用。</p><h4 id="2-1-3-使用「お……です」句型"><a href="#2-1-3-使用「お……です」句型" class="headerlink" title="2.1.3 使用「お……です」句型"></a>2.1.3 使用「お……です」句型</h4><p>将一般动词换成「一类い形活用词根」，前加「お」、后加「です」，也成为尊敬语。例如「読む」，尊敬语可以用「お読みです」。</p><h4 id="2-1-4-动词被动形也可以当尊敬语使用"><a href="#2-1-4-动词被动形也可以当尊敬语使用" class="headerlink" title="2.1.4 动词被动形也可以当尊敬语使用"></a>2.1.4 动词被动形也可以当尊敬语使用</h4><p>「読みましたか」，尊敬语亦可说成「読まれましたか」</p><h3 id="2-2-名词形容词的尊敬语形式"><a href="#2-2-名词形容词的尊敬语形式" class="headerlink" title="2.2 名词形容词的尊敬语形式"></a>2.2 名词形容词的尊敬语形式</h3><p>除了动词外，部分名词也有尊敬语。例如「その人」，尊敬语是「その方」。一般情况下，大部分名词前可以加上词头表示尊敬。<br>日语固有词即訓読み单词通常加「お」，例如「お顔」、「お話」，汉字词即音読み单词通常加「ご」，例如「ご冗談」、「ご両親」。如写成汉字，两者均作「御」。<br>部分形容词也加上「お」、「ご」做成尊敬语，规则与名词类似。例如「お忙しい」、「お元気」、「ご満足」。</p><h2 id="3-谦逊语"><a href="#3-谦逊语" class="headerlink" title="3. 谦逊语"></a>3. 谦逊语</h2><p>谦逊语又称谦让语，说话人通过谦虚地讲述、甚至是贬低话题中行为主体的动作，用来对接受行为的人表示尊敬。行为主体是说话人自身的时候，也可以用谦让语。</p><h2 id="3-1-用特殊谦逊语动词"><a href="#3-1-用特殊谦逊语动词" class="headerlink" title="3.1 用特殊谦逊语动词"></a>3.1 用特殊谦逊语动词</h2><p>谦逊语可以用特殊词汇来表示，例如自有一套动词。一般例如动词「する」，谦让语动词则为「いたす」。一般动词「話す」，谦让语动词则为「申す」。</p><h2 id="3-2-使用「お-x2F-ご……する-x2F-いたす-x2F-申し上げる」句型"><a href="#3-2-使用「お-x2F-ご……する-x2F-いたす-x2F-申し上げる」句型" class="headerlink" title="3.2 使用「お&#x2F;ご……する&#x2F;いたす&#x2F;申し上げる」句型"></a>3.2 使用「お&#x2F;ご……する&#x2F;いたす&#x2F;申し上げる」句型</h2><p>另外，如果没有相对的谦逊动词，可以使用「お&#x2F;ご……する&#x2F;いたす&#x2F;申し上げる」句型。一般动词换成「一类い形活用词根」，前加「お」或「ご」、后加「する」或「いたす」，便可成为谦让语，「いたす」实际上又是「する」的谦逊语。例如「持つ」，谦让语可以说成「お持ちする」，「案内する」谦让语可以说成「ご案内する」。</p><h2 id="3-3-注意事项"><a href="#3-3-注意事项" class="headerlink" title="3.3 注意事项"></a>3.3 注意事项</h2><p>部分谦逊语已经成为固有短语，例如「いただく」本为「もらう」的谦逊语，但这个动词的丁宁语体「いただきます」则是吃喝之前所说的寒暄话。</p><h2 id="4-特殊动词"><a href="#4-特殊动词" class="headerlink" title="4. 特殊动词"></a>4. 特殊动词</h2><h3 id="4-1-特殊尊敬语和特殊谦逊语"><a href="#4-1-特殊尊敬语和特殊谦逊语" class="headerlink" title="4.1 特殊尊敬语和特殊谦逊语"></a>4.1 特殊尊敬语和特殊谦逊语</h3><p>这里列出一些尊敬语和谦逊语与一般用语完全不一样的动词。</p><p align="center">表3 尊敬语和谦逊语</p><table><thead><tr><th align="center">字典形</th><th align="center">尊敬语</th><th align="center">谦逊语</th></tr></thead><tbody><tr><td align="center">する</td><td align="center">なさる</td><td align="center">致す</td></tr><tr><td align="center">行く</td><td align="center">いらっしゃる／おいでになる</td><td align="center">参る</td></tr><tr><td align="center">来る</td><td align="center">いらっしゃる／おいでになる</td><td align="center">参る</td></tr><tr><td align="center">いる</td><td align="center">いらっしゃる／おいでになる</td><td align="center">おる</td></tr><tr><td align="center">見る</td><td align="center">ご覧になる</td><td align="center">拝見する</td></tr><tr><td align="center">聞く</td><td align="center">－</td><td align="center">伺う</td></tr><tr><td align="center">言う</td><td align="center">おっしゃる</td><td align="center">申す／申し上げる</td></tr><tr><td align="center">あげる</td><td align="center">－</td><td align="center">差し上げる</td></tr><tr><td align="center">くれる</td><td align="center">下さる</td><td align="center">－</td></tr><tr><td align="center">もらう</td><td align="center">－</td><td align="center">いただく</td></tr><tr><td align="center">食べる</td><td align="center">召し上がる</td><td align="center">いただく</td></tr><tr><td align="center">飲む</td><td align="center">召し上がる</td><td align="center">いただく</td></tr><tr><td align="center">知っている</td><td align="center">ご存知（です）</td><td align="center">存じる</td></tr></tbody></table><h3 id="4-2-特殊尊敬语和特殊谦逊语的活用规则"><a href="#4-2-特殊尊敬语和特殊谦逊语的活用规则" class="headerlink" title="4.2 特殊尊敬语和特殊谦逊语的活用规则"></a>4.2 特殊尊敬语和特殊谦逊语的活用规则</h3><p>在使用特殊尊敬语和特殊谦逊语基础之上，还可以对这些动词使用丁宁语的规则。<br>但这些动词很多并不遵循普通的ます活用规则，包括「なさる」、「いらっしゃる」、「おっしゃる」、「下さる」和「ござる」。对这些东西要改写为ます形的话，不是像う动词那样把「る」变为「り」，而是要变为「い」。除了ます形，它们的其他活用规则跟普通う动词一样。</p><p align="center">表4 尊敬语和谦逊语的特殊活用规则</p><table><thead><tr><th align="center">字典形</th><th align="center">ます形</th><th align="center">过去ます形</th><th align="center">未然ます形</th><th align="center">过去未然ます形</th></tr></thead><tbody><tr><td align="center">なさる</td><td align="center">なさいます</td><td align="center">なさいました</td><td align="center">なさいません</td><td align="center">なさいませんでした</td></tr><tr><td align="center">いらっしゃる</td><td align="center">いらっしゃいます</td><td align="center">いらっしゃいました</td><td align="center">いらっしゃいません</td><td align="center">いらっしゃいませんでした</td></tr><tr><td align="center">おっしゃる</td><td align="center">おっしゃいます</td><td align="center">おっしゃいました</td><td align="center">おっしゃいません</td><td align="center">おっしゃいませんでした</td></tr><tr><td align="center">下さる</td><td align="center">下さいます</td><td align="center">下さいました</td><td align="center">下さいません</td><td align="center">下さいませんでした</td></tr><tr><td align="center">ござる</td><td align="center">ございます</td><td align="center">ございました</td><td align="center">ございません</td><td align="center">ございませんでした</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇主要讲解了日语的敬语系统，下一篇将讲解日语中的复合句。</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">姚莉萍. 现代日语敬语的分类研究. 日语学习与研究 3(1996):6-10.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Tae, and Pizza. 敬语和动词词根. 日语语法指南 | Learn Japanese, http://res.wokanxing.info/jpgramma/polite.html.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. 日語敬語. Wikipedia, Wikimedia Foundation, 7 June 2018, https://zh.wikipedia.org/wiki/日語敬語.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">三吉礼子. 日语敬语. 北京大学出版社, 2006.<a href="#fnref:4" rev="footnote">↩</a></span></li><li id="fn:5"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">桑凤平. 试论日语敬语现象. 外语与外语教学 8(2001):21-23.<a href="#fnref:5" rev="footnote">↩</a></span></li><li id="fn:6"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">杜玲莉. 日语敬语的常见错误分析. 东北亚外语研究 6(2004):7-8.<a href="#fnref:6" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇文章介绍了日语的语气，这一篇Kino将要讲解日语的敬语系统。&lt;br&gt;日语敬语是日语中用于表达敬意的表达方式，用来表示说话者、说话对象、话中人物之间的社会阶级、亲疏等关系。出席使用日语的许多社交场合必须使用敬语，以表达适当的身份关系和礼貌。&lt;br&gt;现代日语敬语的分类研究&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;姚莉萍. 现代日语敬语的分类研究. 日语学习与研究 3(1996):6-10.
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt; 中介绍了几种日语的分类方式，包括以敬意形式进行的分类和待遇表现进行的分类。而现在常用的分类方法还是按照前者进行分类的，一般可分为丁宁语（礼貌语）、尊敬语和谦逊语三大类。有时丁宁语也可以再另分出郑重语和美化语两类敬语。说话人会根据谈话内容以及对象，而使用相关的辞汇或是动词变形。&lt;br&gt;根据相关参考资料如日语语法指南&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;Tae, and Pizza. 敬语和动词词根. 日语语法指南 | Learn Japanese, http://res.wokanxing.info/jpgramma/polite.html.
&quot;&gt;[2]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;、维基百科&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;Wikipedians. 日語敬語. Wikipedia, Wikimedia Foundation, 7 June 2018, https://zh.wikipedia.org/wiki/日語敬語.
&quot;&gt;[3]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;、日语敬语&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;三吉礼子. 日语敬语. 北京大学出版社, 2006.
&quot;&gt;[4]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;、试论日语敬语现象&lt;sup id=&quot;fnref:5&quot;&gt;&lt;a href=&quot;#fn:5&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;桑凤平. 试论日语敬语现象. 外语与外语教学 8(2001):21-23.
&quot;&gt;[5]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;、日语敬语的常见错误分析&lt;sup id=&quot;fnref:6&quot;&gt;&lt;a href=&quot;#fn:6&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;杜玲莉. 日语敬语的常见错误分析. 东北亚外语研究 6(2004):7-8.
&quot;&gt;[6]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;对敬体的几大类进行介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="humanities" scheme="https://blog.xuwei.fun/categories/humanities/"/>
    
    <category term="languages" scheme="https://blog.xuwei.fun/categories/humanities/languages/"/>
    
    
    <category term="japanese" scheme="https://blog.xuwei.fun/tags/japanese/"/>
    
  </entry>
  
</feed>
