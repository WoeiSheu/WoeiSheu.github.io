<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>霁月荒馆</title>
  
  <subtitle>以今日之我与昨日之我战</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.xuwei.fun/"/>
  <updated>2020-09-20T05:22:57.873Z</updated>
  <id>https://blog.xuwei.fun/</id>
  
  <author>
    <name>Kino</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读书笔记十二</title>
    <link href="https://blog.xuwei.fun/2020/09/13/reading12/"/>
    <id>https://blog.xuwei.fun/2020/09/13/reading12/</id>
    <published>2020-09-13T15:51:33.000Z</published>
    <updated>2020-09-20T05:22:57.873Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>《罪与罚》杂谈.<br>转录Kino在微信读书上关于《罪与罚》的笔记.</p><a id="more"></a><h3 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h3><p>看完全书后，过了一遍陀思妥耶夫斯基的生平，发现小说有时还是需要结合作者经历来看。陀神在写“罪与罚”之前，一直患有癫痫-&gt;父亲去世-&gt;当过中尉-&gt;因革命被捕-&gt;被流放到西伯利亚-&gt;服役期间开始笃信宗教-&gt;妻兄逝世-&gt;赌博欠债，而在“罪与罚”中，这一切都呈现了出来，且大多是赋在了主人公拉斯柯尔尼科夫身上。将陀神的经历代入作品后，我甚至会怀疑陀神是否也曾想过自己是更特别的存在，想通过自己的手代替法律执行正义，也会怀疑陀神是否也曾想过自杀。</p><p>既然小说中的原型来源于自己的生活，那么多精彩的心理描写也就不难理解了，我相信小说中的主人公有多挣扎，陀神也就有过同样的挣扎，经历越多的读者也就越能产生共鸣(产生共鸣越多的读者大概越不幸吧)。能将如此多的心理活动生动准确地描写出来，能将读者的注意力迅速抓住，能将种种情节在主线中穿插自如，能将前期的处处伏笔完整收回，虽然陀神以心理描写而闻名，却显然不限于此。</p><p>“罪与罚”中最让我印象深刻的是描写斯维德里盖洛夫寻求自杀的那几节，让我莫名相信自杀者的心里状态就该如此，于反复中坚定，再无被挽救的可能。</p><p>陀神很残忍，“罪与罚”中的底层人大多都被生活蹂躏，没有一丝光明的希望；陀神也心系幻想，拉斯柯尔尼科夫一家获得了一笔意外的财富，拉斯柯尔尼科夫还有个一直愿意帮助他的朋友拉祖米欣，拉斯柯尔尼科夫的心灵最终在服役期间获得了救赎。拉斯柯尔尼科夫虽然经历坎坷，不幸中也还有着诸多幸运。</p><p>可是，书中那些已经死去的小人物呢？他们再也没有未来了。那些住在公寓套间里的底层穷人呢？他们还有希望吗？</p><p>群租在大城市套间中的我们又如何在一片压力中寻求自由与救赎呢？该怎样寻找自己的生存价值呢？不过还好，我们还算幸运，既然还有这一小片幸运的云，就努力生活下去吧，暂且不做无谓的思辩，就如陀神所说: “生活已经代替了思辨，因此思想意识必须完全另起炉灶。”</p><h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h3><p> <a href="https://book.douban.com/subject/30438790/" target="_blank" rel="noopener">罪与罚</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;《罪与罚》杂谈.&lt;br&gt;转录Kino在微信读书上关于《罪与罚》的笔记.&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="https://blog.xuwei.fun/categories/life/"/>
    
      <category term="reading" scheme="https://blog.xuwei.fun/categories/life/reading/"/>
    
    
      <category term="陀思妥耶夫斯基" scheme="https://blog.xuwei.fun/tags/%E9%99%80%E6%80%9D%E5%A6%A5%E8%80%B6%E5%A4%AB%E6%96%AF%E5%9F%BA/"/>
    
      <category term="罪与罚" scheme="https://blog.xuwei.fun/tags/%E7%BD%AA%E4%B8%8E%E7%BD%9A/"/>
    
  </entry>
  
  <entry>
    <title>从一个Emoji字符说起</title>
    <link href="https://blog.xuwei.fun/2020/09/07/characterset/"/>
    <id>https://blog.xuwei.fun/2020/09/07/characterset/</id>
    <published>2020-09-07T14:22:22.000Z</published>
    <updated>2020-09-20T07:08:22.382Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在和朋友聊天时，突然无话可说，屏幕前的你该如何是好呢? 很多时候屏幕前的我们，都会想到发个表情，然后彼此心照不宣地沉默。如果你用的是windows 10的新版本，按下 <code>winkey + period</code> （即windows图标和英文句点按钮），就会有如下的弹出框。</p><p><img src="/images/character_set/image_1_1.png" alt="image_1_1.png"></p><p align="center">图1.1</p><p>反复斟酌、几度纠结之后，你选择了这样一个表情：😤。将鼠标停留在这个表情上几秒，可以看到提示文字：“傲慢”。如果你用的是andriod、ios，在输入法中仔细搜寻，一定也可以发现这样一个表情。</p><p>如果哪里都找不到，也没关系，直接将这个表情复制，粘贴到微信聊天框中，回车，成功地将这个表情发了出去。在对方沉默不语的时间里，你点开了微信对话框里的表情，却发现怎么也找不着这个傲慢的表情?！但是这个表情的确正确地显示了呀?这是怎么回事呢?“微信连不存在的表情都支持，太厉害了叭！”也许你会发出这样的感慨。也有可能你会嗤之以鼻：“不过是显示了一张图片而已”。不过，这真的是图片吗? 且听我缓缓道来。<br><a id="more"></a></p><p><a name="29Um5"></a></p><h2 id="二、Emoji的前世今生"><a href="#二、Emoji的前世今生" class="headerlink" title="二、Emoji的前世今生"></a>二、Emoji的前世今生</h2><p>上面的表情，其实是个emoji字符。emoji这个词，互联网时代的人当然都不会陌生。但是刚刚的表述，又说它是表情，又说它是字符，似乎将表情和字符混为一谈了，这是怎么回事呢?其实准确来说，emoji应该称为“表情字符”，其本质还是一个字符，只是个用来象征表情的字符罢了。一个emoji字符，和一个字母、一个汉字，没有什么本质的不同，或者想象一下，对于一个不懂汉字的人来说，汉字看起来也许也就像一个个表情呢~ 当然啦，表情也可以用图片表示，至于计算机上区别字符和图片的根本因素是什么，稍后再论，这里先说下emoji出现的历史。</p><p>Emoji用日语表示就是「絵文字」，平假名为「えもじ」，1999年，由株式会社NTT DoCoMo的iMode服务团队开发，在12×12格的方格纸上以简单的图案描绘出人的各种表情及生活事物，再把它们对应成字符数据，NTT公司的这一发明意在提供一种在画面尺寸和通信量受限的情况下，让用户们通过视觉顺利进行交流的方式。</p><p>Emoji诞生之初，就得到了年轻人的追捧，到了2004年左右它已经被全日本所接受。2009年emoji被收录进Unicode编码，成为了世界标准的通用字符，2012年智能手机中加入了对emoji的支持，2014年提出了“世界Emoji日(World Emoji Day)”，2015年《牛津词典》的年度词汇是😂，2016年起，纽约现代美术馆（MoMA）将NTT DoCoMo的iMode中提供的第一版176个emoji纳入永久收藏。如今，emoji已经成为了iOS、Android、Mac OS及Windows中默认支持的表情符号。</p><blockquote><p>关于世界Emoji日，是在每年的7月17日，因为提出了World Emoji Day, 因此各个平台上表示日历的Emoji也都展示的是7月17日，📅<a href="https://emojipedia.org/calendar/" target="_blank" rel="noopener">Calendar Emoji</a>，还有一个专门的World Emoji Day网站：<a href="https://worldemojiday.com/" target="_blank" rel="noopener">点我试试</a></p></blockquote><p>iMode的开发负责人是栗田穣崇(Shigetaka Kurita)，也是他设计了最早版本的emoji，引用一句栗田先生后来的回忆分析：</p><blockquote><p>“在以数字信息互动为主的手机世界中，仅用文字来沟通的话，容易产生理解上的误会，因此有必要附加上感情语气，因此emoji的登场有其符合时代刚需的必然性”</p></blockquote><p><img src="/images/character_set/image_2_1.jpg" alt="image_2_1.jpg"></p><p align="center">图2.1</p><p>一个没有接触过编程的人，应该也能看懂上面大部分的内容，唯一可能有疑惑的大概是： <strong>2009年emoji被收录进Unicode编码</strong>。这个Unicode编码又是个什么玩意呢? 开头说的计算机上区别字符和图片的根本因素是什么呢?</p><h2 id="三、字符集和字符编码"><a href="#三、字符集和字符编码" class="headerlink" title="三、字符集和字符编码"></a>三、字符集和字符编码</h2><p>说起字符集，首先不得不扯一些语言学和计算机的基础。</p><h3 id="3-1-语言学简介"><a href="#3-1-语言学简介" class="headerlink" title="3.1 语言学简介"></a>3.1 语言学简介</h3><p>每个文化都有自己的语言体系，每种语言大致都会包含 发音系统、书写系统、语法系统 等几大方面。发音系统的基本单位是音素(phoneme)，书写系统的基本单位是字素(grapheme)，语法系统的基本单位是语素(morpheme)。</p><ul><li>小学时，我们学的声母表、韵母表，里面的每个音，就可以认为是普通话的音素，英文的音标就可以当作是英文的音素。</li><li>中文的字素有两种看法了，一种认为汉字可以按照偏旁部首的拆分，每个偏旁部首作为一个字素，比如“河”，可以认为是“氵”和“可”两个字素（李玲璞先生就持这种看法），另一种看法则认为每个汉字作为一个字素。而在英文等拉丁语族中, 字素其实并没有特别确切的概念, 不同的论文中可能使用的是不同的概念.</li><li>中文的语素通常就是对应着单个汉字，而英文的语素可能就会复杂点，例如really, 可以看作是 real 和 -ly 两个语素，这种区别主要是因为中文不通过词语形变来表达语法，只通过语法词汇来区分语法，比如“的”、“了”等。</li></ul><p>当然啦，回到字符集上来，这里面与字符集关系最密切的显然是字素，那么文字、字符、字素，这些有区别吗?为什么要发明这么多名词?！太难了…</p><p>1）先说“文字”</p><blockquote><p>文字是记录语言的视觉符号系统，是人类社会运用语言相当长时间以后出现的文化现象。</p></blockquote><p>也就是说，文字是个宏观的概念。语言的发展都是先有发音后有文字的，文字的出现是一种必然，同样作为信息的载体，文字显然比声音更容易保存，这也是为什么历史上知识都是通过文字流传下来的。即使是互联网时代来临，多媒体技术诞生，文字载体相对于音频载体，信息密度也是高到不知道哪里去了，音视频种的信息冗余太大，利于传播，但并不利于保存，如今一门语言如果没有文字，慢慢也就会被淘汰了吧。</p><p>2）再说“字符”（Character）</p><p>字符这个概念在英语和汉语种很容易，一个字母、一个汉字就是一个字符，如果给个概念，大概是：拥有实际语义的最小文字单位。但这其实并不严谨，还引入了更为模糊的语义概念。我觉得，简单一点可以理解成，字符就是一门语言的文字中，可以独立有意义的最小单位，它并不是一个特别严谨的概念。只是在计算机科学中，字符的概念有特殊的地位，接着往下看, 暂且按下不表。</p><p>3）后说“字素”（Grapheme）</p><p>正如前面所述, 中文的字素概念有两种学派, 拉丁语族的字素也分类不明确, 所以实际上, 很难严格意义上给字素一个具体的概念进行分类. 只能模糊地给出“字素是书写系统的最小功能单位”, 但是具体这个单位该细分到什么程度, 标准并不统一. 那为何还需要提到这个概念, 一切都是因为, 和字符一样, 在计算机科学中, 字素这个概念被赋予了特殊的意义, 而具体意义是什么, 一直往下看, 你就可以看到.</p><blockquote><p>后续行文中, 在未涉及到字素概念前, 可以暂且先认为一个字符就是一个英文字符、一个汉字、一个符号</p></blockquote><h3 id="3-2-计算机科学简介"><a href="#3-2-计算机科学简介" class="headerlink" title="3.2 计算机科学简介"></a>3.2 计算机科学简介</h3><p>学过编程的人都知道，计算机程序中，一切数据的最终形态，其实都是二进制。</p><p><img src="/images/character_set/image_3_1.png" alt="image_3_1.png"></p><p align="center">图3.1</p><p>也就是说，此时此刻呈现在你眼前的所有信息，你耳中听到的音乐，在计算机中全都是 010101010101 这样的存在。</p><blockquote><p>世界上有10种人，懂10进制的，和不懂10进制的。——鲁迅</p></blockquote><p>那么文字自然也是如此，每个有独立语言的国家，在计算机诞生之初，便需要考虑如何表示和存储字符了。即如何将本国语言中的每个文字，对应到一个二进制数中，而这种一一对应的规则，我们就可以将其称为字符集。</p><blockquote><p>在计算机世界中，二进制虽然可以区分到每一位，但实际的读取和写入，最小都是1个字节(byte)，1个字节包含8位二进制。</p></blockquote><h3 id="3-3-（编码）字符集"><a href="#3-3-（编码）字符集" class="headerlink" title="3.3 （编码）字符集"></a>3.3 （编码）字符集</h3><p>在说字符集之前，先厘清几个概念。 而这些概念中，我们经常将编码字符集和字符集混为一谈，倒也不太影响理解，因此这里也就不那么严谨，理解万岁！！</p><blockquote><ul><li>字符集/字符库(Character set/Character repertoire)：被一种或多种语言使用的字符的集合。也就是说，字符集告诉了我们，一门语言中，到底有多少个字符，每个字符是什么。</li><li>编码字符集(Coded character set)：每个字符对应一个独一无二的数字的集合。即将字符集和数字一一对应的集合。</li><li>码点(Code point)：编码字符集中的任一个合法数字，称之为码点。</li><li>编码空间(Code space)：包含所有码点的整数范围。</li><li>编码单位(Code unit)：用来编码字符集中每个字符的二进制序列。</li></ul></blockquote><p>对于计算机的诞生国美国来说，很简单，只需要考虑26个英文字母及其大小写，再加上阿拉伯数字、标点符号和一些特殊的控制字符，字符集的容量只要128够了。因此美帝标准协会制定了一个标准，用来表示英文世界中需要用到的所有字符，这个标准就是ASCII(American Standard Code for Information Interchange)。128个数，用二进制来表示，7位也就够了，一个字节绰绰有余。</p><p><img src="/images/character_set/image_3_2.gif" alt="image_3_2"></p><p align="center">图3.2</p><p>但是渐渐地，欧洲国家也开始有了计算机，它们使用更多的字符，因此将一个字节中没有使用的最高位也用上了，制定了一套Extended ASCII Codes.</p><p><img src="/images/character_set/image_3_3.gif" alt="image_3_3"></p><p align="center">图3.3</p><p>后来亚洲国家也开始使用计算机，汉字需要制定一套标准字符集，因此中国国家标准总局逐步制定了GB2312、GBK、GB13000、GB18030的标准字符集。日语也需要一套字符集，于是日本政府就逐步制定了JIS X 0201–1976、JIS X 0208–1990、JIS X 0212–1990、JIS X 0213–2000等标准字符集。</p><p>这样一直下去，问题就来了，不同国家之间没有沟通，同样一个数字，用汉语的编码字符集解读是正常的，用日语编码字符集就会出错。为了解决这个问题，各国之间也想约定一个世界统一的文字字符集标准，这就诞生了 Unicode。</p><p>Unicode目前使用了0(0x0000)~1114111(0x10FFFF)的编码范围，也就是说，当前Unicode的编码空间(Code Space)是0~0x10FFFF，之所以说是“当前”，是因为Unicode本身也是在不断发展的，早期Unicode的Code Space只用了0~65535(0xFFFF)的范围，只是随着发展，Unicode标准委员会的人才发现，原来还有各种各样隐藏在世界各处的字符，当然需要加进来！这就导致BMP的范围不够用了，只好扩展Unicode的范围，只是，实际扩展到1114111(0x10FFFF)之后，委员会的人又发现，这么多字符不可能用得完呀！不用又觉得浪费，不如加一些不太正常的语言文字吧，这就包含了文章开头提到的Emoji表情字符。</p><p>Unicode范围如此之大，当然就会想要将它划分成几大块，方便分类，也更容易理解，Unicode标准将这种分片叫做平面(Plane)。最早使用的 0~0xFFFF，就是 基本多语言平面(BMP, Basic Multilingual Plane) 的范围。</p><p><img src="/images/character_set/image_3_4.png" alt="image_3_4"></p><p align="center">图3.4</p><p>Unicode总共划分了17个平面，每个平面65536个编码空间，总共正好是 65536*17=1114112=0x10FFFF+1</p><p><img src="/images/character_set/image_3_5.png" alt="image_3_5"></p><p align="center">图3.5</p><p>所有的Unicode字符都可以在 <a href="https://unicode-table.com/en" target="_blank" rel="noopener">这里</a> 看到。 <strong>值得注意的是，哪怕Unicode的编码空间大到用不完，却也不包含任何商标，比如Windows和Apple的注册商标等</strong>，这也是为何 文章开头只能用 winkey 来指代windows的按钮，却无法找到合适的字符。</p><h3 id="3-4-字符编码"><a href="#3-4-字符编码" class="headerlink" title="3.4 字符编码"></a>3.4 字符编码</h3><p>Unicode字符集，在概念上只是编码字符集，它本身只指定了每个数字对应哪个字符，但在计算机中，这个数字究竟存储成什么样的二进制，却没有指定一个统一的标准。Unicode字符集的字符编码方式，就是UTF(Unicode Transformation Format)系列。</p><h4 id="3-4-1-UTF-32"><a href="#3-4-1-UTF-32" class="headerlink" title="3.4.1 UTF-32"></a>3.4.1 UTF-32</h4><p>UTF-32就是用32位(也就是4个字节)来存储一个Unicode字符集中的一个字符，UTF-32的值，正好对应Unicode字符集中字符的码点(Code point)值。<br>比如：</p><ul><li>😤的码点值为 <code>128548(0x1F624)</code>，那么对应的UTF-32编码也就是 <code>0x1F624</code>，在计算机中存储的二进制形态就是： <code>00000000 00000001 11110110 00100100</code> </li><li>“梦”的码点值是 <code>0x68A6</code>，用UTF-32存储在计算机中就是： <code>00000000 00000000 01101000 10100110</code> </li><li>“S”的码点是 <code>0x0053</code>，用UTF-32存储就是： <code>00000000 00000000 00000000 01010011</code> </li></ul><p><strong>UTF-32编码在实际中是没有被使用的</strong></p><h4 id="3-4-2-UTF-16"><a href="#3-4-2-UTF-16" class="headerlink" title="3.4.2 UTF-16"></a>3.4.2 UTF-16</h4><p>相信你已经发现UTF-32的问题所在了，那就是大多数字符都不需要用到32位，最多也就是24位（3个字节），所有字符都用UTF-32编码太浪费，而且Unicode标准刚制定时，也就只有BMP范围，BMP范围的字符，两个字节就刚好够了，因此有UTF-16的编码格式。在BMP平面上的字符，其UTF-16的编码，和UTF-32一样，也就是字符对应的码点值。</p><p>比如：</p><ul><li>“梦”的码点值是 <code>0x68A6</code>，用UTF-16存储就是： <code>01101000 10100110</code></li><li>“S”的码点是 <code>0x0053</code>，用UTF-16存储就是： <code>00000000 01010011</code></li></ul><p>但是这样就出现了一个问题，那些后来追加的字符集，码点值大于 0xFFFF 的，该怎么用 UTF-16 表示呢? 比如😤。而且这种表示方法，还不能影响已有的UTF-16编码的字符数据，这可怎么办?</p><p>没办法，为了照顾很多采用UTF-16的系统、软件，Unicode规定了BMP平面中的 0xD800~0xDFFF 为 <strong>surrogates</strong> 字符，在图3.5中也可以看到，Unicode规定这部分码点值，不能用来表示任何字符。实际上，这部分还可被分为两部分，0xD800~0xDBFF，称为 high surrogates，0xDC00~0xDFFF，称为 low surrogates。</p><p>这样的话，对于一个大于0xFFFF的值，如果想用UTF-16编码，就可以用32位4个字节表示，high surrogate + low surrogate 拼成一个surrogate pair就行，这样在程序读到两个字节时，如果判断它是 surrogate，那么就认为它不是正常字符，需要和另一个surrogate拼接起来才行，组成另一个字符。例如：</p><ul><li>😤的码点值为 <code>0x1F624</code>，那么对应的UTF-16的surrogate pair也就是 <code>0xD83D + 0xDE24</code>，二进制就是： <code>11011000 01011101 11011110 00100100</code></li></ul><p><strong>不难算出，Surrogate pair总共能表示 1024*1024=1048576=0x100000个字符，所以UTF-16总共可以编码0x100000+0xFFFF=0x10FFFF个字符，这也是为什么当前Unicode字符集的上限是这么大的原因，也影响了接下来我们要说的UTF-8的上限范围。</strong></p><h4 id="3-4-3-UTF-8"><a href="#3-4-3-UTF-8" class="headerlink" title="3.4.3 UTF-8"></a>3.4.3 UTF-8</h4><p>更进一步，对于英语国家的人来说，总觉得一个字节八位就足够了呀，用两位也觉得浪费空间，但对于其他国家比如中国来说，一个字节又肯定不够，这便引出了一种变长的编码格式UTF-8。引一张Wiki上的图来说明UTF-8的编码规范。</p><p><img src="/images/character_set/image_3_6.png" alt="image_3_6"></p><p align="center">图3.6</p><p>例如：</p><ul><li>“S”的码点是 <code>0x0053</code>，用UTF-8存储就是： <code>01010011</code></li><li>“µ”的码点是 <code>0x00B5</code>, 用UTF-8存储就是： <code>11000010 10110101</code></li><li>“梦”的码点值是 <code>0x68A6</code>，用UTF-8存储就是： <code>11100110 10100010 1010 0110</code></li><li>😤的码点值为 <code>0x1F624</code>，用UTF-8存储就是：<code>11110000 10011111 10011000 10100100</code> </li></ul><p>如果我们算一下四字节的UTF-8实际能表示的范围，会发现理论上应该能表示到 <code>0x1FFFFF</code> ，但是实际上却限制了上限为 <code>0x10FFFF</code> ，这就是上节所述的UTF-16的上限，既然编码空间足够大，目前看来总是够用的，那为了兼容UTF-16，就先这样规定吧。（RFC3629的标准如此规定了上限，大概就是这样想的吧）。</p><p>关于UTF-8，还有一些比较有意思的现象，比如在早期Windows中， <strong>当你在 windows 的记事本里新建一个文件，输入”联通”两个字之后，保存，关闭，然后再次打开，你会发现这两个字已经消失了，代之的是几个乱码</strong> ，这是由于GBK编码和UTF-8编码的识别错误导致的，可以动手搜一搜相应字节码分析一下，然后再看<sup id="fnref:17"><a href="#fn:17" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="infocodez. “【转载】随便说说字符集和编码.” 博客园, 27 Sept. 2017, www.cnblogs.com/infocodez/p/7600459.html. ">[17]</span></a></sup>这篇文章，验证下自己的分析是否正确。</p><h3 id="3-5-大端小端"><a href="#3-5-大端小端" class="headerlink" title="3.5 大端小端"></a>3.5 大端小端</h3><p>Danny Cohen在论文 <sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Cohen, Danny. “ON HOLY WARS AND A PLEA FOR PEACE.” IETF, 1 Apr. 1980, www.ietf.org/rfc/ien/ien137.txt. ">[13]</span></a></sup> 中提出了大端小端的说法，想要结束字节序(Endianness)的“战争”，自那以后，在程序员眼中，大端小端不再是《格列佛游记》的名词，而是字节序的专属名词了。在介绍UTF-32、UTF-16、UTF-8三种编码方式时，我们都没有考虑大端小端的问题，细心的读者可能已经意识到这个问题了，在此我们再简单介绍下。</p><blockquote><p>大端(Big Endian): 将一个多位数的高位放在较小的地址处，低位放在较大的地址处<br>小端(Little Endian): 将一个多位数的低位放在较小的地址处，高位放在较大的地址处</p></blockquote><p>直接拿Wiki上的示例说明， <code>0x0A0B0C0D</code> 这个32位的整数，大小端分别如下：</p><p><img src="/images/character_set/image_3_7_1.png" alt="image_3_7_1"> <img src="/images/character_set/image_3_7_2.png" alt="image_3_7_2"></p><p align="center">图3.7</p><p>我们还是以😤为例，在UTF-32中编码为： <code>0x0001F624</code>，大端小端分别如图。</p><p><img src="/images/character_set/image_3_8.png" alt="image_3_8"></p><p align="center">图3.8</p><p>在UTF-16中编码为： <code>0xD83DDE24</code> ，大端小端分别如图。</p><p><img src="/images/character_set/image_3_9.png" alt="image_3_9"></p><p align="center">图3.9</p><p>看到这里，屏幕前的你，是不是都自信满满地准备自己画出UTF-8的大端小端了? <strong>不过对不起，UTF-8是不需要区分大端小端的</strong>。倒回去看UTF-8的编码标准，我们会发现，UTF-8的最小处理单位是单字节，而不是像UTF-16和UTF-32的多字节。也就是说：</p><ul><li>对于UTF-32，程序需要一次读取4个字节，然后计算这四个字节的实际值，如果字节序不同，会导致结果不同</li><li>对于UTF-16，程序需要一次读取2个字节，然后计算这两个字节的实际值，如果字节序不同，结果也会不同</li><li><strong>但是对于UTF-8来说，程序一次只会读取1个字节，程序需要通过每个字节的字节头去决定是否需要继续读取下一个字节，既然一次只读取一个字节，自然不会受大小端的影响。</strong> </li></ul><p>😤用UTF-8编码是 <code>0xF09F98A4</code>，那么实际上，计算机永远会先读取 <code>F0</code> ，然后判断还需要读取接下来的三个字节，就依次读取 <code>9F</code> 、<code>98</code> 、 <code>A4</code>，然后将四个字节组合计算得出实际表示的值。计算机总共读取了四次，而不是一次读取了 4个字节。实际在计算机内存中，存储总是如图。</p><p><img src="/images/character_set/image_3_10.png" alt="image_3_10"></p><p align="center">图3.10</p><h3 id="3-6-BOM-byte-order-mark"><a href="#3-6-BOM-byte-order-mark" class="headerlink" title="3.6 BOM(byte order mark)"></a>3.6 BOM(byte order mark)</h3><p>既然字节序对计算机读取字符有很大的影响，那么对于一个文本文件，知道它实际存储的数据是大端还是小端就很重要了。为了实现这个目的，使用BOM来标记一个文本文件的开头，从而区分该文件是大端还是小端存储的。BOM本质上也还是个字符，只不过是个特殊的字符，在UTF-16的文本文件中，BOM就是 <code>0xFEFF</code> ，这时，计算机程序首先读取文本文件的前两个字节，通过判断高低地址的实际值，就可以判断是大端还是小端了。 <strong>0xFEFF这个字符实际上被称为ZERO WIDTH NO-BREAK SPACE字符，之所以用这个字符，是因为根据UTF-8编码标准，UTF-8不可能出现0xFE或者0xFF开头的字符，因此不会和UTF-8产生混淆。</strong> </p><p><img src="/images/character_set/image_3_11.png" alt="image_3_11"></p><p align="center">图3.11</p><p>对于UTF-32来说，虽然实际上没人用，但是字节序标准还是有的，用 <code>0x0000FEFF</code> 四个字节表示。</p><p>对于UTF-8来说，由于其自身的字节就有字节头标志，也不区分大小端，其实并不需要BOM，但是在早期Windows系统中，默认用记事本编辑时，用UTF-8保存也会默认加个BOM头，具体是 <code>0xEFBBBF</code> 。这时，实际上这个BOM并不是标志字节序的，而是标志编码方式，即该文件是用UTF-8编码的，仅此而已。</p><p>而这个BOM带来了各种巨坑的问题，不限于：</p><blockquote><ul><li>gcc会报告源码文件开头有无法识别的字符</li><li>Linux的shell脚本无法运行： <code>Shell:  #!/bin/sh: No such file or directory</code> </li><li>早期一些比较坑的教程会教人用记事本学Java，然后用 javac 编译，这时会报“错误：非法字符：blablabla”，但是却不在教程中说明这一点。（之所以记得这件事，是因为直到研究生期间还有人问过这种问题…</li><li>其他一系列知名不知名软件读取配置文件的坑…</li><li>…</li></ul></blockquote><p><strong>但是，竟然还有反向操作的，举一个自己曾经遇到的坑，知名音乐播放软件Foobar 2000，在读取 .cue 文件时，必须是 UTF-8 With BOM，曾经强迫症把所有 .cue 文件改成了 UTF-8 Without BOM，结果Foobar 2000全部无法识别…</strong> </p><p>其他还有一些不常见的BOM如下。</p><p><img src="/images/character_set/image_3_12.png" alt="image_3_12"></p><p align="center">图3.12</p><h3 id="3-7-Unicode控制字符"><a href="#3-7-Unicode控制字符" class="headerlink" title="3.7 Unicode控制字符"></a>3.7 Unicode控制字符</h3><p>上面说到了UTF-16和UTF-32用 <code>0xFEFF</code> 作为BOM字符，这个字符实际上是不可见的，主要用于标志字节序。在编码字符集中, 这种特殊码位的字符，一般可以叫做“控制字符”(Control character,Non-printable character)，即“用于控制文本解释或者显示，而不可见或不占空间的Unicode字符”。<br>而在Unicode的一般性分类中, 控制字符大多都归属于 Other(C) 这个大类. Other(C)大类下又分:</p><ul><li>Cc(Other, control), 共有65个, 而且这个数量永远都不会再变</li><li>Cf(Other, format), 共有161个, 这是Unicode 13.0中的数量, 以后可能会再变</li><li>Cs(Other, surrogate), 共有2048个, 永远都不会再变</li><li>Co(Other, private use), 共有137468个, 永远都不会再变</li><li>Cn(Other, not assigned), 还未分配的保留字符</li></ul><p>这其中, 严格意义上来说, 只有Cc是控制类型的字符, 但是广义上或者口语化中所说的控制字符, 其实也包含了格式化类型的字符, 这就包括了Cf, 以及另一个和Other(C)平行的大类 Separator(Z)中的字符.<br><strong>简单来说, 广义上将Control Type和Format Type的字符都作为控制字符来表达, 也没什么问题</strong><br>对广义上的控制字符细分如下.</p><h4 id="3-7-1-ISO-6429控制字符-C0与C1控制字符"><a href="#3-7-1-ISO-6429控制字符-C0与C1控制字符" class="headerlink" title="3.7.1 ISO 6429控制字符(C0与C1控制字符)"></a>3.7.1 ISO 6429控制字符(C0与C1控制字符)</h4><p>控制字符U+0000‐U+001F 与U+007F来自ASCII。此外，ISO 8859字符集定义了U+0080‐U+009F。二者都定义在ISO 6429中，常被称为C0与C1控制字符。</p><p>大部分这些字符在Unicode文本处理中没有明确作用。字符<code>U+0000 &lt;control-0000&gt; ，NUL、U+0009 &lt;control-0009&gt; ，HT、U+000A &lt;control-000A&gt; ，LF、U+000D &lt;control-000D&gt; ，CR、U+0085 &lt;control-0085&gt; ，NEL</code>常用于格式化字符。</p><p><strong>这65个字符就是所有Cc类别的字符</strong></p><h4 id="3-7-2-Unicode引入的分隔符"><a href="#3-7-2-Unicode引入的分隔符" class="headerlink" title="3.7.2 Unicode引入的分隔符"></a>3.7.2 Unicode引入的分隔符</h4><p>为了简化几种换行字符，Unicode引入了它自己的分隔符来格式化文本：</p><ul><li>U+2028 line separator ，HTML： <code>&amp;#8232;</code>，LSEP</li><li>U+2029 paragraph separator ，HTML： <code>&amp;#8233;</code>，PSEP</li></ul><p><strong>这就是Separator(Z)大类中仅有的两个Format Type的字符了</strong><br><strong>因此, 剩下的所有细分类别, 其实全是Cf类别的字符, 包括了开始所说的<code>0xFEFF</code></strong></p><h4 id="3-7-3-语言标记"><a href="#3-7-3-语言标记" class="headerlink" title="3.7.3 语言标记"></a>3.7.3 语言标记</h4><p>不予叙述，可参考<sup id="fnref:18"><a href="#fn:18" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “Unicode控制字符.” Wikipedia, Wikimedia Foundation, 28 July 2020, zh.wikipedia.org/wiki/Unicode控制字符.">[18]</span></a></sup>的说明。</p><h4 id="3-7-4-行间标注"><a href="#3-7-4-行间标注" class="headerlink" title="3.7.4 行间标注"></a>3.7.4 行间标注</h4><p>3个格式化字符用于支持旁注标记（U+FFF9、U+FFFA、U+FFFB）。</p><blockquote><p>所谓旁注标记（ruby character），又称注音标示、加注音、Ruby字符、ruby或rubi，是一种表意文字的音标印刷方式，广泛地运用于日文及中文。一般这些字是放于表意文字的上方或右边，作为文字的拼音或注解。</p></blockquote><p>了解过HTML5的童鞋也许知道HTML5引入了 <code>&lt;ruby&gt;</code> 标签，也是同样的意思，（我之所以知道，是因为我的主页也用了嘛！~不过主页也是模仿前端大神的网页做的啦）</p><p><img src="/images/character_set/image_3_13.png" alt="image_3_13"></p><p align="center">图3.13</p><h4 id="3-7-5-双向文本控制"><a href="#3-7-5-双向文本控制" class="headerlink" title="3.7.5 双向文本控制"></a>3.7.5 双向文本控制</h4><p>英文、中文的印刷作品，基本都是从左向右，自上而下的，但并不是所有语言的印刷品都是如此，比如日语就是自右向左的，中国古代的书籍也是。</p><p>Unicode本身是支持从左到右、从右到左，或者其混合排版，而不需要任何特殊字符。但考虑到为了处理一些特殊情形，Unicode还是定义了12个字符<code>（U+061C、U+200E、U+200F、U+202A、U+202B、U+202C、U+202D、U+202E、U+2066、U+2067、U+2068、U+2069）</code>以帮助控制嵌入式双向文本的顺序，最大可以有125层深。</p><p>这个到底是干嘛用的，主要还是因为世界上有阿拉伯语这种存在。。。<br>比如“阿拉伯字母”这五个字的阿拉伯语写法，就是：</p><blockquote><p>أَبْجَدِيَّة عَرَبِيَّة‎</p></blockquote><p>说实话我不知道屏幕前的你看到的实际上是什么样的字符串… 对照下图看看..</p><p><img src="/images/character_set/image_3_14.png" alt="image_3_14"></p><p align="center">图3.14</p><p>而如果我在IDEA的编辑器中，赋值这行字符串为字面量，就会显示成下图，甚至影响了我的光标显示。。。</p><p><img src="/images/character_set/image_3_15.png" alt="image_3_15"></p><p align="center">图3.15</p><p>这其中，虽然那个<code>\u200E</code>的 <code>\</code> 已经位置错误，还是可以看出就是刚刚提到的Unicode定义的12个双向文本控制字符中的一个。实际上它的作用就是控制“从左至右书写标记”，而<code>\u200F</code>是“从右至左书写标记”<br>这就就是阿拉伯语的其中一个特殊之处：<strong>从右向左书写</strong>。(虽然日语、中国古籍，也都是从右向左，但只是排版概念上从右向左，而且还是竖着写的呀)。<br>阿拉伯语的这个特性带来了一个问题，如果在一行阿拉伯文字里，我写了一个英文单词，那该怎么办，nice 岂不是要显示成 ecin，于是就需要对一行文本内的某些文字再单独进行方向控制，那如果单词里再嵌套个阿拉伯字母呢，阿拉伯字母间再嵌套中文…… 如此套娃无穷尽也，因此Unicode规定了最大的嵌套深度是125层。</p><blockquote><p>笔者按: 一个阿拉伯语撑起了字符串处理Bug的半边天…</p></blockquote><h4 id="3-7-6-异体字选择器"><a href="#3-7-6-异体字选择器" class="headerlink" title="3.7.6 异体字选择器"></a>3.7.6 异体字选择器</h4><p>异体字的具体说明可参考<sup id="fnref:19"><a href="#fn:19" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “異體字選擇器.” Wikipedia, Wikimedia Foundation, 4 Sept. 2020, zh.wikipedia.org/wiki/異體字選擇器.">[19]</span></a></sup>. 简单来说，就是一种语言中，某一个字有两种写法，但是意义完全相同，因此当初编码时，没有将其区分开，但在实际使用中，可能在用于人名等专有名词时，还是需要进行区分的，因此提供了“异体字选择器”这种控制字符。</p><h4 id="3-7-7-控制字符的图片"><a href="#3-7-7-控制字符的图片" class="headerlink" title="3.7.7 控制字符的图片"></a>3.7.7 控制字符的图片</h4><p>不予叙述。</p><h3 id="3-8-组合字符-Combining-Character"><a href="#3-8-组合字符-Combining-Character" class="headerlink" title="3.8 组合字符(Combining Character)"></a>3.8 组合字符(Combining Character)</h3><h4 id="3-8-1-组合标记-Combining-Marks"><a href="#3-8-1-组合标记-Combining-Marks" class="headerlink" title="3.8.1 组合标记(Combining Marks)"></a>3.8.1 组合标记(Combining Marks)</h4><p>上面在说控制字符时，有一类所谓的行间标记提到了“旁注标记”，在汉字上方标注拼音，可以称之为“旁注标记”。那对于某些欧洲语言来说，可以在字母上方加一些变音符号，实质上就表示成了另一个不同的字符，但它又是在原字符基础上变化的，如果每种变化都算作一个新字符，那即使是Unicode，可能也装不下这些排列组合的数量，因此出现了附加组合标记的组合字符。如Wiki的图<sup id="fnref:20"><a href="#fn:20" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “組合字符.” Wikipedia, Wikimedia Foundation, 30 May 2019, zh.wikipedia.org/wiki/組合字符. ">[20]</span></a></sup>。</p><p><img src="/images/character_set/image_3_16.png" alt="image_3_16"></p><p align="center">图3.16</p><p>在统一码中，用于欧洲语言和国际音标的组合用附加符号为〈U+0300–U+036F〉。上图的字符 y̌ 就可以表示成： <code>\u0079\u030C</code> ， <code>\u0079</code> 就是 <code>y</code> ， <code>\u030C</code> 就是变音符号’̌。</p><p>说到这里, 不得不提的就是在中二时期网络上流行的越界文字(Zalgo text), 其本质就是对组合字符的叠加, 因为Unicode没有规定组合字符必须是实际存在的字符, 那实际上我们可以叠加变音符号, 从而使得字符越界. 如果我们组合这样一个字符”\u0079\u030C\u030C\u030C\u030C\u030C\u030C\u030C”, 实际就是:</p><blockquote><p>y̌̌̌̌̌̌̌</p></blockquote><h4 id="3-8-2-Grapheme-和-Grapheme-Cluster"><a href="#3-8-2-Grapheme-和-Grapheme-Cluster" class="headerlink" title="3.8.2 Grapheme 和 Grapheme Cluster"></a>3.8.2 Grapheme 和 Grapheme Cluster</h4><p>不过，你以为Unicode的组合字符序列到此就结束了吗? まだまだだね<br>关于组合字符序列, Unicode官网给出了一些FAQ<sup id="fnref:32"><a href="#fn:32" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Unicode Consortium. (2020, September 19). Characters and Combining Marks. Retrieved September 19, 2020, from http://unicode.org/faq/char_combmark.html">[32]</span></a></sup>. 在这些Q&amp;A中, 有一个问题:</p><blockquote><p>Q: So is a combining character sequence the same as a “character”?</p></blockquote><p>终于, 我们还是逃避不了这个问题, 究竟什么是字符? 组合字符还是传统意义上的”字符”吗? 怎么在概念上区分它们呢? 最终, 我们引入了字素(grapheme), 那个在语言学简介中提了之后, 一直没有出现的名词.</p><p>在程序员的眼中, 一个字符一般指一个Unicode的Code point, 但对于终端用户来说, 将字符等价于字素(grapheme), 是更加直观的, 字素的概念始终是不变的: <strong>a minimally distinctive unit of writing in the context of a particular writing system</strong>. 只不过之前无法具体细分字素的范围, 现在我们终于有工具能够确切描述字素的范围了.<br>在Unicode世界中, 一个字素至少包含一个Code point, 包含组合标记、控制字符等的多个组合字符序列也可作为一个字素. 这样, 至少在Unicode中, 我们将字素的最小范围限定到了一个Code point, 不会有比一个Code point范围更小的字素了!<br>事实上, Unicode引入的字素(grapheme)概念, 也可以称为用户感知字符(user-perceived character), 不仅可以在基础字符上附加组合字符, 用来形成新的字素, 也可以通过控制字符(如方向控制等)来形成新的字素.</p><p>字素的集合, 就可以统一称为 Grapheme Cluster, 或者通俗一点: user-perceived characters</p><p>So… Why? 为什么要划分这么细, 规定这么多细节, 直接认为 y̌ 就是两个字符, 不搞其他一些幺蛾子, 难道不香吗?<br>Unicode在TR29的技术报告里<sup id="fnref:30"><a href="#fn:30" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Davis, Mark, and Christopher Chapman. Unicode Text Segmentation. 19 Feb. 2020, unicode.org/reports/tr29/. ">[30]</span></a></sup>，给出了一段话:</p><blockquote><p>Grapheme cluster boundaries are important for collation, regular expressions, UI interactions, segmentation for vertical text, identification of boundaries for first-letter styling, and counting “character” positions within text. Word boundaries, line boundaries, and sentence boundaries should not occur within a grapheme cluster: in other words, a grapheme cluster should be an atomic unit with respect to the process of determining these other boundaries.</p></blockquote><p>我给大家画个重点，就是: <strong>grapheme cluster应该作为一个原子性的整体看待, 至少不能在在一个grapheme cluster中间出现换行符、单词分隔符、连字符等破坏性字符吧，那既然有这些限制，识别grapheme cluster的边界就十分有必要了, 这样才能更好的做字符排序、正则匹配、UI交互等字符串(实际上现在该叫字素串)处理工作</strong></p><blockquote><p><strong>总结一下: 可以认为字素是在Code point/Character之上的一种更高一层的抽象.</strong></p></blockquote><p>在tr29中，还提到了三类不同的grapheme clusters: legacy grapheme clusters, extended grapheme clusters, tailored grapheme clusters. 具体的概念我也不翻译了，因为…水平不够. 就截几张图, 大概感受一下.</p><p><img src="/images/character_set/image_3_17.png" alt="image_3_17"></p><p align="center">图3.17</p><p>好的，我知道其实你根本不想看，那就略过，我们继续。</p><h4 id="3-8-3-Unicode等价-Unicode-equivalence-及正规化-Normalization"><a href="#3-8-3-Unicode等价-Unicode-equivalence-及正规化-Normalization" class="headerlink" title="3.8.3 Unicode等价(Unicode equivalence)及正规化(Normalization)"></a>3.8.3 Unicode等价(Unicode equivalence)及正规化(Normalization)</h4><p>上面说完了字素, 又引入了另一个问题, 那就是:<br>带变音的拉丁字素等，使用广泛，以及占坑较早，因此，早早地就作为一个个的单独码点在Unicode种有一个码(keng)位了，而后来Unicode又规定了组合字符，这样，同一个字素就有可能有两种编码方式。比如“Å”，既可以是 <code>\u00c5</code> ，也可以是 <code>\u0041\u030A</code> 表示，可以在<a href="https://apps.timwhitlock.info/unicode/inspect" target="_blank" rel="noopener">这个网站</a> 试试。这就引入了另一个话题，Unicode equivalence和Normalization，即判断两个字符/素串相等时，是否需要考虑这种等价情况，如果需要考虑这种意义上的等价，那么就需要对字符/素串先进行正规化(Normalization)，再进行比较。</p><blockquote><p>正规化即将彼此等价的序列转成同一列序, Unicode提供了两种等价概念：标准等价(canonically equivalent)和兼容等价(compatible). 两者的具体概念参考<sup id="fnref:22"><a href="#fn:22" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “Unicode Equivalence.” Wikipedia, Wikimedia Foundation, 7 Aug. 2020, en.wikipedia.org/wiki/Unicode_equivalence. ">[22]</span></a></sup>. 标准等价的一个示例就是 Å<code>\u00c5</code>和 Å<code>\u0041\u030A</code>, 兼容等价的一个示例就是 ﬀ<code>\ufb00</code> 和 ff<code>\u0066\u0066</code></p></blockquote><p>为了进行正规化, 自然会有两种想法:</p><ul><li>一种是分解(Decomposition): 即将字素串中所有单个字素分解为等价的组合字符.</li><li>一种是组合(Composition): 即将字素串中所有分解后的组合重组为单个字素.</li></ul><p>结合标准等价和兼容等价的概念, 正规形式自然可以分为四种:</p><table><thead><tr><th style="text-align:center">正规形式</th><th style="text-align:center">转换算法</th></tr></thead><tbody><tr><td style="text-align:center">NFD,Normalization Form Canonical Decomposition</td><td style="text-align:center">以标准等价方式来分解</td></tr><tr><td style="text-align:center">NFC,Normalization Form Canonical Composition</td><td style="text-align:center">以标准等价方式来分解，然后以标准等价重组之</td></tr><tr><td style="text-align:center">NFKD,Normalization Form Compatibility Decomposition</td><td style="text-align:center">以兼容等价方式来分解</td></tr><tr><td style="text-align:center">NFKC,Normalization Form Compatibility Composition</td><td style="text-align:center">以兼容等价方式来分解，然后以标准等价重组之</td></tr></tbody></table><p>好了, 等价就说到这. 以及, 后续我们还是使用字符串这个名词, 这一小段使用字素串, 主要是为了加深对字素的印象.</p><h3 id="3-9-特殊的组合字符"><a href="#3-9-特殊的组合字符" class="headerlink" title="3.9 特殊的组合字符"></a>3.9 特殊的组合字符</h3><p>在Unicode的兼容性等价示例中, 以 ﬀ<code>\ufb00</code> 为例进行了说明. 这个字符和 两个f的组合 ff<code>\u0066\u0066</code> 具体是什么关系呢?<br>实际上<code>\ufb00</code>是一个连体字/合体字.</p><blockquote><p>在西方字体排印学中将多于一个字母合成一个字形就是连体字, 经过演变、长时间流行后，一些连体字组合就直接变成了一个单个字符, 拥有自己独立的形式了.</p></blockquote><p>说到连字, 其实和排版系统有所牵连, 就不细述概念了, 举个例子.<br>在VS Code中可以在配置中<code>&quot;editor.fontLigatures&quot;: true</code>, 这样设置之后, 如果在VS Code中连着打出&gt;和=, 其实就会显示成≥<br>但这是编辑器自己处理的连字效果, 有没有办法强行使一些本来没有连字效果的字符组合产生连字效果, 或者强行使一些有连字效果的字符组合取消连字效果呢? 答案是肯定的. Unicode的Cf字符中, 有以下两个字符.</p><ul><li>零宽度连字符(zero-width joiner, zwj)U+200D: 用于阿拉伯文等文字中，使不会发生连字的字符间产生连字效果</li><li>零宽度断字符(zero-width non-joiner, zwnj)U+200C: 用于阿拉伯文、德文等文字中，阻止会发生连字的字符间的连字效果</li></ul><p>zwnj的例子大多都和语言相关, 阿拉伯语、德语一类的, 示例也很复杂.<br>但是zwj就很特殊, 除了阿拉伯语这种特殊语言, 还记得我们文章的开头说了什么吗? 没错, 就是 Emoji!</p><p>zwj对Emoji也有效, 本来Emoji就是个设计简单表达心情的表情符号，但随着使用越来越广泛，刮起了一阵“中立表情(Neutral Emojis)”的风，即有男性表情，那就得有对应的女性，有白种人，那就得有黄种人、黑种人，家庭可以是异性恋，那就得有同性恋，有儿子，也得有女儿。如果每种都是单独的字符表示，那Unicode可能也装不下，而且已有的Emoji也不能复用, 因此就想到了用zwj来组合相关Emoji, 形成新的Emoji。</p><p>最典型的一个例子：👨‍👨‍👦‍👦这个家庭的Emoji，实际上是由四个Emoji组合而成，表示两个爸爸和两个儿子一家： <code>\uD83D\uDC68\u200D\uD83D\DC68\u200D\D83D\DC66\u200D\D83D\uDC66</code></p><p>每个字符间用特殊字符 <code>\u200D</code>(zero width joiner) 连接起来. 总共占用了22个字节，每个表情成分是四个字节，而每个控制字符只占用两个字节。</p><h2 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h2><p>已经说了这么多，相信诸位也已经知道了emoji究竟是什么，回到文章开头前言处，微信为何能显示😤这个表情，也不言自明了。</p><p>读到这里，你长输一口气：“终于要结束了！”。抱歉，其实还没完。。。</p><p>既然emoji就是一个字符，那么在计算机程序中，对它的操作、存储，也自然是和普通字符没什么差别，本质就是字符的编码问题。那这是不是意味着，在互联网程序中，凡是可以输入字符的地方，其实也就可以输入emoji、乃至所有unicode字符呢? 最差也就是某些古老的客户端没法正确展示嘛！真是如此，还是说服务器端有必要对unicode字符做一些限制呢? 答案是肯定的，在很多情况下，的确要对字符进行限制。这样做的原因有很多，这里列举以下几个原因，进行说明。</p><h3 id="4-1-数据库不支持"><a href="#4-1-数据库不支持" class="headerlink" title="4.1 数据库不支持"></a>4.1 数据库不支持</h3><p>这主要就是MySQL的坑了，MySQL 5.5.3版本之前，设置的所谓utf-8格式，其实只支持三个字节长度的utf-8，不支持四字节长度。之后的版本才支持四字节长度，而为了兼容以前的版本，指定表结构、字段类型为utf-8，其实还是只支持三字节的utf8mb3，只有显示指定utf8mb4，才是支持四字节的utf-8.</p><p>不过这也不能把锅全甩给MySQL，谁让MySQL支持UTF-8太早了呢，根据Wiki<sup id="fnref:25"><a href="#fn:25" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “UTF-8.” Wikipedia, Wikimedia Foundation, 20 Aug. 2020, zh.wikipedia.org/wiki/UTF-8. ">[25]</span></a></sup>所述。</p><blockquote><p>这是由于MySQL在4.1版本开始支持UTF-8编码（当时参考UTF-8草案版本为RFC 2279）时，为2003年，并且在同年9月限制了其实现的UTF-8编码的空间占用最多为3字节，而UTF-8正式形成标准化文档（RFC 3629）是其之后。限制UTF-8编码实现的编码空间占用一般被认为是考虑到数据库文件设计的兼容性和读取最优化，但实际上并没有达到目的，而且在UTF-8编码开始出现需要存入非基本多文种平面的Unicode字符（例如emoji字符）时导致无法存入（由于3字节的实现只能存入基本多文种平面内的字符）。直到2010年在5.5版本推出“utf8mb4”来代替、“utf8”重命名为“utf8mb3”并调整“utf8”为“utf8mb3”的别名，并不建议使用旧“utf8”编码，以此修正遗留问题。</p></blockquote><h3 id="4-2-打印机不支持"><a href="#4-2-打印机不支持" class="headerlink" title="4.2 打印机不支持"></a>4.2 打印机不支持</h3><p>也许你的数据库，你的程序都可以正常的存储、展示Unicode字符，但是对那些需要将字符打印出来的场景，还需要考虑打印机等硬件的限制，有些打印机并不具备打印复杂Unicode字符的能力。</p><h3 id="4-3-安全原因"><a href="#4-3-安全原因" class="headerlink" title="4.3 安全原因"></a>4.3 安全原因</h3><p>安全是个不容忽视的原因，大到苹果、腾讯，也多次在unicode字符上翻车。</p><p>列举一下我还记得的一些相关Bug：</p><ul><li><a href="https://yq.aliyun.com/articles/202488" target="_blank" rel="noopener">iOS漏洞：发送短信即可令任意苹果手机重启</a> </li><li><a href="https://zhuanlan.zhihu.com/p/136328290" target="_blank" rel="noopener">iOS 现重大漏洞，神秘字符可让 iPhone 死机！</a></li><li><a href="https://www.zhihu.com/question/43621727/answer/548216936" target="_blank" rel="noopener">微信「你女朋友撤回了一条消息还亲了你一口」是怎么实现的（微信已经修复了这个bug）？</a></li><li><a href="https://www.sohu.com/a/289091005_120085857" target="_blank" rel="noopener">“我给男神发了7条隐藏微信消息，结果他向我表白了！” </a></li></ul><p>后面两个微信的bug其实都和我们之前提到的Unicode的“双向控制字符”有关，而又因为方向控制通常用在阿拉伯语中，因此这些漏洞的利用都利用了阿拉伯字符.<br>苹果的漏洞都没有披露具体细节，原因也只能靠网友自己去猜，蛤乎上偶尔能搜到。这里给出几个链接，感兴趣可以看看. <a href="https://www.zhihu.com/question/21568134?rf=21568497" target="_blank" rel="noopener">点我</a> ，<a href="https://www.zhihu.com/question/390280089" target="_blank" rel="noopener">还有我</a>，<a href="https://www.guokr.com/question/496989/" target="_blank" rel="noopener">还有我</a> </p><h2 id="五、字体与排版"><a href="#五、字体与排版" class="headerlink" title="五、字体与排版"></a>五、字体与排版</h2><p>回到文章开头的另一个问题，“😤这个表情真的是图片吗?”，也许你会回答，当然不是啦，现在知道了，它就是个字符，和汉字一样。一个整数就可以表示了，而图片需要用专门的图片格式，BMP、GIF或者JPG等。那么你有没有想过，你是怎么看到这个表情的呢? 不是图形眼睛怎么能看到呢?</p><p>这就要扯到字体上去了，这块不是本文重点，但还是在最后顺带一提。</p><p>虽然字符本质上几个字节就编码完成了，可以看作和整数一一对应，但是想要将这个字符渲染出来，就是另一套体系，图形学的体系。换字体强迫症者，也许在网上寻找过各种各样的字体进行尝试，下载一个 <code>.ttf</code> 文件，然后双击安装，就拥有了一种新字体。</p><p>将一个二进制代表的字符转化为人眼可见的图形，大概的流程就是这样的。</p><p><img src="/images/character_set/image_5_1.png" alt="image_5_1.png"></p><p align="center">图5.1</p><p>不过这块了解不多，也没有查阅太多资料，可能不太准确. 如有错误恳请指出。</p><p>参考<sup id="fnref:33"><a href="#fn:33" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Hosken, M., &amp; Gaultney, V. (2003, September 5). Guidelines for Writing System Support: Technical Details: Smart Rendering: Part 1. Retrieved September 20, 2020, from https://scripts.sil.org/cms/scripts/page.php?site_id=nrsi">[33]</span></a></sup>, 可以给出稍微细节点的渲染流程, 如图5.2所示.</p><p><img src="/images/character_set/image_5_2.png" alt="image_5_2.png"></p><p align="center">图5.2</p><p>还有一点就是： <strong>现有的TTF和OTF格式，单个字体文件都只能支持65535个字符，因此想要用一个字体文件涵盖所有的Unicode字符是不可能的</strong> </p><p>在计算机的文字处理领域，除了底层的编码、字体，还要考虑对字符如何进行排版，而这又是另一个复杂而又宏大的话题了<sup id="fnref:33"><a href="#fn:33" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Hosken, M., &amp; Gaultney, V. (2003, September 5). Guidelines for Writing System Support: Technical Details: Smart Rendering: Part 1. Retrieved September 20, 2020, from https://scripts.sil.org/cms/scripts/page.php?site_id=nrsi">[33]</span></a></sup>。就此打住，有机会再研究~</p><h2 id="六、Q-amp-A"><a href="#六、Q-amp-A" class="headerlink" title="六、Q&amp;A"></a>六、Q&amp;A</h2><p>好了，说了这么多理论，问几个问题，看你是否都能答对。<br>以下涉及编程语言的部分, Java 版本为 Java 11, Python 版本为 Python 3.8.2, Go 版本为 Go 1.13.8<br>主要还是以Java为主</p><h3 id="6-1-“😤”在不同的编程语言中的length是多少"><a href="#6-1-“😤”在不同的编程语言中的length是多少" class="headerlink" title="6.1 “😤”在不同的编程语言中的length是多少?"></a>6.1 “😤”在不同的编程语言中的length是多少?</h3><p>通常, 编程语言中 字符串的 length 表示了该字符串的字符数量.<br>从理论上来说, 长度应该为1, 否则会很麻烦.<br>就像早期MySQL中认为汉字是2个字符长度, 英文字母是1个字符长度, 那么编程时, 就需要程序员自己计算实际使用的长度, 防止超出varchar(n)的长度范围. 因为不方便, 而且也不符合字符的实际定义, 后续MySQL就改了.<br>但是各个编程语言又是怎么处理的呢? 是否所有语言所谓的字符就是真正的字符呢?</p><h4 id="6-1-1-Java的表现"><a href="#6-1-1-Java的表现" class="headerlink" title="6.1.1 Java的表现"></a>6.1.1 Java的表现</h4><p>先来看Java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"😤"</span>;</span><br><span class="line">System.out.println(s);</span><br><span class="line">System.out.println(s.length());</span><br><span class="line">System.out.println(s.toCharArray().length);</span><br><span class="line">System.out.println(s.getBytes(StandardCharsets.UTF_8).length);</span><br><span class="line">System.out.println(s.codePointAt(<span class="number">0</span>));</span><br><span class="line">System.out.println(s.codePointAt(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">128548</span></span><br><span class="line"><span class="number">56868</span></span><br></pre></td></tr></table></figure></p><p>实际上, Java认为字符串的长度是2.<br>Java 8之前, Java中的String, 内部存储结构就是char数组, 每个char都是一个UTF-16字符, 所以String的长度就是UTF-16字符的数量.<br>在Java 9之后, 虽然Java的String内部存储改用了 byte 数组, 但实际目的只是为了减少字符串占用的存储空间, 并不是彻底地改变了Java String中char的定义. 通过String的<a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/lang/String.java" target="_blank" rel="noopener">源码</a> 可以看到当前String中核心的几个属性是:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> COMPACT_STRINGS;</span><br></pre></td></tr></table></figure><br>如果COMPACT_STRINGS是false, 那么本质上和JDK 8没有区别, 每个char都是一个UTF-16, 占两个字节.<br>默认COMPACT_STRINGS是true, 此时, String的存储有两种可能的形式, 通过coder区分, coder为0时表示LATIN1, 为1时表示UTF16. LATIN1实际上就是ISO-8859-1字符集, 即如果一个String的只包含了ISO-8859-1字符集的字符, 那么coder=0, 一个字符用一个byte存储即可, 而出现该字符集之外的字符, coder=1, 一个字符用两个byte存储, 即UTF-16的编码方式. 查看String中的<code>coder()</code>和<code>isLatin1()</code>方法, 也可看出是COMPACT_STRINGS和coder共同决定了字符串的编码方式.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">byte</span> <span class="title">coder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> COMPACT_STRINGS ? coder : UTF16;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLatin1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> COMPACT_STRINGS &amp;&amp; coder == LATIN1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果想修改COMPACT_STRINGS的值, 可以指定JVM参数<code>-XX:-CompactStrings</code></p><p>总结一下其实就是, Java中, 如果字符串是<code>isLatin1</code>的, 那么字符串长度就是字节数, 否则, 就是字节数/2, 至于这两个字节是否真的能表示一个字符, Java表示无所谓.<br>所以这个复杂的组合字符 👨‍👨‍👦‍👦 在Java中的length实际上就是11</p><p>可以说, 由于历史原因, Java原生的String在计算长度时, 并不是很好, 甚至可以说有点坑.</p><h4 id="6-1-2-Javascript的表现"><a href="#6-1-2-Javascript的表现" class="headerlink" title="6.1.2 Javascript的表现"></a>6.1.2 Javascript的表现</h4><p>再看下Javascript<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">"😤"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.length);</span><br><span class="line"><span class="built_in">console</span>.log(s.codePointAt(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(s.codePointAt(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">128548</span></span><br><span class="line"><span class="number">56868</span></span><br></pre></td></tr></table></figure><br>毕竟前面带了Java, 难怪表现基本一致…</p><h4 id="6-1-3-Python的表现"><a href="#6-1-3-Python的表现" class="headerlink" title="6.1.3 Python的表现"></a>6.1.3 Python的表现</h4><p>那Python 3上表现又是如何呢?<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"😤"</span></span><br><span class="line">print(len(s))</span><br><span class="line">print(ord(s[<span class="number">0</span>]))</span><br><span class="line"><span class="comment"># print(ord(s[1]))   # 会抛异常</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">128548</span></span><br></pre></td></tr></table></figure><br>终于有一个表现符合我们预期的编程语言了, 可喜可贺.<br>如果考虑组合字符呢?<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">combiningCharacter = <span class="string">"\u0079\u030C"</span></span><br><span class="line">print(len(combiningCharacter))</span><br><span class="line">combiningCharacters = <span class="string">"👨‍👨‍👦‍👦"</span></span><br><span class="line">print(len(combiningCharacters))</span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><br>所以组合字符, 无论是附加组合标记的, 还是用零宽连字符连接的, 还是被认为是单个字符组成的, 统计的长度也是单个字符的数量, 即Code Point的数量</p><h4 id="6-1-4-Go的表现"><a href="#6-1-4-Go的表现" class="headerlink" title="6.1.4 Go的表现"></a>6.1.4 Go的表现</h4><p>最近风头正盛的Go语言呢?<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"😤"</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s))</span><br><span class="line">fmt.Println(s[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"%x "</span>, s[i])</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">fmt.Printf(<span class="string">"%+q\n"</span>, s)</span><br><span class="line"></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">240</span></span><br><span class="line">f0 <span class="number">9</span>f <span class="number">98</span> a4</span><br><span class="line"><span class="string">"\U0001f624"</span></span><br></pre></td></tr></table></figure><br>不科学呀, 怎么和其他语言都不一样呢?<br>直接看Go语言的一篇官方博客<sup id="fnref:31"><a href="#fn:31" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Pike, R. (2013, October 23). Strings, bytes, runes and characters in Go. Retrieved September 19, 2020, from https://blog.golang.org/strings">[31]</span></a></sup>, <a href="https://blog.golang.org/strings" target="_blank" rel="noopener">Strings, bytes, runes and characters in Go</a><br>这篇博客阐述了Go中关于String的几个关键点.</p><ul><li>Go中字符串实际上就等价于一个字节流, 访问一个字符串的index位置, 得到的其实就是对应位置的字节.</li><li>Go只存储字节流, 每个字节的值, 可以随便指定, 因此理论上字节流的编码方式可以是任何编码方式. 但是特殊的是字面量(也就是直接在源码中写出来的), 字面量的值转为什么样的字节流, 实际上在书写源码的那一刻就决定了, 源码文件本身是什么编码格式的, 就对应哪种编码的字节流, 由于Go源码只允许UTF-8格式, 实际上Go的字面量对应的字节流就是UTF-8字节流.</li><li>Go没有使用字符/character的概念, 而是使用了rune</li></ul><p>博客中也解释了这么设计的原因, 因为 字符(character) 这个概念很难定义, 考虑到组合字符等, 在 计算/Computing 中字符的概念很容易引起歧义(也的确如此, 包括这篇文章写的也没那么严谨), 因此Go中没有使用字符这个概念, 取而代之的是rune, 一个rune实际上就等价于一个Unicode中的Code Point, 同时rune实际上就是int32的别名, 这也不难理解, 用整数表示Code Point正好.<br>至于如何迭代string中的rune, Go 提供了 <code>for range</code>语法, 博客示例:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nihongo = <span class="string">"日本語"</span></span><br><span class="line"><span class="keyword">for</span> index, runeValue := <span class="keyword">range</span> nihongo &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"%#U starts at byte position %d\n"</span>, runeValue, index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">U+<span class="number">65E5</span> <span class="string">'日'</span> starts at <span class="keyword">byte</span> position <span class="number">0</span></span><br><span class="line">U+<span class="number">672</span>C <span class="string">'本'</span> starts at <span class="keyword">byte</span> position <span class="number">3</span></span><br><span class="line">U+<span class="number">8</span>A9E <span class="string">'語'</span> starts at <span class="keyword">byte</span> position <span class="number">6</span></span><br></pre></td></tr></table></figure></p><p>如果我们用<code>for range</code>来迭代组合字符呢?<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> combiningCharacter = <span class="string">"\u0079\u030C"</span></span><br><span class="line"><span class="keyword">for</span> index, runeValue := <span class="keyword">range</span> combiningCharacter &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"%#U starts at byte position %d\n"</span>, runeValue, index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> combiningCharacters = <span class="string">"😤👨‍👨‍👦‍👦"</span></span><br><span class="line"><span class="keyword">for</span> index, runeValue := <span class="keyword">range</span> combiningCharacters &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"%#U starts at byte position %d\n"</span>, runeValue, index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">U+<span class="number">0079</span> <span class="string">'y'</span> starts at <span class="keyword">byte</span> position <span class="number">0</span></span><br><span class="line">U+<span class="number">030</span>C <span class="string">'̌'</span> starts at <span class="keyword">byte</span> position <span class="number">1</span></span><br><span class="line"></span><br><span class="line">U+<span class="number">1</span>F624 <span class="string">'😤'</span> starts at <span class="keyword">byte</span> position <span class="number">0</span></span><br><span class="line">U+<span class="number">1</span>F468 <span class="string">'👨'</span> starts at <span class="keyword">byte</span> position <span class="number">4</span></span><br><span class="line">U+<span class="number">200</span>D starts at <span class="keyword">byte</span> position <span class="number">8</span></span><br><span class="line">U+<span class="number">1</span>F468 <span class="string">'👨'</span> starts at <span class="keyword">byte</span> position <span class="number">11</span></span><br><span class="line">U+<span class="number">200</span>D starts at <span class="keyword">byte</span> position <span class="number">15</span></span><br><span class="line">U+<span class="number">1</span>F466 <span class="string">'👦'</span> starts at <span class="keyword">byte</span> position <span class="number">18</span></span><br><span class="line">U+<span class="number">200</span>D starts at <span class="keyword">byte</span> position <span class="number">22</span></span><br><span class="line">U+<span class="number">1</span>F466 <span class="string">'👦'</span> starts at <span class="keyword">byte</span> position <span class="number">25</span></span><br></pre></td></tr></table></figure><br>这是和Python一样的结果.</p><p>现在还剩下一个问题, 如果我不仅仅想在<code>for range</code>中访问rune, 有什么办法直接根据索引访问吗?<br>Go给出的答案是: 语言核心部分不包含该功能, 但是可以使用库. 最常用的就是<code>unicode/utf8</code>了<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, w := <span class="number">0</span>, <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nihongo); i += w &#123;</span><br><span class="line">  runeValue, width := utf8.DecodeRuneInString(nihongo[i:])</span><br><span class="line">  fmt.Printf(<span class="string">"%#U starts at byte position %d\n"</span>, runeValue, i)</span><br><span class="line">  w = width</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>实际上, 在Unicode的FAQ中<sup id="fnref:32"><a href="#fn:32" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Unicode Consortium. (2020, September 19). Characters and Combining Marks. Retrieved September 19, 2020, from http://unicode.org/faq/char_combmark.html">[32]</span></a></sup>, 也提到了如何统计string中的字符数量, <a href="http://unicode.org/faq/char_combmark.html#7" target="_blank" rel="noopener">点我看看</a>, 其中将统计方法归纳总结成了四类: bytes,Code units,Code points,Grapheme clusters</p></blockquote><h3 id="6-2-字符串反转都如何处理"><a href="#6-2-字符串反转都如何处理" class="headerlink" title="6.2 字符串反转都如何处理?"></a>6.2 字符串反转都如何处理?</h3><p>如果只是对bytes反转, 是很简单的, 但很多情况下对终端用户来说, 反转之后的字符串还想能够正常显示的, 因此对于复杂文字来说, 需要以字素为单位切分, 而不仅仅是字符/Code point</p><p>按照上一个问题的分析, 可以知道Java一般都是按照Code point切分字符的, 但由于用了UTF-16的编码方式, 超过两字节的Code point就会被统计成两个字符, 那么在反转字符串时, 会如何呢?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"😤Ly̌L\uD83D\uDC68\u200D\uD83D\uDC68\u200D\uD83D\uDC66\u200D\uD83D\uDC66Ry̌R😤"</span>;</span><br><span class="line">System.out.println(s);</span><br><span class="line">String reverseStr = <span class="keyword">new</span> StringBuffer(s).reverse().toString();</span><br><span class="line">System.out.println(reverseStr);</span><br><span class="line"></span><br><span class="line">😤Ly̌L👨‍👨‍👦‍👦Ry̌R😤</span><br><span class="line">😤ŘyR👦‍👦‍👨‍👨ĽyL😤</span><br></pre></td></tr></table></figure><p>Emoji还是正常的, 会按照Code point切分, 查看源码可以很清晰的看到对Surrogate做了特殊处理. 但是对组合字符就无能为力了</p><p>Python 3应该是一样的表现.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"😤Ly̌L👨‍👨‍👦‍👦Ry̌R😤"</span></span><br><span class="line">print(s)</span><br><span class="line">print(s[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">😤Ly̌L👨‍👨‍👦‍👦Ry̌R😤</span><br><span class="line">😤ŘyR👦‍👦‍👨‍👨ĽyL😤</span><br></pre></td></tr></table></figure></p><p>Javascript原生split再反转, 理论上应该是不行的, 测试了一下也的确不行, 使用Array.from可以解决把一个Emoji的Code point当作两个的问题, 但是对组合字符还是无效的.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"😤Ly̌L👨‍👨‍👦‍👦Ry̌R😤"</span></span><br><span class="line"><span class="built_in">console</span>.log(s)</span><br><span class="line"><span class="built_in">console</span>.log(s.split(<span class="string">""</span>).reverse().join(<span class="string">""</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(s).reverse().join(<span class="string">""</span>))</span><br><span class="line"></span><br><span class="line">😤Ly̌L👨‍👨‍👦‍👦Ry̌R😤</span><br><span class="line">��ŘyR��‍��‍��‍��ĽyL��</span><br><span class="line">😤ŘyR👦‍👦‍👨‍👨ĽyL😤</span><br></pre></td></tr></table></figure></p><p>Go还是和之前说的一样, string本质上就是字节流, 所以需要封装对字节的处理, 一个示例.<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="string">"😤Ly̌L👨‍👨‍👦‍👦Ry̌R😤"</span></span><br><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(Reverse(s))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  size := <span class="built_in">len</span>(s)</span><br><span class="line">  buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">  <span class="keyword">for</span> start := <span class="number">0</span>; start &lt; size; &#123;</span><br><span class="line">    r, n := utf8.DecodeRuneInString(s[start:])</span><br><span class="line">    start += n</span><br><span class="line">    utf8.EncodeRune(buf[size-start:], r)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">string</span>(buf)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">😤Ly̌L👨‍👨‍👦‍👦Ry̌R😤</span><br><span class="line">😤ŘyR👦‍👦‍👨‍👨ĽyL😤</span><br></pre></td></tr></table></figure></p><p><strong>其实, 这个问题, 本质上还是在界定字节、Code point、字素的概念, 反转函数究竟是按照byte、Code point还是字素去处理字符串, 可以看到, 语言核心类库一般只支持到按照Code point去切分, 想要处理组合字符等特殊的字素, 需要付出更多的努力</strong></p><h3 id="6-3-怎么除去4字节编码的utf-8字符"><a href="#6-3-怎么除去4字节编码的utf-8字符" class="headerlink" title="6.3 怎么除去4字节编码的utf-8字符"></a>6.3 怎么除去4字节编码的utf-8字符</h3><p>由于历史因素, 无法修改MySQL的编码, 这时可能就需要在落库时过滤一遍字符串, 将4字节的utf-8字符去除.<br>对于严格按照Code point切分的语言, 比如python和go, 通过每个字符、rune的长度, 很容易就能判定.</p><p>对于Java这种UTF-16存储的, 我们可以利用一个很简单却很容易被忽略的事实: <strong>UTF-8编码的3字节的字符范围, 就是BMP的范围</strong>, 也就是说, 基本UTF-16范围的字符, 用UTF-8都不超过3字节, 所以只要判断一个字符是否是Surrogate, 移除所有Surrogate, 其实就可以保证不会超过UTF-8的3字节范围.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">removeSurrogate</span><span class="params">(String originStr)</span> </span>&#123;</span><br><span class="line">  StringBuilder returnStr = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> ch : originStr.toCharArray()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!Character.isSurrogate(ch)) &#123;</span><br><span class="line">      returnStr.append(ch);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> returnStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)">Kawasaki, Tamaki. <em>Emoji（表情符号）是如何诞生并在全世界普及的？</em>. 12 Aug. 2018, <a href="http://www.gov-online.go.jp/eng/publicity/book/hlj/html/201808/201808_12_ch.html" target="_blank" rel="noopener">www.gov-online.go.jp/eng/publicity/book/hlj/html/201808/201808_12_ch.html</a>.<a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)">Wikipedians. “World Emoji Day.” <em>Wikipedia</em>, Wikimedia Foundation, 10 Aug. 2020, en.wikipedia.org/wiki/World_Emoji_Day.<a href="#fnref:2" rev="footnote"> ↩</a></span></div><div id="fn:3" style="display:flex"><span style="width:20px">3.</span><span style="width:calc(100% - 20px)">池昌海 . “语言学概论.” 浙江大学-远程教育学院, 16 Dec. 2010, 218.108.57.198/yyxgl1/.<a href="#fnref:3" rev="footnote"> ↩</a></span></div><div id="fn:4" style="display:flex"><span style="width:20px">4.</span><span style="width:calc(100% - 20px)">李玲璞. &quot;汉字学元点理论及相关问题——兼谈汉字认知的若干误区.&quot; 中国文字研究 (2004).<a href="#fnref:4" rev="footnote"> ↩</a></span></div><div id="fn:5" style="display:flex"><span style="width:20px">5.</span><span style="width:calc(100% - 20px)">Wikipedians. “Character Encoding.” Wikipedia, Wikimedia Foundation, 25 Aug. 2020, en.wikipedia.org/wiki/Character_encoding.<a href="#fnref:5" rev="footnote"> ↩</a></span></div><div id="fn:6" style="display:flex"><span style="width:20px">6.</span><span style="width:calc(100% - 20px)">Tero, Paul. “Unicode, UTF8 &amp; Character Sets: The Ultimate Guide.” Smashing Magazine, 6 June 2012, <a href="http://www.smashingmagazine.com/2012/06/all-about-unicode-utf8-character-sets/" target="_blank" rel="noopener">www.smashingmagazine.com/2012/06/all-about-unicode-utf8-character-sets/</a>.<a href="#fnref:6" rev="footnote"> ↩</a></span></div><div id="fn:7" style="display:flex"><span style="width:20px">7.</span><span style="width:calc(100% - 20px)">Wikipedians. “Plane (Unicode).” <em>Wikipedia</em>, Wikimedia Foundation, 28 Aug. 2020, en.wikipedia.org/wiki/Plane_(Unicode).<a href="#fnref:7" rev="footnote"> ↩</a></span></div><div id="fn:8" style="display:flex"><span style="width:20px">8.</span><span style="width:calc(100% - 20px)">Unkown. “Unicode Character Table.” ✔️ ❤️ ★ Unicode Character Table, 6 Sept. 2020, unicode-table.com/en/.<a href="#fnref:8" rev="footnote"> ↩</a></span></div><div id="fn:9" style="display:flex"><span style="width:20px">9.</span><span style="width:calc(100% - 20px)">timwhitlock. “Unicode Character Inspector.” <em>apps.timwhitlock.info</em>, 6 Sept. 2020, apps.timwhitlock.info/unicode/inspect.<a href="#fnref:9" rev="footnote"> ↩</a></span></div><div id="fn:10" style="display:flex"><span style="width:20px">10.</span><span style="width:calc(100% - 20px)">纤夫张 . “其实你并不懂 Unicode.” 知乎专栏, 31 Dec. 2018, zhuanlan.zhihu.com/p/53714077.<a href="#fnref:10" rev="footnote"> ↩</a></span></div><div id="fn:11" style="display:flex"><span style="width:20px">11.</span><span style="width:calc(100% - 20px)">Wikipedians. “UTF-8.” Wikipedia, Wikimedia Foundation, 5 Sept. 2020, en.wikipedia.org/wiki/UTF-8.<a href="#fnref:11" rev="footnote"> ↩</a></span></div><div id="fn:12" style="display:flex"><span style="width:20px">12.</span><span style="width:calc(100% - 20px)">F. Yergeau. “UTF-8, a Transformation Format of ISO 10646.” IETF Tools, 1 Nov. 2003, tools.ietf.org/html/rfc3629.<a href="#fnref:12" rev="footnote"> ↩</a></span></div><div id="fn:13" style="display:flex"><span style="width:20px">13.</span><span style="width:calc(100% - 20px)">Cohen, Danny. “ON HOLY WARS AND A PLEA FOR PEACE.” IETF, 1 Apr. 1980, <a href="http://www.ietf.org/rfc/ien/ien137.txt" target="_blank" rel="noopener">www.ietf.org/rfc/ien/ien137.txt</a>.<a href="#fnref:13" rev="footnote"> ↩</a></span></div><div id="fn:14" style="display:flex"><span style="width:20px">14.</span><span style="width:calc(100% - 20px)">Wikipedians. “字节序.” Wikipedia, Wikimedia Foundation, 18 Aug. 2020, zh.wikipedia.org/wiki/字节序.<a href="#fnref:14" rev="footnote"> ↩</a></span></div><div id="fn:15" style="display:flex"><span style="width:20px">15.</span><span style="width:calc(100% - 20px)">Unicode. “Glossary of Unicode Terms.” Glossary, 21 May 2020, unicode.org/glossary/.<a href="#fnref:15" rev="footnote"> ↩</a></span></div><div id="fn:16" style="display:flex"><span style="width:20px">16.</span><span style="width:calc(100% - 20px)">Wikipedians. “位元組順序記號.” Wikipedia, Wikimedia Foundation, 30 June 2020, zh.wikipedia.org/wiki/位元組順序記號.<a href="#fnref:16" rev="footnote"> ↩</a></span></div><div id="fn:17" style="display:flex"><span style="width:20px">17.</span><span style="width:calc(100% - 20px)">infocodez. “【转载】随便说说字符集和编码.” 博客园, 27 Sept. 2017, <a href="http://www.cnblogs.com/infocodez/p/7600459.html" target="_blank" rel="noopener">www.cnblogs.com/infocodez/p/7600459.html</a>.<a href="#fnref:17" rev="footnote"> ↩</a></span></div><div id="fn:18" style="display:flex"><span style="width:20px">18.</span><span style="width:calc(100% - 20px)">Wikipedians. “Unicode控制字符.” Wikipedia, Wikimedia Foundation, 28 July 2020, zh.wikipedia.org/wiki/Unicode控制字符.<a href="#fnref:18" rev="footnote"> ↩</a></span></div><div id="fn:19" style="display:flex"><span style="width:20px">19.</span><span style="width:calc(100% - 20px)">Wikipedians. “異體字選擇器.” Wikipedia, Wikimedia Foundation, 4 Sept. 2020, zh.wikipedia.org/wiki/異體字選擇器.<a href="#fnref:19" rev="footnote"> ↩</a></span></div><div id="fn:20" style="display:flex"><span style="width:20px">20.</span><span style="width:calc(100% - 20px)">Wikipedians. “組合字符.” Wikipedia, Wikimedia Foundation, 30 May 2019, zh.wikipedia.org/wiki/組合字符.<a href="#fnref:20" rev="footnote"> ↩</a></span></div><div id="fn:21" style="display:flex"><span style="width:20px">21.</span><span style="width:calc(100% - 20px)">Zachary. “Emoji与Unicode.” Emoji与Unicode · Zablog, 18 Sept. 2017, zablog.me/2017/09/18/emoji/.<a href="#fnref:21" rev="footnote"> ↩</a></span></div><div id="fn:22" style="display:flex"><span style="width:20px">22.</span><span style="width:calc(100% - 20px)">Wikipedians. “Unicode Equivalence.” Wikipedia, Wikimedia Foundation, 7 Aug. 2020, en.wikipedia.org/wiki/Unicode_equivalence.<a href="#fnref:22" rev="footnote"> ↩</a></span></div><div id="fn:23" style="display:flex"><span style="width:20px">23.</span><span style="width:calc(100% - 20px)">deerchao. “基本修养：字符集与编码.” 超越代码, 12 Sept. 2019, deerchao.cn/blog/posts/unicode.html.<a href="#fnref:23" rev="footnote"> ↩</a></span></div><div id="fn:24" style="display:flex"><span style="width:20px">24.</span><span style="width:calc(100% - 20px)">vstinner. “Programming with Unicode.” 4. Unicode - Programming with Unicode, 23 June 2017, unicodebook.readthedocs.io/unicode.html.<a href="#fnref:24" rev="footnote"> ↩</a></span></div><div id="fn:25" style="display:flex"><span style="width:20px">25.</span><span style="width:calc(100% - 20px)">Wikipedians. “UTF-8.” Wikipedia, Wikimedia Foundation, 20 Aug. 2020, zh.wikipedia.org/wiki/UTF-8.<a href="#fnref:25" rev="footnote"> ↩</a></span></div><div id="fn:26" style="display:flex"><span style="width:20px">26.</span><span style="width:calc(100% - 20px)">Cenalulu(卢钧轶) . “十分钟搞清字符集和字符编码.” Cenalulu’s Tech Blog, 25 Jan. 2015, cenalulu.github.io/linux/character-encoding/.<a href="#fnref:26" rev="footnote"> ↩</a></span></div><div id="fn:27" style="display:flex"><span style="width:20px">27.</span><span style="width:calc(100% - 20px)">Wikipedians. “Unicode Font.” Wikipedia, Wikimedia Foundation, 13 July 2020, en.wikipedia.org/wiki/Unicode_font.<a href="#fnref:27" rev="footnote"> ↩</a></span></div><div id="fn:28" style="display:flex"><span style="width:20px">28.</span><span style="width:calc(100% - 20px)">DrStrangeLove. “How Are Character Encodings Related to Fonts?” Super User, 15 Nov. 2011, superuser.com/questions/357530/how-are-character-encodings-related-to-fonts.<a href="#fnref:28" rev="footnote"> ↩</a></span></div><div id="fn:29" style="display:flex"><span style="width:20px">29.</span><span style="width:calc(100% - 20px)">Belleve. “字符编码与字体的关系是什么？.” 知乎, 27 Apr. 2015, <a href="http://www.zhihu.com/question/29924586" target="_blank" rel="noopener">www.zhihu.com/question/29924586</a>.<a href="#fnref:29" rev="footnote"> ↩</a></span></div><div id="fn:30" style="display:flex"><span style="width:20px">30.</span><span style="width:calc(100% - 20px)">Davis, Mark, and Christopher Chapman. Unicode Text Segmentation. 19 Feb. 2020, unicode.org/reports/tr29/.<a href="#fnref:30" rev="footnote"> ↩</a></span></div><div id="fn:31" style="display:flex"><span style="width:20px">31.</span><span style="width:calc(100% - 20px)">Pike, R. (2013, October 23). Strings, bytes, runes and characters in Go. Retrieved September 19, 2020, from <a href="https://blog.golang.org/strings" target="_blank" rel="noopener">https://blog.golang.org/strings</a><a href="#fnref:31" rev="footnote"> ↩</a></span></div><div id="fn:32" style="display:flex"><span style="width:20px">32.</span><span style="width:calc(100% - 20px)">Unicode Consortium. (2020, September 19). Characters and Combining Marks. Retrieved September 19, 2020, from <a href="http://unicode.org/faq/char_combmark.html" target="_blank" rel="noopener">http://unicode.org/faq/char_combmark.html</a><a href="#fnref:32" rev="footnote"> ↩</a></span></div><div id="fn:33" style="display:flex"><span style="width:20px">33.</span><span style="width:calc(100% - 20px)">Hosken, M., &amp; Gaultney, V. (2003, September 5). Guidelines for Writing System Support: Technical Details: Smart Rendering: Part 1. Retrieved September 20, 2020, from <a href="https://scripts.sil.org/cms/scripts/page.php?site_id=nrsi" target="_blank" rel="noopener">https://scripts.sil.org/cms/scripts/page.php?site_id=nrsi</a><a href="#fnref:33" rev="footnote"> ↩</a></span></div><div id="fn:34" style="display:flex"><span style="width:20px">34.</span><span style="width:calc(100% - 20px)">Unicode Consortium. (2002, October 28). A General Method for Rendering Combining Marks. Retrieved September 20, 2020, from <a href="http://www.unicode.org/notes/tn2/" target="_blank" rel="noopener">http://www.unicode.org/notes/tn2/</a><a href="#fnref:34" rev="footnote"> ↩</a></span></div></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;在和朋友聊天时，突然无话可说，屏幕前的你该如何是好呢? 很多时候屏幕前的我们，都会想到发个表情，然后彼此心照不宣地沉默。如果你用的是windows 10的新版本，按下 &lt;code&gt;winkey + period&lt;/code&gt; （即windows图标和英文句点按钮），就会有如下的弹出框。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/character_set/image_1_1.png&quot; alt=&quot;image_1_1.png&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图1.1&lt;/p&gt;

&lt;p&gt;反复斟酌、几度纠结之后，你选择了这样一个表情：😤。将鼠标停留在这个表情上几秒，可以看到提示文字：“傲慢”。如果你用的是andriod、ios，在输入法中仔细搜寻，一定也可以发现这样一个表情。&lt;/p&gt;
&lt;p&gt;如果哪里都找不到，也没关系，直接将这个表情复制，粘贴到微信聊天框中，回车，成功地将这个表情发了出去。在对方沉默不语的时间里，你点开了微信对话框里的表情，却发现怎么也找不着这个傲慢的表情?！但是这个表情的确正确地显示了呀?这是怎么回事呢?“微信连不存在的表情都支持，太厉害了叭！”也许你会发出这样的感慨。也有可能你会嗤之以鼻：“不过是显示了一张图片而已”。不过，这真的是图片吗? 且听我缓缓道来。&lt;br&gt;
    
    </summary>
    
      <category term="techonology" scheme="https://blog.xuwei.fun/categories/techonology/"/>
    
      <category term="cs" scheme="https://blog.xuwei.fun/categories/techonology/cs/"/>
    
    
      <category term="character set" scheme="https://blog.xuwei.fun/tags/character-set/"/>
    
      <category term="encode" scheme="https://blog.xuwei.fun/tags/encode/"/>
    
      <category term="emoji" scheme="https://blog.xuwei.fun/tags/emoji/"/>
    
  </entry>
  
  <entry>
    <title>日语学习十一</title>
    <link href="https://blog.xuwei.fun/2020/05/04/japanese12/"/>
    <id>https://blog.xuwei.fun/2020/05/04/japanese12/</id>
    <published>2020-05-04T10:08:23.000Z</published>
    <updated>2020-05-04T10:57:11.264Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇介绍了一些实用表达，这一篇聊几句语篇。<br>语篇是在读这本语法教程<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.">[1]</span></a></sup>中了解到的，想想也的确有道理，学习了音素、书写，记忆了单词，学会了语法，知道如何去表达一句话，总还有比一句话更广一点的语法概念的.<br>语篇的概念在该书<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="关春园, 徐宏亮. 多元化视角下的日语研究. 新华出版社, 2015.">[2]</span></a></sup>中也有描述:</p><blockquote><p>普通语言学认为，语言的结构单位自上而下分为五级，即: 词素、词、词组、句子以及大于句子的语言单位。语篇是大于句子的语言单位。在特定语境中，一个句子也可以视为语篇.</p></blockquote><p>专业的日语研究者想要看学术性的语篇研究，这篇”现代日语语篇研究”<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="杜静波. 现代日语语篇研究. Diss.">[3]</span></a></sup>的论文应该值得一看.</p><p>只不过，姑且认为语篇就是文章的一部分的话，那么分析文章、写文章的难点，其实不在于语言本身，无论是中文、英语还是日语，想要写出好文章，逻辑、思想才是最难的~</p><a id="more"></a><h2 id="1-语篇连贯"><a href="#1-语篇连贯" class="headerlink" title="1. 语篇连贯"></a>1. 语篇连贯</h2><p>语篇连贯即:</p><ul><li>语篇内部各部分在意义上是相互联系的</li><li>语篇的衔接形成的语义网络形成一个语义整体</li><li>语篇必须适合情景语境, 在语境中有适当的功能</li></ul><p>日语研究<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="关春园, 徐宏亮. 多元化视角下的日语研究. 新华出版社, 2015.">[2]</span></a></sup>中总结出的语篇连贯概念的四个基本特点有:</p><ul><li>整体性</li><li>分级性</li><li>连接性</li><li>功能性</li></ul><h2 id="2-语篇内部衔接的手段"><a href="#2-语篇内部衔接的手段" class="headerlink" title="2. 语篇内部衔接的手段"></a>2. 语篇内部衔接的手段</h2><p>一般来说有: 指示与词汇衔接、预设、替代与省略、会话含义、话语分析等…<br>学术性的东西，就不搬运太多了~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章提及了下语篇，至此，日语学习系列的主框架也就完结了。剩下的，就是练习、练习、再练习了，直到不用再思考语法这件事.</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)">马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.<a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)">关春园, 徐宏亮. 多元化视角下的日语研究. 新华出版社, 2015.<a href="#fnref:2" rev="footnote"> ↩</a></span></div><div id="fn:3" style="display:flex"><span style="width:20px">3.</span><span style="width:calc(100% - 20px)">杜静波. 现代日语语篇研究. Diss.<a href="#fnref:3" rev="footnote"> ↩</a></span></div></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇介绍了一些实用表达，这一篇聊几句语篇。&lt;br&gt;语篇是在读这本语法教程&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;中了解到的，想想也的确有道理，学习了音素、书写，记忆了单词，学会了语法，知道如何去表达一句话，总还有比一句话更广一点的语法概念的.&lt;br&gt;语篇的概念在该书&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;关春园, 徐宏亮. 多元化视角下的日语研究. 新华出版社, 2015.
&quot;&gt;[2]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;中也有描述:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;普通语言学认为，语言的结构单位自上而下分为五级，即: 词素、词、词组、句子以及大于句子的语言单位。语篇是大于句子的语言单位。在特定语境中，一个句子也可以视为语篇.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;专业的日语研究者想要看学术性的语篇研究，这篇”现代日语语篇研究”&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;杜静波. 现代日语语篇研究. Diss.&quot;&gt;[3]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;的论文应该值得一看.&lt;/p&gt;
&lt;p&gt;只不过，姑且认为语篇就是文章的一部分的话，那么分析文章、写文章的难点，其实不在于语言本身，无论是中文、英语还是日语，想要写出好文章，逻辑、思想才是最难的~&lt;/p&gt;
    
    </summary>
    
      <category term="humanities" scheme="https://blog.xuwei.fun/categories/humanities/"/>
    
      <category term="languages" scheme="https://blog.xuwei.fun/categories/humanities/languages/"/>
    
    
      <category term="japanese" scheme="https://blog.xuwei.fun/tags/japanese/"/>
    
  </entry>
  
  <entry>
    <title>日语学习十</title>
    <link href="https://blog.xuwei.fun/2020/05/03/japanese11/"/>
    <id>https://blog.xuwei.fun/2020/05/03/japanese11/</id>
    <published>2020-05-03T10:58:09.000Z</published>
    <updated>2020-05-04T10:07:27.179Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇总结了日语句子的分析和改造，这一章主要介绍一些实用表达。<br>实用表达，实际上也就是一些常用助词和动词的学习，包括他们常用的变形形式. 其实也可以说就是惯用语啦. 这一篇很多都是来源于Tae Kim的教程，Tae Kim的教程中语法系统和惯用表达揉在了一起，这里将其讲解惯用表达摘了出来.</p><a id="more"></a><h2 id="1-授受表达"><a href="#1-授受表达" class="headerlink" title="1. 授受表达"></a>1. 授受表达</h2><p>参考了这两篇文章: 文章一<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="“日语语法：授受动词.” 日语语法：授受动词 - 日语入门 - 丫丫日语, 4 Jan. 2015, http://www.yayajp.com/index.php?a=shows&catid=4&id=136.">[1]</span></a></sup>、文章二<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="KIM, TAE. “授受动词.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/favors.html.">[2]</span></a></sup><br>所谓授受表达，即授予和接受，由于在日语文化中，长幼尊卑是非常重要的元素，因此授予的主体不同时，表达也各不相同。</p><h3 id="1-1-やる、あげる、さしあげる"><a href="#1-1-やる、あげる、さしあげる" class="headerlink" title="1.1 やる、あげる、さしあげる"></a>1.1 やる、あげる、さしあげる</h3><p>表示说话者一方给另一方东西时，常用到这三个词.<br>其中:</p><ul><li>「やる」用于上对下或关系密切的同辈之间或者为动植物做某事</li><li>「あげる」用于对等关系</li><li>「さしあげる」是敬语动词，用于下对上，是一种自谦表达。</li></ul><p>例句:</p><ul><li>犬に餌をやった？</li><li>花に水をやる</li><li>あなたは時には妹さんにおこづかいをあげますか</li><li>彼の誕生日に贈り物をあげたいんnです</li><li>恩師に記念品をさしあげます</li></ul><h3 id="1-2-もらう、いただく"><a href="#1-2-もらう、いただく" class="headerlink" title="1.2 もらう、いただく"></a>1.2 もらう、いただく</h3><h4 id="1-2-1-独立使用"><a href="#1-2-1-独立使用" class="headerlink" title="1.2.1 独立使用"></a>1.2.1 独立使用</h4><p>作为一个独立的动词使用时，表示从别人那里接受或得到某东西。「いただく」表示从上司或者长辈处领受某物品时。</p><ul><li>手紙をもらう</li><li>この時計は田中さんからもらったのです</li><li>結構な品物をいただきます</li></ul><h4 id="1-2-2-助词使用"><a href="#1-2-2-助词使用" class="headerlink" title="1.2.2 助词使用"></a>1.2.2 助词使用</h4><p>接在动词连用形之后，以「～てもらう」、「～ていただく」的形式作为补助动词来使用。「～ていただく」是「～てもらう」的谦逊表达。</p><ul><li>私は日本の友達に日本料理を教えてもらった</li></ul><h3 id="1-3-くれる、くださる"><a href="#1-3-くれる、くださる" class="headerlink" title="1.3 くれる、くださる"></a>1.3 くれる、くださる</h3><h4 id="1-3-1-独立使用"><a href="#1-3-1-独立使用" class="headerlink" title="1.3.1 独立使用"></a>1.3.1 独立使用</h4><p>作为一个独立的动词使用时，表示别人给自己或给属于自己一方的人予东西。「くださる」是「くれる」的敬语形式。</p><ul><li>これは友達が妹にくれた本です。</li><li>先生は私に日本の地図をくださいました。</li></ul><h4 id="1-3-2-助词使用"><a href="#1-3-2-助词使用" class="headerlink" title="1.3.2 助词使用"></a>1.3.2 助词使用</h4><p>接在动词连用形之后，以「～てくれる」、「～てくださる」的形式作为补助动词来使用。</p><ul><li>課長がこの地図を貸してくださいました。</li></ul><h3 id="1-4-表达请求"><a href="#1-4-表达请求" class="headerlink" title="1.4 表达请求"></a>1.4 表达请求</h3><h4 id="1-4-1-请求对方帮忙做什么"><a href="#1-4-1-请求对方帮忙做什么" class="headerlink" title="1.4.1 请求对方帮忙做什么"></a>1.4.1 请求对方帮忙做什么</h4><p>用くれる、もらえる表示想请人帮忙，其中「もらえる」是「もらう」的可能型</p><ul><li>千円を貸してくれる？</li><li>千円を貸してもらえる？</li></ul><h4 id="1-4-2-请对方不要作什么"><a href="#1-4-2-请对方不要作什么" class="headerlink" title="1.4.2 请对方不要作什么"></a>1.4.2 请对方不要作什么</h4><p>只要把「で」加到用言否定式后面就可以了。</p><ul><li>全部食べないでくれますか</li><li>高い物を買わないでくれる</li></ul><h3 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h3><p>Tae Kim<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="KIM, TAE. “授受动词.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/favors.html.">[2]</span></a></sup>总结得很好: “从说话者的角度来看，所有给出的东西都是「向上」的，而别人给自己的东西则是「向下」的”，你也可以理解为对方总是高高在上的，说话者一方总是需要尽量表达谦卑，以表示尊敬对方，除非对方足够亲密或者非人等.<br>特别需要说明的是”说话人”，说话者在说出一句话时，总是代表了某一方，无论是他自己还是他人，他意指何方，那么那一方就是谦卑的一方.<br>最后再给个用了多种表达的一个例句:</p><ul><li>突然にかような奇怪な手紙を差し上げる非礼をお許し下さい。</li></ul><h2 id="2-比较表达"><a href="#2-比较表达" class="headerlink" title="2. 比较表达"></a>2. 比较表达</h2><p>又是Tae Kim<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Kim, Tae. “运用「方」和「よる」.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/comparison.html.">[3]</span></a></sup>，这个系列的教程写的确实太好，就拿来主义了，当然还有Wasabi的这个系列<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Admin, Wasabi. “Japanese Comparison: より, ...の方が, and ...で一番.” Wasabi, 24 Sept. 2016, https://www.wasabi-jpn.com/japanese-grammar/japanese-comparison/.">[4]</span></a></sup>，也非常棒.<br>表达比较首先需要有比较的对象: A和B. 当我们想对这两个对象进行比较时，从汉语的角度，我们会说:</p><ul><li>“A比B更…「述語」”</li><li>“和B相比, A更…「述語」”</li><li>“A这样/A这一方/A这种情况 比 B更…「述語」”</li><li>“和B相比, A这样/A这一方/A这种情况 更…「述語」”</li></ul><p>我们会发现这些句子中，无论怎么表达，A才是主语，B是作为被比较的一方存在的.<br>考虑到日语和汉语一样基本什么语法成分也都能省略，其实A、B两方也都有可能在表达中被省略. 基于此，我们来看下面的语法。</p><h3 id="2-1-「方」"><a href="#2-1-「方」" class="headerlink" title="2.1 「方」"></a>2.1 「方」</h3><p>「方」就是用来表达 “A这样/A这一方/A这种情况” 的 “这样/这一方/这种情况”，通常在句子中都是用「Aの方」，假设上下文明确的情况下，我们省略了B，给出一些例句.</p><ul><li>ボブの方が年上です</li><li>学生じゃない方がいいよ</li></ul><h3 id="2-2-「より」"><a href="#2-2-「より」" class="headerlink" title="2.2 「より」"></a>2.2 「より」</h3><p>相对的，「より」就是用来表达 “与B相比” 中的 “与…相比” 的意思. 同样的，假设可以省略A，给出一些例句.</p><ul><li>仕事がないよりましだよ</li></ul><p>如果把双方都用上，当然也可.</p><ul><li>辛からい方ほうが甘あまいのより好すき</li></ul><p>注:</p><blockquote><p>1) <strong>被「より」粘黏的单词不需要任何时态。</strong><br>2) 可以将「より」与疑问词例如「誰」、「何」或「どこ」合用来表示与其他人或其他东西相比最高的意思</p><ul><li>この仕事は誰よりも早くできます</li></ul></blockquote><h3 id="2-3-「と同じくらい」"><a href="#2-3-「と同じくらい」" class="headerlink" title="2.3 「と同じくらい」"></a>2.3 「と同じくらい」</h3><p>这个短语可以用来表达 “A就像和B一样” 这种意思</p><ul><li>小野さんは森さんと同じくらい林檎が好すきです</li></ul><h3 id="2-4-「一番」-「最も」"><a href="#2-4-「一番」-「最も」" class="headerlink" title="2.4 「一番」/「最も」"></a>2.4 「一番」/「最も」</h3><p>这个词用来表达最高级的意思，后者比前者更正式.</p><ul><li>中国は世界で一番人口が多いです</li><li>中国は世界で最も人口が多いです</li></ul><h3 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h3><p>比较的表达并不难，明确比较双方，使用关键的两个词: 「方」和「よる」，就很容易表达</p><h2 id="3-引用表达"><a href="#3-引用表达" class="headerlink" title="3. 引用表达"></a>3. 引用表达</h2><p>这其实是复合句的一种形式，但是引用他人的话这种复合句比较特殊，在之前的复合句中也没有提及，在此补充。<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Kim, Tae. “将关系从句作为宾语.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/actionclause.html.">[5]</span></a></sup></p><h3 id="3-1-直接引用"><a href="#3-1-直接引用" class="headerlink" title="3.1 直接引用"></a>3.1 直接引用</h3><p>直接引用别人的话，最特殊的点在于，虽然是复合的句子，但是被引用的话，其语法表达、时体态，全都保持原封不动就行了，在英语中，直接给引用的句子加个引号就行，中文多了个冒号，共同点就是都是靠标点符号来区分的，而在日语中，额外多了个助词「と」来表达这种情况.</p><ul><li>「今日は授業がない」と先生から聞いたんだけど</li></ul><h3 id="3-2-转述引用"><a href="#3-2-转述引用" class="headerlink" title="3.2 转述引用"></a>3.2 转述引用</h3><p>转述不是逐字逐句的引用，所以不用加引号。和动词「思う」一起用还能用来表达想法，意为”你认为…”，或者和动词「考える」一起用表达你在考虑某事。</p><ul><li>先生から今日は授業がないと聞いたんだけど</li><li>私は、アリスと言います</li><li>レーを食べようと思ったけど、食べる時間がなかった。</li></ul><p>注:</p><blockquote><p><strong>转述引用中，如果所引用的关系从句是名词或者な形容词形成的状态表示的话，必须显式加上表陈述的「だ」</strong></p><ul><li>これは何だと言いましたか。  //（他）说这是什么?</li><li>何と言いましたか。          //（他）说什么？</li></ul></blockquote><h3 id="3-3-口语版本"><a href="#3-3-口语版本" class="headerlink" title="3.3 口语版本"></a>3.3 口语版本</h3><p>「と」在口语中经常换成「って」来表达，用这种口语版本，可以省略句子的其他部分，靠上下文让对方理解.</p><ul><li>もうお金がないって。</li></ul><p>注: <strong>日常对话中，「って」 还可以用来谈论其他任何事情，大多数时候它是用来代替「は」以提出一个新的话题。</strong></p><ul><li>明日って、雨が降るんだって。</li></ul><h2 id="4-相似性表达"><a href="#4-相似性表达" class="headerlink" title="4. 相似性表达"></a>4. 相似性表达</h2><p>这个Tae Kim已经写得很好了，参考这篇文章<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Kim, Tae. “相似性或传闻.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/similarity.html.">[6]</span></a></sup>即可.<br>介绍了「よう（様）」、「みたい」、「～そう」、「～そうだ」、「～らしい」、「っぽい」六种表达方式，经常看动画其实读起来就有很熟悉的感觉，重点关注其中的活用变化，不赘述.</p><h2 id="5-被覆盖表达"><a href="#5-被覆盖表达" class="headerlink" title="5. 被覆盖表达"></a>5. 被覆盖表达</h2><p>参考Tae Kim的这一节<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Kim, Tae. “被某物所覆盖.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/covered.html.">[7]</span></a></sup>，主要介绍了「だらけ」、「まみれ」、「ずくめ」</p><h2 id="6-意向表达"><a href="#6-意向表达" class="headerlink" title="6. 意向表达"></a>6. 意向表达</h2><p>参考Tae Kim的这一节<sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Kim, Tae. “希望和建议.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/desire.html.">[8]</span></a></sup>和这一节<sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Kim, Tae. “高级意向形.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/volitional2.html.">[9]</span></a></sup>，主要介绍了「たい」、「欲しい」、意向形，以及一些高级用法</p><h2 id="7-常用句型"><a href="#7-常用句型" class="headerlink" title="7. 常用句型"></a>7. 常用句型</h2><p>还有一些其他常用句型，在此列举一些.</p><blockquote><ul><li>～以外の何ものでもない</li><li>～か[否(いな)]か</li><li>～限りだ</li><li>～かたがた</li><li>～ずじまいだ</li></ul></blockquote><h2 id="8-常用短语"><a href="#8-常用短语" class="headerlink" title="8. 常用短语"></a>8. 常用短语</h2><p>有一些常用短语，如果去分析它们的词源或者语法结构的话，会觉得很别扭，像背单词一样把它们背下来，能够做到熟练到张口就来就好了~</p><blockquote><ul><li>こちらこそ</li><li>よろしくお願いします</li><li>いらっしゃいませ</li><li>いただきます</li></ul></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章主要介绍了日语中的一些实用表达，下一篇简单说几句语篇的内容，整个系列也就结束了。</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)">“日语语法：授受动词.” 日语语法：授受动词 - 日语入门 - 丫丫日语, 4 Jan. 2015, <a href="http://www.yayajp.com/index.php?a=shows&amp;catid=4&amp;id=136" target="_blank" rel="noopener">http://www.yayajp.com/index.php?a=shows&amp;catid=4&amp;id=136</a>.<a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)">KIM, TAE. “授受动词.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, <a href="http://res.wokanxing.info/jpgramma/favors.html" target="_blank" rel="noopener">http://res.wokanxing.info/jpgramma/favors.html</a>.<a href="#fnref:2" rev="footnote"> ↩</a></span></div><div id="fn:3" style="display:flex"><span style="width:20px">3.</span><span style="width:calc(100% - 20px)">Kim, Tae. “运用「方」和「よる」.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, <a href="http://res.wokanxing.info/jpgramma/comparison.html" target="_blank" rel="noopener">http://res.wokanxing.info/jpgramma/comparison.html</a>.<a href="#fnref:3" rev="footnote"> ↩</a></span></div><div id="fn:4" style="display:flex"><span style="width:20px">4.</span><span style="width:calc(100% - 20px)">Admin, Wasabi. “Japanese Comparison: より, …の方が, and …で一番.” Wasabi, 24 Sept. 2016, <a href="https://www.wasabi-jpn.com/japanese-grammar/japanese-comparison/" target="_blank" rel="noopener">https://www.wasabi-jpn.com/japanese-grammar/japanese-comparison/</a>.<a href="#fnref:4" rev="footnote"> ↩</a></span></div><div id="fn:5" style="display:flex"><span style="width:20px">5.</span><span style="width:calc(100% - 20px)">Kim, Tae. “将关系从句作为宾语.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, <a href="http://res.wokanxing.info/jpgramma/actionclause.html" target="_blank" rel="noopener">http://res.wokanxing.info/jpgramma/actionclause.html</a>.<a href="#fnref:5" rev="footnote"> ↩</a></span></div><div id="fn:6" style="display:flex"><span style="width:20px">6.</span><span style="width:calc(100% - 20px)">Kim, Tae. “相似性或传闻.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, <a href="http://res.wokanxing.info/jpgramma/similarity.html" target="_blank" rel="noopener">http://res.wokanxing.info/jpgramma/similarity.html</a>.<a href="#fnref:6" rev="footnote"> ↩</a></span></div><div id="fn:7" style="display:flex"><span style="width:20px">7.</span><span style="width:calc(100% - 20px)">Kim, Tae. “被某物所覆盖.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, <a href="http://res.wokanxing.info/jpgramma/covered.html" target="_blank" rel="noopener">http://res.wokanxing.info/jpgramma/covered.html</a>.<a href="#fnref:7" rev="footnote"> ↩</a></span></div><div id="fn:8" style="display:flex"><span style="width:20px">8.</span><span style="width:calc(100% - 20px)">Kim, Tae. “希望和建议.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, <a href="http://res.wokanxing.info/jpgramma/desire.html" target="_blank" rel="noopener">http://res.wokanxing.info/jpgramma/desire.html</a>.<a href="#fnref:8" rev="footnote"> ↩</a></span></div><div id="fn:9" style="display:flex"><span style="width:20px">9.</span><span style="width:calc(100% - 20px)">Kim, Tae. “高级意向形.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, <a href="http://res.wokanxing.info/jpgramma/volitional2.html" target="_blank" rel="noopener">http://res.wokanxing.info/jpgramma/volitional2.html</a>.<a href="#fnref:9" rev="footnote"> ↩</a></span></div></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇总结了日语句子的分析和改造，这一章主要介绍一些实用表达。&lt;br&gt;实用表达，实际上也就是一些常用助词和动词的学习，包括他们常用的变形形式. 其实也可以说就是惯用语啦. 这一篇很多都是来源于Tae Kim的教程，Tae Kim的教程中语法系统和惯用表达揉在了一起，这里将其讲解惯用表达摘了出来.&lt;/p&gt;
    
    </summary>
    
      <category term="humanities" scheme="https://blog.xuwei.fun/categories/humanities/"/>
    
      <category term="languages" scheme="https://blog.xuwei.fun/categories/humanities/languages/"/>
    
    
      <category term="japanese" scheme="https://blog.xuwei.fun/tags/japanese/"/>
    
  </entry>
  
  <entry>
    <title>日语学习九</title>
    <link href="https://blog.xuwei.fun/2020/05/02/japanese10/"/>
    <id>https://blog.xuwei.fun/2020/05/02/japanese10/</id>
    <published>2020-05-02T11:29:53.000Z</published>
    <updated>2020-05-03T11:41:46.517Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>距离上一次写日语学习系列已经快两年了，这两年间日语水平并没有什么长进，甚至还在倒退，但却总有一个心结，想要将这个系列完成。<br>好了，话不多说，其实之前的文章内容已经基本涵盖了日语基础语法的各个方面，而这篇文章打算说说日语中一个句子的分析和改造顺序，也算是对前面内容的一个总结。<br>日语的变形，主要体现在用言(动词/形容词/形容动词)、助动词上，这其中又属动词最为复杂。</p><a id="more"></a><h2 id="1-分析顺序"><a href="#1-分析顺序" class="headerlink" title="1. 分析顺序"></a>1. 分析顺序</h2><h3 id="1-1-说明"><a href="#1-1-说明" class="headerlink" title="1.1 说明"></a>1.1 说明</h3><p>给出一句日语，我们如何分析它用了哪些语法结构呢？</p><ol><li>如果这个句子是由多个句子复合而成的句子，首先将句子拆分，按照2至6的步骤分析单个从句，分析完从句后，将从句看作整个句子的一个成分，用符号代替，再按照2至6的步骤分析主句。需要注意的是，语气和敬意通常都是在主句中表达的，所以从句也不太可能需要分析2和3，还有一点是，如果从句本身是经过活用变形的(如假定型的活用)，先将这种变形去除.</li><li>在讲解语气的文章中提到了语气的种种分类，但实际中，语气大多还是通过特定词语、附加助词和语调的变化来表达的，因此即使一个句子用到了特定的语气，也不会在句子形式上有大的变化，最常见的也只是添加了句尾助词，可以先将助词去掉，简化句子，再做分析.</li><li>之后我们需要区分的是这句话是否是敬语形式，敬语的形式很容易看出来，因此如果用了敬语，那么先将这个句子还原为普通形式.</li><li>在还原为普通形式后，可以继续分析该句是否用到了特殊的”体”，如「ている」这种表示持续体的特殊形式，如果有的话，将特殊的”体”去掉，再次简化句子.</li><li>已经去掉了”体”的变形，之后就是分析简化的句子中，是否还用到了特殊的语态，如果用到了语态，就将其变化形式还原.</li><li>经过以上还原后，剩下的句子就只剩下时和极性的变形了，而时和极性我们通常都是放在一起记忆的，所以也可以一次性将其还原为基本型. 如果硬要分一个顺序，应该是先还原时，再还原极性.</li></ol><h3 id="1-2-示例"><a href="#1-2-示例" class="headerlink" title="1.2 示例"></a>1.2 示例</h3><p>写了这么多，给出几个句子我们分析一下。</p><ol><li><p>人は褒められれば嬉しいものなのです<br>这个句子首先是一个复合句，那么先分析从句: 「人は褒められれば」<br>由于用了假定型，将其还原为 「人は褒められる」<br>可以看出现在这种形式，是用了被动态的，将其还原为「人は褒める」<br>这样从句就分析完毕了，接着分析主句「嬉しいものなのです」<br>可以看出主句只用了敬语的一种比较特殊的形式「な+のです」，直接简化为「嬉しいものだ」</p></li><li><p>勉強をさせられている生徒に教えることは、ザルに水を注ぎ続けるようなもの！<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="“消えた記事？　「勉強する」「させられる」.” 勉強が楽しくなる塾, 5 June 2015, https://shou3.ti-da.net/e7625869.html.">[1]</span></a></sup><br>这个句子也是一个复句，可以当作包孕句处理吧。<br>首先分析前半句，「勉強をさせられている生徒に教えることは」，<br>去掉从句的连接词，句子可以简化为「勉強をさせられている生徒に教える」.<br>而这个从句中还有一个定语从句「勉強をさせられている」，这个句子用了「ている」的”体”表示一种持续的状态，简化后变为「勉強をさせられる」<br>而「勉強をさせられる」又是典型的被役态，还原成最基本的形式就是「勉強をする」<br>这样就可以理解前半句的意思了: “教一直被逼着学习的学生这种事”.<br>再分析后半句，「ザルに水を注ぎ続けるようなもの」，后半句没有用到特殊的变形，只是用了「ようなもの」这种惯用语，表示”像xx一样”</p></li></ol><h2 id="2-改造顺序"><a href="#2-改造顺序" class="headerlink" title="2. 改造顺序"></a>2. 改造顺序</h2><h3 id="2-1-说明"><a href="#2-1-说明" class="headerlink" title="2.1 说明"></a>2.1 说明</h3><p>给定一个句子，如何去分析已经了解了。那在实际语境下，假设我们从最基础的形式出发，需要以什么样的顺序来对这个句子进行变形，从而达到我们想要表达的意思呢？ 其实就是把分析的过程倒过来就行.</p><ol><li>先明确句子的极性和时</li><li>再思考这句话的主体、情态，是否需要用到特殊的语态</li><li>考虑语境下是否有特殊的时间状态，即是否要用到体的变形</li><li>是否需要用敬体，如果需要用敬体的时和体替换原有的时和体</li><li>如果需要特殊语气，就通过助词和语调调整</li><li>单句无法表达时，通过组合句子来表达</li></ol><h3 id="2-2-示例"><a href="#2-2-示例" class="headerlink" title="2.2 示例"></a>2.2 示例</h3><p>平时在看剧时，多分析看到的复杂句是怎么构成的，如果是自己来表达同样的意思，会怎么表达，这样就好啦，具体的示例就不给了，意义也不大~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分析的目的，和语文、英语的拆解句子结构一样，就是熟悉语法。<br>改造的目的，和语文、英语中的造句一样，就是正确熟练地表达。<br>等到不拘于此，不再需要思考如何去理解、如何去说，直接就能阅读和表达时，也就是真正掌握日语语法的时候.<br>本篇文章主要总结了日语中句子的分析和改造顺序，下一篇将介绍日语中的一些实用表达。</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)">“消えた記事？　「勉強する」「させられる」.” 勉強が楽しくなる塾, 5 June 2015, <a href="https://shou3.ti-da.net/e7625869.html" target="_blank" rel="noopener">https://shou3.ti-da.net/e7625869.html</a>.<a href="#fnref:1" rev="footnote"> ↩</a></span></div></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;距离上一次写日语学习系列已经快两年了，这两年间日语水平并没有什么长进，甚至还在倒退，但却总有一个心结，想要将这个系列完成。&lt;br&gt;好了，话不多说，其实之前的文章内容已经基本涵盖了日语基础语法的各个方面，而这篇文章打算说说日语中一个句子的分析和改造顺序，也算是对前面内容的一个总结。&lt;br&gt;日语的变形，主要体现在用言(动词/形容词/形容动词)、助动词上，这其中又属动词最为复杂。&lt;/p&gt;
    
    </summary>
    
      <category term="humanities" scheme="https://blog.xuwei.fun/categories/humanities/"/>
    
      <category term="languages" scheme="https://blog.xuwei.fun/categories/humanities/languages/"/>
    
    
      <category term="japanese" scheme="https://blog.xuwei.fun/tags/japanese/"/>
    
  </entry>
  
  <entry>
    <title>Metaheuristic algorithm —— Concept</title>
    <link href="https://blog.xuwei.fun/2018/11/19/metaheuristicAlgorithm01/"/>
    <id>https://blog.xuwei.fun/2018/11/19/metaheuristicAlgorithm01/</id>
    <published>2018-11-19T13:21:09.000Z</published>
    <updated>2019-05-25T08:06:54.900Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Kino的课题常需要用到元启发式算法，就在此稍稍总结。<br>元启发式(metaheuristic)，很多时候也被称为智能优化(intelligent optimization)、现代启发式(Modern Heuristic)、智能计算(Intelligent Computation)、自然计算(Natural Computation)等，细分到具体算法有<em>遗传算法</em>、<em>粒子群算法</em>、<em>差分进化算法</em>、<em>蚁群算法</em>等。<br><strong>元启发式(metaheuristic)</strong>这个词本身可以拆成两部分来看，<em>元(meta)</em>和<em>启发式(heuristic)</em>，本文主要从这两方面来阐述元启发式的概念，后续文章再介绍各算法的原理、步骤、代码等。</p><a id="more"></a><h3 id="1-Meta"><a href="#1-Meta" class="headerlink" title="1. Meta"></a>1. Meta</h3><p>首先来解释<em>元(meta)</em>，程序员对这个词并不陌生，学习编程语言到某个阶段总会出来一个<em>元编程(metaprogramming)</em>技术，还会经常见到<em>元数据(metadata)</em>等。与顾名思义的一些概念相比，<em>元</em>的概念就有点晦涩了，初次遇见总是一脸诧异，难以理解。<br>感性上来看，<strong>metaXXX</strong>就是相比XXX来说更高级的一种概念/理论，是研究超越XXX的存在，玄之又玄，不能理解不是你的错，就像形而上学(metaphysics)一样难以理解。<br>而不去探讨<strong>meta</strong>哲学性质的意义，只考虑其作为前缀(prefix)的情况，根据<em>meta</em>在Wikipedia的相应词条<a href="https://en.wikipedia.org/wiki/Meta" target="_blank" rel="noopener">Meta</a><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. (2018, November 12). Meta. Retrieved from https://en.wikipedia.org/wiki/Meta">[1]</span></a></sup>，<strong>meta</strong>大多数时候可以理解为<strong>X about X</strong>，大致翻译为<strong>关于X的X</strong>，这里的<strong>关于</strong>在中文语境里通常用<strong>实现、描述、编写</strong>等动词代替。例如<strong>metadata</strong>就是<strong>data about data</strong>，即描述数据的数据，<strong>metaprogramming</strong>就是<strong>programming about programming</strong>，即<strong>编写程序的程序</strong>，诸如此类。如果有需要，这种概念还可以递归，即添加任意多的<strong>meta</strong>前缀，变身成为<strong>metametameta…</strong>。<br>在此基础上再去看<strong>meta</strong>的中文翻译<strong>元</strong>，就会发现这个翻译其实很巧妙。“元”汉语里有 起源/开始(如元旦/元始天尊)、基本/根本(如元素/元气/元件) 的意思，完美地涵盖了meta想要表达的意思。然而<strong>元</strong>这个字很少单用，已经融合在最常见的一些词语中，所以当看到用<strong>元</strong>的前缀生造出的词语时，大多数人还是会难以理解。</p><p>这样说完感觉可能还是一片迷茫，就拿上面所说的<em>metadata</em>和<em>metaprogramming</em>作为示例来具体说明。</p><h4 id="1-1-Metadata"><a href="#1-1-Metadata" class="headerlink" title="1.1 Metadata"></a>1.1 Metadata</h4><p>关于Metadata，循序渐进地来举几个栗子。</p><ul><li>填写各类登记表时，通常需要填写姓名、性别、爱好等信息，那么我们填写的信息<strong>Kino、女、睡觉</strong>就是具体需要的data，而<strong>姓名、性别、爱好</strong>这种描述属性的文字，就属于metadata</li><li>对上面的内容稍加扩展，可以认为在进行关系型数据库设计时，我们建立的表结构就可以看作是metadata，而最终记录到表中的内容就是data，而对于K-V数据库来说，也不妨理解为Key是metadata，Value是data，JSON数据自然也可如此理解。</li><li>XML数据格式，XML(Extensible Markup Language)作为一种标记语言(Markup Language)，本就是Metadata一种表现形式。可以把XML的tag和property的key作为metadata，而把content和property的value作为data。HTML作为XML的亲戚，也可以如此理解，而至于HTML中的meta标签，又是将整个HTML文件看作data，这个meta标签里的内容就是用来描述这整个HTML的data也就是metadata了，比如<code>&lt;meta name=&quot;google-site-verification&quot; content=&quot;......&quot; /&gt;</code></li></ul><h4 id="1-2-Metaprogramming"><a href="#1-2-Metaprogramming" class="headerlink" title="1.2 Metaprogramming"></a>1.2 Metaprogramming</h4><p>按照上面的逻辑继续下去，变量声明就是描述变量的类型，难道就是metaprogramming了吗? 显然不会是这么简单的事情。<br>metaprogramming本身还是一个比较宏观的定义，对应到不同编程语言的具体实现上，又各有不同。下面简单叙述几种语言的metaprogramming机制，只要实际使用过其中一种，就不难理解了。</p><ul><li>C++：在C++中，可以利用模板实现元编程，在Effective C++中就有关于模板元编程的讨论</li><li>Java：在Java中，最为人熟知的反射，就可以用来实现元编程</li><li>Python：在Python中，如果一个类继承的不是object而是type，那么它就被成为<strong>元类(metaclass)</strong>，可以用元类来验证、注册子类，这也可以称为元编程</li></ul><p>从上面的例子中总结一下，元编程的实现手段各异，但大多是想解决这几个问题：</p><ul><li>设计中出现的相似内容太多，而这些重复内容存在于类层面，已经不能通过类的抽象来解决了，或者解决起来更为复杂(比如引入过于复杂的设计模式等)，这个时候需要更高一层的抽象来处理问题，解决这个问题的过程就可以称为元编程，Python中的metaclass就是典型的应用</li><li>面向对象程序的设计中，类的定义是在编译期就确定的，运行时动态生成的是实例，如果想要更高一层，在运行时动态生成类，那么这个实现过程就可以称为元编程，Java中的反射是典型的应用</li><li>…</li></ul><p>这也提醒了我们，在使用元编程前需要思考这个问题是否必须使用元编程、使用元编程能否简化实现过程，如果可以再尝试使用，否则就需要谨慎对待。<br><strong>元编程更大程度上是一个概念和思想，而不是一个具体方法和手段</strong></p><h4 id="1-3-Off-topic"><a href="#1-3-Off-topic" class="headerlink" title="1.3 Off topic"></a>1.3 Off topic</h4><p>思维一发散，意识就止不住到处游走，虽然离题万里，但且记录在此吧。</p><blockquote><p>突然想到导师最喜欢提的问题：“你这个效能评估的参数选取标准是什么呢？你怎么证明你这个效能评估的结果是可信的呢？毁伤评估的结果是怎么得来的呢？”似也有点元的意味，而且还可以无限递归，最终变成“评估评估…评估的结果”。如果该项工作有客观的评估标准，评估起来就相对简单可信，如果没有客观标准，靠专家标准或者自己选取的参数标准评估，可信性就大打折扣了，这个时候就可以再追问一句：“你怎么评价你选取的参数是可靠的呢？”。<br>今天刚好看到<a href="https://en.wikipedia.org/wiki/2019_redefinition_of_SI_base_units" target="_blank" rel="noopener">新闻</a>，国际单位制的七个基本单位重新进行了定义，都改以宇宙的基本常数为基础定义<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. (2018, November 19). 2019 redefinition of SI base units. Retrieved from https://en.wikipedia.org/wiki/2019_redefinition_of_SI_base_units">[2]</span></a></sup>，于是突然想到，所谓度量系统<strong>Metric System</strong>里的单词<strong>metric</strong>，在词源上是不是和<strong>meta</strong>同源的，毕竟metric是用来衡量一切的标准，有种meta的意味在里面，不过事实到底如何，毫无词源学基础的Kino是无法确定了。<br>似乎更能理解那句不是爱因斯坦的名言“越简单越好，但不要过于简单”，过犹不及，繁简之间如何取舍是个永恒的问题，奥卡姆剃刀并不是万能的，更何况繁简也是相互转化的，就像有时想为了简洁不停地添加meta，最终却导致设计模式的臃肿，反而更复杂了。所谓大道至简，是对还是错，还未可知。但是爱因斯坦真的说过这句：“不应否认任何理论的终极目标都是尽可能让不可削减的基本元素变得更加简单且更少，但也不能放弃对任何一个单一经验数据的充分阐释。”这似乎是个比较恰当的说法。</p></blockquote><h3 id="2-Heuristic"><a href="#2-Heuristic" class="headerlink" title="2. Heuristic"></a>2. Heuristic</h3><p>维基百科也有启发式(Heuristic)的词条<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. (2014, May 25). Heuristic (computer science). Retrieved from https://en.wikipedia.org/wiki/Heuristic_(computer_science)">[3]</span></a></sup>，但实际的定义很简单。<br>启发式算法(Heuristic)算法和精确(Exact)算法相对应，它们的求解对象都是运筹优化类问题。区别在于，对于组合优化等非凸优化问题，用精确算法虽可求出其全局最优解，但计算效率低，有时还是NP问题，规模变大则无法在有限时间内求解，而利用启发式算法，可以提高计算效率，但求得的解可能只是较好的次优解，而不能达到全局最优解。<br>针对一个具体的优化问题，提出一个在计算效率和求解质量间取得均衡的具体算法，这个算法就叫做启发式算法。<br>例如需要求解\(y=f(x)\)的最小值，用精确求解可以得到准确值为\(\min{y}=22\)，耗时\(t=10s\)，而使用启发式算法求得的结果是\(\min{y}=22.22\)，但耗时只有\(t=3s\)。<br>对于精确求解法，具体包括穷举法、分支定界法、割平面法、动态规划法等，而对于传统的启发式算法，包括构造型方法、局部搜索算法、松弛方法、解空间缩减法等。</p><h3 id="3-Metaheuristic"><a href="#3-Metaheuristic" class="headerlink" title="3. Metaheuristic"></a>3. Metaheuristic</h3><p>综合以上概念，将meta和heuristic结合得到的所谓元启发(metaheuristic)，理论定义上应该是<strong>heuristic about heuristic</strong>，但是这种<strong>实现启发式的启发式</strong>，还是很难直观理解。<br>先回到刚刚说的启发式算法，严格意义上的启发式，是针对某个特定优化问题的，只要是能够取得较好值的算法都可以叫做启发式算法，而元启发，就是给定一套流程/方法论，对不同的问题，只要按照该流程设计，就能实现一个针对具体问题的启发式算法，因此把这个抽象的流程称之为元启发。换句话说，启发式是面向问题的(Problem Oriented)，而元启发是面向方法的(Method Oriented)。最常见的比如遗传算法，它只给定了一个标准流程：编码-&gt;初始化-&gt;选择-&gt;交叉-&gt;变异-&gt;…，而针对一个具体的优化问题，需要设计特定的编码方式、选择特定的适应度函数…，如此设计完成的具体算法才是启发式算法。<br><strong>但是、然而、不过</strong>，现在的论文中，大多数时候把元启发和启发式也混着用，在整篇文章中，通常只使用元启发式或启发式其中一个词，所以界限并没有那么分明了，元启发经常被称为启发式、启发式也经常被叫做元启发。<br>元启发也有维基百科页面，<a href="https://en.wikipedia.org/wiki/Metaheuristic" target="_blank" rel="noopener">戳这里</a></p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>传统的任务分配、组合优化类等运筹学问题，大多都可以抽象成非凸优化的模型，也是NP问题，无法用传统方法求解，同时这些问题大多缺少或不能统计历史数据，因此也无法使用有监督机器学习等算法，这种情况下使用智能优化算法就非常合适。<br>针对这些运筹学问题，只要能够利用元启发算法的思想设计出合理的启发式算法，从而解决问题，其实就是一个很好的工作，但是现在的研究导向是发论文至上，研究智能优化算法的实验室也不例外，一切以发论文为导向，设计全新的元启发式算法实在困难，于是现在的论文大多还是Problem Oriented，通过说动听的故事阐述问题意义，再找出和之前的问题区别，比如多了一个小小的约束条件，这时就可以命名这个问题为XXXXX，以此说明自己定义了一个新问题，再抽象出该问题的数学模型(大多数时候只是在目标函数或约束条件上做些许修改，太简单没有做的意义，太复杂元启发也难以求解)，然后根据元启发算法的流程设计出完整的算法(在流程中的任一处加一点修改即可称之为改进)，编程实现算法做比较，得出结论;当然Method Oriented也还是有的，刚刚提到的一些小的改动、针对经典的TSP等做算法改进、超多目标优化问题的求解方法等。<br>总之一切为了论文，至于这些论文里的问题是否真的有意义、方法是否真的有创新，谁在乎呢。</p><h3 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h3><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)">Wikipedians. (2018, November 12). Meta. Retrieved from <a href="https://en.wikipedia.org/wiki/Meta" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Meta</a><a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)">Wikipedians. (2018, November 19). 2019 redefinition of SI base units. Retrieved from <a href="https://en.wikipedia.org/wiki/2019_redefinition_of_SI_base_units" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/2019_redefinition_of_SI_base_units</a><a href="#fnref:2" rev="footnote"> ↩</a></span></div><div id="fn:3" style="display:flex"><span style="width:20px">3.</span><span style="width:calc(100% - 20px)">Wikipedians. (2014, May 25). Heuristic (computer science). Retrieved from <a href="https://en.wikipedia.org/wiki/Heuristic_(computer_science)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heuristic_(computer_science)</a><a href="#fnref:3" rev="footnote"> ↩</a></span></div><div id="fn:4" style="display:flex"><span style="width:20px">4.</span><span style="width:calc(100% - 20px)">Wikipedians. (2018, November 16). Metaheuristic. Retrieved from <a href="https://en.wikipedia.org/wiki/Metaheuristic" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Metaheuristic</a><a href="#fnref:4" rev="footnote"> ↩</a></span></div></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Kino的课题常需要用到元启发式算法，就在此稍稍总结。&lt;br&gt;元启发式(metaheuristic)，很多时候也被称为智能优化(intelligent optimization)、现代启发式(Modern Heuristic)、智能计算(Intelligent Computation)、自然计算(Natural Computation)等，细分到具体算法有&lt;em&gt;遗传算法&lt;/em&gt;、&lt;em&gt;粒子群算法&lt;/em&gt;、&lt;em&gt;差分进化算法&lt;/em&gt;、&lt;em&gt;蚁群算法&lt;/em&gt;等。&lt;br&gt;&lt;strong&gt;元启发式(metaheuristic)&lt;/strong&gt;这个词本身可以拆成两部分来看，&lt;em&gt;元(meta)&lt;/em&gt;和&lt;em&gt;启发式(heuristic)&lt;/em&gt;，本文主要从这两方面来阐述元启发式的概念，后续文章再介绍各算法的原理、步骤、代码等。&lt;/p&gt;
    
    </summary>
    
      <category term="techonology" scheme="https://blog.xuwei.fun/categories/techonology/"/>
    
      <category term="cs" scheme="https://blog.xuwei.fun/categories/techonology/cs/"/>
    
    
      <category term="algorithm" scheme="https://blog.xuwei.fun/tags/algorithm/"/>
    
      <category term="metaheuristic" scheme="https://blog.xuwei.fun/tags/metaheuristic/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Summary 01 — Cycle Detection</title>
    <link href="https://blog.xuwei.fun/2018/10/29/leetcode01/"/>
    <id>https://blog.xuwei.fun/2018/10/29/leetcode01/</id>
    <published>2018-10-29T08:33:40.000Z</published>
    <updated>2019-05-18T14:24:33.126Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前段时间忙于找工作，因而有正大光明的托词和导师说，11月之后再去做课题相关的事情，也就有了一段较为自由的时间。<br>其中诸多准备，免不了在Leetcode上刷题，虽然对于最终的结果来说没有帮助，但刷题过程中遇到了一些解决思路相似的问题，就依次将这些共性问题阐述一遍罢了。<br>本系列的第一篇介绍的是环检测问题，对应的维基百科页面有<a href="https://en.wikipedia.org/wiki/Cycle_detection" target="_blank" rel="noopener">Cycle detection</a>。这类问题最常见的求解算法是Floyd Cycle Algorithm/Floyd’s Tortoise and Hare，中文名通常为Floyd判圈算法/龟兔赛跑算法。</p><a id="more"></a><h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>在计算机科学中，有一类问题称之为<strong>环检测问题</strong>，即对于一个由迭代函数(iterated function)值组成的序列，判断该序列是否有环及环出现的位置。<br>关于什么是迭代函数(iterated function)，严格定义可以查看<a href="https://en.wikipedia.org/wiki/Iterated_function" target="_blank" rel="noopener">这里</a>，简单来说就是一个函数\(f\)，其定义域和值域都是集合\(X\)，那么对于某个自变量/输入\(a\)，其因变量/输出\(b\)也可以作为函数\(f\)的自变量/输入，如此给定一个初始值\(x\)，将\(f\)的每一次输出作为下一次的输入，如此重复\(n\)次，就称作函数\(f\)的第\(n\)次迭代。</p><p>对于上述函数\(f\)，如果其集合\(X\)是有限的，那么对于序列:<br>$$<br>S = \{x_0, x_1 = f(x_0), x_2 = f(x_1), \cdots, x_i = f(x_{i-1}), \cdots\}<br>$$<br>那么必然会有两个位置\(i\)和\(j\)，且\(i &lt; j\)，其\(x_i = x_j\)，一旦出现这种状况，显然在\(j\)位置之后，会重复从\(x_i\)到\(x_{j-1}\)的序列。所谓环检测问题，就是给定\(f\)和\(x_0\)，要求找到\(i\)和\(j\)。<br>当然对于无限集合\(X\)，是有可能不存在环的，这取决于\(f\)和\(x_0\)的共同作用。例如\(f=x^2\)，如果\(X\)的范围是复数域，那么\(x_0=0,1,-1,e^{\frac{2\pi{}mi}{n}}\)，则有环，否则没有。这里\(m\)的取值范围是整数，\(n\)的取值范围是\({1,2,3,4,6,7,8,12,14,15,16,24,28,30,31,32,\cdots}\)，就不仔细推导了，有兴趣的可以自行推导。</p><h3 id="2-求解算法"><a href="#2-求解算法" class="headerlink" title="2. 求解算法"></a>2. 求解算法</h3><p>对于上述问题，最常见的算法是Floyd’s Tortoise and Hare，其次还有Brent’s algorithm和Gosper’s algorithm等。<br>最直接的想法是记录每次迭代的值，建立一个hash表，这样可以在重复出现时直接定位，但是这种方法空间复杂度太高，故弃。</p><h4 id="2-1-Floyd’s-Tortoise-and-Hare"><a href="#2-1-Floyd’s-Tortoise-and-Hare" class="headerlink" title="2.1 Floyd’s Tortoise and Hare"></a>2.1 Floyd’s Tortoise and Hare</h4><p>对于问题描述中迭代函数组成的序列，如果存在环，那么对于\(i\ge{}\mu\)，则\(x_i = x_{i+k\lambda}\)，其中\(\lambda\)是环的长度，\(\mu\)是环的第一个元素出现的位置。<br>基于此，可以推出，\(\exists{}i = k\lambda\ge\mu\Longrightarrow{}x_i = x_{2i}\)<br>因此，只要设定两个指针\(P1\)和\(P2\)，其中\(P2\)的步长是2，\(P1\)的步长是1，那么就可以找到两个指针指向值相等的位置，反过来说，即只要存在相等值，就存在环，此时可以得出\(\nu = P2 - P1 = P1 = k\lambda\).<br>显然\(x_{\mu{}+\nu} = x_{\mu}\)，即\(x_{\nu{}+\mu} = x_{\mu}\)，故找到上述位置之后，\(P1\)仍保持原来位置，而\(P2\)放回序列最初位置，此时两个指针的推进步长都设置为1，两指针指向的值再次相等时，就是环开始的位置。找到环开始的位置后，向后迭代找到下一次重复位置，就可以得到环的长度\(\lambda\)了。<br><img src="/images/leetcode01_1.png" alt="img01"></p><h4 id="2-2-Brent’s-algorithm"><a href="#2-2-Brent’s-algorithm" class="headerlink" title="2.2 Brent’s algorithm"></a>2.2 Brent’s algorithm</h4><p>Floyd’s Tortoise and Hare算法很精巧，但是判断环存在、找到环开始位置和确定环长度需要分为三步，Brent’s algorithm效率更高，且只需要两步。<br>Brent’s algorithm也是利用了快慢两个指针的想法，但是它的想法是动态增加步长，加快搜索速度。<br>其基本意图是设立两个指针，尽快让第一个指针到达环内，然后第二个指针以步长1前进，再次相等时走过的步数正好是环的长度\(\lambda\)，具体做法如下。<br>首先，设定两个指针\(P1\)和\(P2\)，\(P2\)第一次先前进\(2^0=1\)步，在前进的过程中若始终\(x_{P2}\ne{}x_{P1}\)，则令\(P1 = P2\)，然后\(P2\)再前进\(2^1=2\)，在前进的过程中若始终\(x_{P2}\ne{}x_{P1}\)，则令\(P1 = P2\)，然后\(P2\)再前进\(2^2=4\)……<br>如此，直到出现相等的位置，在出现相等位置之前，最后一次\(P2\)前进的步数就是环的长度\(\lambda\)。<br>此时，将\(P1\)放于序列开始位置0，\(P2\)放于\(\lambda\)位置，由于\(x_{\mu} = x_{\lambda{}+\mu}\)，故只要让\(P1\)和\(P2\)依次向前前进，等到两者指向值相同时，\(P1\)的位置正好就是环的开始位置。<br><img src="/images/leetcode01_2.png" alt="img02"></p><p>Brent’s algorithm的效率比Floyd’s Tortoise and Hare要高，最差情况是Floyd’s Tortoise and Hare算法。其主要原因是，步长动态增加，速度提高，以及首次找到相同值时，记录了环的长度，而Floyd’s Tortoise and Hare算法首次找到相同值时，并不知道环的长度，只能知道环长度的整数倍。</p><h4 id="2-3-Gosper’s-algorithm"><a href="#2-3-Gosper’s-algorithm" class="headerlink" title="2.3 Gosper’s algorithm"></a>2.3 Gosper’s algorithm</h4><p>Gosper算法可以参考<a href="http://www.inwap.com/pdp10/hbaker/hakmem/flows.html" target="_blank" rel="noopener">此处</a>，Kino还没有细看，就不细说了。</p><h3 id="3-相关练习"><a href="#3-相关练习" class="headerlink" title="3. 相关练习"></a>3. 相关练习</h3><p>Leetcode上有以下数题与此相关。</p><h4 id="3-1-Leetcode-141-Linked-List-Cycle"><a href="#3-1-Leetcode-141-Linked-List-Cycle" class="headerlink" title="3.1 Leetcode 141. Linked List Cycle"></a>3.1 Leetcode 141. Linked List Cycle</h4><p><a href="https://leetcode.com/problems/linked-list-cycle" target="_blank" rel="noopener">Link</a></p><blockquote><p>Description: Given a linked list, determine if it has a cycle in it.</p></blockquote><p>Floyd’s Tortoise and Hare<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !(head-&gt;next)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* tortoise = head-&gt;next;</span><br><span class="line">    ListNode* hare = head-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(hare &amp;&amp; hare-&gt;next) &#123;</span><br><span class="line">      <span class="keyword">if</span>(tortoise == hare) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      tortoise = tortoise-&gt;next;</span><br><span class="line">      hare = hare-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Brent’s algorithm<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !(head-&gt;next)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> current_step = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> limited_step = <span class="number">1</span>;</span><br><span class="line">    ListNode* tortoise = head-&gt;next;</span><br><span class="line">    ListNode* hare = head-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(hare &amp;&amp; hare-&gt;next) &#123;</span><br><span class="line">      <span class="keyword">if</span>(tortoise == hare) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(current_step == limited_step) &#123;</span><br><span class="line">        current_step = <span class="number">0</span>;</span><br><span class="line">        limited_step *= <span class="number">2</span>;</span><br><span class="line">        tortoise = hare;</span><br><span class="line">      &#125;</span><br><span class="line">      hare = hare-&gt;next;</span><br><span class="line">      current_step++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="3-2-Leetcode-142-Linked-List-Cycle-II"><a href="#3-2-Leetcode-142-Linked-List-Cycle-II" class="headerlink" title="3.2 Leetcode 142. Linked List Cycle II"></a>3.2 Leetcode 142. Linked List Cycle II</h4><p><a href="https://leetcode.com/problems/linked-list-cycle-ii" target="_blank" rel="noopener">Link</a></p><blockquote><p>Description: Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p></blockquote><p>Floyd’s Tortoise and Hare<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !(head-&gt;next)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* tortoise = head-&gt;next;</span><br><span class="line">    ListNode* hare = head-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(tortoise != hare) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!hare || !(hare-&gt;next)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      tortoise = tortoise-&gt;next;</span><br><span class="line">      hare = hare-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tortoise = head;</span><br><span class="line">    <span class="keyword">while</span>(tortoise != hare) &#123;</span><br><span class="line">      tortoise = tortoise-&gt;next;</span><br><span class="line">      hare = hare-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tortoise;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Brent’s algorithm<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !(head-&gt;next)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> current_step = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> limited_step = <span class="number">1</span>;</span><br><span class="line">    ListNode* tortoise = head-&gt;next;</span><br><span class="line">    ListNode* hare = head-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(tortoise != hare) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!hare || !(hare-&gt;next)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(current_step == limited_step) &#123;</span><br><span class="line">        current_step = <span class="number">0</span>;</span><br><span class="line">        limited_step *= <span class="number">2</span>;</span><br><span class="line">        tortoise = hare;</span><br><span class="line">      &#125;</span><br><span class="line">      hare = hare-&gt;next;</span><br><span class="line">      current_step++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tortoise = head;</span><br><span class="line">    hare = head;</span><br><span class="line">    <span class="keyword">while</span>(current_step--) &#123;</span><br><span class="line">      tortoise = tortoise-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(tortoise != hare) &#123;</span><br><span class="line">      tortoise = tortoise-&gt;next;</span><br><span class="line">      hare = hare-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tortoise;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="3-3-Leetcode-202-Happy-Number"><a href="#3-3-Leetcode-202-Happy-Number" class="headerlink" title="3.3 Leetcode 202. Happy Number"></a>3.3 Leetcode 202. Happy Number</h4><p><a href="https://leetcode.com/problems/happy-number/" target="_blank" rel="noopener">Link</a></p><blockquote><p>Description: Write an algorithm to determine if a number is “happy”.<br>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p></blockquote><p>Floyd’s Tortoise and Hare<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tortoise = nextNum(n);</span><br><span class="line">    <span class="keyword">int</span> hare = nextNum(nextNum(n));</span><br><span class="line">    <span class="keyword">while</span>(tortoise != hare) &#123;</span><br><span class="line">      tortoise = nextNum(tortoise);</span><br><span class="line">      hare = nextNum(nextNum(hare));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tortoise == <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">nextNum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nxt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">      <span class="keyword">int</span> digit = n%<span class="number">10</span>;</span><br><span class="line">      nxt += digit*digit;</span><br><span class="line">      n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nxt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Brent’s algorithm<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> current_step = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> limited_step = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tortoise = nextNum(n);</span><br><span class="line">    <span class="keyword">int</span> hare = nextNum(nextNum(n));</span><br><span class="line">    <span class="keyword">while</span>(tortoise != hare) &#123;</span><br><span class="line">      <span class="keyword">if</span>(current_step == limited_step) &#123;</span><br><span class="line">        current_step = <span class="number">0</span>;</span><br><span class="line">        limited_step *= <span class="number">2</span>;</span><br><span class="line">        tortoise = hare;</span><br><span class="line">      &#125;</span><br><span class="line">      hare = nextNum(hare);</span><br><span class="line">      current_step++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tortoise == <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">nextNum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nxt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">      <span class="keyword">int</span> digit = n%<span class="number">10</span>;</span><br><span class="line">      nxt += digit*digit;</span><br><span class="line">      n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nxt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="3-4-Leetcode-287-Find-the-Duplicate-Number"><a href="#3-4-Leetcode-287-Find-the-Duplicate-Number" class="headerlink" title="3.4 Leetcode 287. Find the Duplicate Number"></a>3.4 Leetcode 287. Find the Duplicate Number</h4><p><a href="https://leetcode.com/problems/find-the-duplicate-number" target="_blank" rel="noopener">Link</a></p><blockquote><p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p></blockquote><p>Floyd’s Tortoise and Hare<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.empty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;nums = nums;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> tortoise = f(nums[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> hare = f(f(nums[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">while</span>(tortoise != hare) &#123;</span><br><span class="line">      tortoise = f(tortoise);</span><br><span class="line">      hare = f(f(hare));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tortoise = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(tortoise != hare) &#123;</span><br><span class="line">      tortoise = f(tortoise);</span><br><span class="line">      hare = f(hare);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tortoise;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nums[n];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Brent’s algorithm<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.empty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;nums = nums;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> current_step = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> limited_step = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tortoise = f(nums[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> hare = f(f(nums[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">while</span>(tortoise != hare) &#123;</span><br><span class="line">      <span class="keyword">if</span>(current_step == limited_step) &#123;</span><br><span class="line">        current_step = <span class="number">0</span>;</span><br><span class="line">        limited_step *= <span class="number">2</span>;</span><br><span class="line">        tortoise = hare;</span><br><span class="line">      &#125;</span><br><span class="line">      hare = f(hare);</span><br><span class="line">      current_step++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tortoise = nums[<span class="number">0</span>];</span><br><span class="line">    hare = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(current_step--) &#123;</span><br><span class="line">      tortoise = f(tortoise);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(tortoise != hare) &#123;</span><br><span class="line">      tortoise = f(tortoise);</span><br><span class="line">      hare = f(hare);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tortoise;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nums[n];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="4-实际应用"><a href="#4-实际应用" class="headerlink" title="4. 实际应用"></a>4. 实际应用</h3><p>环检测(cycle detection)问题的实际应用有 <em>伪随机数生成器(pseudorandom number generators)强度的度量</em>，比如 <em>线性同余生成器(linear congruential generator)</em>，<em>加密哈希函数的冲突检测</em>，<em>细胞自动机(cellular automaton)的振荡周期配置</em>等</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;前段时间忙于找工作，因而有正大光明的托词和导师说，11月之后再去做课题相关的事情，也就有了一段较为自由的时间。&lt;br&gt;其中诸多准备，免不了在Leetcode上刷题，虽然对于最终的结果来说没有帮助，但刷题过程中遇到了一些解决思路相似的问题，就依次将这些共性问题阐述一遍罢了。&lt;br&gt;本系列的第一篇介绍的是环检测问题，对应的维基百科页面有&lt;a href=&quot;https://en.wikipedia.org/wiki/Cycle_detection&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cycle detection&lt;/a&gt;。这类问题最常见的求解算法是Floyd Cycle Algorithm/Floyd’s Tortoise and Hare，中文名通常为Floyd判圈算法/龟兔赛跑算法。&lt;/p&gt;
    
    </summary>
    
      <category term="techonology" scheme="https://blog.xuwei.fun/categories/techonology/"/>
    
      <category term="cs" scheme="https://blog.xuwei.fun/categories/techonology/cs/"/>
    
    
      <category term="algorithm" scheme="https://blog.xuwei.fun/tags/algorithm/"/>
    
      <category term="Cycle Detection" scheme="https://blog.xuwei.fun/tags/Cycle-Detection/"/>
    
      <category term="Floyd Cycle Algorithm" scheme="https://blog.xuwei.fun/tags/Floyd-Cycle-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>日语学习八</title>
    <link href="https://blog.xuwei.fun/2018/06/29/japanese09/"/>
    <id>https://blog.xuwei.fun/2018/06/29/japanese09/</id>
    <published>2018-06-29T13:45:02.000Z</published>
    <updated>2020-05-03T10:57:47.054Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇介绍了敬语系统，这一章主要介绍日语中的复合句。日语中复句的相关概念在维基百科上有複文<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. 複文. Wikipedia, Wikimedia Foundation, 16 Apr. 2018, ja.wikipedia.org/wiki/複文.">[1]</span></a></sup>和節<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. 節 (文法). Wikipedia, Wikimedia Foundation, 18 Apr. 2018, ja.wikipedia.org/wiki/節_(文法).">[2]</span></a></sup>等。<br>区别简单句和复合句的主要标志是看它主谓关系的次数，主谓关系在语法上仅成立一次的句子叫做单句。反之，句中有两层或两层以上主谓关系的就可成为复合句。简单句与复合句的区别决不是以句子长短、单词多少而定。常常是句子很长的是简单句；句子很短，但具有两层以上主谓关系的都是复合句。</p><a id="more"></a><h2 id="1-分类和结构"><a href="#1-分类和结构" class="headerlink" title="1. 分类和结构"></a>1. 分类和结构</h2><p>根据日语复句<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="henry19931224. 日语复句. 百度文库, 16 Nov. 2011, wenku.baidu.com/view/bfe202d0b14e852458fb5731.html.">[3]</span></a></sup>、试论日语的复合句<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="谢秀忱. 试论日语的复合句. 现代外语 3(1982):33-38.">[4]</span></a></sup>和试论日语复句中从属句节的多层立体结构<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="吴春竹. 试论日语复句中从属句节的多层立体结构. 外语学刊 6(2008):49-52.">[5]</span></a></sup>等文献，可以对日语的分类和结构做出相应总结。<br>日语中存在着大量的复合句，其联系手段都是不相同的。根据联系手段的不同，大致可把日语复合句分为三大类。</p><h3 id="1-1-包孕句"><a href="#1-1-包孕句" class="headerlink" title="1.1 包孕句"></a>1.1 包孕句</h3><p>句子中的主谓宾补定状的某一个成份或者某几个成份是用主谓结构形成的，这样的句子叫包孕句。每一个顶替句子成份的主谓结构，称为从句，所以有“主语从句”“谓语从句”“宾语从句”“定语从句”“补语从句”等。其中“主语从句”“宾语从句”“补语从句”等常是主谓结构＋形式体言の构成。<br>形式体言“こと”“もの”“の”虽然本身没有固定的词意，但可充当句中各种成份，可把它们分别放在主语、宾语、补语等位置上，用来充当句中相应的各种不同的成分，不过必须在形式体言前面有其说明内容的句子或词组，相当于汉语的包孕句的结构。下面是不同的从句类型及相关示例，{}为各种从句内容。</p><h4 id="1-1-1-主语从句"><a href="#1-1-1-主语从句" class="headerlink" title="1.1.1 主语从句"></a>1.1.1 主语从句</h4><p>{魚が泳いでいるのが}見えます。<br>{向こうから来るのが}李さんです。<br>{この問題をどうやって解「と」くか}、分かりますか。<br>{私が買いたいのは}これです。</p><h4 id="1-1-2-谓语从句"><a href="#1-1-2-谓语从句" class="headerlink" title="1.1.2 谓语从句"></a>1.1.2 谓语从句</h4><p>即在句子中做述語成分<br>わが国は{土地が広いです}。<br>山田さんは{中国語が上手です}。<br>私は{息子「むすこ」が二人います}。</p><h4 id="1-1-3-宾语从句"><a href="#1-1-3-宾语从句" class="headerlink" title="1.1.3 宾语从句"></a>1.1.3 宾语从句</h4><p>即在句子中做对象语和目的语成分<br>電車が来たらまず{人が降りるのを}待ちます。<br>教師は{学生が一人一人本を読むのを}聞いています。<br>私は{王さんがどこへ行ったか}知りません。</p><h4 id="1-1-4-状语从句"><a href="#1-1-4-状语从句" class="headerlink" title="1.1.4 状语从句"></a>1.1.4 状语从句</h4><p>即在句子中做连用修饰语成分<br>今回の試験は{頭が痛くなるほど}難しいです。<br>私は{王さんが言ったとおり}やりましたが、成功しませんでした。<br>私たちの生活は{国が発展するにしたがって}良くなっていく。</p><h4 id="1-1-5-定语从句"><a href="#1-1-5-定语从句" class="headerlink" title="1.1.5 定语从句"></a>1.1.5 定语从句</h4><p>即在句子中做连体修饰语成分<br>{私が買いたい}辞書はこの日中辞典です。<br>ここは{私が勉強している}大学です。<br>{私が大学を卒業した}時、姉は25歳でした。</p><h4 id="1-1-6-补语从句"><a href="#1-1-6-补语从句" class="headerlink" title="1.1.6 补语从句"></a>1.1.6 补语从句</h4><p>私はその時まで{日本の映画館は全部指定席だと}思っていたのです。<br>私は{子供たちは立派な将来があると}考える。</p><h3 id="1-2-主从句"><a href="#1-2-主从句" class="headerlink" title="1.2 主从句"></a>1.2 主从句</h3><p>在这类复合句中，分句与分句之间的关系不是平等并列的，而是有主有从的。一般从句在前，独立于主句之外，主句在后，形成两层或两层以上的主谓关系，以各种接续助词、助动词、形式体言或用言的各种活用形、惯用形等作为联系手段，把前后两个不同的分句连结起来。根据不同意义的连接手段，可把主从句分为原因、结果、条件等从句。<br>主句和从句可以各有自己的主语，也可以通用一个主语；不同的主语时一般情况下，从句主语用が，主句主语用は（有违反此规则的时候）；通用主语的情况下，主语用は，其位置在句子的最前面。另外，接续助词与从句连接时，不同的接续助词有不同的活用形要求，请注意。</p><h4 id="1-2-1-状态从句"><a href="#1-2-1-状态从句" class="headerlink" title="1.2.1 状态从句"></a>1.2.1 状态从句</h4><p>表示同时发生的状态，“一边…一边…”<br>私は{テレビを見ながら}食事をする。<br>政府「せいふ」は{都市の発展を促進「そくしん」しつつ}、環境「かんきょう」も改善「かいぜん」していく。</p><h4 id="1-2-2-让步从句"><a href="#1-2-2-让步从句" class="headerlink" title="1.2.2 让步从句"></a>1.2.2 让步从句</h4><p>表示“虽然、即使、要是…就好了”等<br>{雨が降っているが}、訓練は中止しない。<br>{雨が降っても}、訓練は中止しない。<br>{君がもう少し早く来たらよかったのに}、バスはもう出てしまった。<br>{自分がいくらできるとも}、油断は大敵「たいてき」だ。<br>彼は{知っているくせに}、知らない振りをしている。</p><h4 id="1-2-3-条件从句"><a href="#1-2-3-条件从句" class="headerlink" title="1.2.3 条件从句"></a>1.2.3 条件从句</h4><p>日语中存在着一些用各种活用形加上不同的助词、助动词连接起来的条件从句。这种句子的意义，相当于汉语的“只要/一旦/如果/假如…就…”。 归纳起来有四种表现方法。</p><h5 id="1-2-3-1-「と」"><a href="#1-2-3-1-「と」" class="headerlink" title="1.2.3.1 「と」"></a>1.2.3.1 「と」</h5><p>主要表示客观上的事实，客观性较强，表示两种动作相继发生。<br>使用条件语「と」的规则:</p><ul><li>把「と」加到条件后面，再跟上满足了条件会发生的结果: [ 条件 ] + と + [ 结果 ]</li><li>状态表示必须显式声明: [ 状态 ] + だと + [ 结果 ]</li></ul><p>例句:</p><ul><li>学校に行かないと友達と会えないよ</li><li>たくさん食べると太るよ</li></ul><h5 id="1-2-3-2「なら-ば-」"><a href="#1-2-3-2「なら-ば-」" class="headerlink" title="1.2.3.2「なら(ば)」"></a>1.2.3.2「なら(ば)」</h5><p>使用前提条件语「なら」的规则:</p><ul><li>把「なら」加在前提条件后面: [ 假设会发生的前提条件 ] + なら + [ 结果 ]</li><li>不能加表陈述的「だ」</li></ul><p>也可以用「ならば」替代「なら」，两者意思完全一样，但前者让人感觉更正式。<br>例句:</p><ul><li>みんなが行くなら私も行く</li><li>アリスさんが言うなら問題ないよ</li></ul><h5 id="1-2-3-3「ば」"><a href="#1-2-3-3「ば」" class="headerlink" title="1.2.3.3「ば」"></a>1.2.3.3「ば」</h5><p>这种条件语是通用的，它不预设条件，也没有蕴含的意思。<br>「ば」条件语的活用规则如下，注意名词和な形容词的活用规则其实是在活用「である」里面的动词「ある」<br>「ば」的活用规则:</p><ul><li>对动词: [ 一类え形活用词根 ] + 「ば」，即把动词最后假名从 /u/ 段改为同行 /e/ 段，再加上「ば」</li><li>对い形容词以及「ない」结尾的未然形: 把最后的「い」换成「ければ」</li><li>对名词和な形容词: 加「であれば」</li></ul><p>例句:</p><ul><li>友達に会えれば、買い物に行きます</li><li>お金があればいいね</li><li>楽しければ、私も行く</li><li>楽しくなければ、私も行かない</li><li>食べなければ病気になるよ</li></ul><h5 id="1-2-3-4-「たら-ば-」完成时条件语"><a href="#1-2-3-4-「たら-ば-」完成时条件语" class="headerlink" title="1.2.3.4 「たら(ば)」完成时条件语"></a>1.2.3.4 「たら(ば)」完成时条件语</h5><p>「たら」的重点在于满足条件后发生的事，主要用来表示对事物完了的假定。<br>「たら」的活用规则:</p><ul><li>首先把名词、形容词或动词活用为过去形，再加上「ら」</li></ul><p>也可以用「たらば」替代「たら」，类似「ならば」，二者意思完全相同，只是前者感觉更正式。<br>例句:</p><ul><li>暇だったら、遊びに行くよ</li><li>学生だったら、学生割引で買えます</li></ul><h5 id="1-2-3-5-「もし」"><a href="#1-2-3-5-「もし」" class="headerlink" title="1.2.3.5 「もし」"></a>1.2.3.5 「もし」</h5><p>「もし」是条件句中常用的一个副词，用来增加一种对假设条件不确定的语气，可以翻译为“要是，如果”。但是必须搭配上述四种条件句的形式使用，「もし」本身是不能构成条件句的语法形式的。<br>例句:</p><ul><li>もしよかったら、映画を観に行きますか？</li><li>もし時間がないなら、明日でもいいよ。</li></ul><h4 id="1-2-4-原因从句"><a href="#1-2-4-原因从句" class="headerlink" title="1.2.4 原因从句"></a>1.2.4 原因从句</h4><p>表示“因为、由于”等原因，一般有以下联系手段。</p><h5 id="1-2-4-1-から"><a href="#1-2-4-1-から" class="headerlink" title="1.2.4.1 から"></a>1.2.4.1 から</h5><p>[ 原因 ] + から + [ 结果 ]<br>如果原因是字典形名词或な形容词，后面必须加「だ」来显式的表示它是原因，即「( 名词 / な形容词 ) だから」。如果忘了在「から」前面加表陈述的「だ」的话，听起来「から」就是「从…」的意思了。<br>如果是在用丁宁语的话，应该把「から」当成普通名词，在后面加「です」。<br>有上下文的时候，原因和结果都可以省略掉。省略原因的时候，必须加上表陈述的「だ」或「です」，所以经常会听到「だから」<br>例句:</p><ul><li>時間がなかったからです</li><li>うん、時間がなかったから</li><li>だからパーティーに行かなかったの？</li><li>天気が悪いから、山へ行くのは止めましょう。</li></ul><h5 id="1-2-4-2-ので"><a href="#1-2-4-2-ので" class="headerlink" title="1.2.4.2 ので"></a>1.2.4.2 ので</h5><p>「ので」基本上跟「から」可以互换使用，除了一些微妙的区别。「から」显式的表明了前面的句子是原因，而「ので」这仅仅是把两个句子连了起来，然后把前一个句子变味了解释的口吻。<br>「ので」听起来口气更柔和，也更礼貌，所以在解释做了失礼之事的原因的时候，人们更倾向于用它而非「から」。<br>总体上来看，在说话者的意志和能动性更强时，使用「から」；如果需要较恭敬的表达，或者是表达判断的理由时，用「ので」较多。<br><strong>「の」前面如果是字典形名词或者な形容词的话，一定要加「な」</strong><br>解释口气的「の」可以简写成「ん」，说话的时候「ので」也可以改成「んで」，因为这样可以省略音节 / o / 的发音，形成连读。<br>例句:</p><ul><li>時間がなかったのでパーティーに行かなかった</li><li>ちょっと忙しいので、そろそろ失礼します</li><li>私は学生なので、お金がないんです</li><li>なので、友達に会う時間がない</li><li>天気が悪いので、山へ行くのは止めました。</li></ul><h5 id="1-2-4-3-ため"><a href="#1-2-4-3-ため" class="headerlink" title="1.2.4.3 ため"></a>1.2.4.3 ため</h5><p>写成汉字应该是「為」。与「から」和「ので」相比，「ため」是一个能够与对方拉开距离的词语。<br>「から」和「ので」都是传达说话者的意志和判断的表达方式，与此相比，「ため」多用于描述发生的事情。<br>正因为此，「ため」多在新闻和论文中被使用，它能给对方一种严肃感，让人觉得情报的来源很可靠。<br>例句:</p><ul><li>大雨のため一時通行止めとなった</li><li>王さんは風邪を引いたために、会社を休みました。</li></ul><h5 id="1-2-4-4-によって"><a href="#1-2-4-4-によって" class="headerlink" title="1.2.4.4 によって"></a>1.2.4.4 によって</h5><p>「に」在表示对象、方向时通常接的是名词，但在表示目的、目标时既可接名词也可接动词简体。<br>「よって」原形为「よる」，可写做「寄る」、「拠る」、「因る」等，「～によって」這個句型在日文中是常见的，用法很多，主要有以下几种:</p><ul><li>名词 + によって(により/によりまして/による) + 名词。依据前者的条件及选项取舍的不同，結果、情況、作法也会随之改变的句型表现。「AによってB」A只能置入名詞，作为条件依据，而随着A不同B也會改变，中文意思为「依A的不同而B」。</li><li>名词 + によって(により/による) + 名词。表示事物、情況成立或发生的理由以及原因之句型表现。「AによってB」A只能置入名词，表理由、原因，因为A而造成B的场面</li><li>名词 + によって(により/による) + 名词。表示方法、手段之句型表现。「AによってB」A只能置入名词，表方法、手段，意即透过或运用A作为手段而来做B，有些人会将它与「～によると」的传闻来源表现搞混，需要注意。</li><li>名词 + によって(により/による) + 名词。表示消息、传闻的来源或出处的句型表现。「Aによると～」A只能置入名词，表示消息、传闻的来源，「によると」的結尾常与「～そうだ」、「～ということだ」一起使用。</li></ul><p>例句:</p><ul><li>日本人との付き合いによって日本語の会話を練習している</li></ul><h5 id="1-2-4-5-おかげで"><a href="#1-2-4-5-おかげで" class="headerlink" title="1.2.4.5 おかげで"></a>1.2.4.5 おかげで</h5><p>可以译为“托…的福”。<br>规则:</p><ul><li>名词 + 「の」 + 「おかげで」</li><li>形容词基本形 + 「おかげで」</li><li>形容动词 + 「な」 + 「おかげで」</li><li>动词基本形 + 「おかげで」</li></ul><p>例句:</p><ul><li>あなたのおかげで助かりました</li></ul><h5 id="1-2-4-6-せいで"><a href="#1-2-4-6-せいで" class="headerlink" title="1.2.4.6 せいで"></a>1.2.4.6 せいで</h5><p>名词「せい」的汉字是「所为」，「で」是「です」的中顿形式，可以翻译成“是…的所为”，一般是带来不好的结果。<br>规则:</p><ul><li>名词 + 「の」 + 「せいで」</li><li>形容词基本形 + 「せいで」</li><li>形容动词 + 「な」 + 「せいで」</li><li>动词基本形 + 「せいで」</li></ul><p>例句:</p><ul><li>わがままな母親のせいで、彼女は結婚が遅れた</li></ul><h4 id="1-2-5-结果从句"><a href="#1-2-5-结果从句" class="headerlink" title="1.2.5 结果从句"></a>1.2.5 结果从句</h4><p>日语中存在着这样一种句子结构: “…は…が…からです(だ、である)”。相当于汉语的“事情之所以这样，是由于…的缘故”。表示一种因果关系。<br>结果从句的“から”是作为副助词和“だ、です、である”结合起来，接在动词的连体形后面做谓语，先强调其结果，后叙述原因。<br>也可以用另一种惯用型“…のは…が…ためです”来表示</p><p>例句:</p><ul><li>任务を完成するてとができなかったのは计画が十分ではなかったからだ </li></ul><h4 id="1-2-6-目的从句"><a href="#1-2-6-目的从句" class="headerlink" title="1.2.6 目的从句"></a>1.2.6 目的从句</h4><p>表示行为的目的。<br>一般常用惯用形”…ために”、”…には”，是表示达到某种目的的句子。但这种类型的句子，一般做目的状语较多，因为前后两个事项都属于一个主体——主语，如有两层主谓关系者，可看作目的从句。</p><p>例句:</p><ul><li>私たちは{健康「けんこう」を保つために}、毎日運動をします。</li><li>{友人が早く快復「かいふく」するように}心から祈「いの」ります。</li><li>私は{朝起きるのに}目覚「めざ」ましが必要です。</li></ul><h4 id="1-2-6-方式从句"><a href="#1-2-6-方式从句" class="headerlink" title="1.2.6 方式从句"></a>1.2.6 方式从句</h4><p>日语中有这样一种惯用型: “…ように”、”…とおりに”，而这两者的前后都是一个句子形式，又具有两层主谓关系，我们可以把它统称为方式从句。</p><p>例句:</p><ul><li>レーニンが教えたように、共产党はプロレタリアートの前卫である</li></ul><p>除了表示方式以外，也可以利用 “…ように” 这一形式表示祈使目的。<br>例句:</p><ul><li>みなが気持よく休めるように、私にちが部屋をきれいに掃除している</li></ul><h4 id="1-2-7-时间从句"><a href="#1-2-7-时间从句" class="headerlink" title="1.2.7 时间从句"></a>1.2.7 时间从句</h4><p>在日常生活的语言中，经常会遇到这类惯用型: “…たびに”、”…ときに”、”…あとで(に)”、”…てから”、”…うちに” 。这一类型句子的共同点是都表示时间的含义，相当于汉语的“每逢…声”、“在…时候”、“在…之后” 、“在…之中”的意义。试论日语的复合句[4]中认为，如果在这一类惯用型前后有两个句子，又具有两层主谓关系，和前述其他副句一样，把它作为复合句看待，将其归属为时间从句。 </p><p>例句:</p><ul><li>吴先生の家に行くたびに、彼はいろいろなおもしろい話を聞かせてくれます</li><li>父からはじめ手紙が届いた時、私はとてもうれしかった</li><li>私が外出しためとで(に)、陈君があそびに来た</li><li>彼らは大学に入学してから、まだ日があさい</li></ul><h3 id="1-3-并列句"><a href="#1-3-并列句" class="headerlink" title="1.3 并列句"></a>1.3 并列句</h3><p>句中有2层以上的主谓结构，虽然这些主谓结构有某种语法形式上的联系，但是在意义上是并列的，互不依赖的。并列句中的各自的句子称作分句，前面的分句是以中顿形式，或者用接续助词て、し、が等，以及某些惯用形与后面的分句连接。<br>例句：<br>①“河水很清澈，河底看得很清楚。”<br>川の水が綺麗で、川の底「そこ」がよく見えます。（用形容动词的中顿）<br>②“客人来了，就在那里喝茶；孩子回来了，那个房间就变成了学习室。”<br>人が来ればそこでお茶を飲んで、子供が学校から帰ってくると、その部屋は勉強部屋になる。（用接续助词て）<br>③“有的人显得高兴，有的人显得伤心。”<br>嬉しそうな顔をする人もいるし、悲「かな」しそうな顔をする人もいます。（用接续助词し）<br>④ “即有山，又有海。”<br>山もあれば、海もある。（用惯用形……も……ば、……も）<br>⑤“冬天过去，春天来了”<br>冬が過ぎ、春が来た</p><h3 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h3><p>日语的复合句按照基本结构可以分为三大类，包孕句、主从句和并列句，这三者的从属度是逐渐递减的。在实际中，还可以将三者混合起来，构成更为复杂的句式结构。</p><h2 id="2-复句中的时体"><a href="#2-复句中的时体" class="headerlink" title="2. 复句中的时体"></a>2. 复句中的时体</h2><p>日语复句中的时体和英语不同，没有十分标准的研究，相应文章也较少，论日语从句的时态变化<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="林泽清, and 耿铁珍. 论日语从句的时态变化. 日语学习与研究 2(2000):16-21.">[6]</span></a></sup>和浅析日语复句中的“时”和“体”<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="辛宇峰. 浅析日语复句中的“时”和“体”. 外语与翻译 4(2014):54-55.">[7]</span></a></sup>有一些介绍。<br>一般来说，日语复句的时体的基本原则是，主句的时体，以说话者的视角为基准，从句的时体以主句的时间为基准，但也会考虑到说话者的视角。<br>一般来说:</p><ul><li>如果从句的动作、状态发生在主句之前，那么通常从句都是过去时，有时也反映在体上例如完成体等</li><li>如果从句的动作、状态和主句同时发生，那么通常从句的时和主句相同</li><li>如果从句的动作、状态发生在主句之后，此时考虑主句的时间和整个句子在说话者中的视角，若主句是现在时，那从句也就用现在时即可，若主句是过去时，需要考虑从句的动作、状态在说话者视角中是否仍处于过去时，是则也用过去时，否则现在时。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章主要介绍了日语复合句的内容，下一篇将尝试综合考虑已有内容归纳日语句子的改造顺序。</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)">Wikipedians. 複文. Wikipedia, Wikimedia Foundation, 16 Apr. 2018, ja.wikipedia.org/wiki/複文.<a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)">Wikipedians. 節 (文法). Wikipedia, Wikimedia Foundation, 18 Apr. 2018, ja.wikipedia.org/wiki/節_(文法).<a href="#fnref:2" rev="footnote"> ↩</a></span></div><div id="fn:3" style="display:flex"><span style="width:20px">3.</span><span style="width:calc(100% - 20px)">henry19931224. 日语复句. 百度文库, 16 Nov. 2011, wenku.baidu.com/view/bfe202d0b14e852458fb5731.html.<a href="#fnref:3" rev="footnote"> ↩</a></span></div><div id="fn:4" style="display:flex"><span style="width:20px">4.</span><span style="width:calc(100% - 20px)">谢秀忱. 试论日语的复合句. 现代外语 3(1982):33-38.<a href="#fnref:4" rev="footnote"> ↩</a></span></div><div id="fn:5" style="display:flex"><span style="width:20px">5.</span><span style="width:calc(100% - 20px)">吴春竹. 试论日语复句中从属句节的多层立体结构. 外语学刊 6(2008):49-52.<a href="#fnref:5" rev="footnote"> ↩</a></span></div><div id="fn:6" style="display:flex"><span style="width:20px">6.</span><span style="width:calc(100% - 20px)">林泽清, and 耿铁珍. 论日语从句的时态变化. 日语学习与研究 2(2000):16-21.<a href="#fnref:6" rev="footnote"> ↩</a></span></div><div id="fn:7" style="display:flex"><span style="width:20px">7.</span><span style="width:calc(100% - 20px)">辛宇峰. 浅析日语复句中的“时”和“体”. 外语与翻译 4(2014):54-55.<a href="#fnref:7" rev="footnote"> ↩</a></span></div></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇介绍了敬语系统，这一章主要介绍日语中的复合句。日语中复句的相关概念在维基百科上有複文&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;Wikipedians. 複文. Wikipedia, Wikimedia Foundation, 16 Apr. 2018, ja.wikipedia.org/wiki/複文.
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;和節&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;Wikipedians. 節 (文法). Wikipedia, Wikimedia Foundation, 18 Apr. 2018, ja.wikipedia.org/wiki/節_(文法).
&quot;&gt;[2]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;等。&lt;br&gt;区别简单句和复合句的主要标志是看它主谓关系的次数，主谓关系在语法上仅成立一次的句子叫做单句。反之，句中有两层或两层以上主谓关系的就可成为复合句。简单句与复合句的区别决不是以句子长短、单词多少而定。常常是句子很长的是简单句；句子很短，但具有两层以上主谓关系的都是复合句。&lt;/p&gt;
    
    </summary>
    
      <category term="humanities" scheme="https://blog.xuwei.fun/categories/humanities/"/>
    
      <category term="languages" scheme="https://blog.xuwei.fun/categories/humanities/languages/"/>
    
    
      <category term="japanese" scheme="https://blog.xuwei.fun/tags/japanese/"/>
    
  </entry>
  
  <entry>
    <title>日语学习七</title>
    <link href="https://blog.xuwei.fun/2018/06/18/japanese08/"/>
    <id>https://blog.xuwei.fun/2018/06/18/japanese08/</id>
    <published>2018-06-18T12:00:35.000Z</published>
    <updated>2019-05-18T14:24:33.116Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章介绍了日语的语气，这一篇Kino将要讲解日语的敬语系统。<br>日语敬语是日语中用于表达敬意的表达方式，用来表示说话者、说话对象、话中人物之间的社会阶级、亲疏等关系。出席使用日语的许多社交场合必须使用敬语，以表达适当的身份关系和礼貌。<br>现代日语敬语的分类研究<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="姚莉萍. 现代日语敬语的分类研究. 日语学习与研究 3(1996):6-10.">[1]</span></a></sup> 中介绍了几种日语的分类方式，包括以敬意形式进行的分类和待遇表现进行的分类。而现在常用的分类方法还是按照前者进行分类的，一般可分为丁宁语（礼貌语）、尊敬语和谦逊语三大类。有时丁宁语也可以再另分出郑重语和美化语两类敬语。说话人会根据谈话内容以及对象，而使用相关的辞汇或是动词变形。<br>根据相关参考资料如日语语法指南<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Tae, and Pizza. 敬语和动词词根. 日语语法指南 | Learn Japanese, http://res.wokanxing.info/jpgramma/polite.html.">[2]</span></a></sup>、维基百科<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. 日語敬語. Wikipedia, Wikimedia Foundation, 7 June 2018, https://zh.wikipedia.org/wiki/日語敬語.">[3]</span></a></sup>、日语敬语<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="三吉礼子. 日语敬语. 北京大学出版社, 2006.">[4]</span></a></sup>、试论日语敬语现象<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="桑凤平. 试论日语敬语现象. 外语与外语教学 8(2001):21-23.">[5]</span></a></sup>、日语敬语的常见错误分析<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="杜玲莉. 日语敬语的常见错误分析. 东北亚外语研究 6(2004):7-8.">[6]</span></a></sup>对敬体的几大类进行介绍。</p><a id="more"></a><h2 id="1-丁宁语"><a href="#1-丁宁语" class="headerlink" title="1. 丁宁语"></a>1. 丁宁语</h2><p>表示客气、礼貌、文雅、郑重的语言，叫丁宁语，丁宁语是代表说话人礼貌的敬语，代表尊重听话对象。<br>丁宁语反映在句尾，根据句尾的不同，有以下两种情况:</p><h3 id="1-1-句尾是动词"><a href="#1-1-句尾是动词" class="headerlink" title="1.1 句尾是动词"></a>1.1 句尾是动词</h3><p>将动词变为一类い形活用词根，之后再句尾加「ます」。<br>此外，考虑极性和时轴，「ます」形有相应变化:</p><ul><li>肯定现在: 「ます」</li><li>否定现在: 「ません」</li><li>肯定过去: 「ました」</li><li>否定过去: 「ませんでした」</li></ul><h3 id="1-2-句尾是名词、形容词"><a href="#1-2-句尾是名词、形容词" class="headerlink" title="1.2 句尾是名词、形容词"></a>1.2 句尾是名词、形容词</h3><p>句尾若是有「だ」，将「だ」除去，之后在句尾加「です」。<br>考虑极性和时轴，「です」形也有不同变化。</p><p align="center">表1 い形容词结尾</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">口语</th><th style="text-align:center">丁宁语</th></tr></thead><tbody><tr><td style="text-align:center">肯定现在</td><td style="text-align:center">かわいい</td><td style="text-align:center">かわいいです</td></tr><tr><td style="text-align:center">否定现在</td><td style="text-align:center">かわいくない</td><td style="text-align:center">かわいくないです</td></tr><tr><td style="text-align:center">肯定过去</td><td style="text-align:center">かわいかった</td><td style="text-align:center">かわいかったです</td></tr><tr><td style="text-align:center">否定过去</td><td style="text-align:center">かわいくなかった</td><td style="text-align:center">かわいくなかったです</td></tr></tbody></table><p align="center">表2 な形容词或名词结尾</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">口语</th><th style="text-align:center">丁宁语</th></tr></thead><tbody><tr><td style="text-align:center">肯定现在</td><td style="text-align:center">静か（だ）</td><td style="text-align:center">静かです</td></tr><tr><td style="text-align:center">否定现在</td><td style="text-align:center">静かじゃない</td><td style="text-align:center">静かじゃないです</td></tr><tr><td style="text-align:center">肯定过去</td><td style="text-align:center">静かだった</td><td style="text-align:center"><strong>静かでした</strong></td></tr><tr><td style="text-align:center">否定过去</td><td style="text-align:center">静かじゃなかった</td><td style="text-align:center">静かじゃなかったです</td></tr></tbody></table><h3 id="1-3-否定情况下的另一种表达"><a href="#1-3-否定情况下的另一种表达" class="headerlink" title="1.3 否定情况下的另一种表达"></a>1.3 否定情况下的另一种表达</h3><p>上述否定形的丁宁语不是「官方」的正确活用。更加「正确」的活用形应该是把「ないです」部分改为「ありません」，理由是动词「ある」的丁宁未然形不是「ないです」而是「ありません」。所以，「かわいくない」应该写作「かわいくありません」，「静かじゃない」则应该是「静かじゃありません」。<br>实际上，这种所谓的「官方」用法听起来太过呆板和正式。在日常对话中，大家基本用的都是上述介绍的形式，虽然在用丁宁语写作时应该用更加正式的活用形，但日常说话几乎用不到。</p><h3 id="1-4-特殊词"><a href="#1-4-特殊词" class="headerlink" title="1.4 特殊词"></a>1.4 特殊词</h3><p>有一些词汇的丁宁语版本完全是另外一个词汇，主要有:</p><ul><li>「ある」: 「ござる」，「ござる」总是以「ます」形出现，即「ございます」</li><li>「です」: 「でございます」，其实就是「でござる」的「ます」形活用，从「である」而来，字面意思是「以…的形式存在」</li><li>「いい」: 「よろしい」是更正式的表达方式</li><li>「さん」: 「様」，这个后缀在口语里面不常用到，即使在说尊敬语或谦逊语。不过，写信的时候一般会用到它，即使对方是熟人也一样。还有服务行业例如收银员或服务员通常会称呼客户为「お客様」。当然了，皇族和神灵一定是会用「様」的，例如「神様」</li></ul><h2 id="2-尊敬语"><a href="#2-尊敬语" class="headerlink" title="2. 尊敬语"></a>2. 尊敬语</h2><p>对他人的行为、状态及有关事物等表示敬意的语言，尊敬语代表尊敬话题里施行行为的人。<br>话题提及社会阶级较高的人，例如长辈、师长、上司、客户等，便会使用尊敬语。提及说话人自身的时候，不用尊敬语。</p><h3 id="2-1-动词的尊敬语形式"><a href="#2-1-动词的尊敬语形式" class="headerlink" title="2.1 动词的尊敬语形式"></a>2.1 动词的尊敬语形式</h3><p>对动作主体表示尊敬有四个方法。</p><h4 id="2-1-1-用特殊尊敬语动词"><a href="#2-1-1-用特殊尊敬语动词" class="headerlink" title="2.1.1 用特殊尊敬语动词"></a>2.1.1 用特殊尊敬语动词</h4><p>和一般用语完全不一样。例如动词「する」，尊敬语动词则为「なさる」。动词「話す」，尊敬语动词则为「おっしゃる」。</p><h4 id="2-1-2-使用「お……になる」句型"><a href="#2-1-2-使用「お……になる」句型" class="headerlink" title="2.1.2 使用「お……になる」句型"></a>2.1.2 使用「お……になる」句型</h4><p>一般没有相应尊敬语的动词，也可以换成「一类い形活用词根」，前加「お」、后加「になる」，使之成为尊敬语。例如「読む」，尊敬语可以用「お読みになる」。<br>也可以用「下さい」替代「になる」。当你想用尊敬语动词请别人做什么的时候，这种表达很有用。</p><h4 id="2-1-3-使用「お……です」句型"><a href="#2-1-3-使用「お……です」句型" class="headerlink" title="2.1.3 使用「お……です」句型"></a>2.1.3 使用「お……です」句型</h4><p>将一般动词换成「一类い形活用词根」，前加「お」、后加「です」，也成为尊敬语。例如「読む」，尊敬语可以用「お読みです」。</p><h4 id="2-1-4-动词被动形也可以当尊敬语使用"><a href="#2-1-4-动词被动形也可以当尊敬语使用" class="headerlink" title="2.1.4 动词被动形也可以当尊敬语使用"></a>2.1.4 动词被动形也可以当尊敬语使用</h4><p>「読みましたか」，尊敬语亦可说成「読まれましたか」</p><h3 id="2-2-名词形容词的尊敬语形式"><a href="#2-2-名词形容词的尊敬语形式" class="headerlink" title="2.2 名词形容词的尊敬语形式"></a>2.2 名词形容词的尊敬语形式</h3><p>除了动词外，部分名词也有尊敬语。例如「その人」，尊敬语是「その方」。一般情况下，大部分名词前可以加上词头表示尊敬。<br>日语固有词即訓読み单词通常加「お」，例如「お顔」、「お話」，汉字词即音読み单词通常加「ご」，例如「ご冗談」、「ご両親」。如写成汉字，两者均作「御」。<br>部分形容词也加上「お」、「ご」做成尊敬语，规则与名词类似。例如「お忙しい」、「お元気」、「ご満足」。</p><h2 id="3-谦逊语"><a href="#3-谦逊语" class="headerlink" title="3. 谦逊语"></a>3. 谦逊语</h2><p>谦逊语又称谦让语，说话人通过谦虚地讲述、甚至是贬低话题中行为主体的动作，用来对接受行为的人表示尊敬。行为主体是说话人自身的时候，也可以用谦让语。</p><h2 id="3-1-用特殊谦逊语动词"><a href="#3-1-用特殊谦逊语动词" class="headerlink" title="3.1 用特殊谦逊语动词"></a>3.1 用特殊谦逊语动词</h2><p>谦逊语可以用特殊词汇来表示，例如自有一套动词。一般例如动词「する」，谦让语动词则为「いたす」。一般动词「話す」，谦让语动词则为「申す」。</p><h2 id="3-2-使用「お-ご……する-いたす-申し上げる」句型"><a href="#3-2-使用「お-ご……する-いたす-申し上げる」句型" class="headerlink" title="3.2 使用「お/ご……する/いたす/申し上げる」句型"></a>3.2 使用「お/ご……する/いたす/申し上げる」句型</h2><p>另外，如果没有相对的谦逊动词，可以使用「お/ご……する/いたす/申し上げる」句型。一般动词换成「一类い形活用词根」，前加「お」或「ご」、后加「する」或「いたす」，便可成为谦让语，「いたす」实际上又是「する」的谦逊语。例如「持つ」，谦让语可以说成「お持ちする」，「案内する」谦让语可以说成「ご案内する」。</p><h2 id="3-3-注意事项"><a href="#3-3-注意事项" class="headerlink" title="3.3 注意事项"></a>3.3 注意事项</h2><p>部分谦逊语已经成为固有短语，例如「いただく」本为「もらう」的谦逊语，但这个动词的丁宁语体「いただきます」则是吃喝之前所说的寒暄话。</p><h2 id="4-特殊动词"><a href="#4-特殊动词" class="headerlink" title="4. 特殊动词"></a>4. 特殊动词</h2><h3 id="4-1-特殊尊敬语和特殊谦逊语"><a href="#4-1-特殊尊敬语和特殊谦逊语" class="headerlink" title="4.1 特殊尊敬语和特殊谦逊语"></a>4.1 特殊尊敬语和特殊谦逊语</h3><p>这里列出一些尊敬语和谦逊语与一般用语完全不一样的动词。</p><p align="center">表3 尊敬语和谦逊语</p><table><thead><tr><th style="text-align:center">字典形</th><th style="text-align:center">尊敬语</th><th style="text-align:center">谦逊语</th></tr></thead><tbody><tr><td style="text-align:center">する</td><td style="text-align:center">なさる</td><td style="text-align:center">致す</td></tr><tr><td style="text-align:center">行く</td><td style="text-align:center">いらっしゃる／おいでになる</td><td style="text-align:center">参る</td></tr><tr><td style="text-align:center">来る</td><td style="text-align:center">いらっしゃる／おいでになる</td><td style="text-align:center">参る</td></tr><tr><td style="text-align:center">いる</td><td style="text-align:center">いらっしゃる／おいでになる</td><td style="text-align:center">おる</td></tr><tr><td style="text-align:center">見る</td><td style="text-align:center">ご覧になる</td><td style="text-align:center">拝見する</td></tr><tr><td style="text-align:center">聞く</td><td style="text-align:center">－</td><td style="text-align:center">伺う</td></tr><tr><td style="text-align:center">言う</td><td style="text-align:center">おっしゃる</td><td style="text-align:center">申す／申し上げる</td></tr><tr><td style="text-align:center">あげる</td><td style="text-align:center">－</td><td style="text-align:center">差し上げる</td></tr><tr><td style="text-align:center">くれる</td><td style="text-align:center">下さる</td><td style="text-align:center">－</td></tr><tr><td style="text-align:center">もらう</td><td style="text-align:center">－</td><td style="text-align:center">いただく</td></tr><tr><td style="text-align:center">食べる</td><td style="text-align:center">召し上がる</td><td style="text-align:center">いただく</td></tr><tr><td style="text-align:center">飲む</td><td style="text-align:center">召し上がる</td><td style="text-align:center">いただく</td></tr><tr><td style="text-align:center">知っている</td><td style="text-align:center">ご存知（です）</td><td style="text-align:center">存じる</td></tr></tbody></table><h3 id="4-2-特殊尊敬语和特殊谦逊语的活用规则"><a href="#4-2-特殊尊敬语和特殊谦逊语的活用规则" class="headerlink" title="4.2 特殊尊敬语和特殊谦逊语的活用规则"></a>4.2 特殊尊敬语和特殊谦逊语的活用规则</h3><p>在使用特殊尊敬语和特殊谦逊语基础之上，还可以对这些动词使用丁宁语的规则。<br>但这些动词很多并不遵循普通的ます活用规则，包括「なさる」、「いらっしゃる」、「おっしゃる」、「下さる」和「ござる」。对这些东西要改写为ます形的话，不是像う动词那样把「る」变为「り」，而是要变为「い」。除了ます形，它们的其他活用规则跟普通う动词一样。</p><p align="center">表4 尊敬语和谦逊语的特殊活用规则</p><table><thead><tr><th style="text-align:center">字典形</th><th style="text-align:center">ます形</th><th style="text-align:center">过去ます形</th><th style="text-align:center">未然ます形</th><th style="text-align:center">过去未然ます形</th></tr></thead><tbody><tr><td style="text-align:center">なさる</td><td style="text-align:center">なさいます</td><td style="text-align:center">なさいました</td><td style="text-align:center">なさいません</td><td style="text-align:center">なさいませんでした</td></tr><tr><td style="text-align:center">いらっしゃる</td><td style="text-align:center">いらっしゃいます</td><td style="text-align:center">いらっしゃいました</td><td style="text-align:center">いらっしゃいません</td><td style="text-align:center">いらっしゃいませんでした</td></tr><tr><td style="text-align:center">おっしゃる</td><td style="text-align:center">おっしゃいます</td><td style="text-align:center">おっしゃいました</td><td style="text-align:center">おっしゃいません</td><td style="text-align:center">おっしゃいませんでした</td></tr><tr><td style="text-align:center">下さる</td><td style="text-align:center">下さいます</td><td style="text-align:center">下さいました</td><td style="text-align:center">下さいません</td><td style="text-align:center">下さいませんでした</td></tr><tr><td style="text-align:center">ござる</td><td style="text-align:center">ございます</td><td style="text-align:center">ございました</td><td style="text-align:center">ございません</td><td style="text-align:center">ございませんでした</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇主要讲解了日语的敬语系统，下一篇将讲解日语中的复合句。</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)">姚莉萍. 现代日语敬语的分类研究. 日语学习与研究 3(1996):6-10.<a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)">Tae, and Pizza. 敬语和动词词根. 日语语法指南 | Learn Japanese, <a href="http://res.wokanxing.info/jpgramma/polite.html" target="_blank" rel="noopener">http://res.wokanxing.info/jpgramma/polite.html</a>.<a href="#fnref:2" rev="footnote"> ↩</a></span></div><div id="fn:3" style="display:flex"><span style="width:20px">3.</span><span style="width:calc(100% - 20px)">Wikipedians. 日語敬語. Wikipedia, Wikimedia Foundation, 7 June 2018, <a href="https://zh.wikipedia.org/wiki/日語敬語" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/日語敬語</a>.<a href="#fnref:3" rev="footnote"> ↩</a></span></div><div id="fn:4" style="display:flex"><span style="width:20px">4.</span><span style="width:calc(100% - 20px)">三吉礼子. 日语敬语. 北京大学出版社, 2006.<a href="#fnref:4" rev="footnote"> ↩</a></span></div><div id="fn:5" style="display:flex"><span style="width:20px">5.</span><span style="width:calc(100% - 20px)">桑凤平. 试论日语敬语现象. 外语与外语教学 8(2001):21-23.<a href="#fnref:5" rev="footnote"> ↩</a></span></div><div id="fn:6" style="display:flex"><span style="width:20px">6.</span><span style="width:calc(100% - 20px)">杜玲莉. 日语敬语的常见错误分析. 东北亚外语研究 6(2004):7-8.<a href="#fnref:6" rev="footnote"> ↩</a></span></div></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇文章介绍了日语的语气，这一篇Kino将要讲解日语的敬语系统。&lt;br&gt;日语敬语是日语中用于表达敬意的表达方式，用来表示说话者、说话对象、话中人物之间的社会阶级、亲疏等关系。出席使用日语的许多社交场合必须使用敬语，以表达适当的身份关系和礼貌。&lt;br&gt;现代日语敬语的分类研究&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;姚莉萍. 现代日语敬语的分类研究. 日语学习与研究 3(1996):6-10.
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt; 中介绍了几种日语的分类方式，包括以敬意形式进行的分类和待遇表现进行的分类。而现在常用的分类方法还是按照前者进行分类的，一般可分为丁宁语（礼貌语）、尊敬语和谦逊语三大类。有时丁宁语也可以再另分出郑重语和美化语两类敬语。说话人会根据谈话内容以及对象，而使用相关的辞汇或是动词变形。&lt;br&gt;根据相关参考资料如日语语法指南&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;Tae, and Pizza. 敬语和动词词根. 日语语法指南 | Learn Japanese, http://res.wokanxing.info/jpgramma/polite.html.
&quot;&gt;[2]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;、维基百科&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;Wikipedians. 日語敬語. Wikipedia, Wikimedia Foundation, 7 June 2018, https://zh.wikipedia.org/wiki/日語敬語.
&quot;&gt;[3]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;、日语敬语&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;三吉礼子. 日语敬语. 北京大学出版社, 2006.
&quot;&gt;[4]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;、试论日语敬语现象&lt;sup id=&quot;fnref:5&quot;&gt;&lt;a href=&quot;#fn:5&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;桑凤平. 试论日语敬语现象. 外语与外语教学 8(2001):21-23.
&quot;&gt;[5]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;、日语敬语的常见错误分析&lt;sup id=&quot;fnref:6&quot;&gt;&lt;a href=&quot;#fn:6&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;杜玲莉. 日语敬语的常见错误分析. 东北亚外语研究 6(2004):7-8.
&quot;&gt;[6]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;对敬体的几大类进行介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="humanities" scheme="https://blog.xuwei.fun/categories/humanities/"/>
    
      <category term="languages" scheme="https://blog.xuwei.fun/categories/humanities/languages/"/>
    
    
      <category term="japanese" scheme="https://blog.xuwei.fun/tags/japanese/"/>
    
  </entry>
  
  <entry>
    <title>日语学习六</title>
    <link href="https://blog.xuwei.fun/2018/06/18/japanese07/"/>
    <id>https://blog.xuwei.fun/2018/06/18/japanese07/</id>
    <published>2018-06-18T04:45:02.000Z</published>
    <updated>2019-05-18T14:24:33.113Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇介绍了日语的语态，这一篇文章开始讲述日语的语气。语气简单来说就是说话者对某一命题的主观意见和心里态度的总称。<br>王忻在日语语气再考(上)<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="王忻. 日语语气再考(上)[J]. 日语学习与研究, 2002(2):18-24.">[1]</span></a></sup>和日语语气再考(下)<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="王忻. 日语语气再考(下)[J]. 日语学习与研究, 2002(3):18-24.">[2]</span></a></sup>中对日语语气进行了详细的研究，刘峰在日语语气概论<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="刘峰. 日语语气概论(モダリティ)[J]. 科教文汇(上旬刊), 2010(2):141-142.">[3]</span></a></sup>中也对日语语气进行了简要说明，日语语法专题教程<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.">[4]</span></a></sup>中有单独一章介绍语气。<br>本篇将结合这些资料，对语气进行相关说明。</p><a id="more"></a><h2 id="1-语气概述"><a href="#1-语气概述" class="headerlink" title="1. 语气概述"></a>1. 语气概述</h2><h3 id="1-1-命题与语气的对立"><a href="#1-1-命题与语气的对立" class="headerlink" title="1.1 命题与语气的对立"></a>1.1 命题与语气的对立</h3><p>日语的句子(话语)在语义和句法结构的关系上，大体呈现出表现客观语义的“叙述素材”和表达主观语义的“句子的叙述方式”两个层面，前者称为“命题内容”，日语为“言表事态”，下文简称为“命题”，后者称为“语气”，日语为“言表态度”，即日语的句子由“命题”与“语气”这两个性质不同的部分构成。具体来说，所谓命题，是指说话人在句中所表述的、与说话人主观思维相分离的客观事实；所谓语气，是指说话人在说话时从说话人的立场出发、主观性地对命题的把握方法和态度。通过两者的对立统一，构成句子的意义结构。</p><h3 id="1-2-命题与语气的界定与位置"><a href="#1-2-命题与语气的界定与位置" class="headerlink" title="1.2 命题与语气的界定与位置"></a>1.2 命题与语气的界定与位置</h3><p>虽说句子是由命题和语气两部分组成的，但并不是说句子等于命题和语气两部分的简单相加。也就是说命题与语气并不是并列关系，而是一种包容关系：{[命题]语气}<br>从作为语气载体的语法形式上来看，命题和语气还是应该能够划分并有自己的位置的。一般说来:</p><ul><li>命题部分包括主语部分和谓语部分中的体、认定方式、态、时等。</li><li>语气部分包括谓语活用形、系词(即“コピュラ”，在传统语法中称为助动词)及形式名词、终助词/特提助词/陈述副词/感叹词和接续词等等。另外敬语表达形式也应包括其中。</li></ul><p>语气的位置是多种多样的，它因种类和词类不同而定。语气表现形式出现在句子尾部的频率大大高于其它位置。<br>王忻在日语语气再考(上)<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="王忻. 日语语气再考(上)[J]. 日语学习与研究, 2002(2):18-24.">[1]</span></a></sup>归纳为: 任意一个句子都应有表现语气的部分(尽管有时可能很难清楚地划分出来)，它在句中的位置不定，但句子的后部必然是语气。<br>此外，一个句子有两处以上出现语气时，就应把它们分为主要语气和次要语气等来考察。</p><h2 id="2-语气的分类"><a href="#2-语气的分类" class="headerlink" title="2. 语气的分类"></a>2. 语气的分类</h2><p>与语气研究有关的分类可归纳为两大类，一种是对各种不同语气的句子类型进行的分类，一种是对语气载体（表现语气的语法形式）的分类。前者是从句子语一气的类型入手，在对这些类型进行分析的过程中涉及到构成这些语气的“构件”——表现语气的语法形式。后者与前者方向相反，是从这些“构件”入手，对这些“构件”构成的语气进行归纳研究的。</p><h3 id="2-1-不同语气类型的分类"><a href="#2-1-不同语气类型的分类" class="headerlink" title="2.1 不同语气类型的分类"></a>2.1 不同语气类型的分类</h3><h4 id="2-1-1-经典分类"><a href="#2-1-1-经典分类" class="headerlink" title="2.1.1 经典分类"></a>2.1.1 经典分类</h4><p>日语语气再考(上)<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="王忻. 日语语气再考(上)[J]. 日语学习与研究, 2002(2):18-24.">[1]</span></a></sup>和日语语法专题教程<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.">[4]</span></a></sup>中列出了已有的几种较为代表性的分类，包括:</p><ul><li>高桥太郎等(2001)编著的《日本語の文法2001》中的分类</li><li>仁田义雄(1997)在《日本語のモダリティと人称》中的分类</li><li>奥田靖雄(1996)在《文のことーその分类をめぐってー》中的分类</li><li>寺村秀夫(1982)在《日本語のシンタクスと意味》中的分类</li><li>益冈隆志(2000)在《日本語の文法诸相》中的分类</li><li>森山卓郎(2000)在《日本語の文法3モダリテイ》中的分类</li><li>井上优在(2006)在《シリーズ方言学2方言の文法》中的分类</li></ul><h4 id="2-1-2-详解两种分类"><a href="#2-1-2-详解两种分类" class="headerlink" title="2.1.2 详解两种分类"></a>2.1.2 详解两种分类</h4><h5 id="2-1-2-1-第一种分类方式"><a href="#2-1-2-1-第一种分类方式" class="headerlink" title="2.1.2.1 第一种分类方式"></a>2.1.2.1 第一种分类方式</h5><p>日语语气概论<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="刘峰. 日语语气概论(モダリティ)[J]. 科教文汇(上旬刊), 2010(2):141-142.">[3]</span></a></sup>中将语气类型分为四类:<br>1. 反映句子所表达内容的功能语气。<br>这是决定句子最基本性质的语气，其有两种类型：信息类与行为类。它们都属于表现类型的语气。<br>信息类语气就承担着向听者传达信息（叙述语气）以及从听者那里获取信息的功能（疑问语气）。</p><blockquote><p>例: 昨日上海に行った(叙述语气，礼貌语气)<br>例: 明日休むか(疑问语气，非礼貌语气)</p></blockquote><p>行为类语气承担着说话者和听话者的行为实现的机能，其中又分为说话者自身行为实现（意志型语气），说话者以自己的行为实现为前提，要求对方也实现某种行为（劝诱语气），要求对方实现某种行为（行为要求语气）。</p><blockquote><p>例: 美味しいな、やっぱり食べようか(意志形语气)<br>例: 仕事もう終わっただろう、じゃ、一緒に帰ろう(劝诱语气)<br>例: 部屋が散らかってるぞ、速く片付けろ(行为要求语气)</p></blockquote><p>2. 针对命题的把握方法的语气。<br>该语气是说话者对于命题内容的把握方式，有两种语气类型：评价语气和认知语气。<br>评价语气是对命题所表达的事象做出的必要、不必要 或者允许、不允许的评价式表达。</p><blockquote><p>例: この仕事を引き受けた以上さ、 最後までやらなくてはならない. 句中的なくてはならない是说话者对やる这个事象是必要的一种评价的表达。<br>例: ここにある飲み物は自由に取ってもいい. 句中的てもいい是表示对取る这个事象是被许可的一种评价的表达。</p></blockquote><p>认知语气在认知的把握方法上，有对命题的基本认知态度，如断 定、推量、对命题成立的可能性、必然性的认知，通过证据来对命题进行把握的表示推断、传闻等语气。</p><blockquote><p>例: 上海は今雪を降っているだろう(推量的语气)<br>例: 今晩、風が吹くかもしれない(可能性的语气)<br>例: 道は濡れているから、 昨夜雨が降っていたようだ(推定的语气)<br>例: 天気予報によると、明日も雨が降るそうだ(传闻的语气)</p></blockquote><p>3. 表示上下文之间关系的语气。<br>该语气称为说明语气，通过提示上下文之间的关系使得听话者对所叙内容更易理解。</p><blockquote><p>例: 遅くなってすみません、 いきなり社長から電話をもらったんだ(说明语气)</p></blockquote><p>4. 表示对听话者的语气。<br>由于语言交流是双方相互进行的，因此，除了说话这自身对命题主观表达外，还有向听话者表示传达的义务，像这类语气称之为对听话者语气。对听话者语气中有两种语气类型：传达态度和礼貌的语气。<br>礼貌体与普通体的选择，要根据双方的年龄、地位、场合等来决定。</p><blockquote><p>例: 昨日、スーパーへ買い物に行った(普通体语气)<br>例: 昨日、スーパーへ買い物に行きました(礼貌体语气)</p></blockquote><p>传达态度语气是向对方传达时在语气上所做的一些细微调整等,传达态度语气通常会用よ、 ね、 わ这种语气终助词来表达。</p><blockquote><p>例: 仕事はストレスがいっぱい溜まっているなあ<br>例: ね、本、ここにあるよ、何で見つからないの?</p></blockquote><p>表示传达的语气既有向对方传达的意图也有自言自语的场合，如なあ多用于自言自语的场合。</p><h5 id="2-1-2-2-第二种分类方式"><a href="#2-1-2-2-第二种分类方式" class="headerlink" title="2.1.2.2 第二种分类方式"></a>2.1.2.2 第二种分类方式</h5><p>日语语法专题教程<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.">[4]</span></a></sup>采用了井上优在「シリーズ方言学2方言の文法」(岩波書店,2006)中对语气的分类。Kino在这里也j简要介绍一下。主要分为两大类: “说话者对命题内容的判断”和“对听话者的发话态度和传递态度”。<br>1. 说话者对命题内容的判断<br>即“判断性语气”、“对事性语气”、“命题指向性语气”，包括“真伪判断性语气”和“价值判断语气”。</p><ul><li>真伪判断语气主要包括断定、推量、概然性判断、证据性判断、当然性判断、传闻、说明等语气</li><li>价值判断语气主要有“适当适度”、“必要”、“容许认可”三类语气</li></ul><p>2. 对听话者的发话态度和传递态度<br>即“发话传递语气”、“对人性语气”、“听话者指向性语气”，包括“描述判断”、“表抒”、“号令”、“疑问、询问、确认”、“强调”等。</p><h3 id="2-2-不同语气载体的分类"><a href="#2-2-不同语气载体的分类" class="headerlink" title="2.2 不同语气载体的分类"></a>2.2 不同语气载体的分类</h3><p>所谓语气载体即表达各种语气的语法形式，如用言活用形、系词、形式名词、特提助词等。<br>在日语语法专题教程<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.">[4]</span></a></sup>中，作者按照语气载体的方式将日语中语气的表达方式主要分为四类:</p><ul><li>述语的活用形及其他附着在述语上的语法形式</li><li>副词的使用</li><li>感叹词和间投助词的使用(这里间投助词的意思是“加在语句和语句、句子中间的助词”，即在句节后通过停顿提示听话者，以表达说话者感叹等语气的助词)</li><li>句尾语调</li></ul><p>而王忻在日语语气再考(上)<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="王忻. 日语语气再考(上)[J]. 日语学习与研究, 2002(2):18-24.">[1]</span></a></sup>和日语语气再考(下)<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="王忻. 日语语气再考(下)[J]. 日语学习与研究, 2002(3):18-24.">[2]</span></a></sup>中将语气载体按与命题的距离分为三个级次。下面简要说明一下。</p><h4 id="2-2-1-第一级语气"><a href="#2-2-1-第一级语气" class="headerlink" title="2.2.1 第一级语气"></a>2.2.1 第一级语气</h4><p>第一级语气是以活用形为手段表现的。具体活用形中的哪种形式表达何种语气基本如图1所示。</p><p><img src="/images/japanese07_1.png" alt="figure 1"></p><p align="center">图1 活用形表达的语气</p><p>本图除动词外还可适用于形容词，只是形容词没有劝诱形和命令形。</p><h4 id="2-2-2-第二级语气"><a href="#2-2-2-第二级语气" class="headerlink" title="2.2.2 第二级语气"></a>2.2.2 第二级语气</h4><p>第二级语气是接在表第一级确切语气的形式后，表明说话人对所述内容的态度的形式。在层次结构上它把命题+第一级语气作为一个整体对其进行包容。它由助动词和形式名词+だ的形式担当。<br>根据表意，本群词可分为表述推断事实的推测语气者、表述解释说明的说明语气者和表说话人心中认为“可否”、“愿否”的语气这三小类。前者主要由助动词担任，中者由“形式体言+だ”的形式担当，后者主要由形容词性短语担当。</p><h4 id="2-2-3-第三级语气"><a href="#2-2-3-第三级语气" class="headerlink" title="2.2.3 第三级语气"></a>2.2.3 第三级语气</h4><p>第三级语气的表现形式由特提(取リ立て)助词，陈述副词、终助词、感叹词、部分接续词和敬语等形式担当<br>其中除特提助词(把句子中某些成分特别提出加以强调来表达某种言外之意为特提)、陈述副词是表示对事性语气以外其余均表示对人性语气。<br>与第一级、第二级语气相比，第三级语气的最大特点是位置相对不稳定，第一级语气活用形处于谓语位置，第二级语气系 词又是紧随活用形之后，位置都比较固定，而第三级语气因成分复杂等原因位置也就不固定了。<br>从词类来看表现对人性语气的终助词、感叹词和接续词位置相对稳定，终助词在句尾，感叹词一 般在句首，接续词则在下句之前。但敬语和表现对事性语气的特提助助词的位置就难以如此简单地划定了。</p><h2 id="3-特殊用法"><a href="#3-特殊用法" class="headerlink" title="3. 特殊用法"></a>3. 特殊用法</h2><p>将一个句子全部用片假名书写，用来表示惊讶、敌意等强烈的语气。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章主要阐述了日语的语气，下一篇将讲解日语中的敬体。</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)">王忻. 日语语气再考(上)[J]. 日语学习与研究, 2002(2):18-24.<a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)">王忻. 日语语气再考(下)[J]. 日语学习与研究, 2002(3):18-24.<a href="#fnref:2" rev="footnote"> ↩</a></span></div><div id="fn:3" style="display:flex"><span style="width:20px">3.</span><span style="width:calc(100% - 20px)">刘峰. 日语语气概论(モダリティ)[J]. 科教文汇(上旬刊), 2010(2):141-142.<a href="#fnref:3" rev="footnote"> ↩</a></span></div><div id="fn:4" style="display:flex"><span style="width:20px">4.</span><span style="width:calc(100% - 20px)">马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.<a href="#fnref:4" rev="footnote"> ↩</a></span></div></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇介绍了日语的语态，这一篇文章开始讲述日语的语气。语气简单来说就是说话者对某一命题的主观意见和心里态度的总称。&lt;br&gt;王忻在日语语气再考(上)&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;王忻. 日语语气再考(上)[J]. 日语学习与研究, 2002(2):18-24.
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;和日语语气再考(下)&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;王忻. 日语语气再考(下)[J]. 日语学习与研究, 2002(3):18-24.
&quot;&gt;[2]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;中对日语语气进行了详细的研究，刘峰在日语语气概论&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;刘峰. 日语语气概论(モダリティ)[J]. 科教文汇(上旬刊), 2010(2):141-142.
&quot;&gt;[3]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;中也对日语语气进行了简要说明，日语语法专题教程&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.
&quot;&gt;[4]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;中有单独一章介绍语气。&lt;br&gt;本篇将结合这些资料，对语气进行相关说明。&lt;/p&gt;
    
    </summary>
    
      <category term="humanities" scheme="https://blog.xuwei.fun/categories/humanities/"/>
    
      <category term="languages" scheme="https://blog.xuwei.fun/categories/humanities/languages/"/>
    
    
      <category term="japanese" scheme="https://blog.xuwei.fun/tags/japanese/"/>
    
  </entry>
  
  <entry>
    <title>日语学习五</title>
    <link href="https://blog.xuwei.fun/2018/06/03/japanese06/"/>
    <id>https://blog.xuwei.fun/2018/06/03/japanese06/</id>
    <published>2018-06-03T13:46:33.000Z</published>
    <updated>2020-05-03T11:06:01.658Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇叙述了日语中的体，这篇文章Kino将讲解日语中的态。<br>语态指在动词做述语的句子中，述语动词和主语的关系，即主语所表示的人物、事物是述语动词所表示的动作、作用的执行者还是承受者，是促进动作进行的人还是具备能力进行动作的人。<br>通常认为日语有五种语态, 不过这五种本身是建立在无任何变形的基本语态的基础上, 这种基本语态当然也得算作语态的一种, 可以被称为: 能动态/主动态.</p><a id="more"></a><h2 id="1-主动态"><a href="#1-主动态" class="headerlink" title="1. 主动态"></a>1. 主动态</h2><p>从施动者的角度叙述其动作、作用时，使用主动语态。述语动词就是基本形式即可。</p><h2 id="2-被动态"><a href="#2-被动态" class="headerlink" title="2. 被动态"></a>2. 被动态</h2><p>被动态表示主语是动作的承受者。从动作承受者的角度，叙述其受到、遭受的动作、作用时，使用被动语态。<br>被动态由述语动词后续助动词「(ら)れる」构成，不同类型的动词构成方式不同，具体为:</p><ul><li>五段动词的未然形+れる</li><li>一段动词的未然形+られる</li><li>する的被动态: せられる，约音形: される</li><li>くる的被动态: こられる</li></ul><p>示例:</p><ul><li>Eg. 学生は先生に褒められた</li><li>Eg. 雨に降られて、風邪を引いた</li></ul><h2 id="3-使役态"><a href="#3-使役态" class="headerlink" title="3. 使役态"></a>3. 使役态</h2><p>当叙述某个人引起了某个事态或强制、支使、允许他人进行了某个动作时，使用使役态。<br>使役态由述语动词后续助动词「(さ)せる」构成，不同类型的动词构成方式也不同，具体为:</p><ul><li>五段动词的未然形+せる</li><li>一段动词的未然形+させる</li><li>する的使役态: せさせる，约音形: させる</li><li>くる的使役态: こさせる</li></ul><p>示例:</p><ul><li>Eg. わたしは娘を自由に遊ばせました</li><li>Eg. 先生は学生に自由に意見を言わせました</li></ul><h2 id="4-被役态"><a href="#4-被役态" class="headerlink" title="4. 被役态"></a>4. 被役态</h2><p>又叫使役被动态。当叙述某个人受到别人的强迫，不得已、被迫做某事时，使用使役被动态。<br>被役态由述语动词后续助动词「(さ)せられる」构成，不同类型的动词构成方式也不同，具体为:</p><ul><li>五段动词的未然形+せられる</li><li>一段动词的未然形+させられる</li><li>する的被役态: させられる</li><li>くる的被役态: こさせられる</li></ul><p>示例:</p><ul><li>Eg. 私は母に宿題をさせられます</li></ul><h2 id="5-可能态"><a href="#5-可能态" class="headerlink" title="5. 可能态"></a>5. 可能态</h2><p>当叙述某人具有某种能力、技能或某事具有发生的条件、可能性时，使用可能态。可能态的构成方式比较多，主要有以下五种。</p><h3 id="5-1-使用可能助动词"><a href="#5-1-使用可能助动词" class="headerlink" title="5.1 使用可能助动词"></a>5.1 使用可能助动词</h3><p>在述语动词后面接续可能助动词「(ら)れる」，不同类型的动词接续方式也不同，具体为:</p><ul><li>五段动词的未然形+れる</li><li>一段动词的未然形+られる</li><li>くる的可能态: こられる<h3 id="5-2-使用可能动词"><a href="#5-2-使用可能动词" class="headerlink" title="5.2 使用可能动词"></a>5.2 使用可能动词</h3>把五段动词变成对应行的下一段动词，例如把「歩く」变成「歩ける」，把「読む」变成「読める」等。五段动词在实际的使用中多使用其对应的可能动词，而不是后续可能助动词。<h3 id="5-3-使用「できる」"><a href="#5-3-使用「できる」" class="headerlink" title="5.3 使用「できる」"></a>5.3 使用「できる」</h3>包括以下三种情况:</li><li>「する」变为「できる」，「~する」变为「~できる」</li><li>名词+ができる</li><li>动词原形+ことができる<h3 id="5-4-使用带有可能意义的自动词"><a href="#5-4-使用带有可能意义的自动词" class="headerlink" title="5.4 使用带有可能意义的自动词"></a>5.4 使用带有可能意义的自动词</h3>「分かる」「見える」「聞こえる」等动词本身带有可能的意义，不需要形式变化。<h3 id="5-5-使用接尾动词「うる」"><a href="#5-5-使用接尾动词「うる」" class="headerlink" title="5.5 使用接尾动词「うる」"></a>5.5 使用接尾动词「うる」</h3>在动词的连用形后面接续接尾词「うる」，如「考えうる」「ありうる」等。</li></ul><h2 id="6-自发态"><a href="#6-自发态" class="headerlink" title="6. 自发态"></a>6. 自发态</h2><p>当叙述动作自然发生或感情不可抑制时，使用自发态。<br>自发态的构成方式有三种。</p><h3 id="6-1-使用自发助动词"><a href="#6-1-使用自发助动词" class="headerlink" title="6.1 使用自发助动词"></a>6.1 使用自发助动词</h3><p>在表示感情、思想活动的述语动词后面接续自发助动词「(ら)れる」，不同类型的动词接续方式也不同，具体有:</p><ul><li>五段动词的未然形+れる</li><li>一段动词的未然形+られる</li><li>する的被动态: せられる，约音形: される<h3 id="6-2-使用可能动词"><a href="#6-2-使用可能动词" class="headerlink" title="6.2 使用可能动词"></a>6.2 使用可能动词</h3>「泣ける」「笑える」「思える」等<h3 id="6-3-使用带有可能意义的自动词"><a href="#6-3-使用带有可能意义的自动词" class="headerlink" title="6.3 使用带有可能意义的自动词"></a>6.3 使用带有可能意义的自动词</h3>「見える」「聞こえる」等</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文的例句选自日语五种语态、わかって使える日本語等文献.<br>这篇文章主要介绍了日语的语态，可以看出这六种语态在语法上并不完全是平行的，如果从平行关系来考虑，Kino认为可以这样划分:</p><ul><li>主动、被动、自发态三种在一个层级</li><li>使役态单独一个层级</li><li>可能态单独一个层级</li></ul><p>只从语法的构成可能性上来说，这三种是可以自由组合的，比如被动使役态、被动可能态、自发使役态、自发可能态，只不过由于日语的语言习惯以及现实世界的因果关系等限制，最终实际能够组合的就是被动使役态.<br>下一篇文章将介绍日语的语气。</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><p> yueaegis9. “日语五种语态” 百度文库, 13 Jan 2011, <a href="https://wenku.baidu.com/view/ff190636ee06eff9aef807e5.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/ff190636ee06eff9aef807e5.html</a>.<br> 名古屋YWCA教材作成グループ. わかって使える日本語―中級レベル[M]. スリーエーネットワーク, 2004. </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇叙述了日语中的体，这篇文章Kino将讲解日语中的态。&lt;br&gt;语态指在动词做述语的句子中，述语动词和主语的关系，即主语所表示的人物、事物是述语动词所表示的动作、作用的执行者还是承受者，是促进动作进行的人还是具备能力进行动作的人。&lt;br&gt;通常认为日语有五种语态, 不过这五种本身是建立在无任何变形的基本语态的基础上, 这种基本语态当然也得算作语态的一种, 可以被称为: 能动态/主动态.&lt;/p&gt;
    
    </summary>
    
      <category term="humanities" scheme="https://blog.xuwei.fun/categories/humanities/"/>
    
      <category term="languages" scheme="https://blog.xuwei.fun/categories/humanities/languages/"/>
    
    
      <category term="japanese" scheme="https://blog.xuwei.fun/tags/japanese/"/>
    
  </entry>
  
  <entry>
    <title>日语学习四</title>
    <link href="https://blog.xuwei.fun/2018/06/02/japanese05/"/>
    <id>https://blog.xuwei.fun/2018/06/02/japanese05/</id>
    <published>2018-06-02T11:49:08.000Z</published>
    <updated>2020-05-03T10:57:45.472Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="/2018/06/01/japanese04/">上一篇文章</a>介绍了极性和时轴，这一章主要介绍体的相关语法，体的概念在<a href="/2017/09/16/japanese01/#2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">第一篇文章</a>里已经介绍过，此处再介绍一遍: 体表示某个动作或变化在<strong>说话人所设的时间轴</strong>上处于开始、持续和完成状态中的某一阶段，是从时间角度上对动作和变化的描写或把握。<strong>需要注意的是在日语中体仅仅反映在动词上</strong><br>PS: 日语语法在”体”这方面的变化并不是那么明显, 虽然语法概念上可以分很细, 但实际需要进行特殊的变形转换的并不多, 更多的是靠上下文的时间轴来界定”体”的状态.</p><a id="more"></a><h2 id="1-完整体（完成相）"><a href="#1-完整体（完成相）" class="headerlink" title="1. 完整体（完成相）"></a>1. 完整体（完成相）</h2><p>完整体用以整体来描述某个动作或变化，把动词表示的运动从开始到结束的整个过程完整地表达出来，一般不涉及该动作或变化的中间过程。根据涉及的动作是出于“完了”这一界限达成前还是达成后，完整体被分为未成体和完成体两种。</p><h3 id="1-1-未成体"><a href="#1-1-未成体" class="headerlink" title="1.1 未成体"></a>1.1 未成体</h3><p>表示动作即将完成或者将来完成。动词不用做变化。</p><ul><li>Eg. いま、新聞を読む</li><li>Eg. 明日、新聞を読む<h3 id="1-2-完成体"><a href="#1-2-完成体" class="headerlink" title="1.2 完成体"></a>1.2 完成体</h3>表示动作的完成，但是并不是一定过去时，整个行为可能发生在未来或是一个经常性的动作，只要在说话人设定的时间轴上是完成的动作即可。动词的变化规则和过去时相同。</li><li>Eg. 今朝、新聞を読んだ</li><li>Eg. 今朝、新聞を読んだ後に散歩に出かける</li></ul><h2 id="2-过程体（継続相）"><a href="#2-过程体（継続相）" class="headerlink" title="2. 过程体（継続相）"></a>2. 过程体（継続相）</h2><p>过程体用以描述动作或变化的各个环节，是把这种运动持续过程中的某一个局部表达出来。<br>参考Wasabi网站上的这篇文章, 即一个动作的开始、现在和结束的阶段.</p><h3 id="2-1-备放体（準備相）"><a href="#2-1-备放体（準備相）" class="headerlink" title="2.1 备放体（準備相）"></a>2.1 备放体（準備相）</h3><p>表示该动作是为下一步做准备的。表现形式有: <strong>一型词根+「ておく」</strong>。其中的动词必须是意志动词。</p><ul><li>Eg. 明日お客さんが来ますから、お菓子をかっておいてください<h3 id="2-2-即将体"><a href="#2-2-即将体" class="headerlink" title="2.2 即将体"></a>2.2 即将体</h3>表示动作、行为、作用等就要发生。表现形式有: 「ようとしている」「ところだ」「しそうだ」「ばかりになっている」「かかる」「かける」<h3 id="2-3-起始体"><a href="#2-3-起始体" class="headerlink" title="2.3 起始体"></a>2.3 起始体</h3>表示动作、行为、作用的开始。表现形式多为复合动词，如「始める」「出す」「かける」等，和「てくる」<h3 id="2-4-持续体"><a href="#2-4-持续体" class="headerlink" title="2.4 持续体"></a>2.4 持续体</h3>表示动作、行为正在进行或者反复进行，要求动词是一种持续性动词。表现形式很多，有: 「ている」「てくる」「ていく」「ているところだ」「つづく」「つづける」「つづある」「一方だ」「ている最中だ」「中」，相当于汉语的“正在…”、“持续…”、“持续…”</li><li>Eg. 日本語を勉強している</li><li>Eg. 森さんが一人で歩いている<h3 id="2-5-完结体"><a href="#2-5-完结体" class="headerlink" title="2.5 完结体"></a>2.5 完结体</h3>表示动作、行为的完成、结束。表现形式多为复合动词，如「終わる」「あがる」「あげる」「尽くす」「切る」「通す」「ぬく」等，和「てしまう」<h3 id="2-6-存续体"><a href="#2-6-存续体" class="headerlink" title="2.6 存续体"></a>2.6 存续体</h3>表示动作或作用完成后的状态的存续。表现形式有: 「ている」「てある」「(ら)れている」「たところだ」「たばかりだ」等，相当于汉语的“…了”、“…着”</li></ul><h2 id="3-特殊体"><a href="#3-特殊体" class="headerlink" title="3. 特殊体"></a>3. 特殊体</h2><h3 id="3-1-完成体的进行意义"><a href="#3-1-完成体的进行意义" class="headerlink" title="3.1 完成体的进行意义"></a>3.1 完成体的进行意义</h3><p>有些动词虽然是“完成体”的形态，但并不表示“完成体”的基本意义，而是表达行进过程中的状态。<br>「いく」「くる」以及类似它们的「むかい」「おく」之类的移动动词，以「していく」「している」的形式出现的动词，以及被「どんどん」「ぐんぐん」等行进性的副词修饰限定的变化动词等属于此类。</p><h3 id="3-2-完成体与持续体相同意义的情况"><a href="#3-2-完成体与持续体相同意义的情况" class="headerlink" title="3.2 完成体与持续体相同意义的情况"></a>3.2 完成体与持续体相同意义的情况</h3><p>表状态时“完成体”和“持续体”两者表达同样事物，“体”未实现其分化。主要有以下两类:</p><ul><li>表说话人以感官感觉到的状态性现象</li><li>表存在</li></ul><h3 id="3-3-整体性无法识别的情况"><a href="#3-3-整体性无法识别的情况" class="headerlink" title="3.3 整体性无法识别的情况"></a>3.3 整体性无法识别的情况</h3><p>在表示说话人内心活动时，是否是整体性处置的状态看不出来。主要有以下两类:</p><ul><li>表说话人的考虑和想法</li><li>表说话人的感觉</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>撰写本文前主要看了以下书籍和文章: 日语语法专题教程<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.">[1]</span></a></sup>, Japanese Aspect: the Beginning, Middle, &amp; End of Actions, “浅析日语复句中的“时”和“体”, “日语动词的“体”特征分类”, Are Japanese ‘Tenses’ Aspects in Disguise?, 【中级日语】日语的时态和体，ル形、タ形和ている形的区别<br>Kino觉得，体的概念在日语中的确存在，但是并不是那么有规律，记住「ている」这种较为常见的用法即可，剩下的主要是能够理解句子的状态。<br>本篇文章主要叙述了体的概念，下一篇将讲解日语中的态。</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><p> Admin, Wasabi. “Japanese Aspect: the Beginning, Middle, &amp; End of Actions.” 20 Aug. 2016, <a href="https://www.wasabi-jpn.com/japanese-grammar/japanese-aspect-the-beginning-middle-end-of-actions/" target="_blank" rel="noopener">https://www.wasabi-jpn.com/japanese-grammar/japanese-aspect-the-beginning-middle-end-of-actions/</a>.<br> 辛宇峰. “浅析日语复句中的“时”和“体”.” 长沙铁道学院学报:社会科学版 4(2014):54-55.<br> 孙敦夫. “日语动词的“体”特征分类” 外语教学 2(2008):39-42.<br> SweeperSweeper 2, et al. “Are Japanese ‘Tenses’ Aspects in Disguise?” Japanese Language Stack Exchange, 29 Jan. 2017, <a href="https://japanese.stackexchange.com/questions/42988/are-japanese-tenses-aspects-in-disguise" target="_blank" rel="noopener">https://japanese.stackexchange.com/questions/42988/are-japanese-tenses-aspects-in-disguise</a>.<br> 日本狸猫田中裕之. “【中级日语】日语的时态和体，ル形、タ形和ている形的区别.” 知乎专栏, 4 June 2019, <a href="https://zhuanlan.zhihu.com/p/67847551" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/67847551</a>.<div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)">马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.<a href="#fnref:1" rev="footnote"> ↩</a></span></div></div></div></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;/2018/06/01/japanese04/&quot;&gt;上一篇文章&lt;/a&gt;介绍了极性和时轴，这一章主要介绍体的相关语法，体的概念在&lt;a href=&quot;/2017/09/16/japanese01/#2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5&quot;&gt;第一篇文章&lt;/a&gt;里已经介绍过，此处再介绍一遍: 体表示某个动作或变化在&lt;strong&gt;说话人所设的时间轴&lt;/strong&gt;上处于开始、持续和完成状态中的某一阶段，是从时间角度上对动作和变化的描写或把握。&lt;strong&gt;需要注意的是在日语中体仅仅反映在动词上&lt;/strong&gt;&lt;br&gt;PS: 日语语法在”体”这方面的变化并不是那么明显, 虽然语法概念上可以分很细, 但实际需要进行特殊的变形转换的并不多, 更多的是靠上下文的时间轴来界定”体”的状态.&lt;/p&gt;
    
    </summary>
    
      <category term="humanities" scheme="https://blog.xuwei.fun/categories/humanities/"/>
    
      <category term="languages" scheme="https://blog.xuwei.fun/categories/humanities/languages/"/>
    
    
      <category term="japanese" scheme="https://blog.xuwei.fun/tags/japanese/"/>
    
  </entry>
  
  <entry>
    <title>日语学习三</title>
    <link href="https://blog.xuwei.fun/2018/06/01/japanese04/"/>
    <id>https://blog.xuwei.fun/2018/06/01/japanese04/</id>
    <published>2018-06-01T11:04:23.000Z</published>
    <updated>2020-05-02T10:18:27.347Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>————<strong>更新于2018.06.01</strong>————<br><a href="/2017/09/30/japanese03/">上一篇文章</a>介绍了词类系统和句法成分，这篇文章Kino主要来讲解极性时轴。<br>在语言学中，极性———即Polarity———表示该句是肯定还是否定、判断真还是假，具体细节可参考<a href="https://ja.wikipedia.org/wiki/極性_%28言語学%29" target="_blank" rel="noopener">極性</a><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “極性 (言語学).” Wikipedia, Wikimedia Foundation, 14 June 2018, https://ja.wikipedia.org/wiki/極性_(言語学).">[1]</span></a></sup>、<a href="https://en.wikipedia.org/wiki/Affirmation_and_negation" target="_blank" rel="noopener">Affirmation and negation</a><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “Affirmation and Negation.” Wikipedia, Wikimedia Foundation, 19 June 2018, https://en.wikipedia.org/wiki/Affirmation_and_negation.">[2]</span></a></sup>、<a href="https://en.wikipedia.org/wiki/Polarity_item" target="_blank" rel="noopener">Polarity item</a><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “Polarity Item.” Wikipedia, Wikimedia Foundation, 19 June 2018, https://en.wikipedia.org/wiki/Polarity_item.">[3]</span></a></sup>等，时轴在这里指时(tense)，在<a href="/2017/09/16/japanese01/#2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">第一篇文章</a>里已经介绍过，Kino为了凑够四字标题且避免使用时态这种说法，就用了时轴这个词，灵感来源于现在常用时间轴来表示过去、现在、将来，后续为方便大多还是只用“时”这个称谓了。<br>将极性和时轴放在一起且最先介绍的理由为: 这两项较为容易理解，且负极性（否定）搭配过去时的变形经常互相影响。<br>考虑极性、时、体、态、式以及敬体系统，在讨论其中一项或几项的概念规则时，其他几项应该有相应基准作为参考，按照惯例应该是正极性、现在时、一般体、主动态、陈述式、非敬体。</p><a id="more"></a><h2 id="1-极性"><a href="#1-极性" class="headerlink" title="1. 极性"></a>1. 极性</h2><p>如前所述，极性分为肯定和否定。本章将分两大节来讲解极性，一是在句尾变形表示整个句子的极性，二是在句中变形词汇表示修饰语的极性。<br>本章所述均为当前状态，也就是现在时。</p><h3 id="1-1-句尾"><a href="#1-1-句尾" class="headerlink" title="1.1 句尾"></a>1.1 句尾</h3><p>完整句子的句尾肯定是述语，包括名词、形容词和动词，其中句尾是名词、形容词时，表达一种状态、情感等，句尾是动词时，表达一种动作。</p><h4 id="1-1-1-名词"><a href="#1-1-1-名词" class="headerlink" title="1.1.1 名词"></a>1.1.1 名词</h4><p>以“我是学生”、“我不是学生”为例。</p><ul><li>肯定: 句尾名词后加「だ」表示肯定极性，「私は学生だ」</li><li>否定: 句尾名词后加「じゃない」，「私は学生じゃない」</li><li><strong>注意: 肯定极性中的「だ」可以省略。</strong></li></ul><h4 id="1-1-2-形容词"><a href="#1-1-2-形容词" class="headerlink" title="1.1.2 形容词"></a>1.1.2 形容词</h4><p>な形容词和い形容词规则不同，分开来讲。</p><h5 id="1-1-2-1-な形容词"><a href="#1-1-2-1-な形容词" class="headerlink" title="1.1.2.1 な形容词"></a>1.1.2.1 な形容词</h5><p>规则和名词在句尾相同，以“学校安静”、“学校不安静”为例。</p><ul><li>肯定: 句尾な形容词后加「だ」表示肯定极性，「学校が静かだ」</li><li>否定: 句尾な形容词后加「じゃない」，「学校が静かじゃない」</li><li><strong>注意: 肯定极性中的「だ」可以省略。</strong></li></ul><h5 id="1-1-2-2-い形容词"><a href="#1-1-2-2-い形容词" class="headerlink" title="1.1.2.2 い形容词"></a>1.1.2.2 い形容词</h5><p>以“她可爱”、“她不可爱”为例。</p><ul><li>肯定: 不做变化，「彼女は可愛い」</li><li>否定: 句尾い形容词，将「い」变为「くない」，「彼女は可愛くない」</li></ul><h4 id="1-1-3-动词"><a href="#1-1-3-动词" class="headerlink" title="1.1.3 动词"></a>1.1.3 动词</h4><p>一段动词、五段动词和特殊动词不同，分开来讲。</p><h5 id="1-1-3-1-一段动词（る动词）"><a href="#1-1-3-1-一段动词（る动词）" class="headerlink" title="1.1.3.1 一段动词（る动词）"></a>1.1.3.1 一段动词（る动词）</h5><p>以“我吃饭”、“我不吃饭”为例。</p><ul><li>肯定: 不做变化，「私はたべる」</li><li>否定: 句尾一段动词，将「る」变为「ない」，「私はたべない」</li></ul><h5 id="1-1-3-2-五段动词（う动词）"><a href="#1-1-3-2-五段动词（う动词）" class="headerlink" title="1.1.3.2 五段动词（う动词）"></a>1.1.3.2 五段动词（う动词）</h5><p>以“我玩”、“我不玩”、“我买”、“我不买”为例。</p><ul><li>肯定: 不做变化，「私は遊ぶ」、「私は買う」</li><li>否定: 句尾五段动词，将词尾变为同行「あ」段假名，再加上「ない」，也即将 /u/ 音变为 /anai/，但是以「う」结尾的词需要变成「わ」，「私は遊ばない」、「私は買わない」</li></ul><h5 id="1-1-3-3-特殊动词"><a href="#1-1-3-3-特殊动词" class="headerlink" title="1.1.3.3 特殊动词"></a>1.1.3.3 特殊动词</h5><p>特殊动词する、くる的的变形比较特别，此外还有ある比较特别。对于する、くる、ある，按照顺序规则分别为:</p><ul><li>肯定: 不做变化</li><li>否定: しない、こない、ない</li></ul><h3 id="1-2-句中"><a href="#1-2-句中" class="headerlink" title="1.2 句中"></a>1.2 句中</h3><p>用在句中，即做修饰语用。</p><h4 id="1-2-1-名词"><a href="#1-2-1-名词" class="headerlink" title="1.2.1 名词"></a>1.2.1 名词</h4><p>以“是学生的人”和“不是学生的人”为例。</p><ul><li>肯定: 名词肯定极性没法直接修饰名词，即*<em>不能使用</em>「学生だ人」这种表达方式。事实上，在日语里没有现在时的“是学生的人”这种形式</li><li>否定: 和在句尾做述语的形式相同，「学生じゃな人」</li><li>注意: 名词A与名词B没有修饰关系时，可以并排放置使用，如「国际教育中心」，名词A和名词B是从属关系时，即“A的B”这种关系，可以用「AのB」表达</li></ul><h4 id="1-2-2-形容词"><a href="#1-2-2-形容词" class="headerlink" title="1.2.2 形容词"></a>1.2.2 形容词</h4><h5 id="1-2-2-1-な形容词"><a href="#1-2-2-1-な形容词" class="headerlink" title="1.2.2.1 な形容词"></a>1.2.2.1 な形容词</h5><p>以“有名的人”和“不有名的人”为例。</p><ul><li>肯定: 在词尾加「な」，「有名な人」</li><li>否定: 和在句尾做述语的形式相同，「有名じゃない人」<h5 id="1-2-2-2-い形容词"><a href="#1-2-2-2-い形容词" class="headerlink" title="1.2.2.2 い形容词"></a>1.2.2.2 い形容词</h5>以“可爱的Kino”和“不可爱的Kino”为例。</li><li>肯定: 和在句尾做述语的形式相同，「可愛いキノ」</li><li>否定: 和在句尾做述语的形式相同，「可愛くないキノ」</li></ul><h4 id="1-2-3-动词"><a href="#1-2-3-动词" class="headerlink" title="1.2.3 动词"></a>1.2.3 动词</h4><p>和在句尾做述语完全相同，不赘述。</p><h2 id="2-时轴"><a href="#2-时轴" class="headerlink" title="2. 时轴"></a>2. 时轴</h2><p>关于时轴，日语里只有两种类型，过去时和现在时，上一章所有变形都是在现在时的情况下，下面结束过去时的变形方式。</p><h3 id="2-1-句尾"><a href="#2-1-句尾" class="headerlink" title="2.1 句尾"></a>2.1 句尾</h3><h4 id="2-1-1-名词"><a href="#2-1-1-名词" class="headerlink" title="2.1.1 名词"></a>2.1.1 名词</h4><p>以“我过去是学生”和“我过去不是学生”为例。</p><ul><li>肯定: 句尾名词后加「だった」表示过去肯定，「私は学生いだった」</li><li>否定: 句尾名词后加「じゃなかった」表示过去否定，「私は学生いじゃなかった」</li></ul><h4 id="2-1-2-形容词"><a href="#2-1-2-形容词" class="headerlink" title="2.1.2 形容词"></a>2.1.2 形容词</h4><h5 id="2-1-2-1-な形容词"><a href="#2-1-2-1-な形容词" class="headerlink" title="2.1.2.1 な形容词"></a>2.1.2.1 な形容词</h5><p>以“学校过去是安静的”和“学校过去是不安静的”为例。</p><ul><li>肯定: 句尾な形容词后加「だった」表示过去肯定，「学校は静かだった」</li><li>否定: 句尾な形容词后加「じゃなかった」表示过去否定，「学校は静かじゃなかった」</li></ul><h5 id="2-1-2-2-い形容词"><a href="#2-1-2-2-い形容词" class="headerlink" title="2.1.2.2 い形容词"></a>2.1.2.2 い形容词</h5><p>以“Kino过去是可爱的”和“Kino过去是不可爱的”为例。</p><ul><li>肯定: 句尾い形容词将「い」变为「かった」表示过去肯定，「キノは可愛かった」</li><li>否定: 句尾い形容词将「い」变为「くなかった」表示过去肯定，「キノは可愛くなかった」</li></ul><h4 id="2-1-3-动词"><a href="#2-1-3-动词" class="headerlink" title="2.1.3 动词"></a>2.1.3 动词</h4><p>一段动词、五段动词和特殊动词不同，分开来讲。</p><h5 id="2-1-3-1-一段动词"><a href="#2-1-3-1-一段动词" class="headerlink" title="2.1.3.1 一段动词"></a>2.1.3.1 一段动词</h5><p>以“我过去吃了”和“我过去没吃”为例。</p><ul><li>肯定: 句尾一段动词将「る」变为「た」，「私は食べた」</li><li>否定: 句尾一段动词将「る」变为「なかった」，「私は食べなかった」<h5 id="2-1-3-2-五段动词"><a href="#2-1-3-2-五段动词" class="headerlink" title="2.1.3.2 五段动词"></a>2.1.3.2 五段动词</h5>五段动词的过去时较为复杂，不举具体例子说明。</li><li>肯定: 句尾五段动词的过去肯定变形较为复杂，结尾词不同其形式不同，分别是「す」-&gt;「した」、「く」-&gt;「いた」、「ぐ」-&gt;「いだ」、「む/ぶ/ぬ」-&gt;「んだ」、「る/う/つ」-&gt;「った」，<strong>唯一的例外是「行く」-&gt;「行いた」-&gt;「行った」</strong>。</li><li>否定: 在现在时的否定基础上，将「い」变为「かった」<h5 id="2-1-3-3-特殊动词"><a href="#2-1-3-3-特殊动词" class="headerlink" title="2.1.3.3 特殊动词"></a>2.1.3.3 特殊动词</h5>特殊动词する、くる的过去时变形比较特别，按照顺序规则分别为:</li><li>肯定: した、きた</li><li>否定: しなかった、こなかった</li></ul><h3 id="2-2-句中"><a href="#2-2-句中" class="headerlink" title="2.2 句中"></a>2.2 句中</h3><p>所有词性的过去时在句中的形式和句尾是相同的，即所有过去时的名词、形容词、动词都可以直接做修饰语，修饰另一个名词。</p><h2 id="3-时极综合"><a href="#3-时极综合" class="headerlink" title="3. 时极综合"></a>3. 时极综合</h2><p>对于名词、な形容词、い形容词、一段动词和五段动词，综合考虑极性、时轴和在句子的位置，分别得到表1、2、3、4、5、6。</p><p align="center">表1 名词</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">现在肯定</th><th style="text-align:center">现在否定</th><th style="text-align:center">过去肯定</th><th style="text-align:center">过去否定</th></tr></thead><tbody><tr><td style="text-align:center">句尾</td><td style="text-align:center">だ</td><td style="text-align:center">じゃない</td><td style="text-align:center">だった</td><td style="text-align:center">じゃなかった</td></tr><tr><td style="text-align:center">句中</td><td style="text-align:center">不存在该用法</td><td style="text-align:center">じゃない</td><td style="text-align:center">だった</td><td style="text-align:center">じゃなかった</td></tr></tbody></table><p align="center">表2 な形容词</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">现在肯定</th><th style="text-align:center">现在否定</th><th style="text-align:center">过去肯定</th><th style="text-align:center">过去否定</th></tr></thead><tbody><tr><td style="text-align:center">句尾</td><td style="text-align:center">だ</td><td style="text-align:center">じゃない</td><td style="text-align:center">だった</td><td style="text-align:center">じゃなかった</td></tr><tr><td style="text-align:center">句中</td><td style="text-align:center">な</td><td style="text-align:center">じゃない</td><td style="text-align:center">だった</td><td style="text-align:center">じゃなかった</td></tr></tbody></table><p align="center">表3 い形容词</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">现在肯定</th><th style="text-align:center">现在否定</th><th style="text-align:center">过去肯定</th><th style="text-align:center">过去否定</th></tr></thead><tbody><tr><td style="text-align:center">句尾</td><td style="text-align:center">原形</td><td style="text-align:center">くない</td><td style="text-align:center">かった</td><td style="text-align:center">くなかった</td></tr><tr><td style="text-align:center">句中</td><td style="text-align:center">原形</td><td style="text-align:center">くない</td><td style="text-align:center">かった</td><td style="text-align:center">くなかった</td></tr></tbody></table><p align="center">表4 一段动词</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">现在肯定</th><th style="text-align:center">现在否定</th><th style="text-align:center">过去肯定</th><th style="text-align:center">过去否定</th></tr></thead><tbody><tr><td style="text-align:center">句尾</td><td style="text-align:center">原形</td><td style="text-align:center"><del>る</del>ない</td><td style="text-align:center"><del>る</del>た</td><td style="text-align:center"><del>る</del>なかった</td></tr><tr><td style="text-align:center">句中</td><td style="text-align:center">原形</td><td style="text-align:center"><del>る</del>ない</td><td style="text-align:center"><del>る</del>た</td><td style="text-align:center"><del>る</del>なかった</td></tr></tbody></table><p align="center">表5 五段动词</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">现在肯定</th><th style="text-align:center">现在否定</th><th style="text-align:center">过去肯定</th><th style="text-align:center">过去否定</th></tr></thead><tbody><tr><td style="text-align:center">句尾</td><td style="text-align:center">原形</td><td style="text-align:center"><del>/u/</del>/a/ない</td><td style="text-align:center">「す-&gt;した」「く-&gt;いた」、「ぐ-&gt;いだ」、「む/ぶ/ぬ-&gt;んだ」、「る/う/つ-&gt;った」</td><td style="text-align:center">否定极+过去时</td></tr><tr><td style="text-align:center">句中</td><td style="text-align:center">原形</td><td style="text-align:center"><del>/u/</del>/a/ない</td><td style="text-align:center">「す-&gt;した」「く-&gt;いた」、「ぐ-&gt;いだ」、「む/ぶ/ぬ-&gt;んだ」、「る/う/つ-&gt;った」</td><td style="text-align:center">否定极+过去时</td></tr></tbody></table><p align="center">表6 特殊动する、くる</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">现在肯定</th><th style="text-align:center">现在否定</th><th style="text-align:center">过去肯定</th><th style="text-align:center">过去否定</th></tr></thead><tbody><tr><td style="text-align:center">句尾</td><td style="text-align:center">原形</td><td style="text-align:center">しない、こない</td><td style="text-align:center">した、きた</td><td style="text-align:center">しなかった、こなかった</td></tr><tr><td style="text-align:center">句中</td><td style="text-align:center">原形</td><td style="text-align:center">しない、こない</td><td style="text-align:center">した、きた</td><td style="text-align:center">しなかった、こなかった</td></tr></tbody></table><p>可以看出，除却名词和な形容词，其余几类在作为述语和作为修饰语的情况下，规则是完全相同的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要讲解了日语中的极性和时，下一篇文章将讲解日语中的动作体貌。</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)">Wikipedians. “極性 (言語学).” Wikipedia, Wikimedia Foundation, 14 June 2018, <a href="https://ja.wikipedia.org/wiki/極性_(言語学)" target="_blank" rel="noopener">https://ja.wikipedia.org/wiki/極性_(言語学)</a>.<a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)">Wikipedians. “Affirmation and Negation.” Wikipedia, Wikimedia Foundation, 19 June 2018, <a href="https://en.wikipedia.org/wiki/Affirmation_and_negation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Affirmation_and_negation</a>.<a href="#fnref:2" rev="footnote"> ↩</a></span></div><div id="fn:3" style="display:flex"><span style="width:20px">3.</span><span style="width:calc(100% - 20px)">Wikipedians. “Polarity Item.” Wikipedia, Wikimedia Foundation, 19 June 2018, <a href="https://en.wikipedia.org/wiki/Polarity_item" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Polarity_item</a>.<a href="#fnref:3" rev="footnote"> ↩</a></span></div></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;————&lt;strong&gt;更新于2018.06.01&lt;/strong&gt;————&lt;br&gt;&lt;a href=&quot;/2017/09/30/japanese03/&quot;&gt;上一篇文章&lt;/a&gt;介绍了词类系统和句法成分，这篇文章Kino主要来讲解极性时轴。&lt;br&gt;在语言学中，极性———即Polarity———表示该句是肯定还是否定、判断真还是假，具体细节可参考&lt;a href=&quot;https://ja.wikipedia.org/wiki/極性_%28言語学%29&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;極性&lt;/a&gt;&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;Wikipedians. “極性 (言語学).” Wikipedia, Wikimedia Foundation, 14 June 2018, https://ja.wikipedia.org/wiki/極性_(言語学).
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;、&lt;a href=&quot;https://en.wikipedia.org/wiki/Affirmation_and_negation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Affirmation and negation&lt;/a&gt;&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;Wikipedians. “Affirmation and Negation.” Wikipedia, Wikimedia Foundation, 19 June 2018, https://en.wikipedia.org/wiki/Affirmation_and_negation.
&quot;&gt;[2]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;、&lt;a href=&quot;https://en.wikipedia.org/wiki/Polarity_item&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Polarity item&lt;/a&gt;&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;Wikipedians. “Polarity Item.” Wikipedia, Wikimedia Foundation, 19 June 2018, https://en.wikipedia.org/wiki/Polarity_item.&quot;&gt;[3]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;等，时轴在这里指时(tense)，在&lt;a href=&quot;/2017/09/16/japanese01/#2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5&quot;&gt;第一篇文章&lt;/a&gt;里已经介绍过，Kino为了凑够四字标题且避免使用时态这种说法，就用了时轴这个词，灵感来源于现在常用时间轴来表示过去、现在、将来，后续为方便大多还是只用“时”这个称谓了。&lt;br&gt;将极性和时轴放在一起且最先介绍的理由为: 这两项较为容易理解，且负极性（否定）搭配过去时的变形经常互相影响。&lt;br&gt;考虑极性、时、体、态、式以及敬体系统，在讨论其中一项或几项的概念规则时，其他几项应该有相应基准作为参考，按照惯例应该是正极性、现在时、一般体、主动态、陈述式、非敬体。&lt;/p&gt;
    
    </summary>
    
      <category term="humanities" scheme="https://blog.xuwei.fun/categories/humanities/"/>
    
      <category term="languages" scheme="https://blog.xuwei.fun/categories/humanities/languages/"/>
    
    
      <category term="japanese" scheme="https://blog.xuwei.fun/tags/japanese/"/>
    
  </entry>
  
  <entry>
    <title>区块链学习一</title>
    <link href="https://blog.xuwei.fun/2018/03/24/blockchain01/"/>
    <id>https://blog.xuwei.fun/2018/03/24/blockchain01/</id>
    <published>2018-03-24T07:28:37.000Z</published>
    <updated>2019-05-18T14:24:32.981Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在协助一个团队做一个和区块链相关的项目，虽然比较边缘性，和区块链联系没那么紧密，但区块链本身还是需要了解一下的。</p><p>花了一天阅读了一下区块链技术指南<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[区块链技术指南](https://github.com/yeasy/blockchain_guide)">[1]</span></a></sup><br><a id="more"></a></p><h2 id="1-区块链思想的诞生与概念"><a href="#1-区块链思想的诞生与概念" class="headerlink" title="1. 区块链思想的诞生与概念"></a>1. 区块链思想的诞生与概念</h2><p>这一章从数字货币入手，比较了传统纸币和数字货币之间的优劣，概述了设计数字货币时需要解决的技术难点，进而引入了区块链的概念。<br>其中一些以前不了解的细节有:</p><ul><li>严格来讲, 货币（money）不等于现金或通货（cash，currency），货币的范围更广，维基百科里的相关解释:<ul><li>Money: Money is any item or verifiable record that is generally accepted as payment for goods and services and repayment of debts in a particular country or socio-economic context.</li><li>Currency: A currency is a system of money (monetary units) in common use, especially in a nation.</li><li>Cash: In economics, cash is money in the physical form of currency, such as banknotes and coins. In bookkeeping and finance, cash is current assets comprising currency or currency equivalents that can be accessed immediately or near-immediately (as in the case of money market accounts).</li></ul></li><li>去中心化场景下，数字货币的实现存在的难点:<ul><li>货币的防伪:谁来负责验证货币</li><li>货币交易:如何确定货币从一方转移到另外一方</li><li>避免双重支付:如何避免出现双重支付</li></ul></li><li>区块链技术雏形最早出现在比特币项目中，作为比特币背后的分布式记账平台，从记账的角度来看，区块链是首个自带对账功能的数字记账技术实现。跟传统的记账技术相比，其特点应该包括:<ul><li>维护一条不断增长的链，只可能添加记录，而发生过的记录都不可篡改</li><li>去中心化，或者说多中心化，无需集中的控制而能达成共识，实现上尽量分布式</li><li>通过密码学的机制来确保交易无法抵赖和破坏，并尽量保护用户信息和记录的隐私性</li></ul></li><li>当前区块链技术的三种典型应用场景:<ul><li>比特币为代表的公信的数字货币</li><li>以太坊为代表的公信的交易处理</li><li>Hyperleger为代表的带权限的交易处理</li></ul></li><li>区块链的基本概念:<ul><li>交易(Transaction):一次操作，导致账本状态的一次改变，如添加一条记录</li><li>区块(Block):记录一段时间内发生的交易和状态结果，是对当前账本状态的一次共识</li><li>链(Chain):由一个个区块按照发生顺序串联而成，是整个状态变化的日志记录</li></ul></li><li>nonce: In cryptography, a nonce is an arbitrary number that can only be used once. It is similar in spirit to a nonce word, hence the name. It is often a random or pseudo-random number issued in an authentication protocol to ensure that old communications cannot be reused in replay attacks. They can also be useful as initialization vectors and in cryptographic hash functions.</li><li>分类:<ul><li>根据参与者的不同，可以分为公开(Public)链、联盟(Consortium)链和私有(Private)链</li><li>根据使用目的和场景的不同，又可以分为以数字货币为目的的货币链，以记录产权为目的的产权链，以众筹为目的的众筹链等</li></ul></li><li>借(Debit): 意味着债务，表示从其他方转移到本科目内; 贷(Credit): 意味着债权，代表从该科目转移出去</li></ul><h2 id="2-区块链技术的价值、挑战和展望"><a href="#2-区块链技术的价值、挑战和展望" class="headerlink" title="2. 区块链技术的价值、挑战和展望"></a>2. 区块链技术的价值、挑战和展望</h2><ul><li>从技术特点上，区块链一般被认为具有:<ul><li>分布式容错性:网络极其鲁棒，容错 1/3 左右节点的异常状态</li><li>不可篡改性:一致提交后的数据会一直存在，不可被销毁或修改</li><li>隐私保护性:密码学保证了未经授权者能访问到数据，但无法解析</li></ul></li><li>随之带来的业务特性将可能包括:<ul><li>可信任性:区块链技术可以提供天然可信的分布式账本平台，不需要额外第三方中介机构</li><li>降低成本:跟传统技术相比，区块链技术可能带来更短的时间、更少的人力和维护成本</li><li>增强安全:区块链技术将有利于安全可靠的审计管理和账目清算，减少犯罪可能性，和各种风险</li></ul></li><li>能否最终带来成本的降低，将是一项技术能否被深入应用的关键</li><li>所有跟信息、价值（包括货币、证券、专利、版权、数字商品、实际物品等）、信用等相关的交换过程，都将可能从区块链技术中得到启发或直接受益</li><li>涉及领域: 分布式、存储、密码学、心理学、经济学、博弈论、网络协议、系统安全等, 相关限制: 处理性能、扩展性等</li><li>常见的分布式系统，可以通过增加节点来扩展整个系统的处理能力。区块链并非如此。</li></ul><h2 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3. 应用场景"></a>3. 应用场景</h2><ul><li>有直接或间接依赖于第三方担保信任机构的活动，均可能从区块链技术中获益<ul><li>金融服务<ul><li>银行金融管理</li><li>证券交易</li></ul></li><li>征信和权属管理</li><li>资源共享</li><li>投资管理</li><li>物联网与供应链</li></ul></li><li>制约区块链技术进一步应用的因素:<ul><li>首先就是谁来为区块链上的合同担保？特别在金融、法律等领域，实际执行的生活往往还得是由人来做</li><li>另外就是物品的数字化。非数字化的物品很难放到数字世界中进行管理。</li></ul></li><li>一些对于上述观点的补充:<ul><li>做任何应用层面的东西，都要意识到这个社会中最重要的永远是人的存在，所以人性永远在考虑范围内，而区块链的应用脱离了人只考虑数字世界必然是行不通的，需要对人性有所分析，对区块链应用涉及的社会活动所影响到的人的心理都要有充分估计，否则只是空谈而已。</li><li>关于物品的数字化，的确是个问题，主要体现在物联网与供应链应用上，因为无法完全数字化，就必然会涉及到人，比如物流过程中从一级到另一级，一个物流人员将一个商品掉包如何确认？肯定不能够通过商品上贴的二维码来保证吧。其实就相当于得找到一个Hash算法，将实际物体映射到数字世界，或者思维转变，不考虑实际物体的数字化，而是着手与供应链过程中涉及到的人的信任保证。</li><li>是不是区块链、叫不叫区块链，其实都不重要，主要是利用技术解决在没有”中介”的情况下如何促成一项交易的完成，确保一件物品的归属。减少交易环节是一个实实在在的需求，能够通过一项技术去减少交易环节，最好是P2P且能够保证双方信任的，这项技术的综合成本比原先的交易流程中间过程成本低，就是有价值的，而技术本身的实现并不唯一，但是技术必然需要实现以上需求的核心要求，其中最重要的就是去中心化，反观现在很多产品是打着区块链幌子的积分制而已，根本没有去中心化。</li><li>以上观点都是一时的想法… 接触了更多知识有了更多思考之后应该有很多地方需要更正吧</li></ul></li></ul><h2 id="4-分布式系统的核心问题"><a href="#4-分布式系统的核心问题" class="headerlink" title="4. 分布式系统的核心问题"></a>4. 分布式系统的核心问题</h2><ul><li>一致性问题: <ul><li>概念: 在分布式系统中，一致性(Consistency，早期也叫 Agreement)是指对于系统中的多个服务节点，给定一系列操作，在协议（往往通过某种共识算法）保障下，试图使得它们对处理结果达成某种程度的一致。</li><li>解决分布式系统一致性问题的核心思想是: 将可能引发不一致的并行操作进行串行化</li><li>一致性需要满足的要求:<ul><li>可终止性(Termination): 一致的结果在有限时间内能完成</li><li>共识性(Consensus): 不同节点最终完成决策的结果应该相同</li><li>合法性(Validity): 决策的结果必须是其它进程提出的提案</li></ul></li><li>强一致性: 顺序一致性(Sequential Consistency)、线性一致性(Linearizability Consistency)</li><li>弱一致性</li><li>关于一致性问题，在学习多智能体协同控制相关知识的时候，也是重点研究的，其实本质上都是相似的，因为多智能体系统也是一个分布式系统，只是在多智能体问题中，一致性通常是更为严格地被数学模型所表达，最简单的就是多个智能体之间某一变量的一致，如位置、速度、加速度等，以方便最后理论证明提出的控制算法是否满足一致性，而计算机分布式系统中将所有进程看成一个序列，考虑序列的一致性，通常是保证序列元素的执行顺序。</li></ul></li><li>共识算法: 保障系统满足不同程度的一致性的解决方法。即便在网络通信可靠情况下，一个可扩展的分布式系统的共识问题的下限是无解。</li><li>FLP不可能原理: 在网络可靠，存在节点失效(即便只有一个)的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性算法。PS: 如果套用多智能体系统里的概念，相当于，若节点间组成的网络拓扑是不连通的，则系统无法达到一致性，但是如果长时间来看，即使某一时间段某个节点down掉了，只要下一时间段可以恢复，从而保证连续时间上的连通性，系统最终还是可以达到一致的。</li><li>CAP原理: 分布式计算系统不可能同时确保一致性(Consistency)、可用性(Availablity)和分区容忍性(Partition)，设计中往往需要弱化对某个特性的保证。<ul><li>一致性(Consistency): 任何操作应该都是原子的，发生在后面的事件能看到前面事件发生导致的结果，注意这里指的是强一致性</li><li>可用性(Availablity): 在有限时间内，任何非失败节点都能应答请求</li><li>分区容忍性(Partition): 网络可能发生分区，即节点之间的通信不可保障</li></ul></li><li>ACID原则: 即Atomicity(原子性)、Consistency(一致性)、Isolation(隔离性)、Durability(持久性)。ACID原则描述了对分布式数据库的一致性需求，同时付出了可用性的代价。</li><li>BASE原则: Basic Availiability，Soft state，Eventually Consistency，牺牲掉对一致性的约束(最终一致性)，来换取一定的可用性。</li><li>PAXOS算法:<ul><li>三种节点: proposer, acceptor, learner</li><li>两个阶段: 准备阶段、提交阶段</li></ul></li><li>Raft算法: Paxos算法的一种简化实现，包括三种角色: leader、candidate和follower，其基本过程为:<ul><li>Leader选举: 每个candidate随机经过一定时间都会提出选举方案，最近阶段中得票最多者被选为leader</li><li>同步log: leader会找到系统中log最新的记录，并强制所有的follower来刷新到这个记录</li></ul></li><li>拜占庭问题: 讨论的是允许存在少数节点作恶(消息可能被伪造)场景下的一致性达成问题<ul><li>PBFT算法: 包括三个阶段来达成共识, Pre-Prepare、Prepare 和 Commit</li><li>PoW算法 </li></ul></li></ul><h2 id="5-密码学与安全技术"><a href="#5-密码学与安全技术" class="headerlink" title="5. 密码学与安全技术"></a>5. 密码学与安全技术</h2><ul><li>工程领域从来没有黑科技；密码学不是工程。目的是保证信息的机密性、完整性、认证性和不可抵赖性</li><li>Hash算法与数字摘要</li><li>加解密算法: 保证机密性</li><li>数字签名: 用于证实某数字内容的完整性(integrity)和来源(或不可抵赖，non-repudiation)<ul><li>HMAC(Hash-based Message Authentication Code): 即”基于 Hash 的消息认证码”，HMAC(K, H, Message)，其中，K为提前共享的对称密钥，H为提前商定的Hash算法，Message为要处理的消息内容。HMAC 一般用于证明身份的场景</li><li>盲签名: 主要是为了实现防止追踪(unlinkability)，签名者无法将签名内容和结果进行对应，且消息的内容对签名者是不可见的</li><li>多重签名: 想象成一份文件被n个人管理，需要m个人签名才有效，这就是多重签名。可以用于电子商务、财产分割、资金监管等场景中，实际上类似电子商务这种需要中介担保的场景都可以用到多重签名</li><li>群签名</li><li>环签名: 属于一种简化的群签名</li></ul></li><li>数字证书: 用来证明某个公钥是谁的，并且内容是正确的</li><li>PKI体系: 在非对称加密中，公钥则可以通过证书机制来进行保护，如何管理和分发证书则可以通过 PKI(Public Key Infrastructure)来保障。PKI至少包含以下组件:<ul><li>CA(Certification Authority): 负责证书的颁发和作废，接收来自RA的请求，是最核心的部分</li><li>RA(Registration Authority): 对用户身份进行验证，校验数据合法性，负责登记，审核过了就发给CA</li><li>证书数据库: 存放证书，一般采用LDAP目录服务，标准格式采用X.500系列</li></ul></li><li>Merkle树，其特点是，底层数据的任何变动，都会传递到其父亲节点，一直到树根。典型应用场景包括:<ul><li>快速比较大量数据</li><li>快速定位修改</li><li>零知识证明</li></ul></li><li>同态加密，函数加密: 相关内容可以参考<a href="http://blog.sciencenet.cn/blog-411071-707426.html" target="_blank" rel="noopener">这里</a></li><li>零知识证明(zero knowledge validation): 证明者在不向验证者提供任何有用的信息的前提下，使验证者相信某个论断是正确的</li></ul><h2 id="6-比特币项目"><a href="#6-比特币项目" class="headerlink" title="6. 比特币项目"></a>6. 比特币项目</h2><ul><li>以前以为比特币交易是没有下限的，原来是有的，交易的最小单位是”聪”，即10exp-8比特币</li><li>原理和设计、挖矿、工具、共识机制、闪电网络、侧链</li></ul><h2 id="7-Ethereum-以太坊项目"><a href="#7-Ethereum-以太坊项目" class="headerlink" title="7. Ethereum(以太坊项目)"></a>7. Ethereum(以太坊项目)</h2><ul><li>智能合约</li></ul><h2 id="8-Hyperledger-超级账本项目"><a href="#8-Hyperledger-超级账本项目" class="headerlink" title="8. Hyperledger(超级账本项目)"></a>8. Hyperledger(超级账本项目)</h2><ul><li>Fabric</li></ul><h2 id="9-区块链服务平台设计"><a href="#9-区块链服务平台设计" class="headerlink" title="9. 区块链服务平台设计"></a>9. 区块链服务平台设计</h2><ul><li>区块链即服务（Blockchain as a Service，BaaS），是部署在云计算基础设施之上，对外提供区块链网络的生命周期管理和运行时服务管理等功能的一套工具</li><li>IBM Bluemix云区块链服务</li><li>微软Azure云区块链服务</li><li>使用超级账本Cello搭建区块链服务</li><li>一个看法是，若是区块链应用都建立在少数厂商的云上，那岂不是该云厂商就是实际的中心，区块链要解决的去中心化就不复存在了，私以为还是有一定道理的</li></ul><h2 id="10-一些想法"><a href="#10-一些想法" class="headerlink" title="10. 一些想法"></a>10. 一些想法</h2><p>区块链实际需要解决的还是去中心化(多中心化)场景下的信任问题，而涉及到现实世界中时，事情总不是那么容易解决的。一方面现实世界中永远是少部分人掌握大多数资源(生产资料)，无论是号称哪种体制，进行何种革命，到头来不过是一个轮回，而区块链目前看来也不可能是革命的手段，毕竟现在控制人类社会运转的资源并不会因为区块链而进行转移和改变，所以区块链若要大规模应用，如何避免其变成实际上的中心化是个很重要的问题，而这个问题很有可能无解，需要找到一种大多数人都有且数量级相当的资源来作为惩罚或奖励，Kino能想到的是生命值，不过这是不可能的。另一方面就是现在都是靠博弈来保证利益的最大化，保证实际结果的可信，而这些独立于数字世界之外的问题会对现实生活产生的影响有多少，也没有充分论证，博弈某种程度上也许就是把人类的恶拿了出来，而整个世界的社会实验，把整个社会的恶都反映了出来，会有什么情况，也是未知的。所以对于区块链技术将会革命整个现有生产关系的说法，Kino觉得不可能，或者保守点，近几十年年不可能。区块链当前最可能的应用大概还是资源相当的企业间的相关应用，其涉及的相关方需要数量偏少且资源没有数量级上的差别，比如汽车行业供应链上的资金流转。</p><h2 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h2><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)"><a href="https://github.com/yeasy/blockchain_guide" target="_blank" rel="noopener">区块链技术指南</a><a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)"><a href="https://bitcoin.org/" target="_blank" rel="noopener">比特币官网</a><a href="#fnref:2" rev="footnote"> ↩</a></span></div><div id="fn:3" style="display:flex"><span style="width:20px">3.</span><span style="width:calc(100% - 20px)"><a href="https://www.ethereum.org/" target="_blank" rel="noopener">以太坊官网</a><a href="#fnref:3" rev="footnote"> ↩</a></span></div></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在协助一个团队做一个和区块链相关的项目，虽然比较边缘性，和区块链联系没那么紧密，但区块链本身还是需要了解一下的。&lt;/p&gt;
&lt;p&gt;花了一天阅读了一下区块链技术指南&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;[区块链技术指南](https://github.com/yeasy/blockchain_guide)
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;&lt;br&gt;
    
    </summary>
    
      <category term="techonology" scheme="https://blog.xuwei.fun/categories/techonology/"/>
    
      <category term="blockchain" scheme="https://blog.xuwei.fun/categories/techonology/blockchain/"/>
    
    
      <category term="blockchain" scheme="https://blog.xuwei.fun/tags/blockchain/"/>
    
      <category term="cryptocurrency" scheme="https://blog.xuwei.fun/tags/cryptocurrency/"/>
    
      <category term="digital currency" scheme="https://blog.xuwei.fun/tags/digital-currency/"/>
    
  </entry>
  
  <entry>
    <title>用音乐逃离尘世</title>
    <link href="https://blog.xuwei.fun/2017/11/19/listening03/"/>
    <id>https://blog.xuwei.fun/2017/11/19/listening03/</id>
    <published>2017-11-19T15:18:23.000Z</published>
    <updated>2019-05-18T14:24:33.154Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="/2016/04/10/listening01">以前的文章</a>写到了最爱的十张专辑, 但十张是远不能记录自己的喜好滴. 就把自己硬盘里躺着的歌手、专辑列出来, 顺便按照喜爱程度评个分…</p><a id="more"></a><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul><li>Adele  ★★★★★★★★★★<br>高三毕业之后听了Adele…<br>有一次和好友A聊天,A突然说到:”我们当初是怎么熟悉的啊?” 我回答说我也忘了… 其实是假装的,因为莫名感觉有点不好意思哈哈哈<br>毕业那个假期大抵有点寂寞,高中才接触网络,却汲汲于学业和种种琐事,于是毕业就成了一个网瘾少年,每天就玩游戏、聊天,在学校的时候对A很好奇却无机会接触,毕业不知哪来的勇气找人聊天了。最开始聊天的内容基本全忘了,只记得A推荐了Adele的Someone like you,果然音乐才是永恒… 此后Adele一直躺在我的歌单里,也就让我记得了这件小事…<br>然而对Adele的评价却无关这些小事,一切只是因为Adele的声音太好了,前两张专辑太对我胃口了.<ul><li>19   ★★★★★★★★★★</li><li>21   ★★★★★★★★★★</li></ul></li><li>Amy Winehouse  ★★★★★★★★☆☆<br>死亡升华了毒后. 她的生平曾经加重了我对这个世界的绝望、不过对于爵士乐,我好像一直兴趣平平,曾经Norah Jones火遍全球时,也是无法欣赏,小野丽莎是为数不多我能听下去的爵士歌手<ul><li>Back to Black  ★★★★★★★★☆☆</li></ul></li><li>Angelic Foe<ul><li>Oppressed By The Heavens</li></ul></li><li>Ankhagram<ul><li>Where Are You Now</li></ul></li><li>Anne-Sophie Mutter<ul><li>Carmen Fantasy</li></ul></li><li>Anúna<ul><li>Omnis (1997)</li></ul></li><li>Bach<br>非专业古典爱好者,若要说一首巴赫的名曲出来,我能记得起来名字的就只有<em>地狱中的奥菲欧</em>了<ul><li>100 Best Bach (6CD)</li><li>Glenn Gould - The Complete Bach Collection (38CD)</li></ul></li><li>Bang Gang<ul><li>Ghosts from the Past</li></ul></li><li>Beethoven<ul><li>[DG 453 700-2]Complete Beethoven Edition (20VOL)</li></ul></li><li>Bette Midler<ul><li>Experience The Divine Greatest Hits</li></ul></li><li>Birdy<br>96年的小姐姐、啊不对,是小妹妹…<ul><li>Birdy</li></ul></li><li>Björk<ul><li>Vespertine</li></ul></li><li>Black Box Recorder<ul><li>England Made Me</li><li>Passionoia</li><li>The Worst Of Black Box Recorder</li></ul></li><li>Black Sabbath<ul><li>Paranoid</li></ul></li><li>Bright eyes<ul><li>I’M Wide Awake It’S Morning</li></ul></li><li>Buckethead<br>发专辑成瘾的桶头、然而我完整听过的只有一张专辑<ul><li>1998 - Colma</li></ul></li><li>Cat Power<ul><li>Dark End of The Street</li><li>Moon Pix</li><li>Myra Lee</li><li>Sun</li><li>The Greatest</li><li>The Greatest(JP Edition)</li><li>What Would The Community Think</li></ul></li><li>Chopin<ul><li>Chopin. Complete Edition (DG 2009)</li></ul></li><li>Chris De Burgh<ul><li>Footsteps (2008)</li></ul></li><li>Cigarettes after Sex<ul><li>Cigarettes After Sex</li></ul></li><li>Cinderella<ul><li>Heartbreak Station</li></ul></li><li>Club 8<ul><li>Best Wishes - Best Of Club 8</li><li>Pleasure</li></ul></li><li>Cocteau Twins<ul><li>Treasure</li></ul></li><li>Corde Oblique<ul><li>A Hail Of Bitter Almonds</li><li>Respiri</li><li>Volonta D’Arte</li></ul></li><li>Dark Lunacy<ul><li>Devoid</li><li>Forget Me Not</li></ul></li><li>Dark the Suns<ul><li>The Dead End</li></ul></li><li>Devil Doll<br>记不清从哪得知这个歌手了,也许是落网推荐的?只记得是和Estatic Fear放一起说的<ul><li>1989 - The Girl Who Was… Death<br>最早的时候无法欣赏,某天耐着性子听完了,自那以后就不定时拿出来重听一遍.</li><li>1990 - Eliogabalus</li><li>1992 - Sacrilegium</li><li>1993 - The Sacrilege Of Fatal Arms</li><li>1996 - Dies Irae</li></ul></li><li>Diana Boncheva<ul><li>Beethoven Virus</li></ul></li><li>Dido<ul><li>Greatest Hits (Deluxe Edition)</li></ul></li><li>Dishwalla<ul><li>Opaline</li></ul></li><li>Dreamtale<ul><li>Beyond Reality (2002)<br>序曲是魔兽玩家的记忆、</li></ul></li><li>Duffy<ul><li>Rockferry(Deluxe Edition)</li></ul></li><li>Dvar<ul><li>Deii</li><li>El Mariil</li></ul></li><li>Dvořák<ul><li>Dvořák _ The Masterworks, CD40</li></ul></li><li>Eric Clapton<ul><li>Basel, Switzerland (Baloise Session)</li><li>Layla And Other Assorted Love Songs</li></ul></li><li>Estatic Fear<ul><li>A Sombre Dance</li></ul></li><li>Gin Wigmore<ul><li>Gravel &amp; Wine</li></ul></li><li>Guns N’ Roses<ul><li>Appetite for Destruction 1987</li><li>Chinese democracy 2008</li><li>Greatest Hits 2004</li><li>Lies 1989 (Remastered MFSL)</li><li>Live Era 1999</li><li>The Spaghetti Incident 1993</li><li>Use Your Illusion I 1991</li><li>Use Your Illusion II 1991</li></ul></li><li>Gwen Stefani<ul><li>Love.Angel.Music.Baby</li></ul></li><li>Gérard Darmon<ul><li>On S’aime</li></ul></li><li>H.I.M<ul><li>Razorblade Romance</li></ul></li><li>Haggard<ul><li>Eppur Si Muove [Limited Edition]</li><li>Tales of Ithiria</li></ul></li><li>ICY<ul><li>Wanderlust流浪癖</li><li>住在春天</li><li>南澜掌</li><li>哼一首歌等日落</li><li>比天空还远</li><li>浅彩虹</li><li>遇见我</li><li>黑色香水</li></ul></li><li>Iggy Pop<ul><li>Préliminaires</li></ul></li><li>Imperium Dekadenz<ul><li>Dämmerung der Szenarien</li></ul></li><li>James Blake<ul><li>Overgrown</li></ul></li><li>Jennifer Warnes<ul><li>Famous Blue Raincoat</li></ul></li><li>Joan Jett<ul><li>The Hit List</li></ul></li><li>Joe Satriani<ul><li>Is There Love in Space</li><li>Super Colossal</li><li>The Complete Studio Albums Collection(Additional Creations and Bonus Tracks)</li><li>The Essential</li></ul></li><li>John Lennon<ul><li>Imagine</li></ul></li><li>Josh Vietti<ul><li>Best Of Both Worlds</li></ul></li><li>Joy Division<ul><li>Closer</li><li>Substance(1977-1980)</li><li>Unknown Pleasures</li></ul></li><li>Kalmah<ul><li>2010 - 12 Gauge</li></ul></li><li>Kate Bush<ul><li>Hounds of Love</li><li>Never for Ever</li><li>The Kick Inside</li><li>The Whole Story</li></ul></li><li>Lana Del Rey<ul><li>Born to die</li></ul></li><li>Leonard Cohen<ul><li>Ten New Songs</li><li>The Essential Leonard Cohen</li></ul></li><li>Lisa Ekdhal<ul><li>Give me that slow knowing smile</li></ul></li><li>Lou Reed<ul><li>Transformer</li></ul></li><li>Lush<ul><li>Hypocrite</li><li>Lovelife</li></ul></li><li>Lynyrd Skynyrd<ul><li>(Pronounced.Leh-Nerd.Skin-Nerd)</li><li>Second Helping</li></ul></li><li>Mac DeMarco<ul><li>Some Other Ones</li></ul></li><li>Mazzy Star<ul><li>Among my swan</li><li>Seasons of Your Day</li><li>She Hangs Brightly</li><li>So Tonight That I Might See</li></ul></li><li>Michael Jackson<ul><li>The Ultimate Collection (Japanese)</li></ul></li><li>Mono Inc<ul><li>After The War</li><li>Viva Hades</li><li>Voices Of Doom</li></ul></li><li>Monta<ul><li>Always Altamont</li><li>Good Morning Stranger</li><li>The Brilliant Masses</li><li>Where Circles Begin</li></ul></li><li>Mozart<ul><li>Mozart_225 (200CD)</li></ul></li><li>Mr. Big<ul><li>Bump Ahead</li><li>Lean Into It</li></ul></li><li>Muse<ul><li>Showbiz(1999)</li></ul></li><li>Mylène Farmer<ul><li>Innamoramento</li></ul></li><li>Nick Colionne<ul><li>Best Of Both Worlds</li></ul></li><li>Oasis<ul><li>Don’t Look Back in Anger</li><li>Let There Be Love</li><li>Wonderwall</li></ul></li><li>Ozzy Osbourne<ul><li>Blizzard Of Ozz</li><li>Blizzard Of Ozz (Expanded Edition)</li></ul></li><li>Paloma Faith<ul><li>Do You Want the Truth or Something Beautiful</li></ul></li><li>Paramore<ul><li>Riot (Deluxe Version)</li></ul></li><li>Pat Metheny Group<ul><li>1987 - Still Life (Talking)</li><li>1989 - Letter From Home</li><li>Upojenie</li></ul></li><li>Pink Floyd<ul><li>Animals</li><li>The Dark Side Of The Moon</li><li>The Dark Side Of The Moon (Immersion Box Set)</li><li>The Wall</li><li>Wish You Were Here</li></ul></li><li>Portishhead<ul><li>Dummy (1994)</li></ul></li><li>Priscilla Ahn<ul><li>A Good Day</li><li>Where You Grow Up</li></ul></li><li>Rachmaninoff<ul><li>Rachmaninov - The Complete Works (2014) <a href="32CD">FLAC</a></li></ul></li><li>Radiohead<ul><li>A Moon Shaped Pool</li></ul></li><li>Shostakovich<ul><li>Shostakovich Edition _ Symphonies - Concertos - Suites - String Quartets - Chamber Music (27CD)</li></ul></li><li>SOAK<ul><li>Before We Forgot How To Dream</li></ul></li><li>Standfast<ul><li>Standfast</li></ul></li><li>Steelheart<ul><li>Tangled in Reins</li></ul></li><li>Suede<ul><li>Coming Up</li></ul></li><li>SymphonyOrchestra<ul><li>Marco Beasley, Accordone - Morini - Solve et Coagula (2014)</li></ul></li><li>Tchaikovsky<ul><li>(60CD)</li></ul></li><li>The Cranberries<ul><li>Bury The Hatchet (The Complete Sessions 2002)</li><li>Everybody Else is Doing It, So Why Can’t We</li><li>Gold</li><li>Wake Up And Smell The Coffee</li></ul></li><li>The Hampdens<ul><li>The Last Party</li></ul></li><li>The Velvet Underground<ul><li>Loaded</li><li>The Velvet Underground(1969)</li></ul></li><li>The Verve<ul><li>Urban Hymns</li></ul></li><li>The Weepies<ul><li>(2006)Say I Am You</li></ul></li><li>The Who<ul><li>Who’s Next</li></ul></li><li>This Mortal Coil<ul><li>1983-1991 (1993)</li><li>Bloody</li><li>Dust &amp; Guitars</li><li>Filigree &amp; Shadow</li><li>It’ll End In Tears</li></ul></li><li>Tiamat<ul><li>Amanethes</li></ul></li><li>Tori Amos<ul><li>Little Earthquake</li></ul></li><li>Tracy Chapman<ul><li>Crossroads</li><li>Let It Rain</li><li>Matters of the Heart</li><li>New Beginning</li><li>Our Bright Future</li><li>Telling Stories</li><li>Tracy Chapman</li><li>Where You Live</li></ul></li><li>Vangelis<ul><li>The Best of Instrumental Works</li></ul></li><li>Various Artists<ul><li>Beautiful Field[2007]</li><li>とある科学の超電磁砲</li><li>クレヨンしんちゃん TV?映画 主題歌集だゾ</li><li>デュラララ!!</li></ul></li><li>Vivaldi<ul><li>Antonio.Vivaldi.-.[Vivaldi.masterworks(40CD)]</li></ul></li><li>WANDS<ul><li>『SLAM DUNK』 ED 02「世界が終わるまでは」</li></ul></li><li>Xandria<ul><li>Now&amp;Forever</li></ul></li><li>Yellow Magic Orchestra<ul><li>Solid State Survivor[1979]</li></ul></li><li>Yuhki Kuramoto<ul><li>Winter Holidays</li></ul></li><li>вечность.слушать.ветер<ul><li>вечность.слушать.ветер</li></ul></li><li>万能青年旅店<ul><li>万能青年旅店</li></ul></li><li>何韵诗<ul><li>First（EP）</li><li>诗与胡说（EP）</li><li>无名·诗（国语）</li><li>Awakening</li><li>Coexistence</li></ul></li><li>刘忻</li><li>发光曲线 (Glow Curve)<ul><li>迷航 (Dedicate To Mind) (2013)</li></ul></li><li>吉森信<ul><li>DuRaRaRa!!x2 Shou Original Soundtrack[320K]</li><li>DuRaRaRa!!x2 Ten Soundtrack CD[320K]</li><li>OST ベストヒット池袋 サイケデリミックス<br>对デュラララ!!爱得太深,也是它的歌曲让我坚持看了下去,没有最开始就放弃… 相辅相成</li></ul></li><li>周杰伦<ul><li>JAY</li><li>范特西</li><li>范特西 PLUS-EP</li><li>八度空间</li><li>叶惠美</li><li>七里香</li><li>十一月的肖邦</li><li>依然范特西</li><li>霍元甲</li><li>我很忙</li><li>魔杰座</li><li>跨时代</li><li>惊叹号</li><li>十二新作</li><li>哎呦，不错哦</li></ul></li><li>声音碎片乐队<ul><li>优美的低于生活</li><li>把光芒洒向更开阔的地方</li></ul></li><li>小野リサ<ul><li>2005-Romance Latino Vol.3</li></ul></li><li>张国荣<ul><li>I Am What I Am</li><li>宠爱</li></ul></li><li>张悬<ul><li>(2009)城市</li></ul></li><li>戸川純<ul><li>TOGAWA LEGEND SELF SELECT BEST &amp; RARE 1979-2008</li></ul></li><li>李志<ul><li>你好,郑州</li><li>梵高先生</li><li>这个世界会好吗</li></ul></li><li>杨乃文<ul><li>应该</li></ul></li><li>林宥嘉<ul><li>神秘嘉宾</li></ul></li><li>林忆莲<ul><li>回忆莲莲</li></ul></li><li>海がきこえるSoundtrack</li><li>海龟先生<ul><li>海龟先生</li></ul></li><li>燕池<ul><li>燕歌行</li></ul></li><li>王若琳<ul><li>Start From Here (Stereo SACD)</li><li>The Things We Do For Love</li></ul></li><li>王菲<ul><li>敷衍</li><li>浮躁</li></ul></li><li>田馥甄<ul><li>My Love</li><li>To Hebe</li><li>渺小</li></ul></li><li>細野晴臣<ul><li>Flying Saucer 1947</li><li>Heavenly Music</li><li>ハリー細野 &amp; TIN PAN ALLEY IN CHINATOWN</li><li>ホソノバ</li><li>細野晴臣 STRANGE SONG BOOK</li></ul></li><li>范晓萱<ul><li>国语真经典</li></ul></li><li>蔡健雅<ul><li>呼吸</li><li>记念</li><li>陌生人</li><li>若你碰到他</li><li>说到爱</li><li>天使与魔鬼的对话</li></ul></li><li>袁泉<ul><li>孤独的花朵</li><li>孤独的花朵 EP</li></ul></li><li>郝蕾<ul><li>关于TA的伤心事</li></ul></li><li>陈粒<ul><li>如也</li></ul></li><li>陈绮贞<ul><li>华丽的冒险</li></ul></li><li>響け！ユーフォニアム<ul><li>オリジナルサウンドトラック「おもいでミュージック」</li></ul></li><li>黄耀明<ul><li>CROSS OVER(EP)</li><li>拂了一身还满</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;/2016/04/10/listening01&quot;&gt;以前的文章&lt;/a&gt;写到了最爱的十张专辑, 但十张是远不能记录自己的喜好滴. 就把自己硬盘里躺着的歌手、专辑列出来, 顺便按照喜爱程度评个分…&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="https://blog.xuwei.fun/categories/life/"/>
    
      <category term="listening" scheme="https://blog.xuwei.fun/categories/life/listening/"/>
    
    
      <category term="music" scheme="https://blog.xuwei.fun/tags/music/"/>
    
  </entry>
  
  <entry>
    <title>升级Ubuntu 17.10之后</title>
    <link href="https://blog.xuwei.fun/2017/11/19/ubuntu02/"/>
    <id>https://blog.xuwei.fun/2017/11/19/ubuntu02/</id>
    <published>2017-11-19T12:39:06.000Z</published>
    <updated>2019-05-18T14:24:33.288Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前写过一篇<a href="/2015/05/26/ubuntu01/">安装Ubuntu 15.04之后</a>. 基本上14.04到17.04应该都可以参照, 在自己电脑上这些版本基本都用过, 没什么大问题.<br>前两天在实验室把Ubuntu更新到了17.10, 可能是太久没用Gnome桌面了, 比想象中的好、那就用下去呗</p><p>不过也带来了一些问题, 需要一步一步解决</p><a id="more"></a><h3 id="1-Root登录"><a href="#1-Root登录" class="headerlink" title="1. Root登录"></a>1. Root登录</h3><p>预警: 一般还是遵循医嘱, 不要学我这种野路子默认root登录…<br>两个地方, 一是<code>/etc/gdm3/custom.conf</code>处, 在<code>[Security]</code>下添加<code>AllowRoot=true</code>; 二是<code>/etc/pam.d/gdm-password</code>处, 将<code>auth    required    pam_succeed_if.so user != root quiet_success</code>注释</p><h3 id="2-Root使用Chrome"><a href="#2-Root使用Chrome" class="headerlink" title="2. Root使用Chrome"></a>2. Root使用Chrome</h3><p>Unity下使用root登录chrome只需要指定<code>user-data-dir</code>就可以了, gnome不行, 还需要额外指定<code>--no-sandbox</code>, 为了使用以前的<code>user-data-dir</code>和指定<code>no-sandbox</code>, 执行了两步.</p><ul><li>将Chrome的默认配置位置软链接到以前的Data保存位置: <code>ln -s &lt;your-user-data-dir&gt; /root/.config/google-chrome</code></li><li>修改google-chrome可执行文件<code>/usr/bin/google-chrome</code>, 将<code>exec -a &quot;$0&quot; &quot;$HERE/chrome&quot; &quot;$@&quot;</code>改为:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ <span class="variable">$EUID</span> -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">exec</span> -a <span class="string">"<span class="variable">$0</span>"</span> <span class="string">"<span class="variable">$HERE</span>/chrome"</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">exec</span> -a <span class="string">"<span class="variable">$0</span>"</span> <span class="string">"<span class="variable">$HERE</span>/chrome"</span> <span class="string">"<span class="variable">$@</span>"</span> --no-sandbox</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-解决出现Invalid-MIT-MAGIC-COOKIE-1-key的问题"><a href="#3-解决出现Invalid-MIT-MAGIC-COOKIE-1-key的问题" class="headerlink" title="3. 解决出现Invalid MIT-MAGIC-COOKIE-1 key的问题"></a>3. 解决出现<code>Invalid MIT-MAGIC-COOKIE-1 key</code>的问题</h3><p>该问题出现在和X桌面相关的程序中, 比如vim运行之后退出就会出现该信息. 解决方法是删除用户目录下的<code>.Xauthority</code>文件即可, 笔者顺手还删了<code>.xsession-errors</code>和<code>.xsession-errors.old</code></p><h3 id="4-更改源"><a href="#4-更改源" class="headerlink" title="4. 更改源"></a>4. 更改源</h3><p>更新系统之后, <code>/etc/apt/sources.list.d/</code>里添加的第三方源默认会被注释掉, 取消注释, 顺便把冗余文件删除.<br>清华的Tuna源很好用, 在上一篇没有提到, 现在改用.</p><h3 id="5-卸载Unity"><a href="#5-卸载Unity" class="headerlink" title="5. 卸载Unity"></a>5. 卸载Unity</h3><p><code>apt remove unity</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前写过一篇&lt;a href=&quot;/2015/05/26/ubuntu01/&quot;&gt;安装Ubuntu 15.04之后&lt;/a&gt;. 基本上14.04到17.04应该都可以参照, 在自己电脑上这些版本基本都用过, 没什么大问题.&lt;br&gt;前两天在实验室把Ubuntu更新到了17.10, 可能是太久没用Gnome桌面了, 比想象中的好、那就用下去呗&lt;/p&gt;
&lt;p&gt;不过也带来了一些问题, 需要一步一步解决&lt;/p&gt;
    
    </summary>
    
      <category term="techonology" scheme="https://blog.xuwei.fun/categories/techonology/"/>
    
      <category term="misc" scheme="https://blog.xuwei.fun/categories/techonology/misc/"/>
    
    
      <category term="linux" scheme="https://blog.xuwei.fun/tags/linux/"/>
    
      <category term="ubuntu" scheme="https://blog.xuwei.fun/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>一起来学Haskell啦</title>
    <link href="https://blog.xuwei.fun/2017/11/12/haskell01/"/>
    <id>https://blog.xuwei.fun/2017/11/12/haskell01/</id>
    <published>2017-11-12T15:57:23.000Z</published>
    <updated>2019-05-18T14:24:33.075Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>函数式语言Haskell听闻已久, 但是没看过, 最近两周看<em>learn you a haskell for great good!</em><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[learn you a haskell for great good!](http://learnyouahaskell.com/)">[1]</span></a></sup>, 有种相见恨晚的感觉, 现在如果让我一个编程入门者学习的话, 我可能会推荐C++和Haskell吧… Haskell里的思想看完, 再看Python, JS ES2015/16/17引入的一些新特性, 一眼就能理解了.</p><p><em>learn you a haskell for great good!</em>这本书看完一遍, 再重新看一遍目录, 从中找到自己印象不深的章节, 稍作记录于此.</p><a id="more"></a><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>工具个人推荐用Stack, 官方文档查询步骤就好, 值得注意的是由于G*F*W的存在, <code>stack setup</code>时竟然没法下载GHC, 这里推荐:<br>中科大镜像:<br><a href="http://mirrors.ustc.edu.cn/help/hackage.html" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/help/hackage.html</a><br><a href="http://mirrors.ustc.edu.cn/help/stackage.html" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/help/stackage.html</a><br>清华Tuna镜像:<br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/hackage/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/hackage/</a><br><a href="https://mirror.tuna.tsinghua.edu.cn/help/stackage/" target="_blank" rel="noopener">https://mirror.tuna.tsinghua.edu.cn/help/stackage/</a></p><h3 id="2-自定义Type和Typeclass"><a href="#2-自定义Type和Typeclass" class="headerlink" title="2. 自定义Type和Typeclass"></a>2. 自定义Type和Typeclass</h3><h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h3><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)"><a href="http://learnyouahaskell.com/" target="_blank" rel="noopener">learn you a haskell for great good!</a><a href="#fnref:1" rev="footnote"> ↩</a></span></div></div></div>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;函数式语言Haskell听闻已久, 但是没看过, 最近两周看&lt;em&gt;learn you a haskell for great good!&lt;/em&gt;&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;[learn you a haskell for great good!](http://learnyouahaskell.com/)
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;, 有种相见恨晚的感觉, 现在如果让我一个编程入门者学习的话, 我可能会推荐C++和Haskell吧… Haskell里的思想看完, 再看Python, JS ES2015/16/17引入的一些新特性, 一眼就能理解了.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;learn you a haskell for great good!&lt;/em&gt;这本书看完一遍, 再重新看一遍目录, 从中找到自己印象不深的章节, 稍作记录于此.&lt;/p&gt;
    
    </summary>
    
      <category term="techonology" scheme="https://blog.xuwei.fun/categories/techonology/"/>
    
      <category term="cs" scheme="https://blog.xuwei.fun/categories/techonology/cs/"/>
    
    
      <category term="programming language" scheme="https://blog.xuwei.fun/tags/programming-language/"/>
    
      <category term="haskell" scheme="https://blog.xuwei.fun/tags/haskell/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记十一</title>
    <link href="https://blog.xuwei.fun/2017/11/12/reading11/"/>
    <id>https://blog.xuwei.fun/2017/11/12/reading11/</id>
    <published>2017-11-12T15:12:47.000Z</published>
    <updated>2019-05-18T14:24:33.255Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>毛选4卷版本买了有一年了，还是只看了前两卷，最近又补了下，深感只读一遍是无法理解其中的很多思想的。至于流传的五卷版本，网上找了mobi格式的放kindle上看了。</p><a id="more"></a><h3 id="1-关于阶级"><a href="#1-关于阶级" class="headerlink" title="1. 关于阶级"></a>1. 关于阶级</h3><p>// To do<br>// 都是草稿, 先存着…</p><h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h3><p> <a href="https://zh.wikipedia.org/wiki/%E6%AF%9B%E6%B3%BD%E4%B8%9C%E9%80%89%E9%9B%86" target="_blank" rel="noopener">毛泽东选集</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;毛选4卷版本买了有一年了，还是只看了前两卷，最近又补了下，深感只读一遍是无法理解其中的很多思想的。至于流传的五卷版本，网上找了mobi格式的放kindle上看了。&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="https://blog.xuwei.fun/categories/life/"/>
    
      <category term="reading" scheme="https://blog.xuwei.fun/categories/life/reading/"/>
    
    
      <category term="毛泽东" scheme="https://blog.xuwei.fun/tags/%E6%AF%9B%E6%B3%BD%E4%B8%9C/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记十</title>
    <link href="https://blog.xuwei.fun/2017/11/12/reading10/"/>
    <id>https://blog.xuwei.fun/2017/11/12/reading10/</id>
    <published>2017-11-12T14:11:55.000Z</published>
    <updated>2019-05-18T14:24:33.252Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>被<em>梁启超致徐志摩函</em>里的几句话启发了, 就找了找原文. 原文颇难寻, <em>饮冰室合集</em><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[饮冰室合集](https://zh.wikipedia.org/wiki/%E9%A5%AE%E5%86%B0%E5%AE%A4%E5%90%88%E9%9B%86)">[1]</span></a></sup>应该是有的, 只是太过厚重网上无资源, Kino网上搜索后在<em>爱眉小札-志摩日记、书信集</em><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[爱眉小札-志摩日记、书信集](https://read.douban.com/ebook/10325492/)">[2]</span></a></sup>找到了.<br>不过也因此想读读梁公的文章, 还将粱公所云<strong>以今日之我与昨日之我战</strong>作为Kino新的签名. 查阅资料了解到<em>饮冰室合集</em><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[饮冰室合集](https://zh.wikipedia.org/wiki/%E9%A5%AE%E5%86%B0%E5%AE%A4%E5%90%88%E9%9B%86)">[1]</span></a></sup>是最全的, 可是太长必然没法看完吧, 看到还有<em>饮冰室文集</em><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[饮冰室文集](https://zh.wikipedia.org/wiki/%E9%A5%AE%E5%86%B0%E5%AE%A4%E6%96%87%E9%9B%86)">[3]</span></a></sup>, 较短, 就找了Kindle版本的来看.</p><a id="more"></a><h3 id="1-梁启超致徐志摩函"><a href="#1-梁启超致徐志摩函" class="headerlink" title="1. 梁启超致徐志摩函"></a>1. 梁启超致徐志摩函</h3><p>嘛, 这一篇不是<em>饮冰室文集</em>里的, 虽然文集里的文章气势磅礴的多, 思想深刻的也有, 此时此刻Kino却最爱粱公这篇<em>梁启超致徐志摩函</em>.</p><blockquote><p>君劢濒行之前两夕，语及弟事，令吾颇起异感。吾昔以为吾弟与夫人(此名或不当，但吾愿姑用之)实有不能相处者存，故不忍复置一词。今闻弟归后尚通信不绝，且屡屡称誉，然则何故有畴昔之举？真神秘不可思议矣。吾初又疑弟亦如君劢然，喜作独身生活，今据劢所云，似又不然，吾益用迷惑。兹事自非局外人所能参末议，然以吾与弟之交，有两事不能为弟忠告者：其一，人类恃有同情心以自贵于万物，义不容以他人之苦痛易自己之快乐，弟之此举，其以弟将来之快乐能得与否，殆茫如捕风，然先已予多数人以无量之苦痛，重闱之悲诧，微，君劢言吾亦可以推想得之，君劢家之老人，当亦同兹感。夫人或与弟同怀抱所痛灭杀(？)然最难堪者两儿，弟既已育之，胡能置之，兹事恐弟将终身受良心上之重罚无以自宁也。其二，恋爱神圣为今之少年所最乐道，吾于兹义固不反对，然吾以为天下神圣之事亦多矣，以兹事为唯一之神圣，非吾之所敢闻，且兹事尽可遇而不可求，非可谓吾欲云云即云云也。况多情多感之人，其幻象起落鹘突，而得满足得宁贴也极难，所梦想之神圣境界，恐终不可得，徒以烦恼终其身已耳。呜呼。志摩，天下岂有圆满之宇宙若尔尔者？孔子赞易无取，以未济终矣，当知吾侪以不求圆满为生活态度。斯可以领略生活之妙味矣。吾以为人类对于两性间相互最好是以“无着落”之态度行之(君劢最能如此，吾亦颇如此。)，则最少亦可以减无量苦痛。吾固知弟为富于情感之人，未易语此，然吾自审吾之情感并不视弟为贫弱，吾固有与弟言此之资格也。呜呼。志摩，当知人生树立甚难，消磨甚易，如志摩之年，实一生最可贵之时期，亦最危险之时期也，若沉迷于不可必得之梦境，挫折数次，生意尽矣，郁邑侘傺以死，死为无名；死犹可也，最可畏者，不死不生，而堕落至不复能自拔，呜呼。志摩，可无愧耶!可无惧耶!吾与志摩相处之日殊浅，吾所虑者或皆不衷于事实，然吾之爱惜吾志摩者至厚，自闻君劢言后，耿耿于中，无一时能释。顷辍课来沪，夜中思此，不复成寐，披衣起，作此数纸。或非志摩所乐闻，然吾终望志摩知我对志摩用情之深，虽今日不寝，终有日能寝也。旬日后即北归，当约志摩就我，再罄其怀抱耳。惓惓之极，不尽欲言，专上<br>志摩爱弟<br>启超  一月二日夜三时上海沧洲旅馆<br>《政治思想史》全部脱稿矣，甚盼，弟能迻译也。</p></blockquote><p>若谈及为何此时此刻最爱这篇信件, 主要是因为这篇信的背景和粱公关于恋爱的论述.<br>彼时, 徐志摩已与张幼仪离婚, 正与林徽因爱恋, 这时粱公写了这封信给徐志摩, 随后徐志摩的回信中有那句著名的<strong>得之我幸,不得我命</strong><br>通篇最喜<strong>其二，恋爱神圣为今之少年所最乐道，吾于兹义固不反对，然吾以为天下神圣之事亦多矣，以兹事为唯一之神圣，非吾之所敢闻，且兹事尽可遇而不可求，非可谓吾欲云云即云云也。况多情多感之人，其幻象起落鹘突，而得满足得宁贴也极难，所梦想之神圣境界，恐终不可得，徒以烦恼终其身已耳。呜呼。志摩，天下岂有圆满之宇宙若尔尔者？孔子赞易无取，以未济终矣，当知吾侪以不求圆满为生活态度。斯可以领略生活之妙味矣</strong>, 论及其中原因, 便是这段话最能麻醉Kino了, 让Kino不要继续陷在难过之中了, 也能用多情多感之人的说辞为对方开脱, 好让彼此心安.<br>PS: 徐志摩的爱情观与Kino当前观念，恰好对立</p><h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h3><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)"><a href="https://zh.wikipedia.org/wiki/%E9%A5%AE%E5%86%B0%E5%AE%A4%E5%90%88%E9%9B%86" target="_blank" rel="noopener">饮冰室合集</a><a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)"><a href="https://read.douban.com/ebook/10325492/" target="_blank" rel="noopener">爱眉小札-志摩日记、书信集</a><a href="#fnref:2" rev="footnote"> ↩</a></span></div><div id="fn:3" style="display:flex"><span style="width:20px">3.</span><span style="width:calc(100% - 20px)"><a href="https://zh.wikipedia.org/wiki/%E9%A5%AE%E5%86%B0%E5%AE%A4%E6%96%87%E9%9B%86" target="_blank" rel="noopener">饮冰室文集</a><a href="#fnref:3" rev="footnote"> ↩</a></span></div></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;被&lt;em&gt;梁启超致徐志摩函&lt;/em&gt;里的几句话启发了, 就找了找原文. 原文颇难寻, &lt;em&gt;饮冰室合集&lt;/em&gt;&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;[饮冰室合集](https://zh.wikipedia.org/wiki/%E9%A5%AE%E5%86%B0%E5%AE%A4%E5%90%88%E9%9B%86)
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;应该是有的, 只是太过厚重网上无资源, Kino网上搜索后在&lt;em&gt;爱眉小札-志摩日记、书信集&lt;/em&gt;&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;[爱眉小札-志摩日记、书信集](https://read.douban.com/ebook/10325492/)
&quot;&gt;[2]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;找到了.&lt;br&gt;不过也因此想读读梁公的文章, 还将粱公所云&lt;strong&gt;以今日之我与昨日之我战&lt;/strong&gt;作为Kino新的签名. 查阅资料了解到&lt;em&gt;饮冰室合集&lt;/em&gt;&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;[饮冰室合集](https://zh.wikipedia.org/wiki/%E9%A5%AE%E5%86%B0%E5%AE%A4%E5%90%88%E9%9B%86)
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;是最全的, 可是太长必然没法看完吧, 看到还有&lt;em&gt;饮冰室文集&lt;/em&gt;&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;[饮冰室文集](https://zh.wikipedia.org/wiki/%E9%A5%AE%E5%86%B0%E5%AE%A4%E6%96%87%E9%9B%86)
&quot;&gt;[3]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;, 较短, 就找了Kindle版本的来看.&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="https://blog.xuwei.fun/categories/life/"/>
    
      <category term="reading" scheme="https://blog.xuwei.fun/categories/life/reading/"/>
    
    
      <category term="梁启超" scheme="https://blog.xuwei.fun/tags/%E6%A2%81%E5%90%AF%E8%B6%85/"/>
    
      <category term="徐志摩" scheme="https://blog.xuwei.fun/tags/%E5%BE%90%E5%BF%97%E6%91%A9/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记九</title>
    <link href="https://blog.xuwei.fun/2017/10/08/reading09/"/>
    <id>https://blog.xuwei.fun/2017/10/08/reading09/</id>
    <published>2017-10-08T14:41:36.000Z</published>
    <updated>2019-05-18T14:24:33.249Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>想重新认真地读一读鲁迅的文章，就买了鲁迅小全集<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[鲁迅小全集](https://item.jd.com/11338330.html)">[1]</span></a></sup>共5册<br>在此摘录一些句子，颓废的时候用于警醒自己（或者暗示自己接着颓，毕竟鲁迅也曾颓废过</p><a id="more"></a><h3 id="1-小说全集"><a href="#1-小说全集" class="headerlink" title="1. 小说全集"></a>1. 小说全集</h3><p>先从较能吸引人的小说全集开始读起</p><ol><li>所谓回忆者，虽说可以使人欢欣，有时也不免使人寂寞，使精神的丝缕还牵着己逝的寂寞的时光，又有什么意味呢，而我偏苦于不能全忘却……</li><li>凡有一人的主张，得了赞和，是促其前进的，得了反对，是促其奋斗的，独有叫喊于生人中，而生人并无反应，既非赞同，也无反对，如置身毫无边际的荒原，无可措手了，这是怎样的悲哀呵，我于是以我所感到者而寂寞<br>评：这句一直到<strong>“独有叫喊于生人中”</strong>还是积极的，在生活中一个人也确是须先得把自己的想法说出来，才能有进步，无论是被人赞同还是反对，闭门造车总是行不通的</li><li>喵喵</li></ol><h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h3><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)"><a href="https://item.jd.com/11338330.html" target="_blank" rel="noopener">鲁迅小全集</a><a href="#fnref:1" rev="footnote"> ↩</a></span></div></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;想重新认真地读一读鲁迅的文章，就买了鲁迅小全集&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-left hint--info hint--autowidth hint--bounce&quot; aria-label=&quot;[鲁迅小全集](https://item.jd.com/11338330.html)
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;共5册&lt;br&gt;在此摘录一些句子，颓废的时候用于警醒自己（或者暗示自己接着颓，毕竟鲁迅也曾颓废过&lt;/p&gt;
    
    </summary>
    
      <category term="life" scheme="https://blog.xuwei.fun/categories/life/"/>
    
      <category term="reading" scheme="https://blog.xuwei.fun/categories/life/reading/"/>
    
    
      <category term="鲁迅" scheme="https://blog.xuwei.fun/tags/%E9%B2%81%E8%BF%85/"/>
    
  </entry>
  
</feed>
