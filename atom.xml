<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>霁月荒馆</title>
  
  <subtitle>以今日之我与昨日之我战</subtitle>
  <link href="https://blog.xuwei.fun/atom.xml" rel="self"/>
  
  <link href="https://blog.xuwei.fun/"/>
  <updated>2021-10-10T15:13:52.488Z</updated>
  <id>https://blog.xuwei.fun/</id>
  
  <author>
    <name>Kino</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>衍生品笔记五 —— 期货市场</title>
    <link href="https://blog.xuwei.fun/2021/10/08/derivatives05/"/>
    <id>https://blog.xuwei.fun/2021/10/08/derivatives05/</id>
    <published>2021-10-08T14:40:14.000Z</published>
    <updated>2021-10-10T15:13:52.488Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#x2F;&#x2F; TODO</p><span id="more"></span><h2 id="1-期货市场"><a href="#1-期货市场" class="headerlink" title="1. 期货市场"></a>1. 期货市场</h2><p>期货市场有一些基本制度:</p><ul><li>交易所: 规避违约风险(default)</li><li>标准化: 促进流动性(liquidity)</li><li>保证金: 增加杠杆(leverage)</li><li>daily settlement: 每日无负债结算, 也可称为mark to market(逐日盯市). 当保证金不足时，会收到Margin Call(追加保证金通知)，提醒需要追加现金或现金等价物(通常就是国债)</li><li>delivery: 交割制度是期货市场和现货市场的连结，期货在趋于交割日时，价格会收敛到现货价格，否则就会存在套利机会<ul><li>physical delivery: 实物交割。商品期货等</li><li>cash settlement: 现金交割。指数期货等</li><li>有些特殊标的既可以实物交割，也可现金交割，取决于市场。比如国债期货、欧洲美元&#x2F;离岸美元(Euro dollar)期货等</li></ul></li><li>position limit: 防止操纵市场。头寸限制也取决于交易类型，套期保值头寸限制的数值较大</li><li>large investor report: 大户报告. 认定的大户，进入交割月后需要报告实际资产状况</li><li>风险准备金: 用于违约后的赔偿</li></ul><blockquote><p>交易所中有hedger(套期保值者)、speculator(投机者)，引入投机者是为了提供对手方、提供流动性</p></blockquote><blockquote><p>欧洲美元期货：其标的资产是本金为100万美元，3个月后到期的欧洲美元定期存款。由于最终是现金交割，除去本金，本质上标的资产是利率。<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="CME Group. “Eurodollar Overview.” Futures & Options Trading for Risk Management - CME Group, 8 Oct. 2021, https://www.cmegroup.com/markets/interest-rates/stirs/eurodollar.html.">[1]</span></a></sup></p></blockquote><h2 id="2-期货合约"><a href="#2-期货合约" class="headerlink" title="2. 期货合约"></a>2. 期货合约</h2><p>合约要素:</p><ul><li>合约名称(Contract Name)</li><li>基础资产(Underlying Assets)</li><li>交易单位(Contract Size)</li><li>报价单位(Price Quotation)</li><li>最小变动价位(Minimum Price Fluctuation)</li><li>涨跌停板幅度(Daily Price Limit)</li><li>合约月份(Contract Months)</li><li>交易时间(Trading Hours)</li><li>最后交易日(Last Trading Day)</li><li>交割日期(Delivery Period)</li><li>交割品级(Grade and Quality Specifications)</li><li>交割地点(Delivery Venue)</li><li>交割单位(Delivery Size)</li><li>最低交易保证金(Minimum Trade Margin)</li><li>交割方式(Settlement Method)</li><li>交易代码(Contract Code)</li><li>上市交易场所(Exchange)</li></ul><h2 id="3-期货术语"><a href="#3-期货术语" class="headerlink" title="3. 期货术语"></a>3. 期货术语</h2><ul><li>contango: 期货溢价，即期货升水、现货贴水. 期货价格近底远高</li><li>backwadation: 现货溢价，即现货升水、期货贴水. 期货价格近高远底</li><li>basis: 基差，即现货-期货的价格，但是期货要取最近月的期货合约</li><li>open interest: 未平仓合约总量</li><li>volume of trading: 交易量</li></ul><blockquote><p>对于非利率期货来说，在供求关系基本平衡的情况下，远月合约由于存货持有成本的存在，所以会比近月合约价格更高.<br><strong>然而利率期货恰好反过来，因为利率期货报价是反向的，也因此使价格反向了</strong></p></blockquote><h2 id="4-期货监管"><a href="#4-期货监管" class="headerlink" title="4. 期货监管"></a>4. 期货监管</h2><p>一委一行两会:</p><ul><li>国务院金融稳定发展委员会</li><li>中国人民银行</li><li>中国银行保险监督管理委员会</li><li>中国证券监督管理委员会</li></ul><p>证监会下有期货监管部，负责监管期货交易所，期货交易所有:</p><ul><li>大连商品交易所</li><li>上海期货交易所</li><li>郑州商品交易所</li><li>中国金融期货交易所(公司制，原始注册资本为5亿元人民币，分别由大连商品交易所、上海期货交易所、上海证券交易所、深圳证券交易所和郑州商品交易所等五家机构各出资1亿元)</li></ul><p>交易所监管其会员，交易所的会员有期货经纪公司 和 自营会员</p><h2 id="5-套期保值"><a href="#5-套期保值" class="headerlink" title="5. 套期保值"></a>5. 套期保值</h2><blockquote><p>套期保值是指把期货市场当作转移价格风险的场所，利用期货合约作为将来在现货市场上买卖商品的临时替代物，对其现在买进准备以后售出商品或对将来需要买进商品的价格进行保险的交易活动。<br>套期保值实际上是现货市场和期货市场的双向下注.<br>对于inventory一方来说，需要规避存货价格下跌的风险，而对于demand一方来说，需要规避存货价格上涨的风险</p></blockquote><ul><li>Long hedge(多头套期保值): 在期货市场的初始头寸是long，就是long hedge</li><li>Short hedge(空头套期保值): 在期货市场的初始头寸是short，就是short hedge</li></ul><h2 id="6-金融期货"><a href="#6-金融期货" class="headerlink" title="6. 金融期货"></a>6. 金融期货</h2><p>外汇期货、利率期货、股指期货(是虚拟金融工具, 天然现金结算)等，外汇期货、股指期货比较简单，下面说的都是利率期货相关内容。</p><ul><li>day count conventions: 国债、企业债、货币市场工具的计息日计算方法都不尽相同，实际交易时需要关注</li><li>discount rate: 折现率</li><li>quoted price: 报价</li><li>cash price: 全价，即包含利息的价格，也是dirty price &#x3D; quoted price + accrued interest</li><li>clean price: 净价</li></ul><p>对于T-note, T-bond来说，现货和期货市场都采用净价报价方式，<strong>而T-bill比较特殊，现货市场采用折现率报价，期货市场可能是反向，比如Eurodollar，报价方式是100-参考利率如LIBOR，联邦基金的拆借利率也类似</strong></p><blockquote><p>T-bond的交割标的有一篮子债券，根据与标准券(例如每半年付息一次，到期收益率和票面利率都是6%)相比制定转换因子，交割时不同债券做相应的转换</p></blockquote><blockquote><ul><li>记账式附息国债: 没有实物形态的票券，以电脑记账形式记录债权，通过无纸化方式发行和交易</li><li>凭证式储蓄国债: 通过银行系统发行，券面上不印制票面金额，为非标准格式，根据认购者的认购额填写实际的缴款金额，以“储蓄国债（凭证式）收款凭证”记录债权</li></ul></blockquote><blockquote><p>Eurodollar Futures的具体合约规则可参考<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="CME Group. “Eurodollar Futures Contract Specs.” Futures &amp; Options Trading for Risk Management, 10 Oct. 2021, https://www.cmegroup.com/markets/interest-rates/stirs/eurodollar.contractSpecs.html.">[7]</span></a></sup></p></blockquote><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">CME Group. “Eurodollar Overview.” Futures &amp; Options Trading for Risk Management - CME Group, 8 Oct. 2021, https://www.cmegroup.com/markets/interest-rates/stirs/eurodollar.html.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Hedge (finance)” Wikipedia, Wikimedia Foundation, 6 Sept. 2021, https://en.wikipedia.org/wiki/Hedge_(finance)<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">资本小论 . “深度研究：关于商品价格波动、对商品顶底的解读.” 雪球, 23 Nov. 2020, https://xueqiu.com/1212782157/163967872.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">资本小论 . “Contango结构下商品的套利分析.” 雪球, 1 Dec. 2020, https://xueqiu.com/1212782157/164656709.<a href="#fnref:4" rev="footnote">↩</a></span></li><li id="fn:5"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">资本小论 . “商品期货在 Back 结构下的套利分析.” Longbridge, 12 Jan. 2021, https://longbridgeapp.com/en/topics/624239.<a href="#fnref:5" rev="footnote">↩</a></span></li><li id="fn:6"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Eurodollar” Wikipedia, Wikimedia Foundation, 7 July. 2021, https://en.wikipedia.org/wiki/Eurodollar<a href="#fnref:6" rev="footnote">↩</a></span></li><li id="fn:7"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">CME Group. “Eurodollar Futures Contract Specs.” Futures &amp; Options Trading for Risk Management, 10 Oct. 2021, https://www.cmegroup.com/markets/interest-rates/stirs/eurodollar.contractSpecs.html.<a href="#fnref:7" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#x2F;&amp;#x2F; TODO&lt;/p&gt;</summary>
    
    
    
    <category term="technology" scheme="https://blog.xuwei.fun/categories/technology/"/>
    
    <category term="finance" scheme="https://blog.xuwei.fun/categories/technology/finance/"/>
    
    
    <category term="finance" scheme="https://blog.xuwei.fun/tags/finance/"/>
    
    <category term="invest" scheme="https://blog.xuwei.fun/tags/invest/"/>
    
    <category term="derivatives" scheme="https://blog.xuwei.fun/tags/derivatives/"/>
    
    <category term="futures" scheme="https://blog.xuwei.fun/tags/futures/"/>
    
  </entry>
  
  <entry>
    <title>衍生品笔记四 —— 互换</title>
    <link href="https://blog.xuwei.fun/2021/10/07/derivatives04/"/>
    <id>https://blog.xuwei.fun/2021/10/07/derivatives04/</id>
    <published>2021-10-07T10:33:22.000Z</published>
    <updated>2021-10-08T15:21:28.941Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#x2F;&#x2F; TODO</p><span id="more"></span><h2 id="1-互换-Swap"><a href="#1-互换-Swap" class="headerlink" title="1. 互换(Swap)"></a>1. 互换(Swap)</h2><p>互换，通常也被称为掉期交易，在Wikipedia上给出的定义是:<br>A swap, in finance, is an agreement between two counterparties to exchange financial instruments or cashflows or payments for a certain time. The instruments can be almost anything but most swaps involve cash based on a notional principal amount.<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. “Swap (Finance).” Wikipedia, Wikimedia Foundation, 6 Sept. 2021, https://en.wikipedia.org/wiki/Swap_(finance).">[1]</span></a></sup></p><p>简单点来看，互换其实也就是顾名思义: 指交易双方约定在未来某一期限相互交换各自持有的金融工具、现金流、支付款项的协议，通常这些金融工具都是基于名义本金的现金流<br>而根据国际清算银行(BIS)的定义，金融掉期是交易双方在一定期间内，掉期不同标的物之现金流的协议。</p><h2 id="2-利率互换-x2F-利率掉期"><a href="#2-利率互换-x2F-利率掉期" class="headerlink" title="2. 利率互换&#x2F;利率掉期"></a>2. 利率互换&#x2F;利率掉期</h2><p>利率掉期的基本交易型态为固定利率与浮动利率(Fixed-Floating Swap)的掉期，亦称为Plain Vanilla IRS，市场上尚有牵涉不同浮动利率指标间的掉期，如基差掉期(Basis Swap)等，完全视交易双方对利率指标之选择，较常见的浮动利率指标为LIBOR。<br>通常，将支付Fixed rate一方视为Payer，另一方视为Receiver<br>对人民币的浮动利率而言，目前人民币利率互换浮动端利率包括最优贷款利率(LPR)、人民银行定期存贷款利率、Shibor利率(隔夜、3个月品种)、银行间7天回购定盘利率(FR007)四大类。其中LPR就是2020年调整之后的房贷利率</p><blockquote><p>对于资产项和负债项来说，期待的利率趋势其实是不同的<br>利率互换，最终计算的是基于名义本金的利率差额</p></blockquote><h2 id="3-外汇互换"><a href="#3-外汇互换" class="headerlink" title="3. 外汇互换"></a>3. 外汇互换</h2><p>外汇互换（又称外汇掉期）是结合外汇现货及远期交易的一种合约，合约双方约定某一日期按即期汇率交换一定数额的外汇，然后在未来某一日期，按约定的汇率(即远期汇率)以相等金额再交换回来。实际上，合约双方是各自获得交换回来的货币一定时间的使用权。外汇互换的条件，反映了合约双方对所交换的两种货币的汇率走势及各自对利率的看法。外汇互换以远期点数的方式报价，除了可用来锁定在未来某一时点交换货币的汇率外，亦可作为对即期与远期汇率间的异常差距进行套利的手段。</p><blockquote><p>外汇互换，开始和结束的一期需要互换本金，但是除开始之外的其他期，还需要支出和收入利息</p></blockquote><p>一笔外汇互换交易的现金流状况，图中左侧为USD，右侧为GBP:<br><img src="/images/derivatives/derivatives04_01.jpg" alt="cash_flows"></p><p>可以看出，这笔交易相当于借出USD，借入GBP，因此利息收入是USD，利息支出是GBP</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Swap (Finance).” Wikipedia, Wikimedia Foundation, 6 Sept. 2021, https://en.wikipedia.org/wiki/Swap_(finance).<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “利率掉期交易.” Wikipedia, Wikimedia Foundation, 20 Sept. 2021, https://zh.wikipedia.org/wiki/利率掉期交易.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Currency Swap.” Wikipedia, Wikimedia Foundation, 4 Aug. 2021, https://en.wikipedia.org/wiki/Currency_swap.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Unknown. “外汇互换” MBA智库百科, 28 Dec. 2009, https://wiki.mbalib.com/wiki/外汇互换<a href="#fnref:4" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#x2F;&amp;#x2F; TODO&lt;/p&gt;</summary>
    
    
    
    <category term="technology" scheme="https://blog.xuwei.fun/categories/technology/"/>
    
    <category term="finance" scheme="https://blog.xuwei.fun/categories/technology/finance/"/>
    
    
    <category term="finance" scheme="https://blog.xuwei.fun/tags/finance/"/>
    
    <category term="invest" scheme="https://blog.xuwei.fun/tags/invest/"/>
    
    <category term="derivatives" scheme="https://blog.xuwei.fun/tags/derivatives/"/>
    
    <category term="swap" scheme="https://blog.xuwei.fun/tags/swap/"/>
    
  </entry>
  
  <entry>
    <title>衍生品笔记三 —— 期货期权</title>
    <link href="https://blog.xuwei.fun/2021/10/06/derivatives03/"/>
    <id>https://blog.xuwei.fun/2021/10/06/derivatives03/</id>
    <published>2021-10-06T13:27:04.000Z</published>
    <updated>2021-10-07T10:28:26.226Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#x2F;&#x2F; TODO</p><span id="more"></span><h2 id="1-期货合约"><a href="#1-期货合约" class="headerlink" title="1. 期货合约"></a>1. 期货合约</h2><p>概念上近似远期协议，约定在未来某一时刻以某一价格交割某一标的资产。<br>区别是期货合约是场内交易的，因此是一个标准化的合约，由交易所做出履约保证</p><p>全球各地可以进行期货交易的交易所:</p><ul><li>Chicago Board of Trade</li><li>Chicago Mercantile Exchange</li><li>LIFFE (London)</li><li>Eurex (Europe)</li><li>BM&amp;F (Sao Paulo, Brazil)</li><li>TIFFE (Tokyo)</li><li>上海期货交易所</li><li>郑州商品交易所</li><li>大连商品交易所</li><li>中国金融期货交易所</li><li>上海国际能源交易中心</li><li>……</li></ul><p>期货合约要素</p><h2 id="2-期权合约"><a href="#2-期权合约" class="headerlink" title="2. 期权合约"></a>2. 期权合约</h2><p>Options 核心是权利，交易的是权利，为了交易权利所付出的金钱称为premium(权利金).<br>期权是非对称交易，期权的买方拥有权利没有义务，期权的卖方有义务无权利.<br>期权的多头是买入权利，空头是卖出权利，但是买入卖出的权利又可分为看涨(call)&#x2F;看跌(put)两类</p><ul><li>call: 看涨期权(call option)又称认购期权，买进期权，买方期权，买权，延买期权，或“敲进”，是指期权的购买者拥有在期权合约有效期内按执行价格买进一定数量标的物的权利。看涨期权是这样一种合约: 它给合约持有者（即买方）按照约定的价格从对手手中购买特定数量之特定交易标的物的权利。</li><li>put: 看跌期权(put option)又称认沽期权，看跌期权则与看涨期权正好相反，它赋予了持有者在未来以确定的价格，也就是行权价格卖出的权利，所以看跌期权的持有者会希望标的资产价格的下跌幅度越大越好。</li></ul><p>在到期日(Expiration Date)买入&#x2F;卖出的价格就是 settle price，也就是行权价格&#x2F;执行价格…<br>而根据权利行权时间的区别，又可分为欧式期权(European Options)和美式期权(American Options)</p><ul><li>欧式期权: 只能在到期日行权</li><li>美式期权: 可以在成交后有效期内任何一天行权</li></ul><p>期权的优势是可以通过对冲平仓免除履约责任.</p><p>期权的价格和标的资产的价格差距是很大的，如图所示:<br><img src="/images/derivatives/derivatives03_01.jpg" alt="ge_options"></p><p>那么期权的价格究竟是怎么算出来的呢? 实际上期权定价的数学模型有:</p><ul><li>Black-Scholes Option Pricing Model</li><li>Black–Scholes–Merton model</li></ul><p>全球各地可以进行期权交易的交易所:</p><ul><li>Chicago Board Options Exchange</li><li>American Stock Exchange</li><li>Philadelphia Stock Exchange</li><li>Pacific Exchange</li><li>LIFFE (London)</li><li>Eurex (Europe)</li><li>……</li></ul><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Futures Contract.” Wikipedia, Wikimedia Foundation, 6 Oct. 2021, https://en.wikipedia.org/wiki/Futures_contract.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">- 合约名称(Contract Name)- 基础资产(Underlying Assets)- 交易单位(Contract Size)- 报价单位(Price Quotation)- 最小变动价位(Minimum Price Fluctuation)- 涨跌停板幅度(Daily Price Limit)- 合约月份(Contract Months)- 交易时间(Trading Hours)- 最后交易日(Last Trading Day)- 交割日期(Delivery Period)- 交割品级(Grade and Quality Specifications)- 交割地点(Delivery Venue)- 交割单位(Delivery Size)- 最低交易保证金(Minimum Trade Margin)- 交割方式(Settlement Method)- 交易代码(Contract Code)- 上市交易场所(Exchange)<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">中国证券监督管理委员会. “期货合约要素.” 中国证券监督管理委员会, 26 Feb. 2020, http://www.csrc.gov.cn/pub/zjhpublic/zjh/202002/P020200228535813027616.pdf.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Black–Scholes model” Wikipedia, Wikimedia Foundation, 17 Sep. 2021, https://en.wikipedia.org/wiki/Black%E2%80%93Scholes_model.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Unknown. “Black-Scholes期权定价模型.” MBA智库百科, 9 Apr. 2008, https://wiki.mbalib.com/wiki/Black-Scholes期权定价模型.<a href="#fnref:4" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#x2F;&amp;#x2F; TODO&lt;/p&gt;</summary>
    
    
    
    <category term="technology" scheme="https://blog.xuwei.fun/categories/technology/"/>
    
    <category term="finance" scheme="https://blog.xuwei.fun/categories/technology/finance/"/>
    
    
    <category term="finance" scheme="https://blog.xuwei.fun/tags/finance/"/>
    
    <category term="invest" scheme="https://blog.xuwei.fun/tags/invest/"/>
    
    <category term="derivatives" scheme="https://blog.xuwei.fun/tags/derivatives/"/>
    
    <category term="futures" scheme="https://blog.xuwei.fun/tags/futures/"/>
    
    <category term="options" scheme="https://blog.xuwei.fun/tags/options/"/>
    
  </entry>
  
  <entry>
    <title>衍生品笔记二 —— 远期</title>
    <link href="https://blog.xuwei.fun/2021/10/04/derivatives02/"/>
    <id>https://blog.xuwei.fun/2021/10/04/derivatives02/</id>
    <published>2021-10-04T02:00:00.000Z</published>
    <updated>2021-10-10T15:30:36.912Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&#x2F;&#x2F; TODO</p><span id="more"></span><h2 id="1-远期汇率-外汇远期"><a href="#1-远期汇率-外汇远期" class="headerlink" title="1. 远期汇率(外汇远期)"></a>1. 远期汇率(外汇远期)</h2><p>根据时间不同，同一标的也会有多个远期合约<br>由于外汇交易中，是以货币换货币，所以需要设定一种货币为商品，另一种为计价货币<br>判断多空的标准，也因此需要明确货币</p><ul><li>多头(long position): 买方</li><li>空头(short position): 卖方</li></ul><p>对于非管制货币来说，由于可以自动兑换，通常做直接远期交易(Outright forward)即可满足需求，在约定的时间以约定价格买卖货币。<br>但是对于管制货币，因为无法直接交易，所以有了NDF(Non-deliverable forward)，不交割本金，只交割计价货币的差额</p><blockquote><p>NDF: 首先要明确一点的是，NDF实际上并不做货币兑换，这更类似于一个赌博协议。以CNY&#x2F;USD为例，假设A预计3个月后会收到一笔 10000 CNY的收入，但是需要换成美金，由于CNY&#x2F;USD没法自由兑换，因此A和做市商做了一笔NDF交易。由于NDF不交割本金，实际上三个月后10000CNY的收入还是在A的账户里，需要A自行将人民币兑换出境，而A和做市商之间只需要就现货汇率计算出损益，进行最终交割即可。<br>为方便计算，假设CNY&#x2F;USD 的三个月远期汇率为 10，也就是说A预期是三个月后以汇率10兑换出境，获得1000USD，而实际上三个月后，CNY&#x2F;USD的现货可能是:</p><ul><li>10。那恰好，A和做市商之间损益为0</li><li>20。那实际上A现在将10000 CNY兑换出境后只能得到500 USD，和预期相比少了500USD，这500USD就由做市商来弥补，因为最终只交割这500USD，不交割本金，所以才是NDF</li><li>5。那实际上A现在将10000 CNY兑换出境后能得到2000 USD，和预期相比多了1000USD，这1000USD就由A来补偿给做市商，因为最终只交割这1000USD，不交割本金，所以才是NDF</li></ul></blockquote><h2 id="2-远期利率-Forward-rate"><a href="#2-远期利率-Forward-rate" class="headerlink" title="2. 远期利率(Forward rate)"></a>2. 远期利率(Forward rate)</h2><p>与远期利率相对应的有如下利率:</p><ul><li>即期利率(Spot rate): 当前时间点上零息债券的到期收益率</li><li>短期利率(Short rate): 既定区间内的收益率</li></ul><p>远期利率则是指隐含在给定的即期利率之中，从未来的某一时点到另一时点的利率。也就是未来的短期利率。<br>1×2远期利率，即表示1个月之后开始的期限1个月的远期利率；2×4远期利率，则表示2个月之后开始的期限为2个月的远期利率。</p><p>contracted rate(合同利率): 远期利率协议签订时合同上所定的利率.<br>reference rate(参考利率): 通常用于确定各种金融合同、贷款、基于账户的产品和金融工具（包括衍生工具和票据）的应付金额及其价值。</p><p>参考利率有</p><blockquote><p>2017年英国金融行为监管局（FCA）宣布，2021年底后将不再强制要求报价行报出LIBOR。这意味着LIBOR将退出市场。</p></blockquote><p>最终损益就是名义本金与合同利率和参考利率的差额的乘积</p><h2 id="3-远期结售汇"><a href="#3-远期结售汇" class="headerlink" title="3. 远期结售汇"></a>3. 远期结售汇</h2><p>对于中国大陆市场来说，由于CNY不能自由兑换，因此人民币有远期结售汇业务，而由于远期结售汇是个人、企业和银行间的交易，非银间交易，因此不被称为外汇远期</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Non-Deliverable Forward.” Wikipedia, Wikimedia Foundation, 24 May 2021, https://en.wikipedia.org/wiki/Non-deliverable_forward.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">- LIBOR(London Interbank Offered Rate)- SHIBOR(Shanghai Interbank Offered Rate)- ......<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Forward Rate Agreement.” Wikipedia, Wikimedia Foundation, 1 Oct. 2021, https://en.wikipedia.org/wiki/Forward_rate_agreement.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedinas. “Reference rate” Wikipedia, Wikimedia Foundation, 1 May. 2018, https://en.wikipedia.org/wiki/Reference_rate.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Unknown. “Forwards in the Debt Markets.” Ebrary, 1 Oct. 2021, https://ebrary.net/788/economics/forwards_debt_markets.<a href="#fnref:4" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;#x2F;&amp;#x2F; TODO&lt;/p&gt;</summary>
    
    
    
    <category term="technology" scheme="https://blog.xuwei.fun/categories/technology/"/>
    
    <category term="finance" scheme="https://blog.xuwei.fun/categories/technology/finance/"/>
    
    
    <category term="finance" scheme="https://blog.xuwei.fun/tags/finance/"/>
    
    <category term="invest" scheme="https://blog.xuwei.fun/tags/invest/"/>
    
    <category term="derivatives" scheme="https://blog.xuwei.fun/tags/derivatives/"/>
    
    <category term="forward" scheme="https://blog.xuwei.fun/tags/forward/"/>
    
  </entry>
  
  <entry>
    <title>衍生品笔记一 —— 概述</title>
    <link href="https://blog.xuwei.fun/2021/10/03/derivatives01/"/>
    <id>https://blog.xuwei.fun/2021/10/03/derivatives01/</id>
    <published>2021-10-03T09:53:26.000Z</published>
    <updated>2021-10-10T06:22:51.564Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自2018年开始的非洲猪瘟，直到2020年底终于基本在大陆消失了，而在猪瘟这几年里，猪肉价格水涨船高，一度接近牛肉价格，而2021年开始，猪肉价格又开始一路下跌，猪周期终于还是来了，如何才能规避猪肉价格的风险呢？2021年初大连商品交易所（简称大商所）设立的生猪期货又是什么？这对猪肉价格有影响吗？Kino就从简单介绍2021年刚设立的生猪期货合约开始谈起。<br>首先期货的标准定义是<strong>由期货交易所统一制定的、规定在将来某一特定的时间和地点交割一定数量和质量标的物的标准化合约。</strong>那么通过大商所的官网，可以查看到<a href="http://www.dce.com.cn/dalianshangpin/sspz/sz/hyygz30/6264142/index.html">生猪期货合约</a>的具体规则，目前生猪合约月份有1、3、5、7、9、11月份，那以Kino写这篇文章时的2021.10.03为例，此时实际上可以开仓的标的就有生猪期货2111、生猪期货2201、生猪期货2203等，生猪期货的最后交易日为合约月份倒数第4个交易日，也就是说如果现在持有生猪期货2203一手16吨，2022.03.28日是最后交易日，2022.03.28之后还持有该标的，就进入了交割日，需要进行生猪的活体实物交割，简单点来说就是需要去指定的仓库真的领回16吨生猪。<br>那么生猪期货合约对于猪肉养殖公司，例如牧原、温氏等，有什么作用呢？其核心就是风险管理，既然猪肉周期价格变化大，那就可以通过期货合同，提前锁定未来的价格，对冲风险。而下游的猪肉产品制作企业如双汇等，也可以通过期货合约提前锁定价格，如此一来，原本2022.01的猪肉价格对于上下游企业来说，都是不确定的，现在都相对确定了，也就可以据此保证自身产品价格的相对稳定。<br>除却生猪期货，基本国内目前的农产品期货、大宗商品期货等，也都是这样的作用，而期货就是金融衍生品中最常见的一种，So除了期货，还有哪些衍生品呢？衍生品的定义究竟是什么呢？<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="黄小玉,于源,王林, and 崔岱虎. 生猪期货合约及规则设计介绍. 中国期货, 1(2012):20-28.">[1]</span></a></sup></p><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-衍生品概念"><a href="#1-1-衍生品概念" class="headerlink" title="1.1 衍生品概念"></a>1.1 衍生品概念</h3><p>In finance, a derivative is a contract that derives its value from the performance of an underlying entity.<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. “Derivative (Finance).” Wikipedia, Wikimedia Foundation, 17 Sept. 2021, https://en.wikipedia.org/wiki/Derivative_(finance). ">[2]</span></a></sup><br>衍生品，根据其字面含义，就是从一个基础标的 的表现衍生出价值的一个合约&#x2F;协议。一般有三个要素:</p><ul><li>基础标的</li><li>双方&#x2F;多方 交易对手</li><li>协议&#x2F;合约</li></ul><h3 id="1-2-衍生品作用"><a href="#1-2-衍生品作用" class="headerlink" title="1.2 衍生品作用"></a>1.2 衍生品作用</h3><p>衍生品的作用主要有:</p><ul><li>风险管理&#x2F;对冲(Risk Management&#x2F;Hedging)</li><li>投机(Speculation)</li><li>套利(Arbitrage)</li></ul><blockquote><p>虽然衍生品早期是为了风险管理，但是任何工具只要有流动性就可以作为投机或套利的工具</p></blockquote><h3 id="1-3-衍生品分类"><a href="#1-3-衍生品分类" class="headerlink" title="1.3 衍生品分类"></a>1.3 衍生品分类</h3><p>四大类:</p><ul><li>Future Contracts(期货合约)</li><li>Forward Agreements(远期协议)</li><li>Swaps Agreements(互换协议)</li><li>Options Contracts(期权合约)</li></ul><blockquote><p>Contracts是标准化的，可在交易所或OTC交易，Agreements多在OTC交易. 目前OTC交易占比远大于场内交易</p></blockquote><p>其他具体衍生品示例:</p><ul><li>Credit derivatives, 比如信用违约互换(credit default swap，CDS)</li><li>Weather derivatives</li><li>Emission (CO2) derivatives</li><li>Economic derivatives</li></ul><p>实际衍生品标的中，占最大市场份额的其实是利率(interest)相关的</p><h3 id="1-4-衍生品市场"><a href="#1-4-衍生品市场" class="headerlink" title="1.4 衍生品市场"></a>1.4 衍生品市场</h3><ul><li>Exchange trades(场内交易): 交易所作为CCP，可以规避对手风险&#x2F;违约风险</li><li>Over-the-counter(场外交易): 参与者主要是商业银行、投行、基金公司、社保基金、保险公司… 中国内地又以银间交易占比最大</li></ul><p>场外 -&gt; Chicago Board of Trade(CBOT,1840) -&gt; New York Mercantile Exchange(NYMEX, 1882) -&gt; Chicago Mercantile Exchange(CME,1972) -&gt; Chicago Board Options Exchange(CBOE,1973)<br>1972年布雷顿森林体系崩溃后，汇率开始剧烈波动，也因此，期货从早期的农产品等实物商品为标的，开始引入外汇期货(Exchange rate futures)，以外汇等基础金融工具作为标的，当然再往后期货发展越来越繁荣，还引入了股指等虚拟金融工具为标的。</p><blockquote><p>虚拟金融工具的特点之一，就是需要有乘数</p></blockquote><h3 id="1-5-衍生品业务"><a href="#1-5-衍生品业务" class="headerlink" title="1.5 衍生品业务"></a>1.5 衍生品业务</h3><p>现实中，究竟哪些公司会有衍生品业务的需求呢？<br>终端用户有以下业务需求:</p><ul><li>跨国巨头需要控制外汇风险，因此需要外汇衍生品</li><li>交通运输公司受油价影响，因此需要原油衍生品</li><li>购买大额存款、债券的基金等受利率波动影响，因此需要利率衍生品</li><li>个人投资者想要通过衍生品投机</li><li>…</li></ul><p>金融平台自身的业务需求:</p><ul><li>大型商业银行、保险公司等天然需要管理金融工具的风险</li><li>做市商控制存货风险</li></ul><h2 id="2-衍生品的标志性事件"><a href="#2-衍生品的标志性事件" class="headerlink" title="2. 衍生品的标志性事件"></a>2. 衍生品的标志性事件</h2><ul><li>Orange county</li><li>Amaranth</li><li>Nick Leeson</li><li>国储铜事件</li><li>中航油亏损事件</li></ul><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">黄小玉,于源,王林, and 崔岱虎. 生猪期货合约及规则设计介绍. 中国期货, 1(2012):20-28.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Derivative (Finance).” Wikipedia, Wikimedia Foundation, 17 Sept. 2021, https://en.wikipedia.org/wiki/Derivative_(finance).<a href="#fnref:2" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;自2018年开始的非洲猪瘟，直到2020年底终于基本在大陆消失了，而在猪瘟这几年里，猪肉价格水涨船高，一度接近牛肉价格，而2021年开始，猪肉价格又开始一路下跌，猪周期终于还是来了，如何才能规避猪肉价格的风险呢？2021年初大连商品交易所（简称大商所）设立的生猪期货又是什么？这对猪肉价格有影响吗？Kino就从简单介绍2021年刚设立的生猪期货合约开始谈起。&lt;br&gt;首先期货的标准定义是&lt;strong&gt;由期货交易所统一制定的、规定在将来某一特定的时间和地点交割一定数量和质量标的物的标准化合约。&lt;/strong&gt;那么通过大商所的官网，可以查看到&lt;a href=&quot;http://www.dce.com.cn/dalianshangpin/sspz/sz/hyygz30/6264142/index.html&quot;&gt;生猪期货合约&lt;/a&gt;的具体规则，目前生猪合约月份有1、3、5、7、9、11月份，那以Kino写这篇文章时的2021.10.03为例，此时实际上可以开仓的标的就有生猪期货2111、生猪期货2201、生猪期货2203等，生猪期货的最后交易日为合约月份倒数第4个交易日，也就是说如果现在持有生猪期货2203一手16吨，2022.03.28日是最后交易日，2022.03.28之后还持有该标的，就进入了交割日，需要进行生猪的活体实物交割，简单点来说就是需要去指定的仓库真的领回16吨生猪。&lt;br&gt;那么生猪期货合约对于猪肉养殖公司，例如牧原、温氏等，有什么作用呢？其核心就是风险管理，既然猪肉周期价格变化大，那就可以通过期货合同，提前锁定未来的价格，对冲风险。而下游的猪肉产品制作企业如双汇等，也可以通过期货合约提前锁定价格，如此一来，原本2022.01的猪肉价格对于上下游企业来说，都是不确定的，现在都相对确定了，也就可以据此保证自身产品价格的相对稳定。&lt;br&gt;除却生猪期货，基本国内目前的农产品期货、大宗商品期货等，也都是这样的作用，而期货就是金融衍生品中最常见的一种，So除了期货，还有哪些衍生品呢？衍生品的定义究竟是什么呢？&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;黄小玉,于源,王林, and 崔岱虎. 生猪期货合约及规则设计介绍. 中国期货, 1(2012):20-28.
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="technology" scheme="https://blog.xuwei.fun/categories/technology/"/>
    
    <category term="finance" scheme="https://blog.xuwei.fun/categories/technology/finance/"/>
    
    
    <category term="finance" scheme="https://blog.xuwei.fun/tags/finance/"/>
    
    <category term="invest" scheme="https://blog.xuwei.fun/tags/invest/"/>
    
    <category term="derivatives" scheme="https://blog.xuwei.fun/tags/derivatives/"/>
    
  </entry>
  
  <entry>
    <title>计算机科学从0到1(Part 2)</title>
    <link href="https://blog.xuwei.fun/2021/03/01/csFromZeroToOne02/"/>
    <id>https://blog.xuwei.fun/2021/03/01/csFromZeroToOne02/</id>
    <published>2021-03-01T09:00:00.000Z</published>
    <updated>2021-03-07T11:58:32.628Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="计算机的数据表示及实现"><a href="#计算机的数据表示及实现" class="headerlink" title="计算机的数据表示及实现"></a>计算机的数据表示及实现</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="science" scheme="https://blog.xuwei.fun/categories/science/"/>
    
    <category term="cs" scheme="https://blog.xuwei.fun/categories/science/cs/"/>
    
    
    <category term="cs" scheme="https://blog.xuwei.fun/tags/cs/"/>
    
    <category term="computer science" scheme="https://blog.xuwei.fun/tags/computer-science/"/>
    
  </entry>
  
  <entry>
    <title>计算机科学从0到1(Part 1)</title>
    <link href="https://blog.xuwei.fun/2020/11/22/csFromZeroToOne01/"/>
    <id>https://blog.xuwei.fun/2020/11/22/csFromZeroToOne01/</id>
    <published>2020-11-22T10:55:11.000Z</published>
    <updated>2021-03-21T07:38:36.113Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="计算机的发展历史"><a href="#计算机的发展历史" class="headerlink" title="计算机的发展历史"></a>计算机的发展历史</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>电子计算机(Computer)可以说是当代社会最重要的工具, 没有之一。<br>就拿人的基本需求——衣食住行来说, 随便举个栗子。</p><ul><li>衣: 电商平台</li><li>食: 外卖平台</li><li>住: 租售平台</li><li>行: 自动驾驶</li></ul><p>可以看出当代社会已经无法离开互联网了, 而每一个互联网服务的背后, 都是一台又一台的计算机在处理数据、提供服务。<br>那么, 计算机的历史, 到底该从何说起呢?</p><span id="more"></span><h2 id="二、计算机历史"><a href="#二、计算机历史" class="headerlink" title="二、计算机历史"></a>二、计算机历史</h2><h3 id="2-1-Calculating-Tool"><a href="#2-1-Calculating-Tool" class="headerlink" title="2.1 Calculating Tool"></a>2.1 Calculating Tool</h3><p>计算机, 顾名思义, 首先是一种计算工具, 而最早的计算工具, 可以追溯到何时呢?</p><ul><li>Abacus(算盘)：2500 BCE(before common era)发明于两河流域</li><li>Astrolabe(星盘)</li><li>Slide rule(算尺)</li><li>…</li></ul><h3 id="2-2-Computer"><a href="#2-2-Computer" class="headerlink" title="2.2 Computer"></a>2.2 Computer</h3><p>计算机的英文单词Computer, 实际于1613年第一次出现，那时该词还只是表示一种职业.<br>或者我们是不是可以说, 人变成了一种计算工具?</p><h3 id="2-3-Stepped-reckoner-莱布尼茨乘法器"><a href="#2-3-Stepped-reckoner-莱布尼茨乘法器" class="headerlink" title="2.3 Stepped reckoner(莱布尼茨乘法器)"></a>2.3 Stepped reckoner(莱布尼茨乘法器)</h3><p>1694年Gottfried Leibniz(没错, 就是那个莱布尼茨)发明了Stepped reckoner.<br>这种机器可以做加减乘除四则运算, 而且支持16位结果的显示和8位数的输入<br><img src="/images/cs_from_zero_to_one/csfzto01_02_01.jpg" alt="stepped_reckoner"></p><h3 id="2-4-Difference-Engine-差分机"><a href="#2-4-Difference-Engine-差分机" class="headerlink" title="2.4 Difference Engine(差分机)"></a>2.4 Difference Engine(差分机)</h3><p>Charles Babbage于1822年提出差分机, 简单来说, 差分机就是一台多项式求值机, 只要将欲求多项式方程的前3个初始值输入到机器里, 机器每运转一轮, 就能产生出一个值来。<br>Charles Babbage于1849设计了Difference Engine No. 2(差分机二号), 这台机器可以进行相当复杂的数学计算，具有31位的精度。<br>这些机器在Babbage生前, 都没有真正地彻底地完成, 只完成了一部分。直到1985年时，伦敦科学博物馆按照Babbage的图纸, 才打造了一台完整的差分机2号, 这台巨大的手摇智能机械计算机, 长3.35米, 高2.13米, 有4000多个零件, 重2.5吨。<br><img src="/images/cs_from_zero_to_one/csfzto01_02_02.jpg" alt="difference_engine"></p><h3 id="2-5-Analytical-Engine-分析机"><a href="#2-5-Analytical-Engine-分析机" class="headerlink" title="2.5 Analytical Engine(分析机)"></a>2.5 Analytical Engine(分析机)</h3><p>Charles Babbage在制作差分机的基础上, 于1837提出了分析机的模型。<br>分析机能用多项式展开的方法计算对数和三角函数, 具体的计算过程则是用打孔卡片输入, 完成类似汇编语言的程序指令。正是因为这种开创性的思想, 虽然Babbage最终没有完成该机器, 只是提出了机器模型, 却仍然被认为是计算机之父。<br><img src="/images/cs_from_zero_to_one/csfzto01_02_03.jpg" alt="analytical_engine"></p><p>而分析机历史上的另一关键人物则是Ada Lovelace, 她于1843为Babbage的分析机模型编写了假想程序，也因此被认为是世界上第一个程序员.</p><blockquote><p>在1842年与1843年期间, Ada花了9个月的时间翻译意大利数学家Luigi Menabrea讲述Charles Babbage计算机分析机的论文。在译文后面, 她增加了许多注记, 详细说明用该机器计算伯努利数的方法, 被认为是世界上第一个计算机程序。因此, Ada也被认为是世界上第一位程序员</p></blockquote><blockquote><p>PS: 著名的逆向软件IDA Pro的图标, 也是以Ada为原型</p></blockquote><p>还有些值得一提的点就是, 上面提到的这些人物中, Luigi Menabrea是第7任意大利首相, Ada是诗人拜伦的女儿…</p><h3 id="2-6-Tabulating-machine-穿孔制表机"><a href="#2-6-Tabulating-machine-穿孔制表机" class="headerlink" title="2.6 Tabulating machine(穿孔制表机)"></a>2.6 Tabulating machine(穿孔制表机)</h3><p>从1790年开始, 美国每十年进行一次人口普查, 由于人口越来越多, 1880年开始的第10次人口普查, 历时8年才完成, 为了能够更高效的统计人口, 美国政府向社会招标寻求更高效的方式, 最终Herman Hollerith脱颖而出。<br>1888年, Herman Hollerith设计完成了穿孔制表机，用于1890年的美国人口普查。<br>后来, Herman Hollerith成立了相关制表机公司，却因经营不善, 1911年与另外3家公司合并成立CTR公司(Computing-Tabulating-Recording Company), 1924年, CTR更名为International Business Machines Corporation, 缩写就是IBM。制表机公司作为其子公司继续运营到1933年。<br><img src="/images/cs_from_zero_to_one/csfzto01_02_04.jpg" alt="tabulating_machine"></p><p>想要了解更多穿孔制表机的历史, 可以参考<em>制表机：穿孔时代的到来</em><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="逸之. “制表机：穿孔时代的到来,” November 10, 2019. https://www.jianshu.com/p/49f23b77dced. ">[2]</span></a></sup> 这篇文章</p><h3 id="2-7-Harvard-Mark-I"><a href="#2-7-Harvard-Mark-I" class="headerlink" title="2.7 Harvard Mark I"></a>2.7 Harvard Mark I</h3><p>在整个计算机的历史中, 经常能见到IBM的身影, 其中便有这台Harvard Mark I。<br>Harvard Mark I其实是使用者哈佛大学为该计算机起的名字, 设计生产者IBM称这台计算机为Automatic Sequence Controlled Calculator(ASCC)。<br>该计算机是1944年IBM为二战同盟国制造的计算机, 是世界上最大的计算机, 也是世界上第一台实现顺序控制的自动数字计算机。<br>Harvard Mark I主要供海军舰船局(Bureau of Ships)用于计算弹道和编制射击表, 也曾在曼哈顿计划中计算有关原子弹的问题。<br>而之所以这台计算机体积如此庞大, 是因为该计算机的基本组件是继电器(Relays), 用电磁控制的机械结构, 而不是后来的电子计算机.<br><img src="/images/cs_from_zero_to_one/csfzto01_02_05.jpg" alt="havard_mark_i"></p><blockquote><p>现代计算机大多用冯诺依曼架构, 而这台计算机用的哈佛架构, 即将程序指令存储和数据存储分开的结构。(哈佛架构这个名字的来源, 应该也不言自明了…</p></blockquote><h3 id="2-8-Harvard-Mark-II"><a href="#2-8-Harvard-Mark-II" class="headerlink" title="2.8 Harvard Mark II"></a>2.8 Harvard Mark II</h3><p>在Harvard Mark I之后, Howard H. Aiken主持了Harvard Mark II的制造, 并于1947年完成, 因此也被称作Aiken Relay Calculator<br>关于Harvard Mark II的最重要的一个趣事就是: 1945年9月9日, Harvard Mark II出现故障, Grace Hopper经过一天的检查, 发现是继电器中有一只死飞蛾，这也是术语 Bug 的起源。<br><img src="/images/cs_from_zero_to_one/csfzto01_02_06.jpg" alt="havard_mark_ii"></p><p>而关于Grace Hopper此人, 却是有更多故事了.</p><blockquote><p>Grace Hopper发明了世界上第一个编译器——A-0 系统; 还是COBOL之母; 于1985年11月升职为海军少将, 是美国第一个到达这个官阶的女性。</p></blockquote><p><img src="/images/cs_from_zero_to_one/csfzto01_02_07.jpg" alt="grace_hopper"></p><h3 id="2-9-Thermionic-valve-x2F-Vacuum-tube-热电子管-x2F-真空管"><a href="#2-9-Thermionic-valve-x2F-Vacuum-tube-热电子管-x2F-真空管" class="headerlink" title="2.9 Thermionic valve&#x2F;Vacuum tube(热电子管&#x2F;真空管)"></a>2.9 Thermionic valve&#x2F;Vacuum tube(热电子管&#x2F;真空管)</h3><p>刚刚说到, 1945年, 二战时期的Harvard Mark计算机竟然还是电磁机械结构的, 难道是电子计算机所需要的基本元件, 一直还没有发明出来吗?<br>其实不是这样的, John Ambrose Fleming于1904年就发明出了世界上第一个真空管。<br>真空管(Vacuum tube)其实概念上很宽泛, 可以泛指二极、三极、多极真空管, 而 Fleming 发明的真空管只允许电流单向流动, 是真空二极管。<br>实际上任何只允许电流单向流动的电子部件，都叫做二极管, 真空管只是第一次实现了实用的小型的二极管。<br><img src="/images/cs_from_zero_to_one/csfzto01_02_08.jpg" alt="thermionic_valve"></p><h3 id="2-10-Triode-vacuum-x2F-Audion-三极管"><a href="#2-10-Triode-vacuum-x2F-Audion-三极管" class="headerlink" title="2.10 Triode vacuum&#x2F;Audion(三极管)"></a>2.10 Triode vacuum&#x2F;Audion(三极管)</h3><p>1906年Lee de Forest在Thermionic valve基础上加入了控制电极，制作了三极管。<br>而Lee de Forest也因此被誉为是电子学之父<br><img src="/images/cs_from_zero_to_one/csfzto01_02_09.jpg" alt="triode_vacuum"></p><h3 id="2-11-Colossus-Mark-1"><a href="#2-11-Colossus-Mark-1" class="headerlink" title="2.11 Colossus Mark 1"></a>2.11 Colossus Mark 1</h3><p>既然二极、三极真空管早就发明出来了, 为何到20世纪40年代制作的计算机还有电磁机械结构?<br>其中一个原因就是使用真空管制作计算机成本太高, 一直到40年代, 真空管的成本终于下降。<br>顺其自然地, 1943年12月, 在Tommy Flowers的主导下, 第一台使用真空管制作的计算机Colossum Mark 1制作完成了, 也被认为是<strong>第一台可编程的电子计算机</strong>。这个时间点诞生的计算机, 显然都是为二战服务的, Colossum Mark 1就被放置在Bletchley Park, 用于破解德军的加密报文。<br>说到Bletchley Park(布莱切利园), 它在二战期间, 是英国政府进行密码解读的主要地点, 比如Enigma密码机等。2012年, ITV还出品过一部英剧 <em>The Bletchley Circle (布莱切利四人组)</em>, 剧中的主人公便是二战时曾在Bletchely Park工作过的人员。(不过该剧本身却是平平无奇, 并不推荐…)<br><img src="/images/cs_from_zero_to_one/csfzto01_02_10.jpg" alt="colossum_mark_i"></p><h3 id="2-12-ENIAC"><a href="#2-12-ENIAC" class="headerlink" title="2.12 ENIAC"></a>2.12 ENIAC</h3><p>Colossus Mark 1及后来的一系列Colossus Mark计算机, 虽然可以说是可编程的电子计算机, 但实际是, 内部具有特定的程序片段, 再通过人工调整开关和插头的组合, 实现不同程序片段的组合, 完成不同的功能, 最重要的是, 它不是图灵完备的, 因此也称不上是可编程的, 只能说是是可组合的。<br>第一台可编程的电子计算机, 1946年在宾夕法尼亚大学完成，也就是计算机教材中最常提到的ENIAC, ENIAC是<strong>第一台真正的通用可编程电子计算机(General Purpose Programmable Electronic Computer)</strong>, 它是图灵完备的, 虽然在操作上, ENIAC也还是通过机械式的plugboard(插线板)实现不同的程序, 但是在本质上发生了变化。<br><img src="/images/cs_from_zero_to_one/csfzto01_02_11.jpg" alt="eniac"></p><h3 id="2-13-Transistor-晶体管"><a href="#2-13-Transistor-晶体管" class="headerlink" title="2.13 Transistor(晶体管)"></a>2.13 Transistor(晶体管)</h3><p>基于真空三极管的计算机, 虽然实现了电子化, 但体积还是过大, 从上面每一代计算机的图片上也可以看出。直到1947年，贝尔实验室的John Bardeen、Walter Brattain和William Shockley发明了晶体管(Transistor), 自此之后, 计算机的体积迅速下降，三位也因此共同获得了1956年的物理学诺贝尔奖。<br><img src="/images/cs_from_zero_to_one/csfzto01_02_12.jpg" alt="transistor"></p><p>不过大概是大师总是有点脾性的，三人间的关系并没有维持长久，发明了晶体管后不久，三人小团队便因种种矛盾分崩离析。实际上，1947年Bardeen和Brattain在发表第一个以锗半导体做成的点接触晶体管过程中，申请的专利竟然都没写小组长Shockley的名字，Shockley得知之后十分Shock…一怒之下，一个月后也以自己的名义提出了使用P-N结面制作接面晶体管的方法（其实也是他本人对自己的工作一直做了保密工作，可真是同组异梦呢…）</p><p>不过在晶体管以外，这三人单独拿出来，也都有一些有趣的小故事可说，就借此说些题外话叭。</p><blockquote><p>也许你知道中国第一个诺贝尔奖获得者是谁, 但是你知道第一位出生在中国的诺贝尔奖获得者是谁吗?<br>没错, 就是三人组中的Brattain, Brattain于1902年2月10日出生于中国厦门, 也就成为了第一位出生在中国的诺贝尔奖得主<br>你知道谁是第一位两次获得诺贝尔物理学奖的人吗?<br>竟然又是三人组中的一员?! Bardeen因BCS理论对超导电性做出了合理解释，因此获得了1972年的诺贝尔物理学奖，是第一位两次获得诺贝尔物理学奖的人，也是截止本文写作时间(就算作2020年12月31)，唯一一位两次获得诺贝尔物理学奖的人<br>AMD, Intel 乃至 硅谷的一系列公司有什么共性吗? 或者说硅谷为何成为了硅谷呢?<br>总算得说到Shockley了, Shockley和贝尔实验室分道扬镳后，来到美国西海岸即加州，创建了肖克利半导体实验室(Shockley Semiconductor Laboratory)，为了公司的发展，他特意从东部召来八位年轻人(Julius Blank, Victor Grinich, Eugene Kleiner, Jean Hoerni, Jay Last, Gordon Moore, Robert Noyce and Sheldon Roberts)。要知道当初美国的技术中心还在西部，这八位年轻人完全是被Shockley的科学声誉吸引过来的。可是无奈Shockley的确没有管理才能，最终这八位无奈出走，创办了自己的公司Fairchild Semiconductor(飞兆半导体&#x2F;仙童半导体)，获得了成功，且至今仍存活着，而从Fairchild中走出的其他人，又创办了National Semiconductor、AMD、Intel等知名公司，最终造就了硅谷传奇。甚至这八人中，有被称为“硅谷市长”的Robert Noyce，有提出摩尔定律的Gordon Moore…还有很多细节可以看看文章<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Martin Groeger. Shockley Semiconductor,” July 8, 2000. http://www.silicon-valley-story.de/sv/shockley.html.">[3]</span></a></sup>和文章<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedian. “硅谷,” January 27, 2021. https://zh.wikipedia.org/zh-cn/%E7%A1%85%E8%B0%B7.">[4]</span></a></sup></p></blockquote><h3 id="2-14-TRADIC"><a href="#2-14-TRADIC" class="headerlink" title="2.14 TRADIC"></a>2.14 TRADIC</h3><p>转回正题，有了晶体管之后，晶体管计算机的出现也就顺理成章了。<br>1954年，美国贝尔实验室研制成功第一台使用晶体管线路的计算机TRADIC，装有800个晶体管。不出例外的，TRADIC也被用于军事用途，主要是海军雷达系统中。<br><img src="/images/cs_from_zero_to_one/csfzto01_02_13.jpg" alt="tradic"></p><h3 id="2-15-IBM-608"><a href="#2-15-IBM-608" class="headerlink" title="2.15 IBM 608"></a>2.15 IBM 608</h3><p>虽然TRADIC总算用上了晶体管，虽然在此之前，发明了那么多的计算机，但却还没有出现一款可以让普通人接触的计算机，都是用于军方、政府等机构，甚至于都没有很好的量产，给每台研制成功的计算机起名，大概就是基于这种背景叭。<br>终于到了1957年，IBM发布了IBM 608，第一个完全晶体管构建且可以在市面上买到的电子计算机。它有3000个晶体管，每秒能执行4500次加法，80次左右的乘除法。自此，计算机算是开启了商用化的道路。<br><img src="/images/cs_from_zero_to_one/csfzto01_02_14.jpg" alt="ibm608"></p><h3 id="2-16-Integrated-Circuits"><a href="#2-16-Integrated-Circuits" class="headerlink" title="2.16 Integrated Circuits"></a>2.16 Integrated Circuits</h3><p>当所有技术都已经成熟，物理学难题逐一解决，工程师剩下的追求就是将计算机越做越小，而计算机越来越小的发展历史其实就是集成电路的发展历史。</p><ul><li>1903年，Albert Hanson发明了Printed Circuit Boards(PCBs)</li><li>1958年, Jack Kilby发明了第一个germanium IC.</li><li>1958年，Jay W. Lathrop &amp; James R. Nall发明了光刻技术</li><li>1959年，Robert Noyce(也就是上文提到的“硅谷市长”)发明了第一个silicon IC，也因此被称为father of modern ICs.</li><li>1965年，Gordon Moore提出了摩尔定律</li><li>1968年，Robert Noyce &amp; Gordon Moor创建了Intel</li><li>1971年, Faggin完成了Intel 4004  Microprocessor，是Intel第一款推出的微处理器，也是全球第一款商用微处理器</li><li>1970s，VLSI(Very Large Scale Integration) Software技术也开始了大规模的发展，最终，让我们现在看到的10nm、7nm等技术成为现实</li></ul><h3 id="2-17-Non-volatile-Memory"><a href="#2-17-Non-volatile-Memory" class="headerlink" title="2.17 Non-volatile Memory"></a>2.17 Non-volatile Memory</h3><p>计算机世界中，最重要的就是数据，计算机处理的是信息，而这些信息全部都是用数据来表示的，那么如何来存储这些数据，也是个必然需要解决的问题，在计算机的发展历程里，存储工具也在不停的更新换代。</p><ul><li>在计算机发展早期，数据是用Punch cards或者Paper tape存储的</li><li>1944年，J. Presper Eckert发明了Delay Line Memory</li><li>1940s, Jay Forrester发明了Magnetic Core Memory</li><li>1950s, J. Presper Eckert &amp; John Mauchly在UNIVAC计算机中使用了Magnetic Tape</li><li>1950s，除了Magnetic Tape，同时也有计算机使用Magnetic Drum Memory，而这一技术实际上是Gustav Tauschek在1932发明的</li><li>1956年，IBM 305 RAMAC成为第一个使用了Hard disk drives的电脑</li><li>1972年，RAM Integrated Circuits发明，成为Flash和SSD的技术基础</li></ul><h3 id="2-18-Program"><a href="#2-18-Program" class="headerlink" title="2.18 Program"></a>2.18 Program</h3><p>计算机的发展，除了硬件的推动，软件的发展也是必不可少的一部分，编程语言在计算机硬件发展之初也就随之诞生了。除了最原始的二进制式的指令编制方法，编程语言的发展也是一直与时俱进的。简单罗列下各个时代的编程语言的发展。</p><ul><li>1947年，Kathleen Booth发明了汇编语言</li><li>1952年，Grace Hopper发明了Arithmetic Language Version 0, 算是世界上第一个高级编程语言，同时创造了第一个编译器</li><li>1957年，John Backus发明了Fortran，用在IBM</li><li>1959年，在Grace Hopper的建议下，研发了COBOL(Common Business-Oriented Language)，实现了上层编程语言的统一, 不同机器不同的编译器</li><li>1960s，诞生的有Algol, Lisp, Basic</li><li>1970s，Pascal, C, Smalltalk等被发明</li><li>1980s，C++, Objective-C, Perl</li><li>1990s，Python, Ruby, Java</li><li>2000s，Swift, C#, Go……</li></ul><h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><p>以上所有计算机的发展历程，最终被Kino做成了一张图，仅供参考。<br><img src="/images/cs_from_zero_to_one/csfzto01_03_01.jpg" alt="summary"></p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedian. “电子计算机,” November 8, 2020. https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">逸之. “制表机：穿孔时代的到来,” November 10, 2019. https://www.jianshu.com/p/49f23b77dced.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Martin Groeger. Shockley Semiconductor,” July 8, 2000. http://www.silicon-valley-story.de/sv/shockley.html.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedian. “硅谷,” January 27, 2021. https://zh.wikipedia.org/zh-cn/%E7%A1%85%E8%B0%B7.<a href="#fnref:4" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;计算机的发展历史&quot;&gt;&lt;a href=&quot;#计算机的发展历史&quot; class=&quot;headerlink&quot; title=&quot;计算机的发展历史&quot;&gt;&lt;/a&gt;计算机的发展历史&lt;/h1&gt;&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;电子计算机(Computer)可以说是当代社会最重要的工具, 没有之一。&lt;br&gt;就拿人的基本需求——衣食住行来说, 随便举个栗子。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;衣: 电商平台&lt;/li&gt;
&lt;li&gt;食: 外卖平台&lt;/li&gt;
&lt;li&gt;住: 租售平台&lt;/li&gt;
&lt;li&gt;行: 自动驾驶&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看出当代社会已经无法离开互联网了, 而每一个互联网服务的背后, 都是一台又一台的计算机在处理数据、提供服务。&lt;br&gt;那么, 计算机的历史, 到底该从何说起呢?&lt;/p&gt;</summary>
    
    
    
    <category term="science" scheme="https://blog.xuwei.fun/categories/science/"/>
    
    <category term="cs" scheme="https://blog.xuwei.fun/categories/science/cs/"/>
    
    
    <category term="cs" scheme="https://blog.xuwei.fun/tags/cs/"/>
    
    <category term="computer science" scheme="https://blog.xuwei.fun/tags/computer-science/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记十二</title>
    <link href="https://blog.xuwei.fun/2020/09/13/reading12/"/>
    <id>https://blog.xuwei.fun/2020/09/13/reading12/</id>
    <published>2020-09-13T15:51:33.000Z</published>
    <updated>2020-09-20T05:22:57.873Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>《罪与罚》杂谈.<br>转录Kino在微信读书上关于《罪与罚》的笔记.</p><span id="more"></span><h3 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h3><p>看完全书后，过了一遍陀思妥耶夫斯基的生平，发现小说有时还是需要结合作者经历来看。陀神在写“罪与罚”之前，一直患有癫痫-&gt;父亲去世-&gt;当过中尉-&gt;因革命被捕-&gt;被流放到西伯利亚-&gt;服役期间开始笃信宗教-&gt;妻兄逝世-&gt;赌博欠债，而在“罪与罚”中，这一切都呈现了出来，且大多是赋在了主人公拉斯柯尔尼科夫身上。将陀神的经历代入作品后，我甚至会怀疑陀神是否也曾想过自己是更特别的存在，想通过自己的手代替法律执行正义，也会怀疑陀神是否也曾想过自杀。</p><p>既然小说中的原型来源于自己的生活，那么多精彩的心理描写也就不难理解了，我相信小说中的主人公有多挣扎，陀神也就有过同样的挣扎，经历越多的读者也就越能产生共鸣(产生共鸣越多的读者大概越不幸吧)。能将如此多的心理活动生动准确地描写出来，能将读者的注意力迅速抓住，能将种种情节在主线中穿插自如，能将前期的处处伏笔完整收回，虽然陀神以心理描写而闻名，却显然不限于此。</p><p>“罪与罚”中最让我印象深刻的是描写斯维德里盖洛夫寻求自杀的那几节，让我莫名相信自杀者的心里状态就该如此，于反复中坚定，再无被挽救的可能。</p><p>陀神很残忍，“罪与罚”中的底层人大多都被生活蹂躏，没有一丝光明的希望；陀神也心系幻想，拉斯柯尔尼科夫一家获得了一笔意外的财富，拉斯柯尔尼科夫还有个一直愿意帮助他的朋友拉祖米欣，拉斯柯尔尼科夫的心灵最终在服役期间获得了救赎。拉斯柯尔尼科夫虽然经历坎坷，不幸中也还有着诸多幸运。</p><p>可是，书中那些已经死去的小人物呢？他们再也没有未来了。那些住在公寓套间里的底层穷人呢？他们还有希望吗？</p><p>群租在大城市套间中的我们又如何在一片压力中寻求自由与救赎呢？该怎样寻找自己的生存价值呢？不过还好，我们还算幸运，既然还有这一小片幸运的云，就努力生活下去吧，暂且不做无谓的思辩，就如陀神所说: “生活已经代替了思辨，因此思想意识必须完全另起炉灶。”</p><h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h3><p><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="">[1]</span></a></sup> <a href="https://book.douban.com/subject/30438790/">罪与罚</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;《罪与罚》杂谈.&lt;br&gt;转录Kino在微信读书上关于《罪与罚》的笔记.&lt;/p&gt;</summary>
    
    
    
    <category term="life" scheme="https://blog.xuwei.fun/categories/life/"/>
    
    <category term="reading" scheme="https://blog.xuwei.fun/categories/life/reading/"/>
    
    
    <category term="陀思妥耶夫斯基" scheme="https://blog.xuwei.fun/tags/%E9%99%80%E6%80%9D%E5%A6%A5%E8%80%B6%E5%A4%AB%E6%96%AF%E5%9F%BA/"/>
    
    <category term="罪与罚" scheme="https://blog.xuwei.fun/tags/%E7%BD%AA%E4%B8%8E%E7%BD%9A/"/>
    
  </entry>
  
  <entry>
    <title>从一个Emoji字符说起</title>
    <link href="https://blog.xuwei.fun/2020/09/07/characterset/"/>
    <id>https://blog.xuwei.fun/2020/09/07/characterset/</id>
    <published>2020-09-07T14:22:22.000Z</published>
    <updated>2020-09-20T07:08:22.382Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在和朋友聊天时，突然无话可说，屏幕前的你该如何是好呢? 很多时候屏幕前的我们，都会想到发个表情，然后彼此心照不宣地沉默。如果你用的是windows 10的新版本，按下 <code>winkey + period</code> （即windows图标和英文句点按钮），就会有如下的弹出框。</p><p><img src="/images/character_set/image_1_1.png" alt="image_1_1.png"></p><p align="center">图1.1</p><p>反复斟酌、几度纠结之后，你选择了这样一个表情：😤。将鼠标停留在这个表情上几秒，可以看到提示文字：“傲慢”。如果你用的是andriod、ios，在输入法中仔细搜寻，一定也可以发现这样一个表情。</p><p>如果哪里都找不到，也没关系，直接将这个表情复制，粘贴到微信聊天框中，回车，成功地将这个表情发了出去。在对方沉默不语的时间里，你点开了微信对话框里的表情，却发现怎么也找不着这个傲慢的表情?！但是这个表情的确正确地显示了呀?这是怎么回事呢?“微信连不存在的表情都支持，太厉害了叭！”也许你会发出这样的感慨。也有可能你会嗤之以鼻：“不过是显示了一张图片而已”。不过，这真的是图片吗? 且听我缓缓道来。</p><span id="more"></span><p><a name="29Um5"></a></p><h2 id="二、Emoji的前世今生"><a href="#二、Emoji的前世今生" class="headerlink" title="二、Emoji的前世今生"></a>二、Emoji的前世今生</h2><p>上面的表情，其实是个emoji字符。emoji这个词，互联网时代的人当然都不会陌生。但是刚刚的表述，又说它是表情，又说它是字符，似乎将表情和字符混为一谈了，这是怎么回事呢?其实准确来说，emoji应该称为“表情字符”，其本质还是一个字符，只是个用来象征表情的字符罢了。一个emoji字符，和一个字母、一个汉字，没有什么本质的不同，或者想象一下，对于一个不懂汉字的人来说，汉字看起来也许也就像一个个表情呢~ 当然啦，表情也可以用图片表示，至于计算机上区别字符和图片的根本因素是什么，稍后再论，这里先说下emoji出现的历史。</p><p>Emoji用日语表示就是「絵文字」，平假名为「えもじ」，1999年，由株式会社NTT DoCoMo的iMode服务团队开发，在12×12格的方格纸上以简单的图案描绘出人的各种表情及生活事物，再把它们对应成字符数据，NTT公司的这一发明意在提供一种在画面尺寸和通信量受限的情况下，让用户们通过视觉顺利进行交流的方式。</p><p>Emoji诞生之初，就得到了年轻人的追捧，到了2004年左右它已经被全日本所接受。2009年emoji被收录进Unicode编码，成为了世界标准的通用字符，2012年智能手机中加入了对emoji的支持，2014年提出了“世界Emoji日(World Emoji Day)”，2015年《牛津词典》的年度词汇是😂，2016年起，纽约现代美术馆（MoMA）将NTT DoCoMo的iMode中提供的第一版176个emoji纳入永久收藏。如今，emoji已经成为了iOS、Android、Mac OS及Windows中默认支持的表情符号。</p><blockquote><p>关于世界Emoji日，是在每年的7月17日，因为提出了World Emoji Day, 因此各个平台上表示日历的Emoji也都展示的是7月17日，📅<a href="https://emojipedia.org/calendar/">Calendar Emoji</a>，还有一个专门的World Emoji Day网站：<a href="https://worldemojiday.com/">点我试试</a></p></blockquote><p>iMode的开发负责人是栗田穣崇(Shigetaka Kurita)，也是他设计了最早版本的emoji，引用一句栗田先生后来的回忆分析：</p><blockquote><p>“在以数字信息互动为主的手机世界中，仅用文字来沟通的话，容易产生理解上的误会，因此有必要附加上感情语气，因此emoji的登场有其符合时代刚需的必然性”</p></blockquote><p><img src="/images/character_set/image_2_1.jpg" alt="image_2_1.jpg"></p><p align="center">图2.1</p><p>一个没有接触过编程的人，应该也能看懂上面大部分的内容，唯一可能有疑惑的大概是： <strong>2009年emoji被收录进Unicode编码</strong>。这个Unicode编码又是个什么玩意呢? 开头说的计算机上区别字符和图片的根本因素是什么呢?</p><h2 id="三、字符集和字符编码"><a href="#三、字符集和字符编码" class="headerlink" title="三、字符集和字符编码"></a>三、字符集和字符编码</h2><p>说起字符集，首先不得不扯一些语言学和计算机的基础。</p><h3 id="3-1-语言学简介"><a href="#3-1-语言学简介" class="headerlink" title="3.1 语言学简介"></a>3.1 语言学简介</h3><p>每个文化都有自己的语言体系，每种语言大致都会包含 发音系统、书写系统、语法系统 等几大方面。发音系统的基本单位是音素(phoneme)，书写系统的基本单位是字素(grapheme)，语法系统的基本单位是语素(morpheme)。</p><ul><li>小学时，我们学的声母表、韵母表，里面的每个音，就可以认为是普通话的音素，英文的音标就可以当作是英文的音素。</li><li>中文的字素有两种看法了，一种认为汉字可以按照偏旁部首的拆分，每个偏旁部首作为一个字素，比如“河”，可以认为是“氵”和“可”两个字素（李玲璞先生就持这种看法），另一种看法则认为每个汉字作为一个字素。而在英文等拉丁语族中, 字素其实并没有特别确切的概念, 不同的论文中可能使用的是不同的概念.</li><li>中文的语素通常就是对应着单个汉字，而英文的语素可能就会复杂点，例如really, 可以看作是 real 和 -ly 两个语素，这种区别主要是因为中文不通过词语形变来表达语法，只通过语法词汇来区分语法，比如“的”、“了”等。</li></ul><p>当然啦，回到字符集上来，这里面与字符集关系最密切的显然是字素，那么文字、字符、字素，这些有区别吗?为什么要发明这么多名词?！太难了…</p><p>1）先说“文字”</p><blockquote><p>文字是记录语言的视觉符号系统，是人类社会运用语言相当长时间以后出现的文化现象。</p></blockquote><p>也就是说，文字是个宏观的概念。语言的发展都是先有发音后有文字的，文字的出现是一种必然，同样作为信息的载体，文字显然比声音更容易保存，这也是为什么历史上知识都是通过文字流传下来的。即使是互联网时代来临，多媒体技术诞生，文字载体相对于音频载体，信息密度也是高到不知道哪里去了，音视频种的信息冗余太大，利于传播，但并不利于保存，如今一门语言如果没有文字，慢慢也就会被淘汰了吧。</p><p>2）再说“字符”（Character）</p><p>字符这个概念在英语和汉语种很容易，一个字母、一个汉字就是一个字符，如果给个概念，大概是：拥有实际语义的最小文字单位。但这其实并不严谨，还引入了更为模糊的语义概念。我觉得，简单一点可以理解成，字符就是一门语言的文字中，可以独立有意义的最小单位，它并不是一个特别严谨的概念。只是在计算机科学中，字符的概念有特殊的地位，接着往下看, 暂且按下不表。</p><p>3）后说“字素”（Grapheme）</p><p>正如前面所述, 中文的字素概念有两种学派, 拉丁语族的字素也分类不明确, 所以实际上, 很难严格意义上给字素一个具体的概念进行分类. 只能模糊地给出“字素是书写系统的最小功能单位”, 但是具体这个单位该细分到什么程度, 标准并不统一. 那为何还需要提到这个概念, 一切都是因为, 和字符一样, 在计算机科学中, 字素这个概念被赋予了特殊的意义, 而具体意义是什么, 一直往下看, 你就可以看到.</p><blockquote><p>后续行文中, 在未涉及到字素概念前, 可以暂且先认为一个字符就是一个英文字符、一个汉字、一个符号</p></blockquote><h3 id="3-2-计算机科学简介"><a href="#3-2-计算机科学简介" class="headerlink" title="3.2 计算机科学简介"></a>3.2 计算机科学简介</h3><p>学过编程的人都知道，计算机程序中，一切数据的最终形态，其实都是二进制。</p><p><img src="/images/character_set/image_3_1.png" alt="image_3_1.png"></p><p align="center">图3.1</p><p>也就是说，此时此刻呈现在你眼前的所有信息，你耳中听到的音乐，在计算机中全都是 010101010101 这样的存在。</p><blockquote><p>世界上有10种人，懂10进制的，和不懂10进制的。——鲁迅</p></blockquote><p>那么文字自然也是如此，每个有独立语言的国家，在计算机诞生之初，便需要考虑如何表示和存储字符了。即如何将本国语言中的每个文字，对应到一个二进制数中，而这种一一对应的规则，我们就可以将其称为字符集。</p><blockquote><p>在计算机世界中，二进制虽然可以区分到每一位，但实际的读取和写入，最小都是1个字节(byte)，1个字节包含8位二进制。</p></blockquote><h3 id="3-3-（编码）字符集"><a href="#3-3-（编码）字符集" class="headerlink" title="3.3 （编码）字符集"></a>3.3 （编码）字符集</h3><p>在说字符集之前，先厘清几个概念。 而这些概念中，我们经常将编码字符集和字符集混为一谈，倒也不太影响理解，因此这里也就不那么严谨，理解万岁！！</p><blockquote><ul><li>字符集&#x2F;字符库(Character set&#x2F;Character repertoire)：被一种或多种语言使用的字符的集合。也就是说，字符集告诉了我们，一门语言中，到底有多少个字符，每个字符是什么。</li><li>编码字符集(Coded character set)：每个字符对应一个独一无二的数字的集合。即将字符集和数字一一对应的集合。</li><li>码点(Code point)：编码字符集中的任一个合法数字，称之为码点。</li><li>编码空间(Code space)：包含所有码点的整数范围。</li><li>编码单位(Code unit)：用来编码字符集中每个字符的二进制序列。</li></ul></blockquote><p>对于计算机的诞生国美国来说，很简单，只需要考虑26个英文字母及其大小写，再加上阿拉伯数字、标点符号和一些特殊的控制字符，字符集的容量只要128够了。因此美帝标准协会制定了一个标准，用来表示英文世界中需要用到的所有字符，这个标准就是ASCII(American Standard Code for Information Interchange)。128个数，用二进制来表示，7位也就够了，一个字节绰绰有余。</p><p><img src="/images/character_set/image_3_2.gif" alt="image_3_2"></p><p align="center">图3.2</p>    <p>但是渐渐地，欧洲国家也开始有了计算机，它们使用更多的字符，因此将一个字节中没有使用的最高位也用上了，制定了一套Extended ASCII Codes.</p><p><img src="/images/character_set/image_3_3.gif" alt="image_3_3"></p><p align="center">图3.3</p><p>后来亚洲国家也开始使用计算机，汉字需要制定一套标准字符集，因此中国国家标准总局逐步制定了GB2312、GBK、GB13000、GB18030的标准字符集。日语也需要一套字符集，于是日本政府就逐步制定了JIS X 0201–1976、JIS X 0208–1990、JIS X 0212–1990、JIS X 0213–2000等标准字符集。</p><p>这样一直下去，问题就来了，不同国家之间没有沟通，同样一个数字，用汉语的编码字符集解读是正常的，用日语编码字符集就会出错。为了解决这个问题，各国之间也想约定一个世界统一的文字字符集标准，这就诞生了 Unicode。</p><p>Unicode目前使用了0(0x0000)<del>1114111(0x10FFFF)的编码范围，也就是说，当前Unicode的编码空间(Code Space)是0</del>0x10FFFF，之所以说是“当前”，是因为Unicode本身也是在不断发展的，早期Unicode的Code Space只用了0~65535(0xFFFF)的范围，只是随着发展，Unicode标准委员会的人才发现，原来还有各种各样隐藏在世界各处的字符，当然需要加进来！这就导致BMP的范围不够用了，只好扩展Unicode的范围，只是，实际扩展到1114111(0x10FFFF)之后，委员会的人又发现，这么多字符不可能用得完呀！不用又觉得浪费，不如加一些不太正常的语言文字吧，这就包含了文章开头提到的Emoji表情字符。</p><p>Unicode范围如此之大，当然就会想要将它划分成几大块，方便分类，也更容易理解，Unicode标准将这种分片叫做平面(Plane)。最早使用的 0~0xFFFF，就是 基本多语言平面(BMP, Basic Multilingual Plane) 的范围。</p><p><img src="/images/character_set/image_3_4.png" alt="image_3_4"></p><p align="center">图3.4</p>    <p>Unicode总共划分了17个平面，每个平面65536个编码空间，总共正好是 65536*17&#x3D;1114112&#x3D;0x10FFFF+1</p><p><img src="/images/character_set/image_3_5.png" alt="image_3_5"></p><p align="center">图3.5</p><p>所有的Unicode字符都可以在 <a href="https://unicode-table.com/en">这里</a> 看到。 <strong>值得注意的是，哪怕Unicode的编码空间大到用不完，却也不包含任何商标，比如Windows和Apple的注册商标等</strong>，这也是为何 文章开头只能用 winkey 来指代windows的按钮，却无法找到合适的字符。</p><h3 id="3-4-字符编码"><a href="#3-4-字符编码" class="headerlink" title="3.4 字符编码"></a>3.4 字符编码</h3><p>Unicode字符集，在概念上只是编码字符集，它本身只指定了每个数字对应哪个字符，但在计算机中，这个数字究竟存储成什么样的二进制，却没有指定一个统一的标准。Unicode字符集的字符编码方式，就是UTF(Unicode Transformation Format)系列。</p><h4 id="3-4-1-UTF-32"><a href="#3-4-1-UTF-32" class="headerlink" title="3.4.1 UTF-32"></a>3.4.1 UTF-32</h4><p>UTF-32就是用32位(也就是4个字节)来存储一个Unicode字符集中的一个字符，UTF-32的值，正好对应Unicode字符集中字符的码点(Code point)值。<br>比如：</p><ul><li>😤的码点值为 <code>128548(0x1F624)</code>，那么对应的UTF-32编码也就是 <code>0x1F624</code>，在计算机中存储的二进制形态就是： <code>00000000 00000001 11110110 00100100</code> </li><li>“梦”的码点值是 <code>0x68A6</code>，用UTF-32存储在计算机中就是： <code>00000000 00000000 01101000 10100110</code> </li><li>“S”的码点是 <code>0x0053</code>，用UTF-32存储就是： <code>00000000 00000000 00000000 01010011</code></li></ul><p> </p><p><strong>UTF-32编码在实际中是没有被使用的</strong></p><h4 id="3-4-2-UTF-16"><a href="#3-4-2-UTF-16" class="headerlink" title="3.4.2 UTF-16"></a>3.4.2 UTF-16</h4><p>相信你已经发现UTF-32的问题所在了，那就是大多数字符都不需要用到32位，最多也就是24位（3个字节），所有字符都用UTF-32编码太浪费，而且Unicode标准刚制定时，也就只有BMP范围，BMP范围的字符，两个字节就刚好够了，因此有UTF-16的编码格式。在BMP平面上的字符，其UTF-16的编码，和UTF-32一样，也就是字符对应的码点值。</p><p>比如：</p><ul><li>“梦”的码点值是 <code>0x68A6</code>，用UTF-16存储就是： <code>01101000 10100110</code></li><li>“S”的码点是 <code>0x0053</code>，用UTF-16存储就是： <code>00000000 01010011</code></li></ul><p>但是这样就出现了一个问题，那些后来追加的字符集，码点值大于 0xFFFF 的，该怎么用 UTF-16 表示呢? 比如😤。而且这种表示方法，还不能影响已有的UTF-16编码的字符数据，这可怎么办?</p><p>没办法，为了照顾很多采用UTF-16的系统、软件，Unicode规定了BMP平面中的 0xD800<del>0xDFFF 为 <strong>surrogates</strong> 字符，在图3.5中也可以看到，Unicode规定这部分码点值，不能用来表示任何字符。实际上，这部分还可被分为两部分，0xD800</del>0xDBFF，称为 high surrogates，0xDC00~0xDFFF，称为 low surrogates。</p><p>这样的话，对于一个大于0xFFFF的值，如果想用UTF-16编码，就可以用32位4个字节表示，high surrogate + low surrogate 拼成一个surrogate pair就行，这样在程序读到两个字节时，如果判断它是 surrogate，那么就认为它不是正常字符，需要和另一个surrogate拼接起来才行，组成另一个字符。例如：</p><ul><li>😤的码点值为 <code>0x1F624</code>，那么对应的UTF-16的surrogate pair也就是 <code>0xD83D + 0xDE24</code>，二进制就是： <code>11011000 01011101 11011110 00100100</code></li></ul><p><strong>不难算出，Surrogate pair总共能表示 1024*1024&#x3D;1048576&#x3D;0x100000个字符，所以UTF-16总共可以编码0x100000+0xFFFF&#x3D;0x10FFFF个字符，这也是为什么当前Unicode字符集的上限是这么大的原因，也影响了接下来我们要说的UTF-8的上限范围。</strong></p><h4 id="3-4-3-UTF-8"><a href="#3-4-3-UTF-8" class="headerlink" title="3.4.3 UTF-8"></a>3.4.3 UTF-8</h4><p>更进一步，对于英语国家的人来说，总觉得一个字节八位就足够了呀，用两位也觉得浪费空间，但对于其他国家比如中国来说，一个字节又肯定不够，这便引出了一种变长的编码格式UTF-8。引一张Wiki上的图来说明UTF-8的编码规范。</p><p><img src="/images/character_set/image_3_6.png" alt="image_3_6"></p><p align="center">图3.6</p><p>例如：</p><ul><li>“S”的码点是 <code>0x0053</code>，用UTF-8存储就是： <code>01010011</code></li><li>“µ”的码点是 <code>0x00B5</code>, 用UTF-8存储就是： <code>11000010 10110101</code></li><li>“梦”的码点值是 <code>0x68A6</code>，用UTF-8存储就是： <code>11100110 10100010 1010 0110</code></li><li>😤的码点值为 <code>0x1F624</code>，用UTF-8存储就是：<code>11110000 10011111 10011000 10100100</code></li></ul><p> </p><p>如果我们算一下四字节的UTF-8实际能表示的范围，会发现理论上应该能表示到 <code>0x1FFFFF</code> ，但是实际上却限制了上限为 <code>0x10FFFF</code> ，这就是上节所述的UTF-16的上限，既然编码空间足够大，目前看来总是够用的，那为了兼容UTF-16，就先这样规定吧。（RFC3629的标准如此规定了上限，大概就是这样想的吧）。</p><p>关于UTF-8，还有一些比较有意思的现象，比如在早期Windows中， <strong>当你在 windows 的记事本里新建一个文件，输入”联通”两个字之后，保存，关闭，然后再次打开，你会发现这两个字已经消失了，代之的是几个乱码</strong> ，这是由于GBK编码和UTF-8编码的识别错误导致的，可以动手搜一搜相应字节码分析一下，然后再看<sup id="fnref:17"><a href="#fn:17" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="infocodez. “【转载】随便说说字符集和编码.” 博客园, 27 Sept. 2017, www.cnblogs.com/infocodez/p/7600459.html. ">[17]</span></a></sup>这篇文章，验证下自己的分析是否正确。</p><h3 id="3-5-大端小端"><a href="#3-5-大端小端" class="headerlink" title="3.5 大端小端"></a>3.5 大端小端</h3><p>Danny Cohen在论文 <sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Cohen, Danny. “ON HOLY WARS AND A PLEA FOR PEACE.” IETF, 1 Apr. 1980, www.ietf.org/rfc/ien/ien137.txt. ">[13]</span></a></sup> 中提出了大端小端的说法，想要结束字节序(Endianness)的“战争”，自那以后，在程序员眼中，大端小端不再是《格列佛游记》的名词，而是字节序的专属名词了。在介绍UTF-32、UTF-16、UTF-8三种编码方式时，我们都没有考虑大端小端的问题，细心的读者可能已经意识到这个问题了，在此我们再简单介绍下。</p><blockquote><p>大端(Big Endian): 将一个多位数的高位放在较小的地址处，低位放在较大的地址处<br>小端(Little Endian): 将一个多位数的低位放在较小的地址处，高位放在较大的地址处</p></blockquote><p>直接拿Wiki上的示例说明， <code>0x0A0B0C0D</code> 这个32位的整数，大小端分别如下：</p><p><img src="/images/character_set/image_3_7_1.png" alt="image_3_7_1"> <img src="/images/character_set/image_3_7_2.png" alt="image_3_7_2"></p><p align="center">图3.7</p><p>我们还是以😤为例，在UTF-32中编码为： <code>0x0001F624</code>，大端小端分别如图。</p><p><img src="/images/character_set/image_3_8.png" alt="image_3_8"></p><p align="center">图3.8</p><p>在UTF-16中编码为： <code>0xD83DDE24</code> ，大端小端分别如图。</p><p><img src="/images/character_set/image_3_9.png" alt="image_3_9"></p><p align="center">图3.9</p><p>看到这里，屏幕前的你，是不是都自信满满地准备自己画出UTF-8的大端小端了? <strong>不过对不起，UTF-8是不需要区分大端小端的</strong>。倒回去看UTF-8的编码标准，我们会发现，UTF-8的最小处理单位是单字节，而不是像UTF-16和UTF-32的多字节。也就是说：</p><ul><li>对于UTF-32，程序需要一次读取4个字节，然后计算这四个字节的实际值，如果字节序不同，会导致结果不同</li><li>对于UTF-16，程序需要一次读取2个字节，然后计算这两个字节的实际值，如果字节序不同，结果也会不同</li><li><strong>但是对于UTF-8来说，程序一次只会读取1个字节，程序需要通过每个字节的字节头去决定是否需要继续读取下一个字节，既然一次只读取一个字节，自然不会受大小端的影响。</strong></li></ul><p> </p><p>😤用UTF-8编码是 <code>0xF09F98A4</code>，那么实际上，计算机永远会先读取 <code>F0</code> ，然后判断还需要读取接下来的三个字节，就依次读取 <code>9F</code> 、<code>98</code> 、 <code>A4</code>，然后将四个字节组合计算得出实际表示的值。计算机总共读取了四次，而不是一次读取了 4个字节。实际在计算机内存中，存储总是如图。</p><p><img src="/images/character_set/image_3_10.png" alt="image_3_10"></p><p align="center">图3.10</p><h3 id="3-6-BOM-byte-order-mark"><a href="#3-6-BOM-byte-order-mark" class="headerlink" title="3.6 BOM(byte order mark)"></a>3.6 BOM(byte order mark)</h3><p>既然字节序对计算机读取字符有很大的影响，那么对于一个文本文件，知道它实际存储的数据是大端还是小端就很重要了。为了实现这个目的，使用BOM来标记一个文本文件的开头，从而区分该文件是大端还是小端存储的。BOM本质上也还是个字符，只不过是个特殊的字符，在UTF-16的文本文件中，BOM就是 <code>0xFEFF</code> ，这时，计算机程序首先读取文本文件的前两个字节，通过判断高低地址的实际值，就可以判断是大端还是小端了。 <strong>0xFEFF这个字符实际上被称为ZERO WIDTH NO-BREAK SPACE字符，之所以用这个字符，是因为根据UTF-8编码标准，UTF-8不可能出现0xFE或者0xFF开头的字符，因此不会和UTF-8产生混淆。</strong> </p><p><img src="/images/character_set/image_3_11.png" alt="image_3_11"></p><p align="center">图3.11</p>    <p>对于UTF-32来说，虽然实际上没人用，但是字节序标准还是有的，用 <code>0x0000FEFF</code> 四个字节表示。</p><p>对于UTF-8来说，由于其自身的字节就有字节头标志，也不区分大小端，其实并不需要BOM，但是在早期Windows系统中，默认用记事本编辑时，用UTF-8保存也会默认加个BOM头，具体是 <code>0xEFBBBF</code> 。这时，实际上这个BOM并不是标志字节序的，而是标志编码方式，即该文件是用UTF-8编码的，仅此而已。</p><p>而这个BOM带来了各种巨坑的问题，不限于：</p><blockquote><ul><li>gcc会报告源码文件开头有无法识别的字符</li><li>Linux的shell脚本无法运行： <code>Shell:  #!/bin/sh: No such file or directory</code> </li><li>早期一些比较坑的教程会教人用记事本学Java，然后用 javac 编译，这时会报“错误：非法字符：blablabla”，但是却不在教程中说明这一点。（之所以记得这件事，是因为直到研究生期间还有人问过这种问题…</li><li>其他一系列知名不知名软件读取配置文件的坑…</li><li>…</li></ul></blockquote><p><strong>但是，竟然还有反向操作的，举一个自己曾经遇到的坑，知名音乐播放软件Foobar 2000，在读取 .cue 文件时，必须是 UTF-8 With BOM，曾经强迫症把所有 .cue 文件改成了 UTF-8 Without BOM，结果Foobar 2000全部无法识别…</strong> </p><p>其他还有一些不常见的BOM如下。</p><p><img src="/images/character_set/image_3_12.png" alt="image_3_12"></p><p align="center">图3.12</p><h3 id="3-7-Unicode控制字符"><a href="#3-7-Unicode控制字符" class="headerlink" title="3.7 Unicode控制字符"></a>3.7 Unicode控制字符</h3><p>上面说到了UTF-16和UTF-32用 <code>0xFEFF</code> 作为BOM字符，这个字符实际上是不可见的，主要用于标志字节序。在编码字符集中, 这种特殊码位的字符，一般可以叫做“控制字符”(Control character,Non-printable character)，即“用于控制文本解释或者显示，而不可见或不占空间的Unicode字符”。<br>而在Unicode的一般性分类中, 控制字符大多都归属于 Other(C) 这个大类. Other(C)大类下又分:</p><ul><li>Cc(Other, control), 共有65个, 而且这个数量永远都不会再变</li><li>Cf(Other, format), 共有161个, 这是Unicode 13.0中的数量, 以后可能会再变</li><li>Cs(Other, surrogate), 共有2048个, 永远都不会再变</li><li>Co(Other, private use), 共有137468个, 永远都不会再变</li><li>Cn(Other, not assigned), 还未分配的保留字符</li></ul><p>这其中, 严格意义上来说, 只有Cc是控制类型的字符, 但是广义上或者口语化中所说的控制字符, 其实也包含了格式化类型的字符, 这就包括了Cf, 以及另一个和Other(C)平行的大类 Separator(Z)中的字符.<br><strong>简单来说, 广义上将Control Type和Format Type的字符都作为控制字符来表达, 也没什么问题</strong><br>对广义上的控制字符细分如下.</p><h4 id="3-7-1-ISO-6429控制字符-C0与C1控制字符"><a href="#3-7-1-ISO-6429控制字符-C0与C1控制字符" class="headerlink" title="3.7.1 ISO 6429控制字符(C0与C1控制字符)"></a>3.7.1 ISO 6429控制字符(C0与C1控制字符)</h4><p>控制字符U+0000‐U+001F 与U+007F来自ASCII。此外，ISO 8859字符集定义了U+0080‐U+009F。二者都定义在ISO 6429中，常被称为C0与C1控制字符。</p><p>大部分这些字符在Unicode文本处理中没有明确作用。字符<code>U+0000 &lt;control-0000&gt; ，NUL、U+0009 &lt;control-0009&gt; ，HT、U+000A &lt;control-000A&gt; ，LF、U+000D &lt;control-000D&gt; ，CR、U+0085 &lt;control-0085&gt; ，NEL</code>常用于格式化字符。</p><p><strong>这65个字符就是所有Cc类别的字符</strong></p><h4 id="3-7-2-Unicode引入的分隔符"><a href="#3-7-2-Unicode引入的分隔符" class="headerlink" title="3.7.2 Unicode引入的分隔符"></a>3.7.2 Unicode引入的分隔符</h4><p>为了简化几种换行字符，Unicode引入了它自己的分隔符来格式化文本：</p><ul><li>U+2028 line separator ，HTML： <code>&amp;#8232;</code>，LSEP</li><li>U+2029 paragraph separator ，HTML： <code>&amp;#8233;</code>，PSEP</li></ul><p><strong>这就是Separator(Z)大类中仅有的两个Format Type的字符了</strong><br><strong>因此, 剩下的所有细分类别, 其实全是Cf类别的字符, 包括了开始所说的<code>0xFEFF</code></strong></p><h4 id="3-7-3-语言标记"><a href="#3-7-3-语言标记" class="headerlink" title="3.7.3 语言标记"></a>3.7.3 语言标记</h4><p>不予叙述，可参考<sup id="fnref:18"><a href="#fn:18" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. “Unicode控制字符.” Wikipedia, Wikimedia Foundation, 28 July 2020, zh.wikipedia.org/wiki/Unicode控制字符.">[18]</span></a></sup>的说明。</p><h4 id="3-7-4-行间标注"><a href="#3-7-4-行间标注" class="headerlink" title="3.7.4 行间标注"></a>3.7.4 行间标注</h4><p>3个格式化字符用于支持旁注标记（U+FFF9、U+FFFA、U+FFFB）。</p><blockquote><p>所谓旁注标记（ruby character），又称注音标示、加注音、Ruby字符、ruby或rubi，是一种表意文字的音标印刷方式，广泛地运用于日文及中文。一般这些字是放于表意文字的上方或右边，作为文字的拼音或注解。</p></blockquote><p>了解过HTML5的童鞋也许知道HTML5引入了 <code>&lt;ruby&gt;</code> 标签，也是同样的意思，（我之所以知道，是因为我的主页也用了嘛！~不过主页也是模仿前端大神的网页做的啦）</p><p><img src="/images/character_set/image_3_13.png" alt="image_3_13"></p><p align="center">图3.13</p><h4 id="3-7-5-双向文本控制"><a href="#3-7-5-双向文本控制" class="headerlink" title="3.7.5 双向文本控制"></a>3.7.5 双向文本控制</h4><p>英文、中文的印刷作品，基本都是从左向右，自上而下的，但并不是所有语言的印刷品都是如此，比如日语就是自右向左的，中国古代的书籍也是。</p><p>Unicode本身是支持从左到右、从右到左，或者其混合排版，而不需要任何特殊字符。但考虑到为了处理一些特殊情形，Unicode还是定义了12个字符<code>（U+061C、U+200E、U+200F、U+202A、U+202B、U+202C、U+202D、U+202E、U+2066、U+2067、U+2068、U+2069）</code>以帮助控制嵌入式双向文本的顺序，最大可以有125层深。</p><p>这个到底是干嘛用的，主要还是因为世界上有阿拉伯语这种存在。。。<br>比如“阿拉伯字母”这五个字的阿拉伯语写法，就是：</p><blockquote><p>أَبْجَدِيَّة عَرَبِيَّة‎</p></blockquote><p>说实话我不知道屏幕前的你看到的实际上是什么样的字符串… 对照下图看看..</p><p><img src="/images/character_set/image_3_14.png" alt="image_3_14"></p><p align="center">图3.14</p><p>而如果我在IDEA的编辑器中，赋值这行字符串为字面量，就会显示成下图，甚至影响了我的光标显示。。。</p><p><img src="/images/character_set/image_3_15.png" alt="image_3_15"></p><p align="center">图3.15</p><p>这其中，虽然那个<code>\u200E</code>的 <code>\</code> 已经位置错误，还是可以看出就是刚刚提到的Unicode定义的12个双向文本控制字符中的一个。实际上它的作用就是控制“从左至右书写标记”，而<code>\u200F</code>是“从右至左书写标记”<br>这就就是阿拉伯语的其中一个特殊之处：<strong>从右向左书写</strong>。(虽然日语、中国古籍，也都是从右向左，但只是排版概念上从右向左，而且还是竖着写的呀)。<br>阿拉伯语的这个特性带来了一个问题，如果在一行阿拉伯文字里，我写了一个英文单词，那该怎么办，nice 岂不是要显示成 ecin，于是就需要对一行文本内的某些文字再单独进行方向控制，那如果单词里再嵌套个阿拉伯字母呢，阿拉伯字母间再嵌套中文…… 如此套娃无穷尽也，因此Unicode规定了最大的嵌套深度是125层。</p><blockquote><p>笔者按: 一个阿拉伯语撑起了字符串处理Bug的半边天…</p></blockquote><h4 id="3-7-6-异体字选择器"><a href="#3-7-6-异体字选择器" class="headerlink" title="3.7.6 异体字选择器"></a>3.7.6 异体字选择器</h4><p>异体字的具体说明可参考<sup id="fnref:19"><a href="#fn:19" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. “異體字選擇器.” Wikipedia, Wikimedia Foundation, 4 Sept. 2020, zh.wikipedia.org/wiki/異體字選擇器.">[19]</span></a></sup>. 简单来说，就是一种语言中，某一个字有两种写法，但是意义完全相同，因此当初编码时，没有将其区分开，但在实际使用中，可能在用于人名等专有名词时，还是需要进行区分的，因此提供了“异体字选择器”这种控制字符。</p><h4 id="3-7-7-控制字符的图片"><a href="#3-7-7-控制字符的图片" class="headerlink" title="3.7.7 控制字符的图片"></a>3.7.7 控制字符的图片</h4><p>不予叙述。</p><h3 id="3-8-组合字符-Combining-Character"><a href="#3-8-组合字符-Combining-Character" class="headerlink" title="3.8 组合字符(Combining Character)"></a>3.8 组合字符(Combining Character)</h3><h4 id="3-8-1-组合标记-Combining-Marks"><a href="#3-8-1-组合标记-Combining-Marks" class="headerlink" title="3.8.1 组合标记(Combining Marks)"></a>3.8.1 组合标记(Combining Marks)</h4><p>上面在说控制字符时，有一类所谓的行间标记提到了“旁注标记”，在汉字上方标注拼音，可以称之为“旁注标记”。那对于某些欧洲语言来说，可以在字母上方加一些变音符号，实质上就表示成了另一个不同的字符，但它又是在原字符基础上变化的，如果每种变化都算作一个新字符，那即使是Unicode，可能也装不下这些排列组合的数量，因此出现了附加组合标记的组合字符。如Wiki的图<sup id="fnref:20"><a href="#fn:20" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. “組合字符.” Wikipedia, Wikimedia Foundation, 30 May 2019, zh.wikipedia.org/wiki/組合字符. ">[20]</span></a></sup>。</p><p><img src="/images/character_set/image_3_16.png" alt="image_3_16"></p><p align="center">图3.16</p><p>在统一码中，用于欧洲语言和国际音标的组合用附加符号为〈U+0300–U+036F〉。上图的字符 y̌ 就可以表示成： <code>\u0079\u030C</code> ， <code>\u0079</code> 就是 <code>y</code> ， <code>\u030C</code> 就是变音符号’̌。</p><p>说到这里, 不得不提的就是在中二时期网络上流行的越界文字(Zalgo text), 其本质就是对组合字符的叠加, 因为Unicode没有规定组合字符必须是实际存在的字符, 那实际上我们可以叠加变音符号, 从而使得字符越界. 如果我们组合这样一个字符”\u0079\u030C\u030C\u030C\u030C\u030C\u030C\u030C”, 实际就是:</p><blockquote><p>y̌̌̌̌̌̌̌</p></blockquote><h4 id="3-8-2-Grapheme-和-Grapheme-Cluster"><a href="#3-8-2-Grapheme-和-Grapheme-Cluster" class="headerlink" title="3.8.2 Grapheme 和 Grapheme Cluster"></a>3.8.2 Grapheme 和 Grapheme Cluster</h4><p>不过，你以为Unicode的组合字符序列到此就结束了吗? まだまだだね<br>关于组合字符序列, Unicode官网给出了一些FAQ<sup id="fnref:32"><a href="#fn:32" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Unicode Consortium. (2020, September 19). Characters and Combining Marks. Retrieved September 19, 2020, from http://unicode.org/faq/char_combmark.html">[32]</span></a></sup>. 在这些Q&amp;A中, 有一个问题:</p><blockquote><p>Q: So is a combining character sequence the same as a “character”?</p></blockquote><p>终于, 我们还是逃避不了这个问题, 究竟什么是字符? 组合字符还是传统意义上的”字符”吗? 怎么在概念上区分它们呢? 最终, 我们引入了字素(grapheme), 那个在语言学简介中提了之后, 一直没有出现的名词.</p><p>在程序员的眼中, 一个字符一般指一个Unicode的Code point, 但对于终端用户来说, 将字符等价于字素(grapheme), 是更加直观的, 字素的概念始终是不变的: <strong>a minimally distinctive unit of writing in the context of a particular writing system</strong>. 只不过之前无法具体细分字素的范围, 现在我们终于有工具能够确切描述字素的范围了.<br>在Unicode世界中, 一个字素至少包含一个Code point, 包含组合标记、控制字符等的多个组合字符序列也可作为一个字素. 这样, 至少在Unicode中, 我们将字素的最小范围限定到了一个Code point, 不会有比一个Code point范围更小的字素了!<br>事实上, Unicode引入的字素(grapheme)概念, 也可以称为用户感知字符(user-perceived character), 不仅可以在基础字符上附加组合字符, 用来形成新的字素, 也可以通过控制字符(如方向控制等)来形成新的字素.</p><p>字素的集合, 就可以统一称为 Grapheme Cluster, 或者通俗一点: user-perceived characters</p><p>So… Why? 为什么要划分这么细, 规定这么多细节, 直接认为 y̌ 就是两个字符, 不搞其他一些幺蛾子, 难道不香吗?<br>Unicode在TR29的技术报告里<sup id="fnref:30"><a href="#fn:30" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Davis, Mark, and Christopher Chapman. Unicode Text Segmentation. 19 Feb. 2020, unicode.org/reports/tr29/. ">[30]</span></a></sup>，给出了一段话:</p><blockquote><p>Grapheme cluster boundaries are important for collation, regular expressions, UI interactions, segmentation for vertical text, identification of boundaries for first-letter styling, and counting “character” positions within text. Word boundaries, line boundaries, and sentence boundaries should not occur within a grapheme cluster: in other words, a grapheme cluster should be an atomic unit with respect to the process of determining these other boundaries.</p></blockquote><p>我给大家画个重点，就是: <strong>grapheme cluster应该作为一个原子性的整体看待, 至少不能在在一个grapheme cluster中间出现换行符、单词分隔符、连字符等破坏性字符吧，那既然有这些限制，识别grapheme cluster的边界就十分有必要了, 这样才能更好的做字符排序、正则匹配、UI交互等字符串(实际上现在该叫字素串)处理工作</strong></p><blockquote><p><strong>总结一下: 可以认为字素是在Code point&#x2F;Character之上的一种更高一层的抽象.</strong></p></blockquote><p>在tr29中，还提到了三类不同的grapheme clusters: legacy grapheme clusters, extended grapheme clusters, tailored grapheme clusters. 具体的概念我也不翻译了，因为…水平不够. 就截几张图, 大概感受一下.</p><p><img src="/images/character_set/image_3_17.png" alt="image_3_17"></p><p align="center">图3.17</p><p>好的，我知道其实你根本不想看，那就略过，我们继续。</p><h4 id="3-8-3-Unicode等价-Unicode-equivalence-及正规化-Normalization"><a href="#3-8-3-Unicode等价-Unicode-equivalence-及正规化-Normalization" class="headerlink" title="3.8.3 Unicode等价(Unicode equivalence)及正规化(Normalization)"></a>3.8.3 Unicode等价(Unicode equivalence)及正规化(Normalization)</h4><p>上面说完了字素, 又引入了另一个问题, 那就是:<br>带变音的拉丁字素等，使用广泛，以及占坑较早，因此，早早地就作为一个个的单独码点在Unicode种有一个码(keng)位了，而后来Unicode又规定了组合字符，这样，同一个字素就有可能有两种编码方式。比如“Å”，既可以是 <code>\u00c5</code> ，也可以是 <code>\u0041\u030A</code> 表示，可以在<a href="https://apps.timwhitlock.info/unicode/inspect">这个网站</a> 试试。这就引入了另一个话题，Unicode equivalence和Normalization，即判断两个字符&#x2F;素串相等时，是否需要考虑这种等价情况，如果需要考虑这种意义上的等价，那么就需要对字符&#x2F;素串先进行正规化(Normalization)，再进行比较。</p><blockquote><p>正规化即将彼此等价的序列转成同一列序, Unicode提供了两种等价概念：标准等价(canonically equivalent)和兼容等价(compatible). 两者的具体概念参考<sup id="fnref:22"><a href="#fn:22" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. “Unicode Equivalence.” Wikipedia, Wikimedia Foundation, 7 Aug. 2020, en.wikipedia.org/wiki/Unicode_equivalence. ">[22]</span></a></sup>. 标准等价的一个示例就是 Å<code>\u00c5</code>和 Å<code>\u0041\u030A</code>, 兼容等价的一个示例就是 ﬀ<code>\ufb00</code> 和 ff<code>\u0066\u0066</code></p></blockquote><p>为了进行正规化, 自然会有两种想法:</p><ul><li>一种是分解(Decomposition): 即将字素串中所有单个字素分解为等价的组合字符.</li><li>一种是组合(Composition): 即将字素串中所有分解后的组合重组为单个字素.</li></ul><p>结合标准等价和兼容等价的概念, 正规形式自然可以分为四种:</p><table><thead><tr><th align="center">正规形式</th><th align="center">转换算法</th></tr></thead><tbody><tr><td align="center">NFD,Normalization Form Canonical Decomposition</td><td align="center">以标准等价方式来分解</td></tr><tr><td align="center">NFC,Normalization Form Canonical Composition</td><td align="center">以标准等价方式来分解，然后以标准等价重组之</td></tr><tr><td align="center">NFKD,Normalization Form Compatibility Decomposition</td><td align="center">以兼容等价方式来分解</td></tr><tr><td align="center">NFKC,Normalization Form Compatibility Composition</td><td align="center">以兼容等价方式来分解，然后以标准等价重组之</td></tr></tbody></table><p>好了, 等价就说到这. 以及, 后续我们还是使用字符串这个名词, 这一小段使用字素串, 主要是为了加深对字素的印象.</p><h3 id="3-9-特殊的组合字符"><a href="#3-9-特殊的组合字符" class="headerlink" title="3.9 特殊的组合字符"></a>3.9 特殊的组合字符</h3><p>在Unicode的兼容性等价示例中, 以 ﬀ<code>\ufb00</code> 为例进行了说明. 这个字符和 两个f的组合 ff<code>\u0066\u0066</code> 具体是什么关系呢?<br>实际上<code>\ufb00</code>是一个连体字&#x2F;合体字.</p><blockquote><p>在西方字体排印学中将多于一个字母合成一个字形就是连体字, 经过演变、长时间流行后，一些连体字组合就直接变成了一个单个字符, 拥有自己独立的形式了.</p></blockquote><p>说到连字, 其实和排版系统有所牵连, 就不细述概念了, 举个例子.<br>在VS Code中可以在配置中<code>&quot;editor.fontLigatures&quot;: true</code>, 这样设置之后, 如果在VS Code中连着打出&gt;和&#x3D;, 其实就会显示成≥<br>但这是编辑器自己处理的连字效果, 有没有办法强行使一些本来没有连字效果的字符组合产生连字效果, 或者强行使一些有连字效果的字符组合取消连字效果呢? 答案是肯定的. Unicode的Cf字符中, 有以下两个字符.</p><ul><li>零宽度连字符(zero-width joiner, zwj)U+200D: 用于阿拉伯文等文字中，使不会发生连字的字符间产生连字效果</li><li>零宽度断字符(zero-width non-joiner, zwnj)U+200C: 用于阿拉伯文、德文等文字中，阻止会发生连字的字符间的连字效果</li></ul><p>zwnj的例子大多都和语言相关, 阿拉伯语、德语一类的, 示例也很复杂.<br>但是zwj就很特殊, 除了阿拉伯语这种特殊语言, 还记得我们文章的开头说了什么吗? 没错, 就是 Emoji!</p><p>zwj对Emoji也有效, 本来Emoji就是个设计简单表达心情的表情符号，但随着使用越来越广泛，刮起了一阵“中立表情(Neutral Emojis)”的风，即有男性表情，那就得有对应的女性，有白种人，那就得有黄种人、黑种人，家庭可以是异性恋，那就得有同性恋，有儿子，也得有女儿。如果每种都是单独的字符表示，那Unicode可能也装不下，而且已有的Emoji也不能复用, 因此就想到了用zwj来组合相关Emoji, 形成新的Emoji。</p><p>最典型的一个例子：👨‍👨‍👦‍👦这个家庭的Emoji，实际上是由四个Emoji组合而成，表示两个爸爸和两个儿子一家： <code>\uD83D\uDC68\u200D\uD83D\DC68\u200D\D83D\DC66\u200D\D83D\uDC66</code></p><p>每个字符间用特殊字符 <code>\u200D</code>(zero width joiner) 连接起来. 总共占用了22个字节，每个表情成分是四个字节，而每个控制字符只占用两个字节。</p><h2 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h2><p>已经说了这么多，相信诸位也已经知道了emoji究竟是什么，回到文章开头前言处，微信为何能显示😤这个表情，也不言自明了。</p><p>读到这里，你长输一口气：“终于要结束了！”。抱歉，其实还没完。。。</p><p>既然emoji就是一个字符，那么在计算机程序中，对它的操作、存储，也自然是和普通字符没什么差别，本质就是字符的编码问题。那这是不是意味着，在互联网程序中，凡是可以输入字符的地方，其实也就可以输入emoji、乃至所有unicode字符呢? 最差也就是某些古老的客户端没法正确展示嘛！真是如此，还是说服务器端有必要对unicode字符做一些限制呢? 答案是肯定的，在很多情况下，的确要对字符进行限制。这样做的原因有很多，这里列举以下几个原因，进行说明。</p><h3 id="4-1-数据库不支持"><a href="#4-1-数据库不支持" class="headerlink" title="4.1 数据库不支持"></a>4.1 数据库不支持</h3><p>这主要就是MySQL的坑了，MySQL 5.5.3版本之前，设置的所谓utf-8格式，其实只支持三个字节长度的utf-8，不支持四字节长度。之后的版本才支持四字节长度，而为了兼容以前的版本，指定表结构、字段类型为utf-8，其实还是只支持三字节的utf8mb3，只有显示指定utf8mb4，才是支持四字节的utf-8.</p><p>不过这也不能把锅全甩给MySQL，谁让MySQL支持UTF-8太早了呢，根据Wiki<sup id="fnref:25"><a href="#fn:25" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. “UTF-8.” Wikipedia, Wikimedia Foundation, 20 Aug. 2020, zh.wikipedia.org/wiki/UTF-8. ">[25]</span></a></sup>所述。</p><blockquote><p>这是由于MySQL在4.1版本开始支持UTF-8编码（当时参考UTF-8草案版本为RFC 2279）时，为2003年，并且在同年9月限制了其实现的UTF-8编码的空间占用最多为3字节，而UTF-8正式形成标准化文档（RFC 3629）是其之后。限制UTF-8编码实现的编码空间占用一般被认为是考虑到数据库文件设计的兼容性和读取最优化，但实际上并没有达到目的，而且在UTF-8编码开始出现需要存入非基本多文种平面的Unicode字符（例如emoji字符）时导致无法存入（由于3字节的实现只能存入基本多文种平面内的字符）。直到2010年在5.5版本推出“utf8mb4”来代替、“utf8”重命名为“utf8mb3”并调整“utf8”为“utf8mb3”的别名，并不建议使用旧“utf8”编码，以此修正遗留问题。</p></blockquote><h3 id="4-2-打印机不支持"><a href="#4-2-打印机不支持" class="headerlink" title="4.2 打印机不支持"></a>4.2 打印机不支持</h3><p>也许你的数据库，你的程序都可以正常的存储、展示Unicode字符，但是对那些需要将字符打印出来的场景，还需要考虑打印机等硬件的限制，有些打印机并不具备打印复杂Unicode字符的能力。</p><h3 id="4-3-安全原因"><a href="#4-3-安全原因" class="headerlink" title="4.3 安全原因"></a>4.3 安全原因</h3><p>安全是个不容忽视的原因，大到苹果、腾讯，也多次在unicode字符上翻车。</p><p>列举一下我还记得的一些相关Bug：</p><ul><li><a href="https://yq.aliyun.com/articles/202488">iOS漏洞：发送短信即可令任意苹果手机重启</a> </li><li><a href="https://zhuanlan.zhihu.com/p/136328290">iOS 现重大漏洞，神秘字符可让 iPhone 死机！</a></li><li><a href="https://www.zhihu.com/question/43621727/answer/548216936">微信「你女朋友撤回了一条消息还亲了你一口」是怎么实现的（微信已经修复了这个bug）？</a></li><li><a href="https://www.sohu.com/a/289091005_120085857">“我给男神发了7条隐藏微信消息，结果他向我表白了！” </a></li></ul><p>后面两个微信的bug其实都和我们之前提到的Unicode的“双向控制字符”有关，而又因为方向控制通常用在阿拉伯语中，因此这些漏洞的利用都利用了阿拉伯字符.<br>苹果的漏洞都没有披露具体细节，原因也只能靠网友自己去猜，蛤乎上偶尔能搜到。这里给出几个链接，感兴趣可以看看. <a href="https://www.zhihu.com/question/21568134?rf=21568497">点我</a> ，<a href="https://www.zhihu.com/question/390280089">还有我</a>，<a href="https://www.guokr.com/question/496989/">还有我</a> </p><h2 id="五、字体与排版"><a href="#五、字体与排版" class="headerlink" title="五、字体与排版"></a>五、字体与排版</h2><p>回到文章开头的另一个问题，“😤这个表情真的是图片吗?”，也许你会回答，当然不是啦，现在知道了，它就是个字符，和汉字一样。一个整数就可以表示了，而图片需要用专门的图片格式，BMP、GIF或者JPG等。那么你有没有想过，你是怎么看到这个表情的呢? 不是图形眼睛怎么能看到呢?</p><p>这就要扯到字体上去了，这块不是本文重点，但还是在最后顺带一提。</p><p>虽然字符本质上几个字节就编码完成了，可以看作和整数一一对应，但是想要将这个字符渲染出来，就是另一套体系，图形学的体系。换字体强迫症者，也许在网上寻找过各种各样的字体进行尝试，下载一个 <code>.ttf</code> 文件，然后双击安装，就拥有了一种新字体。</p><p>将一个二进制代表的字符转化为人眼可见的图形，大概的流程就是这样的。</p><p><img src="/images/character_set/image_5_1.png" alt="image_5_1.png"></p><p align="center">图5.1</p><p>不过这块了解不多，也没有查阅太多资料，可能不太准确. 如有错误恳请指出。</p><p>参考<sup id="fnref:33"><a href="#fn:33" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Hosken, M., &amp; Gaultney, V. (2003, September 5). Guidelines for Writing System Support: Technical Details: Smart Rendering: Part 1. Retrieved September 20, 2020, from https://scripts.sil.org/cms/scripts/page.php?site_id=nrsi">[33]</span></a></sup>, 可以给出稍微细节点的渲染流程, 如图5.2所示.</p><p><img src="/images/character_set/image_5_2.png" alt="image_5_2.png"></p><p align="center">图5.2</p><p>还有一点就是： <strong>现有的TTF和OTF格式，单个字体文件都只能支持65535个字符，因此想要用一个字体文件涵盖所有的Unicode字符是不可能的</strong> </p><p>在计算机的文字处理领域，除了底层的编码、字体，还要考虑对字符如何进行排版，而这又是另一个复杂而又宏大的话题了<sup id="fnref:33"><a href="#fn:33" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Hosken, M., &amp; Gaultney, V. (2003, September 5). Guidelines for Writing System Support: Technical Details: Smart Rendering: Part 1. Retrieved September 20, 2020, from https://scripts.sil.org/cms/scripts/page.php?site_id=nrsi">[33]</span></a></sup>。就此打住，有机会再研究~</p><h2 id="六、Q-amp-A"><a href="#六、Q-amp-A" class="headerlink" title="六、Q&amp;A"></a>六、Q&amp;A</h2><p>好了，说了这么多理论，问几个问题，看你是否都能答对。<br>以下涉及编程语言的部分, Java 版本为 Java 11, Python 版本为 Python 3.8.2, Go 版本为 Go 1.13.8<br>主要还是以Java为主</p><h3 id="6-1-“😤”在不同的编程语言中的length是多少"><a href="#6-1-“😤”在不同的编程语言中的length是多少" class="headerlink" title="6.1 “😤”在不同的编程语言中的length是多少?"></a>6.1 “😤”在不同的编程语言中的length是多少?</h3><p>通常, 编程语言中 字符串的 length 表示了该字符串的字符数量.<br>从理论上来说, 长度应该为1, 否则会很麻烦.<br>就像早期MySQL中认为汉字是2个字符长度, 英文字母是1个字符长度, 那么编程时, 就需要程序员自己计算实际使用的长度, 防止超出varchar(n)的长度范围. 因为不方便, 而且也不符合字符的实际定义, 后续MySQL就改了.<br>但是各个编程语言又是怎么处理的呢? 是否所有语言所谓的字符就是真正的字符呢?</p><h4 id="6-1-1-Java的表现"><a href="#6-1-1-Java的表现" class="headerlink" title="6.1.1 Java的表现"></a>6.1.1 Java的表现</h4><p>先来看Java</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"😤"</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">2</span><span class="token number">2</span><span class="token number">4</span><span class="token number">128548</span><span class="token number">56868</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上, Java认为字符串的长度是2.<br>Java 8之前, Java中的String, 内部存储结构就是char数组, 每个char都是一个UTF-16字符, 所以String的长度就是UTF-16字符的数量.<br>在Java 9之后, 虽然Java的String内部存储改用了 byte 数组, 但实际目的只是为了减少字符串占用的存储空间, 并不是彻底地改变了Java String中char的定义. 通过String的<a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/lang/String.java">源码</a> 可以看到当前String中核心的几个属性是:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span> coder<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> COMPACT_STRINGS<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果COMPACT_STRINGS是false, 那么本质上和JDK 8没有区别, 每个char都是一个UTF-16, 占两个字节.<br>默认COMPACT_STRINGS是true, 此时, String的存储有两种可能的形式, 通过coder区分, coder为0时表示LATIN1, 为1时表示UTF16. LATIN1实际上就是ISO-8859-1字符集, 即如果一个String的只包含了ISO-8859-1字符集的字符, 那么coder&#x3D;0, 一个字符用一个byte存储即可, 而出现该字符集之外的字符, coder&#x3D;1, 一个字符用两个byte存储, 即UTF-16的编码方式. 查看String中的<code>coder()</code>和<code>isLatin1()</code>方法, 也可看出是COMPACT_STRINGS和coder共同决定了字符串的编码方式.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">byte</span> <span class="token function">coder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> COMPACT_STRINGS <span class="token operator">?</span> coder <span class="token operator">:</span> UTF16<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isLatin1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> COMPACT_STRINGS <span class="token operator">&amp;&amp;</span> coder <span class="token operator">==</span> LATIN1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想修改COMPACT_STRINGS的值, 可以指定JVM参数<code>-XX:-CompactStrings</code></p><p>总结一下其实就是, Java中, 如果字符串是<code>isLatin1</code>的, 那么字符串长度就是字节数, 否则, 就是字节数&#x2F;2, 至于这两个字节是否真的能表示一个字符, Java表示无所谓.<br>所以这个复杂的组合字符 👨‍👨‍👦‍👦 在Java中的length实际上就是11</p><p>可以说, 由于历史原因, Java原生的String在计算长度时, 并不是很好, 甚至可以说有点坑.</p><h4 id="6-1-2-Javascript的表现"><a href="#6-1-2-Javascript的表现" class="headerlink" title="6.1.2 Javascript的表现"></a>6.1.2 Javascript的表现</h4><p>再看下Javascript</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"😤"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">2</span><span class="token number">128548</span><span class="token number">56868</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>毕竟前面带了Java, 难怪表现基本一致…</p><h4 id="6-1-3-Python的表现"><a href="#6-1-3-Python的表现" class="headerlink" title="6.1.3 Python的表现"></a>6.1.3 Python的表现</h4><p>那Python 3上表现又是如何呢?</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">s <span class="token operator">=</span> <span class="token string">"😤"</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># print(ord(s[1]))   # 会抛异常</span><span class="token number">1</span><span class="token number">128548</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>终于有一个表现符合我们预期的编程语言了, 可喜可贺.<br>如果考虑组合字符呢?</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">combiningCharacter <span class="token operator">=</span> <span class="token string">"\u0079\u030C"</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>combiningCharacter<span class="token punctuation">)</span><span class="token punctuation">)</span>combiningCharacters <span class="token operator">=</span> <span class="token string">"👨‍👨‍👦‍👦"</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>combiningCharacters<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">2</span><span class="token number">7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以组合字符, 无论是附加组合标记的, 还是用零宽连字符连接的, 还是被认为是单个字符组成的, 统计的长度也是单个字符的数量, 即Code Point的数量</p><h4 id="6-1-4-Go的表现"><a href="#6-1-4-Go的表现" class="headerlink" title="6.1.4 Go的表现"></a>6.1.4 Go的表现</h4><p>最近风头正盛的Go语言呢?</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">s <span class="token operator">:=</span> <span class="token string">"😤"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%x "</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%+q\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token number">4</span><span class="token number">240</span>f0 9f <span class="token number">98</span> a4<span class="token string">"\U0001f624"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不科学呀, 怎么和其他语言都不一样呢?<br>直接看Go语言的一篇官方博客<sup id="fnref:31"><a href="#fn:31" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Pike, R. (2013, October 23). Strings, bytes, runes and characters in Go. Retrieved September 19, 2020, from https://blog.golang.org/strings">[31]</span></a></sup>, <a href="https://blog.golang.org/strings">Strings, bytes, runes and characters in Go</a><br>这篇博客阐述了Go中关于String的几个关键点.</p><ul><li>Go中字符串实际上就等价于一个字节流, 访问一个字符串的index位置, 得到的其实就是对应位置的字节.</li><li>Go只存储字节流, 每个字节的值, 可以随便指定, 因此理论上字节流的编码方式可以是任何编码方式. 但是特殊的是字面量(也就是直接在源码中写出来的), 字面量的值转为什么样的字节流, 实际上在书写源码的那一刻就决定了, 源码文件本身是什么编码格式的, 就对应哪种编码的字节流, 由于Go源码只允许UTF-8格式, 实际上Go的字面量对应的字节流就是UTF-8字节流.</li><li>Go没有使用字符&#x2F;character的概念, 而是使用了rune</li></ul><p>博客中也解释了这么设计的原因, 因为 字符(character) 这个概念很难定义, 考虑到组合字符等, 在 计算&#x2F;Computing 中字符的概念很容易引起歧义(也的确如此, 包括这篇文章写的也没那么严谨), 因此Go中没有使用字符这个概念, 取而代之的是rune, 一个rune实际上就等价于一个Unicode中的Code Point, 同时rune实际上就是int32的别名, 这也不难理解, 用整数表示Code Point正好.<br>至于如何迭代string中的rune, Go 提供了 <code>for range</code>语法, 博客示例:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> nihongo <span class="token operator">=</span> <span class="token string">"日本語"</span><span class="token keyword">for</span> index<span class="token punctuation">,</span> runeValue <span class="token operator">:=</span> <span class="token keyword">range</span> nihongo <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#U starts at byte position %d\n"</span><span class="token punctuation">,</span> runeValue<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>U<span class="token operator">+</span><span class="token number">65E5</span> <span class="token char">'日'</span> starts at <span class="token builtin">byte</span> position <span class="token number">0</span>U<span class="token operator">+</span>672C <span class="token char">'本'</span> starts at <span class="token builtin">byte</span> position <span class="token number">3</span>U<span class="token operator">+</span>8A9E <span class="token char">'語'</span> starts at <span class="token builtin">byte</span> position <span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们用<code>for range</code>来迭代组合字符呢?</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> combiningCharacter <span class="token operator">=</span> <span class="token string">"\u0079\u030C"</span><span class="token keyword">for</span> index<span class="token punctuation">,</span> runeValue <span class="token operator">:=</span> <span class="token keyword">range</span> combiningCharacter <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#U starts at byte position %d\n"</span><span class="token punctuation">,</span> runeValue<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> combiningCharacters <span class="token operator">=</span> <span class="token string">"😤👨‍👨‍👦‍👦"</span><span class="token keyword">for</span> index<span class="token punctuation">,</span> runeValue <span class="token operator">:=</span> <span class="token keyword">range</span> combiningCharacters <span class="token punctuation">&#123;</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#U starts at byte position %d\n"</span><span class="token punctuation">,</span> runeValue<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>U<span class="token operator">+</span><span class="token number">0079</span> <span class="token char">'y'</span> starts at <span class="token builtin">byte</span> position <span class="token number">0</span>U<span class="token operator">+</span>030C <span class="token char">'̌'</span> starts at <span class="token builtin">byte</span> position <span class="token number">1</span>U<span class="token operator">+</span>1F624 <span class="token char">'😤'</span> starts at <span class="token builtin">byte</span> position <span class="token number">0</span>U<span class="token operator">+</span>1F468 <span class="token char">'👨'</span> starts at <span class="token builtin">byte</span> position <span class="token number">4</span>U<span class="token operator">+</span>200D starts at <span class="token builtin">byte</span> position <span class="token number">8</span>U<span class="token operator">+</span>1F468 <span class="token char">'👨'</span> starts at <span class="token builtin">byte</span> position <span class="token number">11</span>U<span class="token operator">+</span>200D starts at <span class="token builtin">byte</span> position <span class="token number">15</span>U<span class="token operator">+</span>1F466 <span class="token char">'👦'</span> starts at <span class="token builtin">byte</span> position <span class="token number">18</span>U<span class="token operator">+</span>200D starts at <span class="token builtin">byte</span> position <span class="token number">22</span>U<span class="token operator">+</span>1F466 <span class="token char">'👦'</span> starts at <span class="token builtin">byte</span> position <span class="token number">25</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是和Python一样的结果.</p><p>现在还剩下一个问题, 如果我不仅仅想在<code>for range</code>中访问rune, 有什么办法直接根据索引访问吗?<br>Go给出的答案是: 语言核心部分不包含该功能, 但是可以使用库. 最常用的就是<code>unicode/utf8</code>了</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> i<span class="token punctuation">,</span> w <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>nihongo<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> w <span class="token punctuation">&#123;</span>  runeValue<span class="token punctuation">,</span> width <span class="token operator">:=</span> utf8<span class="token punctuation">.</span><span class="token function">DecodeRuneInString</span><span class="token punctuation">(</span>nihongo<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%#U starts at byte position %d\n"</span><span class="token punctuation">,</span> runeValue<span class="token punctuation">,</span> i<span class="token punctuation">)</span>  w <span class="token operator">=</span> width<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>实际上, 在Unicode的FAQ中<sup id="fnref:32"><a href="#fn:32" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Unicode Consortium. (2020, September 19). Characters and Combining Marks. Retrieved September 19, 2020, from http://unicode.org/faq/char_combmark.html">[32]</span></a></sup>, 也提到了如何统计string中的字符数量, <a href="http://unicode.org/faq/char_combmark.html#7">点我看看</a>, 其中将统计方法归纳总结成了四类: bytes,Code units,Code points,Grapheme clusters</p></blockquote><h3 id="6-2-字符串反转都如何处理"><a href="#6-2-字符串反转都如何处理" class="headerlink" title="6.2 字符串反转都如何处理?"></a>6.2 字符串反转都如何处理?</h3><p>如果只是对bytes反转, 是很简单的, 但很多情况下对终端用户来说, 反转之后的字符串还想能够正常显示的, 因此对于复杂文字来说, 需要以字素为单位切分, 而不仅仅是字符&#x2F;Code point</p><p>按照上一个问题的分析, 可以知道Java一般都是按照Code point切分字符的, 但由于用了UTF-16的编码方式, 超过两字节的Code point就会被统计成两个字符, 那么在反转字符串时, 会如何呢?</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"😤Ly̌L\uD83D\uDC68\u200D\uD83D\uDC68\u200D\uD83D\uDC66\u200D\uD83D\uDC66Ry̌R😤"</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> reverseStr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reverseStr<span class="token punctuation">)</span><span class="token punctuation">;</span>😤<span class="token class-name">Ly</span>̌<span class="token class-name">L</span>👨‍👨‍👦‍👦<span class="token class-name">Ry</span>̌<span class="token class-name">R</span>😤😤<span class="token class-name">R</span>̌yR👦‍👦‍👨‍👨<span class="token class-name">L</span>̌yL😤<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Emoji还是正常的, 会按照Code point切分, 查看源码可以很清晰的看到对Surrogate做了特殊处理. 但是对组合字符就无能为力了</p><p>Python 3应该是一样的表现.</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">s <span class="token operator">=</span> <span class="token string">"😤Ly̌L👨‍👨‍👦‍👦Ry̌R😤"</span><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>😤Ly̌L👨‍👨‍👦‍👦Ry̌R😤😤ŘyR👦‍👦‍👨‍👨ĽyL😤<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Javascript原生split再反转, 理论上应该是不行的, 测试了一下也的确不行, 使用Array.from可以解决把一个Emoji的Code point当作两个的问题, 但是对组合字符还是无效的.</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">s <span class="token operator">=</span> <span class="token string">"😤Ly̌L👨‍👨‍👦‍👦Ry̌R😤"</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span>😤Ly̌<span class="token constant">L</span>👨‍👨‍👦‍👦Ry̌<span class="token constant">R</span>😤��<span class="token constant">R</span>̌yR��‍��‍��‍��<span class="token constant">L</span>̌yL��😤<span class="token constant">R</span>̌yR👦‍👦‍👨‍👨<span class="token constant">L</span>̌yL😤<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Go还是和之前说的一样, string本质上就是字节流, 所以需要封装对字节的处理, 一个示例.</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token string">"😤Ly̌L👨‍👨‍👦‍👦Ry̌R😤"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">Reverse</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">Reverse</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>  size <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>  buf <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span>  <span class="token keyword">for</span> start <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> start <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token punctuation">&#123;</span>    r<span class="token punctuation">,</span> n <span class="token operator">:=</span> utf8<span class="token punctuation">.</span><span class="token function">DecodeRuneInString</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>start<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    start <span class="token operator">+=</span> n    utf8<span class="token punctuation">.</span><span class="token function">EncodeRune</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span>size<span class="token operator">-</span>start<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>😤Ly̌L👨‍👨‍👦‍👦Ry̌R😤😤ŘyR👦‍👦‍👨‍👨ĽyL😤<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>其实, 这个问题, 本质上还是在界定字节、Code point、字素的概念, 反转函数究竟是按照byte、Code point还是字素去处理字符串, 可以看到, 语言核心类库一般只支持到按照Code point去切分, 想要处理组合字符等特殊的字素, 需要付出更多的努力</strong></p><h3 id="6-3-怎么除去4字节编码的utf-8字符"><a href="#6-3-怎么除去4字节编码的utf-8字符" class="headerlink" title="6.3 怎么除去4字节编码的utf-8字符"></a>6.3 怎么除去4字节编码的utf-8字符</h3><p>由于历史因素, 无法修改MySQL的编码, 这时可能就需要在落库时过滤一遍字符串, 将4字节的utf-8字符去除.<br>对于严格按照Code point切分的语言, 比如python和go, 通过每个字符、rune的长度, 很容易就能判定.</p><p>对于Java这种UTF-16存储的, 我们可以利用一个很简单却很容易被忽略的事实: <strong>UTF-8编码的3字节的字符范围, 就是BMP的范围</strong>, 也就是说, 基本UTF-16范围的字符, 用UTF-8都不超过3字节, 所以只要判断一个字符是否是Surrogate, 移除所有Surrogate, 其实就可以保证不会超过UTF-8的3字节范围.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">removeSurrogate</span><span class="token punctuation">(</span><span class="token class-name">String</span> originStr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token class-name">StringBuilder</span> returnStr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> ch <span class="token operator">:</span> originStr<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Character</span><span class="token punctuation">.</span><span class="token function">isSurrogate</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      returnStr<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> returnStr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Kawasaki, Tamaki. <em>Emoji（表情符号）是如何诞生并在全世界普及的？</em>. 12 Aug. 2018, www.gov-online.go.jp/eng/publicity/book/hlj/html/201808/201808_12_ch.html.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “World Emoji Day.” <em>Wikipedia</em>, Wikimedia Foundation, 10 Aug. 2020, en.wikipedia.org/wiki/World_Emoji_Day.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">池昌海 . “语言学概论.” 浙江大学-远程教育学院, 16 Dec. 2010, 218.108.57.198/yyxgl1/.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">李玲璞. &quot;汉字学元点理论及相关问题——兼谈汉字认知的若干误区.&quot; 中国文字研究 (2004).<a href="#fnref:4" rev="footnote">↩</a></span></li><li id="fn:5"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Character Encoding.” Wikipedia, Wikimedia Foundation, 25 Aug. 2020, en.wikipedia.org/wiki/Character_encoding.<a href="#fnref:5" rev="footnote">↩</a></span></li><li id="fn:6"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Tero, Paul. “Unicode, UTF8 &amp; Character Sets: The Ultimate Guide.” Smashing Magazine, 6 June 2012, www.smashingmagazine.com/2012/06/all-about-unicode-utf8-character-sets/.<a href="#fnref:6" rev="footnote">↩</a></span></li><li id="fn:7"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Plane (Unicode).” <em>Wikipedia</em>, Wikimedia Foundation, 28 Aug. 2020, en.wikipedia.org/wiki/Plane_(Unicode).<a href="#fnref:7" rev="footnote">↩</a></span></li><li id="fn:8"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Unkown. “Unicode Character Table.” ✔️ ❤️ ★ Unicode Character Table, 6 Sept. 2020, unicode-table.com/en/.<a href="#fnref:8" rev="footnote">↩</a></span></li><li id="fn:9"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">timwhitlock. “Unicode Character Inspector.” <em>apps.timwhitlock.info</em>, 6 Sept. 2020, apps.timwhitlock.info/unicode/inspect.<a href="#fnref:9" rev="footnote">↩</a></span></li><li id="fn:10"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">10.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">纤夫张 . “其实你并不懂 Unicode.” 知乎专栏, 31 Dec. 2018, zhuanlan.zhihu.com/p/53714077.<a href="#fnref:10" rev="footnote">↩</a></span></li><li id="fn:11"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">11.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “UTF-8.” Wikipedia, Wikimedia Foundation, 5 Sept. 2020, en.wikipedia.org/wiki/UTF-8.<a href="#fnref:11" rev="footnote">↩</a></span></li><li id="fn:12"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">12.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">F. Yergeau. “UTF-8, a Transformation Format of ISO 10646.” IETF Tools, 1 Nov. 2003, tools.ietf.org/html/rfc3629.<a href="#fnref:12" rev="footnote">↩</a></span></li><li id="fn:13"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">13.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Cohen, Danny. “ON HOLY WARS AND A PLEA FOR PEACE.” IETF, 1 Apr. 1980, www.ietf.org/rfc/ien/ien137.txt.<a href="#fnref:13" rev="footnote">↩</a></span></li><li id="fn:14"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">14.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “字节序.” Wikipedia, Wikimedia Foundation, 18 Aug. 2020, zh.wikipedia.org/wiki/字节序.<a href="#fnref:14" rev="footnote">↩</a></span></li><li id="fn:15"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">15.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Unicode. “Glossary of Unicode Terms.” Glossary, 21 May 2020, unicode.org/glossary/.<a href="#fnref:15" rev="footnote">↩</a></span></li><li id="fn:16"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">16.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “位元組順序記號.” Wikipedia, Wikimedia Foundation, 30 June 2020, zh.wikipedia.org/wiki/位元組順序記號.<a href="#fnref:16" rev="footnote">↩</a></span></li><li id="fn:17"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">17.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">infocodez. “【转载】随便说说字符集和编码.” 博客园, 27 Sept. 2017, www.cnblogs.com/infocodez/p/7600459.html.<a href="#fnref:17" rev="footnote">↩</a></span></li><li id="fn:18"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">18.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Unicode控制字符.” Wikipedia, Wikimedia Foundation, 28 July 2020, zh.wikipedia.org/wiki/Unicode控制字符.<a href="#fnref:18" rev="footnote">↩</a></span></li><li id="fn:19"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">19.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “異體字選擇器.” Wikipedia, Wikimedia Foundation, 4 Sept. 2020, zh.wikipedia.org/wiki/異體字選擇器.<a href="#fnref:19" rev="footnote">↩</a></span></li><li id="fn:20"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">20.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “組合字符.” Wikipedia, Wikimedia Foundation, 30 May 2019, zh.wikipedia.org/wiki/組合字符.<a href="#fnref:20" rev="footnote">↩</a></span></li><li id="fn:21"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">21.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Zachary. “Emoji与Unicode.” Emoji与Unicode · Zablog, 18 Sept. 2017, zablog.me/2017/09/18/emoji/.<a href="#fnref:21" rev="footnote">↩</a></span></li><li id="fn:22"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">22.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Unicode Equivalence.” Wikipedia, Wikimedia Foundation, 7 Aug. 2020, en.wikipedia.org/wiki/Unicode_equivalence.<a href="#fnref:22" rev="footnote">↩</a></span></li><li id="fn:23"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">23.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">deerchao. “基本修养：字符集与编码.” 超越代码, 12 Sept. 2019, deerchao.cn/blog/posts/unicode.html.<a href="#fnref:23" rev="footnote">↩</a></span></li><li id="fn:24"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">24.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">vstinner. “Programming with Unicode.” 4. Unicode - Programming with Unicode, 23 June 2017, unicodebook.readthedocs.io/unicode.html.<a href="#fnref:24" rev="footnote">↩</a></span></li><li id="fn:25"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">25.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “UTF-8.” Wikipedia, Wikimedia Foundation, 20 Aug. 2020, zh.wikipedia.org/wiki/UTF-8.<a href="#fnref:25" rev="footnote">↩</a></span></li><li id="fn:26"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">26.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Cenalulu(卢钧轶) . “十分钟搞清字符集和字符编码.” Cenalulu's Tech Blog, 25 Jan. 2015, cenalulu.github.io/linux/character-encoding/.<a href="#fnref:26" rev="footnote">↩</a></span></li><li id="fn:27"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">27.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Unicode Font.” Wikipedia, Wikimedia Foundation, 13 July 2020, en.wikipedia.org/wiki/Unicode_font.<a href="#fnref:27" rev="footnote">↩</a></span></li><li id="fn:28"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">28.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">DrStrangeLove. “How Are Character Encodings Related to Fonts?” Super User, 15 Nov. 2011, superuser.com/questions/357530/how-are-character-encodings-related-to-fonts.<a href="#fnref:28" rev="footnote">↩</a></span></li><li id="fn:29"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">29.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Belleve. “字符编码与字体的关系是什么？.” 知乎, 27 Apr. 2015, www.zhihu.com/question/29924586.<a href="#fnref:29" rev="footnote">↩</a></span></li><li id="fn:30"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">30.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Davis, Mark, and Christopher Chapman. Unicode Text Segmentation. 19 Feb. 2020, unicode.org/reports/tr29/.<a href="#fnref:30" rev="footnote">↩</a></span></li><li id="fn:31"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">31.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Pike, R. (2013, October 23). Strings, bytes, runes and characters in Go. Retrieved September 19, 2020, from https://blog.golang.org/strings<a href="#fnref:31" rev="footnote">↩</a></span></li><li id="fn:32"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">32.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Unicode Consortium. (2020, September 19). Characters and Combining Marks. Retrieved September 19, 2020, from http://unicode.org/faq/char_combmark.html<a href="#fnref:32" rev="footnote">↩</a></span></li><li id="fn:33"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">33.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Hosken, M., &amp; Gaultney, V. (2003, September 5). Guidelines for Writing System Support: Technical Details: Smart Rendering: Part 1. Retrieved September 20, 2020, from https://scripts.sil.org/cms/scripts/page.php?site_id=nrsi<a href="#fnref:33" rev="footnote">↩</a></span></li><li id="fn:34"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">34.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Unicode Consortium. (2002, October 28). A General Method for Rendering Combining Marks. Retrieved September 20, 2020, from http://www.unicode.org/notes/tn2/<a href="#fnref:34" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;在和朋友聊天时，突然无话可说，屏幕前的你该如何是好呢? 很多时候屏幕前的我们，都会想到发个表情，然后彼此心照不宣地沉默。如果你用的是windows 10的新版本，按下 &lt;code&gt;winkey + period&lt;/code&gt; （即windows图标和英文句点按钮），就会有如下的弹出框。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/character_set/image_1_1.png&quot; alt=&quot;image_1_1.png&quot;&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图1.1&lt;/p&gt;

&lt;p&gt;反复斟酌、几度纠结之后，你选择了这样一个表情：😤。将鼠标停留在这个表情上几秒，可以看到提示文字：“傲慢”。如果你用的是andriod、ios，在输入法中仔细搜寻，一定也可以发现这样一个表情。&lt;/p&gt;
&lt;p&gt;如果哪里都找不到，也没关系，直接将这个表情复制，粘贴到微信聊天框中，回车，成功地将这个表情发了出去。在对方沉默不语的时间里，你点开了微信对话框里的表情，却发现怎么也找不着这个傲慢的表情?！但是这个表情的确正确地显示了呀?这是怎么回事呢?“微信连不存在的表情都支持，太厉害了叭！”也许你会发出这样的感慨。也有可能你会嗤之以鼻：“不过是显示了一张图片而已”。不过，这真的是图片吗? 且听我缓缓道来。&lt;/p&gt;</summary>
    
    
    
    <category term="techonology" scheme="https://blog.xuwei.fun/categories/techonology/"/>
    
    <category term="cs" scheme="https://blog.xuwei.fun/categories/techonology/cs/"/>
    
    
    <category term="character set" scheme="https://blog.xuwei.fun/tags/character-set/"/>
    
    <category term="encode" scheme="https://blog.xuwei.fun/tags/encode/"/>
    
    <category term="emoji" scheme="https://blog.xuwei.fun/tags/emoji/"/>
    
  </entry>
  
  <entry>
    <title>日语学习第十一讲</title>
    <link href="https://blog.xuwei.fun/2020/05/04/japanese12/"/>
    <id>https://blog.xuwei.fun/2020/05/04/japanese12/</id>
    <published>2020-05-04T10:08:23.000Z</published>
    <updated>2021-03-07T12:23:01.611Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇介绍了一些实用表达，这一篇聊几句语篇。<br>语篇是在读这本语法教程<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.">[1]</span></a></sup>中了解到的，想想也的确有道理，学习了音素、书写，记忆了单词，学会了语法，知道如何去表达一句话，总还有比一句话更广一点的语法概念的.<br>语篇的概念在该书<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="关春园, 徐宏亮. 多元化视角下的日语研究. 新华出版社, 2015.">[2]</span></a></sup>中也有描述:</p><blockquote><p>普通语言学认为，语言的结构单位自上而下分为五级，即: 词素、词、词组、句子以及大于句子的语言单位。语篇是大于句子的语言单位。在特定语境中，一个句子也可以视为语篇.</p></blockquote><p>专业的日语研究者想要看学术性的语篇研究，这篇”现代日语语篇研究”<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="杜静波. 现代日语语篇研究. Diss.">[3]</span></a></sup>的论文应该值得一看.</p><p>只不过，姑且认为语篇就是文章的一部分的话，那么分析文章、写文章的难点，其实不在于语言本身，无论是中文、英语还是日语，想要写出好文章，逻辑、思想才是最难的~</p><span id="more"></span><h2 id="1-语篇连贯"><a href="#1-语篇连贯" class="headerlink" title="1. 语篇连贯"></a>1. 语篇连贯</h2><p>语篇连贯即:</p><ul><li>语篇内部各部分在意义上是相互联系的</li><li>语篇的衔接形成的语义网络形成一个语义整体</li><li>语篇必须适合情景语境, 在语境中有适当的功能</li></ul><p>日语研究<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="关春园, 徐宏亮. 多元化视角下的日语研究. 新华出版社, 2015.">[2]</span></a></sup>中总结出的语篇连贯概念的四个基本特点有:</p><ul><li>整体性</li><li>分级性</li><li>连接性</li><li>功能性</li></ul><h2 id="2-语篇内部衔接的手段"><a href="#2-语篇内部衔接的手段" class="headerlink" title="2. 语篇内部衔接的手段"></a>2. 语篇内部衔接的手段</h2><p>一般来说有: 指示与词汇衔接、预设、替代与省略、会话含义、话语分析等…<br>学术性的东西，就不搬运太多了~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章提及了下语篇，至此，日语学习系列的主框架也就完结了。剩下的，就是练习、练习、再练习了，直到不用再思考语法这件事.</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">关春园, 徐宏亮. 多元化视角下的日语研究. 新华出版社, 2015.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">杜静波. 现代日语语篇研究. Diss.<a href="#fnref:3" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇介绍了一些实用表达，这一篇聊几句语篇。&lt;br&gt;语篇是在读这本语法教程&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;中了解到的，想想也的确有道理，学习了音素、书写，记忆了单词，学会了语法，知道如何去表达一句话，总还有比一句话更广一点的语法概念的.&lt;br&gt;语篇的概念在该书&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;关春园, 徐宏亮. 多元化视角下的日语研究. 新华出版社, 2015.
&quot;&gt;[2]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;中也有描述:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;普通语言学认为，语言的结构单位自上而下分为五级，即: 词素、词、词组、句子以及大于句子的语言单位。语篇是大于句子的语言单位。在特定语境中，一个句子也可以视为语篇.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;专业的日语研究者想要看学术性的语篇研究，这篇”现代日语语篇研究”&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;杜静波. 现代日语语篇研究. Diss.&quot;&gt;[3]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;的论文应该值得一看.&lt;/p&gt;
&lt;p&gt;只不过，姑且认为语篇就是文章的一部分的话，那么分析文章、写文章的难点，其实不在于语言本身，无论是中文、英语还是日语，想要写出好文章，逻辑、思想才是最难的~&lt;/p&gt;</summary>
    
    
    
    <category term="humanities" scheme="https://blog.xuwei.fun/categories/humanities/"/>
    
    <category term="languages" scheme="https://blog.xuwei.fun/categories/humanities/languages/"/>
    
    
    <category term="japanese" scheme="https://blog.xuwei.fun/tags/japanese/"/>
    
  </entry>
  
  <entry>
    <title>日语学习第十讲</title>
    <link href="https://blog.xuwei.fun/2020/05/03/japanese11/"/>
    <id>https://blog.xuwei.fun/2020/05/03/japanese11/</id>
    <published>2020-05-03T10:58:09.000Z</published>
    <updated>2021-03-07T12:23:07.897Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇总结了日语句子的分析和改造，这一章主要介绍一些实用表达。<br>实用表达，实际上也就是一些常用助词和动词的学习，包括他们常用的变形形式. 其实也可以说就是惯用语啦. 这一篇很多都是来源于Tae Kim的教程，Tae Kim的教程中语法系统和惯用表达揉在了一起，这里将其讲解惯用表达摘了出来.</p><span id="more"></span><h2 id="1-授受表达"><a href="#1-授受表达" class="headerlink" title="1. 授受表达"></a>1. 授受表达</h2><p>参考了这两篇文章: 文章一<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="“日语语法：授受动词.” 日语语法：授受动词 - 日语入门 - 丫丫日语, 4 Jan. 2015, http://www.yayajp.com/index.php?a=shows&catid=4&id=136.">[1]</span></a></sup>、文章二<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="KIM, TAE. “授受动词.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/favors.html.">[2]</span></a></sup><br>所谓授受表达，即授予和接受，由于在日语文化中，长幼尊卑是非常重要的元素，因此授予的主体不同时，表达也各不相同。</p><h3 id="1-1-やる、あげる、さしあげる"><a href="#1-1-やる、あげる、さしあげる" class="headerlink" title="1.1 やる、あげる、さしあげる"></a>1.1 やる、あげる、さしあげる</h3><p>表示说话者一方给另一方东西时，常用到这三个词.<br>其中:</p><ul><li>「やる」用于上对下或关系密切的同辈之间或者为动植物做某事</li><li>「あげる」用于对等关系</li><li>「さしあげる」是敬语动词，用于下对上，是一种自谦表达。</li></ul><p>例句:</p><ul><li>犬に餌をやった？</li><li>花に水をやる</li><li>あなたは時には妹さんにおこづかいをあげますか</li><li>彼の誕生日に贈り物をあげたいんnです</li><li>恩師に記念品をさしあげます</li></ul><h3 id="1-2-もらう、いただく"><a href="#1-2-もらう、いただく" class="headerlink" title="1.2 もらう、いただく"></a>1.2 もらう、いただく</h3><h4 id="1-2-1-独立使用"><a href="#1-2-1-独立使用" class="headerlink" title="1.2.1 独立使用"></a>1.2.1 独立使用</h4><p>作为一个独立的动词使用时，表示从别人那里接受或得到某东西。「いただく」表示从上司或者长辈处领受某物品时。</p><ul><li>手紙をもらう</li><li>この時計は田中さんからもらったのです</li><li>結構な品物をいただきます</li></ul><h4 id="1-2-2-助词使用"><a href="#1-2-2-助词使用" class="headerlink" title="1.2.2 助词使用"></a>1.2.2 助词使用</h4><p>接在动词连用形之后，以「～てもらう」、「～ていただく」的形式作为补助动词来使用。「～ていただく」是「～てもらう」的谦逊表达。</p><ul><li>私は日本の友達に日本料理を教えてもらった</li></ul><h3 id="1-3-くれる、くださる"><a href="#1-3-くれる、くださる" class="headerlink" title="1.3 くれる、くださる"></a>1.3 くれる、くださる</h3><h4 id="1-3-1-独立使用"><a href="#1-3-1-独立使用" class="headerlink" title="1.3.1 独立使用"></a>1.3.1 独立使用</h4><p>作为一个独立的动词使用时，表示别人给自己或给属于自己一方的人予东西。「くださる」是「くれる」的敬语形式。</p><ul><li>これは友達が妹にくれた本です。</li><li>先生は私に日本の地図をくださいました。</li></ul><h4 id="1-3-2-助词使用"><a href="#1-3-2-助词使用" class="headerlink" title="1.3.2 助词使用"></a>1.3.2 助词使用</h4><p>接在动词连用形之后，以「～てくれる」、「～てくださる」的形式作为补助动词来使用。</p><ul><li>課長がこの地図を貸してくださいました。</li></ul><h3 id="1-4-表达请求"><a href="#1-4-表达请求" class="headerlink" title="1.4 表达请求"></a>1.4 表达请求</h3><h4 id="1-4-1-请求对方帮忙做什么"><a href="#1-4-1-请求对方帮忙做什么" class="headerlink" title="1.4.1 请求对方帮忙做什么"></a>1.4.1 请求对方帮忙做什么</h4><p>用くれる、もらえる表示想请人帮忙，其中「もらえる」是「もらう」的可能型</p><ul><li>千円を貸してくれる？</li><li>千円を貸してもらえる？</li></ul><h4 id="1-4-2-请对方不要作什么"><a href="#1-4-2-请对方不要作什么" class="headerlink" title="1.4.2 请对方不要作什么"></a>1.4.2 请对方不要作什么</h4><p>只要把「で」加到用言否定式后面就可以了。</p><ul><li>全部食べないでくれますか</li><li>高い物を買わないでくれる</li></ul><h3 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h3><p>Tae Kim<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="KIM, TAE. “授受动词.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/favors.html.">[2]</span></a></sup>总结得很好: “从说话者的角度来看，所有给出的东西都是「向上」的，而别人给自己的东西则是「向下」的”，你也可以理解为对方总是高高在上的，说话者一方总是需要尽量表达谦卑，以表示尊敬对方，除非对方足够亲密或者非人等.<br>特别需要说明的是”说话人”，说话者在说出一句话时，总是代表了某一方，无论是他自己还是他人，他意指何方，那么那一方就是谦卑的一方.<br>最后再给个用了多种表达的一个例句:</p><ul><li>突然にかような奇怪な手紙を差し上げる非礼をお許し下さい。</li></ul><h2 id="2-比较表达"><a href="#2-比较表达" class="headerlink" title="2. 比较表达"></a>2. 比较表达</h2><p>又是Tae Kim<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Kim, Tae. “运用「方」和「よる」.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/comparison.html.">[3]</span></a></sup>，这个系列的教程写的确实太好，就拿来主义了，当然还有Wasabi的这个系列<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Admin, Wasabi. “Japanese Comparison: より, ...の方が, and ...で一番.” Wasabi, 24 Sept. 2016, https://www.wasabi-jpn.com/japanese-grammar/japanese-comparison/.">[4]</span></a></sup>，也非常棒.<br>表达比较首先需要有比较的对象: A和B. 当我们想对这两个对象进行比较时，从汉语的角度，我们会说:</p><ul><li>“A比B更…「述語」”</li><li>“和B相比, A更…「述語」”</li><li>“A这样&#x2F;A这一方&#x2F;A这种情况 比 B更…「述語」”</li><li>“和B相比, A这样&#x2F;A这一方&#x2F;A这种情况 更…「述語」”</li></ul><p>我们会发现这些句子中，无论怎么表达，A才是主语，B是作为被比较的一方存在的.<br>考虑到日语和汉语一样基本什么语法成分也都能省略，其实A、B两方也都有可能在表达中被省略. 基于此，我们来看下面的语法。</p><h3 id="2-1-「方」"><a href="#2-1-「方」" class="headerlink" title="2.1 「方」"></a>2.1 「方」</h3><p>「方」就是用来表达 “A这样&#x2F;A这一方&#x2F;A这种情况” 的 “这样&#x2F;这一方&#x2F;这种情况”，通常在句子中都是用「Aの方」，假设上下文明确的情况下，我们省略了B，给出一些例句.</p><ul><li>ボブの方が年上です</li><li>学生じゃない方がいいよ</li></ul><h3 id="2-2-「より」"><a href="#2-2-「より」" class="headerlink" title="2.2 「より」"></a>2.2 「より」</h3><p>相对的，「より」就是用来表达 “与B相比” 中的 “与…相比” 的意思. 同样的，假设可以省略A，给出一些例句.</p><ul><li>仕事がないよりましだよ</li></ul><p>如果把双方都用上，当然也可.</p><ul><li>辛からい方ほうが甘あまいのより好すき</li></ul><p>注:</p><blockquote><ol><li><strong>被「より」粘黏的单词不需要任何时态。</strong></li><li>可以将「より」与疑问词例如「誰」、「何」或「どこ」合用来表示与其他人或其他东西相比最高的意思</li></ol><ul><li>この仕事は誰よりも早くできます</li></ul></blockquote><h3 id="2-3-「と同じくらい」"><a href="#2-3-「と同じくらい」" class="headerlink" title="2.3 「と同じくらい」"></a>2.3 「と同じくらい」</h3><p>这个短语可以用来表达 “A就像和B一样” 这种意思</p><ul><li>小野さんは森さんと同じくらい林檎が好すきです</li></ul><h3 id="2-4-「一番」-x2F-「最も」"><a href="#2-4-「一番」-x2F-「最も」" class="headerlink" title="2.4 「一番」&#x2F;「最も」"></a>2.4 「一番」&#x2F;「最も」</h3><p>这个词用来表达最高级的意思，后者比前者更正式.</p><ul><li>中国は世界で一番人口が多いです</li><li>中国は世界で最も人口が多いです</li></ul><h3 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h3><p>比较的表达并不难，明确比较双方，使用关键的两个词: 「方」和「よる」，就很容易表达</p><h2 id="3-引用表达"><a href="#3-引用表达" class="headerlink" title="3. 引用表达"></a>3. 引用表达</h2><p>这其实是复合句的一种形式，但是引用他人的话这种复合句比较特殊，在之前的复合句中也没有提及，在此补充。<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Kim, Tae. “将关系从句作为宾语.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/actionclause.html.">[5]</span></a></sup></p><h3 id="3-1-直接引用"><a href="#3-1-直接引用" class="headerlink" title="3.1 直接引用"></a>3.1 直接引用</h3><p>直接引用别人的话，最特殊的点在于，虽然是复合的句子，但是被引用的话，其语法表达、时体态，全都保持原封不动就行了，在英语中，直接给引用的句子加个引号就行，中文多了个冒号，共同点就是都是靠标点符号来区分的，而在日语中，额外多了个助词「と」来表达这种情况.</p><ul><li>「今日は授業がない」と先生から聞いたんだけど</li></ul><h3 id="3-2-转述引用"><a href="#3-2-转述引用" class="headerlink" title="3.2 转述引用"></a>3.2 转述引用</h3><p>转述不是逐字逐句的引用，所以不用加引号。和动词「思う」一起用还能用来表达想法，意为”你认为…”，或者和动词「考える」一起用表达你在考虑某事。</p><ul><li>先生から今日は授業がないと聞いたんだけど</li><li>私は、アリスと言います</li><li>レーを食べようと思ったけど、食べる時間がなかった。</li></ul><p>注:</p><blockquote><p><strong>转述引用中，如果所引用的关系从句是名词或者な形容词形成的状态表示的话，必须显式加上表陈述的「だ」</strong></p><ul><li>これは何だと言いましたか。  &#x2F;&#x2F;（他）说这是什么?</li><li>何と言いましたか。          &#x2F;&#x2F;（他）说什么？</li></ul></blockquote><h3 id="3-3-口语版本"><a href="#3-3-口语版本" class="headerlink" title="3.3 口语版本"></a>3.3 口语版本</h3><p>「と」在口语中经常换成「って」来表达，用这种口语版本，可以省略句子的其他部分，靠上下文让对方理解.</p><ul><li>もうお金がないって。</li></ul><p>注: <strong>日常对话中，「って」 还可以用来谈论其他任何事情，大多数时候它是用来代替「は」以提出一个新的话题。</strong></p><ul><li>明日って、雨が降るんだって。</li></ul><h2 id="4-相似性表达"><a href="#4-相似性表达" class="headerlink" title="4. 相似性表达"></a>4. 相似性表达</h2><p>这个Tae Kim已经写得很好了，参考这篇文章<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Kim, Tae. “相似性或传闻.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/similarity.html.">[6]</span></a></sup>即可.<br>介绍了「よう（様）」、「みたい」、「～そう」、「～そうだ」、「～らしい」、「っぽい」六种表达方式，经常看动画其实读起来就有很熟悉的感觉，重点关注其中的活用变化，不赘述.</p><h2 id="5-被覆盖表达"><a href="#5-被覆盖表达" class="headerlink" title="5. 被覆盖表达"></a>5. 被覆盖表达</h2><p>参考Tae Kim的这一节<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Kim, Tae. “被某物所覆盖.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/covered.html.">[7]</span></a></sup>，主要介绍了「だらけ」、「まみれ」、「ずくめ」</p><h2 id="6-意向表达"><a href="#6-意向表达" class="headerlink" title="6. 意向表达"></a>6. 意向表达</h2><p>参考Tae Kim的这一节<sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Kim, Tae. “希望和建议.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/desire.html.">[8]</span></a></sup>和这一节<sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Kim, Tae. “高级意向形.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/volitional2.html.">[9]</span></a></sup>，主要介绍了「たい」、「欲しい」、意向形，以及一些高级用法</p><h2 id="7-常用句型"><a href="#7-常用句型" class="headerlink" title="7. 常用句型"></a>7. 常用句型</h2><p>还有一些其他常用句型，在此列举一些.</p><blockquote><ul><li>～以外の何ものでもない</li><li>～か[否(いな)]か</li><li>～限りだ</li><li>～かたがた</li><li>～ずじまいだ</li></ul></blockquote><h2 id="8-常用短语"><a href="#8-常用短语" class="headerlink" title="8. 常用短语"></a>8. 常用短语</h2><p>有一些常用短语，如果去分析它们的词源或者语法结构的话，会觉得很别扭，像背单词一样把它们背下来，能够做到熟练到张口就来就好了~</p><blockquote><ul><li>こちらこそ</li><li>よろしくお願いします</li><li>いらっしゃいませ</li><li>いただきます</li></ul></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章主要介绍了日语中的一些实用表达，下一篇简单说几句语篇的内容，整个系列也就结束了。</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">“日语语法：授受动词.” 日语语法：授受动词 - 日语入门 - 丫丫日语, 4 Jan. 2015, http://www.yayajp.com/index.php?a=shows&amp;catid=4&amp;id=136.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">KIM, TAE. “授受动词.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/favors.html.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Kim, Tae. “运用「方」和「よる」.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/comparison.html.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Admin, Wasabi. “Japanese Comparison: より, ...の方が, and ...で一番.” Wasabi, 24 Sept. 2016, https://www.wasabi-jpn.com/japanese-grammar/japanese-comparison/.<a href="#fnref:4" rev="footnote">↩</a></span></li><li id="fn:5"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Kim, Tae. “将关系从句作为宾语.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/actionclause.html.<a href="#fnref:5" rev="footnote">↩</a></span></li><li id="fn:6"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Kim, Tae. “相似性或传闻.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/similarity.html.<a href="#fnref:6" rev="footnote">↩</a></span></li><li id="fn:7"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Kim, Tae. “被某物所覆盖.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/covered.html.<a href="#fnref:7" rev="footnote">↩</a></span></li><li id="fn:8"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">8.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Kim, Tae. “希望和建议.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/desire.html.<a href="#fnref:8" rev="footnote">↩</a></span></li><li id="fn:9"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">9.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Kim, Tae. “高级意向形.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/volitional2.html.<a href="#fnref:9" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇总结了日语句子的分析和改造，这一章主要介绍一些实用表达。&lt;br&gt;实用表达，实际上也就是一些常用助词和动词的学习，包括他们常用的变形形式. 其实也可以说就是惯用语啦. 这一篇很多都是来源于Tae Kim的教程，Tae Kim的教程中语法系统和惯用表达揉在了一起，这里将其讲解惯用表达摘了出来.&lt;/p&gt;</summary>
    
    
    
    <category term="humanities" scheme="https://blog.xuwei.fun/categories/humanities/"/>
    
    <category term="languages" scheme="https://blog.xuwei.fun/categories/humanities/languages/"/>
    
    
    <category term="japanese" scheme="https://blog.xuwei.fun/tags/japanese/"/>
    
  </entry>
  
  <entry>
    <title>日语学习第九讲</title>
    <link href="https://blog.xuwei.fun/2020/05/02/japanese10/"/>
    <id>https://blog.xuwei.fun/2020/05/02/japanese10/</id>
    <published>2020-05-02T11:29:53.000Z</published>
    <updated>2021-03-07T12:23:13.130Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>距离上一次写日语学习系列已经快两年了，这两年间日语水平并没有什么长进，甚至还在倒退，但却总有一个心结，想要将这个系列完成。<br>好了，话不多说，其实之前的文章内容已经基本涵盖了日语基础语法的各个方面，而这篇文章打算说说日语中一个句子的分析和改造顺序，也算是对前面内容的一个总结。<br>日语的变形，主要体现在用言(动词&#x2F;形容词&#x2F;形容动词)、助动词上，这其中又属动词最为复杂。</p><span id="more"></span><h2 id="1-分析顺序"><a href="#1-分析顺序" class="headerlink" title="1. 分析顺序"></a>1. 分析顺序</h2><h3 id="1-1-说明"><a href="#1-1-说明" class="headerlink" title="1.1 说明"></a>1.1 说明</h3><p>给出一句日语，我们如何分析它用了哪些语法结构呢？</p><ol><li>如果这个句子是由多个句子复合而成的句子，首先将句子拆分，按照2至6的步骤分析单个从句，分析完从句后，将从句看作整个句子的一个成分，用符号代替，再按照2至6的步骤分析主句。需要注意的是，语气和敬意通常都是在主句中表达的，所以从句也不太可能需要分析2和3，还有一点是，如果从句本身是经过活用变形的(如假定型的活用)，先将这种变形去除.</li><li>在讲解语气的文章中提到了语气的种种分类，但实际中，语气大多还是通过特定词语、附加助词和语调的变化来表达的，因此即使一个句子用到了特定的语气，也不会在句子形式上有大的变化，最常见的也只是添加了句尾助词，可以先将助词去掉，简化句子，再做分析.</li><li>之后我们需要区分的是这句话是否是敬语形式，敬语的形式很容易看出来，因此如果用了敬语，那么先将这个句子还原为普通形式.</li><li>在还原为普通形式后，可以继续分析该句是否用到了特殊的”体”，如「ている」这种表示持续体的特殊形式，如果有的话，将特殊的”体”去掉，再次简化句子.</li><li>已经去掉了”体”的变形，之后就是分析简化的句子中，是否还用到了特殊的语态，如果用到了语态，就将其变化形式还原.</li><li>经过以上还原后，剩下的句子就只剩下时和极性的变形了，而时和极性我们通常都是放在一起记忆的，所以也可以一次性将其还原为基本型. 如果硬要分一个顺序，应该是先还原时，再还原极性.</li></ol><h3 id="1-2-示例"><a href="#1-2-示例" class="headerlink" title="1.2 示例"></a>1.2 示例</h3><p>写了这么多，给出几个句子我们分析一下。</p><ol><li><p>人は褒められれば嬉しいものなのです<br>这个句子首先是一个复合句，那么先分析从句: 「人は褒められれば」<br>由于用了假定型，将其还原为 「人は褒められる」<br>可以看出现在这种形式，是用了被动态的，将其还原为「人は褒める」<br>这样从句就分析完毕了，接着分析主句「嬉しいものなのです」<br>可以看出主句只用了敬语的一种比较特殊的形式「な+のです」，直接简化为「嬉しいものだ」</p></li><li><p>勉強をさせられている生徒に教えることは、ザルに水を注ぎ続けるようなもの！<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="“消えた記事？　「勉強する」「させられる」.” 勉強が楽しくなる塾, 5 June 2015, https://shou3.ti-da.net/e7625869.html.">[1]</span></a></sup><br>这个句子也是一个复句，可以当作包孕句处理吧。<br>首先分析前半句，「勉強をさせられている生徒に教えることは」，<br>去掉从句的连接词，句子可以简化为「勉強をさせられている生徒に教える」.<br>而这个从句中还有一个定语从句「勉強をさせられている」，这个句子用了「ている」的”体”表示一种持续的状态，简化后变为「勉強をさせられる」<br>而「勉強をさせられる」又是典型的被役态，还原成最基本的形式就是「勉強をする」<br>这样就可以理解前半句的意思了: “教一直被逼着学习的学生这种事”.<br>再分析后半句，「ザルに水を注ぎ続けるようなもの」，后半句没有用到特殊的变形，只是用了「ようなもの」这种惯用语，表示”像xx一样”</p></li></ol><h2 id="2-改造顺序"><a href="#2-改造顺序" class="headerlink" title="2. 改造顺序"></a>2. 改造顺序</h2><h3 id="2-1-说明"><a href="#2-1-说明" class="headerlink" title="2.1 说明"></a>2.1 说明</h3><p>给定一个句子，如何去分析已经了解了。那在实际语境下，假设我们从最基础的形式出发，需要以什么样的顺序来对这个句子进行变形，从而达到我们想要表达的意思呢？ 其实就是把分析的过程倒过来就行.</p><ol><li>先明确句子的极性和时</li><li>再思考这句话的主体、情态，是否需要用到特殊的语态</li><li>考虑语境下是否有特殊的时间状态，即是否要用到体的变形</li><li>是否需要用敬体，如果需要用敬体的时和体替换原有的时和体</li><li>如果需要特殊语气，就通过助词和语调调整</li><li>单句无法表达时，通过组合句子来表达</li></ol><h3 id="2-2-示例"><a href="#2-2-示例" class="headerlink" title="2.2 示例"></a>2.2 示例</h3><p>平时在看剧时，多分析看到的复杂句是怎么构成的，如果是自己来表达同样的意思，会怎么表达，这样就好啦，具体的示例就不给了，意义也不大~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分析的目的，和语文、英语的拆解句子结构一样，就是熟悉语法。<br>改造的目的，和语文、英语中的造句一样，就是正确熟练地表达。<br>等到不拘于此，不再需要思考如何去理解、如何去说，直接就能阅读和表达时，也就是真正掌握日语语法的时候.<br>本篇文章主要总结了日语中句子的分析和改造顺序，下一篇将介绍日语中的一些实用表达。</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">“消えた記事？　「勉強する」「させられる」.” 勉強が楽しくなる塾, 5 June 2015, https://shou3.ti-da.net/e7625869.html.<a href="#fnref:1" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;距离上一次写日语学习系列已经快两年了，这两年间日语水平并没有什么长进，甚至还在倒退，但却总有一个心结，想要将这个系列完成。&lt;br&gt;好了，话不多说，其实之前的文章内容已经基本涵盖了日语基础语法的各个方面，而这篇文章打算说说日语中一个句子的分析和改造顺序，也算是对前面内容的一个总结。&lt;br&gt;日语的变形，主要体现在用言(动词&amp;#x2F;形容词&amp;#x2F;形容动词)、助动词上，这其中又属动词最为复杂。&lt;/p&gt;</summary>
    
    
    
    <category term="humanities" scheme="https://blog.xuwei.fun/categories/humanities/"/>
    
    <category term="languages" scheme="https://blog.xuwei.fun/categories/humanities/languages/"/>
    
    
    <category term="japanese" scheme="https://blog.xuwei.fun/tags/japanese/"/>
    
  </entry>
  
  <entry>
    <title>Metaheuristic algorithm —— Concept</title>
    <link href="https://blog.xuwei.fun/2018/11/19/metaheuristicAlgorithm01/"/>
    <id>https://blog.xuwei.fun/2018/11/19/metaheuristicAlgorithm01/</id>
    <published>2018-11-19T13:21:09.000Z</published>
    <updated>2019-05-25T08:06:54.900Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Kino的课题常需要用到元启发式算法，就在此稍稍总结。<br>元启发式(metaheuristic)，很多时候也被称为智能优化(intelligent optimization)、现代启发式(Modern Heuristic)、智能计算(Intelligent Computation)、自然计算(Natural Computation)等，细分到具体算法有<em>遗传算法</em>、<em>粒子群算法</em>、<em>差分进化算法</em>、<em>蚁群算法</em>等。<br>**元启发式(metaheuristic)*<em>这个词本身可以拆成两部分来看，</em>元(meta)<em>和</em>启发式(heuristic)*，本文主要从这两方面来阐述元启发式的概念，后续文章再介绍各算法的原理、步骤、代码等。</p><span id="more"></span><h3 id="1-Meta"><a href="#1-Meta" class="headerlink" title="1. Meta"></a>1. Meta</h3><p>首先来解释<em>元(meta)<em>，程序员对这个词并不陌生，学习编程语言到某个阶段总会出来一个</em>元编程(metaprogramming)<em>技术，还会经常见到</em>元数据(metadata)<em>等。与顾名思义的一些概念相比，</em>元</em>的概念就有点晦涩了，初次遇见总是一脸诧异，难以理解。<br>感性上来看，<strong>metaXXX</strong>就是相比XXX来说更高级的一种概念&#x2F;理论，是研究超越XXX的存在，玄之又玄，不能理解不是你的错，就像形而上学(metaphysics)一样难以理解。<br>而不去探讨<strong>meta</strong>哲学性质的意义，只考虑其作为前缀(prefix)的情况，根据<em>meta</em>在Wikipedia的相应词条<a href="https://en.wikipedia.org/wiki/Meta">Meta</a><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. (2018, November 12). Meta. Retrieved from https://en.wikipedia.org/wiki/Meta">[1]</span></a></sup>，<strong>meta</strong>大多数时候可以理解为<strong>X about X</strong>，大致翻译为<strong>关于X的X</strong>，这里的<strong>关于</strong>在中文语境里通常用<strong>实现、描述、编写</strong>等动词代替。例如<strong>metadata</strong>就是<strong>data about data</strong>，即描述数据的数据，<strong>metaprogramming</strong>就是<strong>programming about programming</strong>，即<strong>编写程序的程序</strong>，诸如此类。如果有需要，这种概念还可以递归，即添加任意多的<strong>meta</strong>前缀，变身成为<strong>metametameta…<strong>。<br>在此基础上再去看</strong>meta</strong>的中文翻译<strong>元</strong>，就会发现这个翻译其实很巧妙。“元”汉语里有 起源&#x2F;开始(如元旦&#x2F;元始天尊)、基本&#x2F;根本(如元素&#x2F;元气&#x2F;元件) 的意思，完美地涵盖了meta想要表达的意思。然而<strong>元</strong>这个字很少单用，已经融合在最常见的一些词语中，所以当看到用<strong>元</strong>的前缀生造出的词语时，大多数人还是会难以理解。</p><p>这样说完感觉可能还是一片迷茫，就拿上面所说的<em>metadata</em>和<em>metaprogramming</em>作为示例来具体说明。</p><h4 id="1-1-Metadata"><a href="#1-1-Metadata" class="headerlink" title="1.1 Metadata"></a>1.1 Metadata</h4><p>关于Metadata，循序渐进地来举几个栗子。</p><ul><li>填写各类登记表时，通常需要填写姓名、性别、爱好等信息，那么我们填写的信息<strong>Kino、女、睡觉</strong>就是具体需要的data，而<strong>姓名、性别、爱好</strong>这种描述属性的文字，就属于metadata</li><li>对上面的内容稍加扩展，可以认为在进行关系型数据库设计时，我们建立的表结构就可以看作是metadata，而最终记录到表中的内容就是data，而对于K-V数据库来说，也不妨理解为Key是metadata，Value是data，JSON数据自然也可如此理解。</li><li>XML数据格式，XML(Extensible Markup Language)作为一种标记语言(Markup Language)，本就是Metadata一种表现形式。可以把XML的tag和property的key作为metadata，而把content和property的value作为data。HTML作为XML的亲戚，也可以如此理解，而至于HTML中的meta标签，又是将整个HTML文件看作data，这个meta标签里的内容就是用来描述这整个HTML的data也就是metadata了，比如<code>&lt;meta name=&quot;google-site-verification&quot; content=&quot;......&quot; /&gt;</code></li></ul><h4 id="1-2-Metaprogramming"><a href="#1-2-Metaprogramming" class="headerlink" title="1.2 Metaprogramming"></a>1.2 Metaprogramming</h4><p>按照上面的逻辑继续下去，变量声明就是描述变量的类型，难道就是metaprogramming了吗? 显然不会是这么简单的事情。<br>metaprogramming本身还是一个比较宏观的定义，对应到不同编程语言的具体实现上，又各有不同。下面简单叙述几种语言的metaprogramming机制，只要实际使用过其中一种，就不难理解了。</p><ul><li>C++：在C++中，可以利用模板实现元编程，在Effective C++中就有关于模板元编程的讨论</li><li>Java：在Java中，最为人熟知的反射，就可以用来实现元编程</li><li>Python：在Python中，如果一个类继承的不是object而是type，那么它就被成为**元类(metaclass)**，可以用元类来验证、注册子类，这也可以称为元编程</li></ul><p>从上面的例子中总结一下，元编程的实现手段各异，但大多是想解决这几个问题：</p><ul><li>设计中出现的相似内容太多，而这些重复内容存在于类层面，已经不能通过类的抽象来解决了，或者解决起来更为复杂(比如引入过于复杂的设计模式等)，这个时候需要更高一层的抽象来处理问题，解决这个问题的过程就可以称为元编程，Python中的metaclass就是典型的应用</li><li>面向对象程序的设计中，类的定义是在编译期就确定的，运行时动态生成的是实例，如果想要更高一层，在运行时动态生成类，那么这个实现过程就可以称为元编程，Java中的反射是典型的应用</li><li>…</li></ul><p>这也提醒了我们，在使用元编程前需要思考这个问题是否必须使用元编程、使用元编程能否简化实现过程，如果可以再尝试使用，否则就需要谨慎对待。<br><strong>元编程更大程度上是一个概念和思想，而不是一个具体方法和手段</strong></p><h4 id="1-3-Off-topic"><a href="#1-3-Off-topic" class="headerlink" title="1.3 Off topic"></a>1.3 Off topic</h4><p>思维一发散，意识就止不住到处游走，虽然离题万里，但且记录在此吧。</p><blockquote><p>突然想到导师最喜欢提的问题：“你这个效能评估的参数选取标准是什么呢？你怎么证明你这个效能评估的结果是可信的呢？毁伤评估的结果是怎么得来的呢？”似也有点元的意味，而且还可以无限递归，最终变成“评估评估…评估的结果”。如果该项工作有客观的评估标准，评估起来就相对简单可信，如果没有客观标准，靠专家标准或者自己选取的参数标准评估，可信性就大打折扣了，这个时候就可以再追问一句：“你怎么评价你选取的参数是可靠的呢？”。<br>今天刚好看到<a href="https://en.wikipedia.org/wiki/2019_redefinition_of_SI_base_units">新闻</a>，国际单位制的七个基本单位重新进行了定义，都改以宇宙的基本常数为基础定义<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. (2018, November 19). 2019 redefinition of SI base units. Retrieved from https://en.wikipedia.org/wiki/2019_redefinition_of_SI_base_units">[2]</span></a></sup>，于是突然想到，所谓度量系统<strong>Metric System</strong>里的单词<strong>metric</strong>，在词源上是不是和<strong>meta</strong>同源的，毕竟metric是用来衡量一切的标准，有种meta的意味在里面，不过事实到底如何，毫无词源学基础的Kino是无法确定了。<br>似乎更能理解那句不是爱因斯坦的名言“越简单越好，但不要过于简单”，过犹不及，繁简之间如何取舍是个永恒的问题，奥卡姆剃刀并不是万能的，更何况繁简也是相互转化的，就像有时想为了简洁不停地添加meta，最终却导致设计模式的臃肿，反而更复杂了。所谓大道至简，是对还是错，还未可知。但是爱因斯坦真的说过这句：“不应否认任何理论的终极目标都是尽可能让不可削减的基本元素变得更加简单且更少，但也不能放弃对任何一个单一经验数据的充分阐释。”这似乎是个比较恰当的说法。</p></blockquote><h3 id="2-Heuristic"><a href="#2-Heuristic" class="headerlink" title="2. Heuristic"></a>2. Heuristic</h3><p>维基百科也有启发式(Heuristic)的词条<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. (2014, May 25). Heuristic (computer science). Retrieved from https://en.wikipedia.org/wiki/Heuristic_(computer_science)">[3]</span></a></sup>，但实际的定义很简单。<br>启发式算法(Heuristic)算法和精确(Exact)算法相对应，它们的求解对象都是运筹优化类问题。区别在于，对于组合优化等非凸优化问题，用精确算法虽可求出其全局最优解，但计算效率低，有时还是NP问题，规模变大则无法在有限时间内求解，而利用启发式算法，可以提高计算效率，但求得的解可能只是较好的次优解，而不能达到全局最优解。<br>针对一个具体的优化问题，提出一个在计算效率和求解质量间取得均衡的具体算法，这个算法就叫做启发式算法。<br>例如需要求解\(y&#x3D;f(x)\)的最小值，用精确求解可以得到准确值为\(\min{y}&#x3D;22\)，耗时\(t&#x3D;10s\)，而使用启发式算法求得的结果是\(\min{y}&#x3D;22.22\)，但耗时只有\(t&#x3D;3s\)。<br>对于精确求解法，具体包括穷举法、分支定界法、割平面法、动态规划法等，而对于传统的启发式算法，包括构造型方法、局部搜索算法、松弛方法、解空间缩减法等。</p><h3 id="3-Metaheuristic"><a href="#3-Metaheuristic" class="headerlink" title="3. Metaheuristic"></a>3. Metaheuristic</h3><p>综合以上概念，将meta和heuristic结合得到的所谓元启发(metaheuristic)，理论定义上应该是<strong>heuristic about heuristic</strong>，但是这种<strong>实现启发式的启发式</strong>，还是很难直观理解。<br>先回到刚刚说的启发式算法，严格意义上的启发式，是针对某个特定优化问题的，只要是能够取得较好值的算法都可以叫做启发式算法，而元启发，就是给定一套流程&#x2F;方法论，对不同的问题，只要按照该流程设计，就能实现一个针对具体问题的启发式算法，因此把这个抽象的流程称之为元启发。换句话说，启发式是面向问题的(Problem Oriented)，而元启发是面向方法的(Method Oriented)。最常见的比如遗传算法，它只给定了一个标准流程：编码-&gt;初始化-&gt;选择-&gt;交叉-&gt;变异-&gt;…，而针对一个具体的优化问题，需要设计特定的编码方式、选择特定的适应度函数…，如此设计完成的具体算法才是启发式算法。<br><strong>但是、然而、不过</strong>，现在的论文中，大多数时候把元启发和启发式也混着用，在整篇文章中，通常只使用元启发式或启发式其中一个词，所以界限并没有那么分明了，元启发经常被称为启发式、启发式也经常被叫做元启发。<br>元启发也有维基百科页面，<a href="https://en.wikipedia.org/wiki/Metaheuristic">戳这里</a></p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>传统的任务分配、组合优化类等运筹学问题，大多都可以抽象成非凸优化的模型，也是NP问题，无法用传统方法求解，同时这些问题大多缺少或不能统计历史数据，因此也无法使用有监督机器学习等算法，这种情况下使用智能优化算法就非常合适。<br>针对这些运筹学问题，只要能够利用元启发算法的思想设计出合理的启发式算法，从而解决问题，其实就是一个很好的工作，但是现在的研究导向是发论文至上，研究智能优化算法的实验室也不例外，一切以发论文为导向，设计全新的元启发式算法实在困难，于是现在的论文大多还是Problem Oriented，通过说动听的故事阐述问题意义，再找出和之前的问题区别，比如多了一个小小的约束条件，这时就可以命名这个问题为XXXXX，以此说明自己定义了一个新问题，再抽象出该问题的数学模型(大多数时候只是在目标函数或约束条件上做些许修改，太简单没有做的意义，太复杂元启发也难以求解)，然后根据元启发算法的流程设计出完整的算法(在流程中的任一处加一点修改即可称之为改进)，编程实现算法做比较，得出结论;当然Method Oriented也还是有的，刚刚提到的一些小的改动、针对经典的TSP等做算法改进、超多目标优化问题的求解方法等。<br>总之一切为了论文，至于这些论文里的问题是否真的有意义、方法是否真的有创新，谁在乎呢。</p><h3 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h3><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. (2018, November 12). Meta. Retrieved from https://en.wikipedia.org/wiki/Meta<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. (2018, November 19). 2019 redefinition of SI base units. Retrieved from https://en.wikipedia.org/wiki/2019_redefinition_of_SI_base_units<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. (2014, May 25). Heuristic (computer science). Retrieved from https://en.wikipedia.org/wiki/Heuristic_(computer_science)<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. (2018, November 16). Metaheuristic. Retrieved from https://en.wikipedia.org/wiki/Metaheuristic<a href="#fnref:4" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Kino的课题常需要用到元启发式算法，就在此稍稍总结。&lt;br&gt;元启发式(metaheuristic)，很多时候也被称为智能优化(intelligent optimization)、现代启发式(Modern Heuristic)、智能计算(Intelligent Computation)、自然计算(Natural Computation)等，细分到具体算法有&lt;em&gt;遗传算法&lt;/em&gt;、&lt;em&gt;粒子群算法&lt;/em&gt;、&lt;em&gt;差分进化算法&lt;/em&gt;、&lt;em&gt;蚁群算法&lt;/em&gt;等。&lt;br&gt;**元启发式(metaheuristic)*&lt;em&gt;这个词本身可以拆成两部分来看，&lt;/em&gt;元(meta)&lt;em&gt;和&lt;/em&gt;启发式(heuristic)*，本文主要从这两方面来阐述元启发式的概念，后续文章再介绍各算法的原理、步骤、代码等。&lt;/p&gt;</summary>
    
    
    
    <category term="techonology" scheme="https://blog.xuwei.fun/categories/techonology/"/>
    
    <category term="cs" scheme="https://blog.xuwei.fun/categories/techonology/cs/"/>
    
    
    <category term="algorithm" scheme="https://blog.xuwei.fun/tags/algorithm/"/>
    
    <category term="metaheuristic" scheme="https://blog.xuwei.fun/tags/metaheuristic/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Summary 01 — Cycle Detection</title>
    <link href="https://blog.xuwei.fun/2018/10/29/leetcode01/"/>
    <id>https://blog.xuwei.fun/2018/10/29/leetcode01/</id>
    <published>2018-10-29T08:33:40.000Z</published>
    <updated>2019-05-18T14:24:33.126Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前段时间忙于找工作，因而有正大光明的托词和导师说，11月之后再去做课题相关的事情，也就有了一段较为自由的时间。<br>其中诸多准备，免不了在Leetcode上刷题，虽然对于最终的结果来说没有帮助，但刷题过程中遇到了一些解决思路相似的问题，就依次将这些共性问题阐述一遍罢了。<br>本系列的第一篇介绍的是环检测问题，对应的维基百科页面有<a href="https://en.wikipedia.org/wiki/Cycle_detection">Cycle detection</a>。这类问题最常见的求解算法是Floyd Cycle Algorithm&#x2F;Floyd’s Tortoise and Hare，中文名通常为Floyd判圈算法&#x2F;龟兔赛跑算法。</p><span id="more"></span><h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>在计算机科学中，有一类问题称之为<strong>环检测问题</strong>，即对于一个由迭代函数(iterated function)值组成的序列，判断该序列是否有环及环出现的位置。<br>关于什么是迭代函数(iterated function)，严格定义可以查看<a href="https://en.wikipedia.org/wiki/Iterated_function">这里</a>，简单来说就是一个函数\(f\)，其定义域和值域都是集合\(X\)，那么对于某个自变量&#x2F;输入\(a\)，其因变量&#x2F;输出\(b\)也可以作为函数\(f\)的自变量&#x2F;输入，如此给定一个初始值\(x\)，将\(f\)的每一次输出作为下一次的输入，如此重复\(n\)次，就称作函数\(f\)的第\(n\)次迭代。</p><p>对于上述函数\(f\)，如果其集合\(X\)是有限的，那么对于序列:<br>$$<br>S &#x3D; \{x_0, x_1 &#x3D; f(x_0), x_2 &#x3D; f(x_1), \cdots, x_i &#x3D; f(x_{i-1}), \cdots\}<br>$$<br>那么必然会有两个位置\(i\)和\(j\)，且\(i &lt; j\)，其\(x_i &#x3D; x_j\)，一旦出现这种状况，显然在\(j\)位置之后，会重复从\(x_i\)到\(x_{j-1}\)的序列。所谓环检测问题，就是给定\(f\)和\(x_0\)，要求找到\(i\)和\(j\)。<br>当然对于无限集合\(X\)，是有可能不存在环的，这取决于\(f\)和\(x_0\)的共同作用。例如\(f&#x3D;x^2\)，如果\(X\)的范围是复数域，那么\(x_0&#x3D;0,1,-1,e^{\frac{2\pi{}mi}{n}}\)，则有环，否则没有。这里\(m\)的取值范围是整数，\(n\)的取值范围是\({1,2,3,4,6,7,8,12,14,15,16,24,28,30,31,32,\cdots}\)，就不仔细推导了，有兴趣的可以自行推导。</p><h3 id="2-求解算法"><a href="#2-求解算法" class="headerlink" title="2. 求解算法"></a>2. 求解算法</h3><p>对于上述问题，最常见的算法是Floyd’s Tortoise and Hare，其次还有Brent’s algorithm和Gosper’s algorithm等。<br>最直接的想法是记录每次迭代的值，建立一个hash表，这样可以在重复出现时直接定位，但是这种方法空间复杂度太高，故弃。</p><h4 id="2-1-Floyd’s-Tortoise-and-Hare"><a href="#2-1-Floyd’s-Tortoise-and-Hare" class="headerlink" title="2.1 Floyd’s Tortoise and Hare"></a>2.1 Floyd’s Tortoise and Hare</h4><p>对于问题描述中迭代函数组成的序列，如果存在环，那么对于\(i\ge{}\mu\)，则\(x_i &#x3D; x_{i+k\lambda}\)，其中\(\lambda\)是环的长度，\(\mu\)是环的第一个元素出现的位置。<br>基于此，可以推出，\(\exists{}i &#x3D; k\lambda\ge\mu\Longrightarrow{}x_i &#x3D; x_{2i}\)<br>因此，只要设定两个指针\(P1\)和\(P2\)，其中\(P2\)的步长是2，\(P1\)的步长是1，那么就可以找到两个指针指向值相等的位置，反过来说，即只要存在相等值，就存在环，此时可以得出\(\nu &#x3D; P2 - P1 &#x3D; P1 &#x3D; k\lambda\).<br>显然\(x_{\mu{}+\nu} &#x3D; x_{\mu}\)，即\(x_{\nu{}+\mu} &#x3D; x_{\mu}\)，故找到上述位置之后，\(P1\)仍保持原来位置，而\(P2\)放回序列最初位置，此时两个指针的推进步长都设置为1，两指针指向的值再次相等时，就是环开始的位置。找到环开始的位置后，向后迭代找到下一次重复位置，就可以得到环的长度\(\lambda\)了。<br><img src="/images/leetcode01_1.png" alt="img01"></p><h4 id="2-2-Brent’s-algorithm"><a href="#2-2-Brent’s-algorithm" class="headerlink" title="2.2 Brent’s algorithm"></a>2.2 Brent’s algorithm</h4><p>Floyd’s Tortoise and Hare算法很精巧，但是判断环存在、找到环开始位置和确定环长度需要分为三步，Brent’s algorithm效率更高，且只需要两步。<br>Brent’s algorithm也是利用了快慢两个指针的想法，但是它的想法是动态增加步长，加快搜索速度。<br>其基本意图是设立两个指针，尽快让第一个指针到达环内，然后第二个指针以步长1前进，再次相等时走过的步数正好是环的长度\(\lambda\)，具体做法如下。<br>首先，设定两个指针\(P1\)和\(P2\)，\(P2\)第一次先前进\(2^0&#x3D;1\)步，在前进的过程中若始终\(x_{P2}\ne{}x_{P1}\)，则令\(P1 &#x3D; P2\)，然后\(P2\)再前进\(2^1&#x3D;2\)，在前进的过程中若始终\(x_{P2}\ne{}x_{P1}\)，则令\(P1 &#x3D; P2\)，然后\(P2\)再前进\(2^2&#x3D;4\)……<br>如此，直到出现相等的位置，在出现相等位置之前，最后一次\(P2\)前进的步数就是环的长度\(\lambda\)。<br>此时，将\(P1\)放于序列开始位置0，\(P2\)放于\(\lambda\)位置，由于\(x_{\mu} &#x3D; x_{\lambda{}+\mu}\)，故只要让\(P1\)和\(P2\)依次向前前进，等到两者指向值相同时，\(P1\)的位置正好就是环的开始位置。<br><img src="/images/leetcode01_2.png" alt="img02"></p><p>Brent’s algorithm的效率比Floyd’s Tortoise and Hare要高，最差情况是Floyd’s Tortoise and Hare算法。其主要原因是，步长动态增加，速度提高，以及首次找到相同值时，记录了环的长度，而Floyd’s Tortoise and Hare算法首次找到相同值时，并不知道环的长度，只能知道环长度的整数倍。</p><h4 id="2-3-Gosper’s-algorithm"><a href="#2-3-Gosper’s-algorithm" class="headerlink" title="2.3 Gosper’s algorithm"></a>2.3 Gosper’s algorithm</h4><p>Gosper算法可以参考<a href="http://www.inwap.com/pdp10/hbaker/hakmem/flows.html">此处</a>，Kino还没有细看，就不细说了。</p><h3 id="3-相关练习"><a href="#3-相关练习" class="headerlink" title="3. 相关练习"></a>3. 相关练习</h3><p>Leetcode上有以下数题与此相关。</p><h4 id="3-1-Leetcode-141-Linked-List-Cycle"><a href="#3-1-Leetcode-141-Linked-List-Cycle" class="headerlink" title="3.1 Leetcode 141. Linked List Cycle"></a>3.1 Leetcode 141. Linked List Cycle</h4><p><a href="https://leetcode.com/problems/linked-list-cycle">Link</a></p><blockquote><p>Description: Given a linked list, determine if it has a cycle in it.</p></blockquote><p>Floyd’s Tortoise and Hare</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">bool</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ListNode<span class="token operator">*</span> tortoise <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> hare <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>hare <span class="token operator">&amp;&amp;</span> hare<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>tortoise <span class="token operator">==</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      tortoise <span class="token operator">=</span> tortoise<span class="token operator">-></span>next<span class="token punctuation">;</span>      hare <span class="token operator">=</span> hare<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Brent’s algorithm</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">bool</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> current_step <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> limited_step <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> tortoise <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> hare <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>hare <span class="token operator">&amp;&amp;</span> hare<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>tortoise <span class="token operator">==</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>current_step <span class="token operator">==</span> limited_step<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        current_step <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        limited_step <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>        tortoise <span class="token operator">=</span> hare<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      hare <span class="token operator">=</span> hare<span class="token operator">-></span>next<span class="token punctuation">;</span>      current_step<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-Leetcode-142-Linked-List-Cycle-II"><a href="#3-2-Leetcode-142-Linked-List-Cycle-II" class="headerlink" title="3.2 Leetcode 142. Linked List Cycle II"></a>3.2 Leetcode 142. Linked List Cycle II</h4><p><a href="https://leetcode.com/problems/linked-list-cycle-ii">Link</a></p><blockquote><p>Description: Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p></blockquote><p>Floyd’s Tortoise and Hare</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  ListNode <span class="token operator">*</span><span class="token function">detectCycle</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ListNode<span class="token operator">*</span> tortoise <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> hare <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tortoise <span class="token operator">!=</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>hare <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>hare<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      tortoise <span class="token operator">=</span> tortoise<span class="token operator">-></span>next<span class="token punctuation">;</span>      hare <span class="token operator">=</span> hare<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        tortoise <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tortoise <span class="token operator">!=</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      tortoise <span class="token operator">=</span> tortoise<span class="token operator">-></span>next<span class="token punctuation">;</span>      hare <span class="token operator">=</span> hare<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> tortoise<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Brent’s algorithm</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  ListNode <span class="token operator">*</span><span class="token function">detectCycle</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>head <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> current_step <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> limited_step <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> tortoise <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>    ListNode<span class="token operator">*</span> hare <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tortoise <span class="token operator">!=</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>hare <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>hare<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>current_step <span class="token operator">==</span> limited_step<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        current_step <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        limited_step <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>        tortoise <span class="token operator">=</span> hare<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      hare <span class="token operator">=</span> hare<span class="token operator">-></span>next<span class="token punctuation">;</span>      current_step<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        tortoise <span class="token operator">=</span> head<span class="token punctuation">;</span>    hare <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>current_step<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      tortoise <span class="token operator">=</span> tortoise<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>tortoise <span class="token operator">!=</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      tortoise <span class="token operator">=</span> tortoise<span class="token operator">-></span>next<span class="token punctuation">;</span>      hare <span class="token operator">=</span> hare<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> tortoise<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-Leetcode-202-Happy-Number"><a href="#3-3-Leetcode-202-Happy-Number" class="headerlink" title="3.3 Leetcode 202. Happy Number"></a>3.3 Leetcode 202. Happy Number</h4><p><a href="https://leetcode.com/problems/happy-number/">Link</a></p><blockquote><p>Description: Write an algorithm to determine if a number is “happy”.<br>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p></blockquote><p>Floyd’s Tortoise and Hare</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">bool</span> <span class="token function">isHappy</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> tortoise <span class="token operator">=</span> <span class="token function">nextNum</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hare <span class="token operator">=</span> <span class="token function">nextNum</span><span class="token punctuation">(</span><span class="token function">nextNum</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tortoise <span class="token operator">!=</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      tortoise <span class="token operator">=</span> <span class="token function">nextNum</span><span class="token punctuation">(</span>tortoise<span class="token punctuation">)</span><span class="token punctuation">;</span>      hare <span class="token operator">=</span> <span class="token function">nextNum</span><span class="token punctuation">(</span><span class="token function">nextNum</span><span class="token punctuation">(</span>hare<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> tortoise <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">nextNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> nxt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> digit <span class="token operator">=</span> n<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>      nxt <span class="token operator">+=</span> digit<span class="token operator">*</span>digit<span class="token punctuation">;</span>      n <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> nxt<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Brent’s algorithm</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">bool</span> <span class="token function">isHappy</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> current_step <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> limited_step <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> tortoise <span class="token operator">=</span> <span class="token function">nextNum</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hare <span class="token operator">=</span> <span class="token function">nextNum</span><span class="token punctuation">(</span><span class="token function">nextNum</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tortoise <span class="token operator">!=</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>current_step <span class="token operator">==</span> limited_step<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        current_step <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        limited_step <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>        tortoise <span class="token operator">=</span> hare<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      hare <span class="token operator">=</span> <span class="token function">nextNum</span><span class="token punctuation">(</span>hare<span class="token punctuation">)</span><span class="token punctuation">;</span>      current_step<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> tortoise <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">nextNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> nxt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">int</span> digit <span class="token operator">=</span> n<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>      nxt <span class="token operator">+=</span> digit<span class="token operator">*</span>digit<span class="token punctuation">;</span>      n <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> nxt<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-Leetcode-287-Find-the-Duplicate-Number"><a href="#3-4-Leetcode-287-Find-the-Duplicate-Number" class="headerlink" title="3.4 Leetcode 287. Find the Duplicate Number"></a>3.4 Leetcode 287. Find the Duplicate Number</h4><p><a href="https://leetcode.com/problems/find-the-duplicate-number">Link</a></p><blockquote><p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p></blockquote><p>Floyd’s Tortoise and Hare</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>  vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">int</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">this</span><span class="token operator">-></span>nums <span class="token operator">=</span> nums<span class="token punctuation">;</span>        <span class="token keyword">int</span> tortoise <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hare <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tortoise <span class="token operator">!=</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      tortoise <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>tortoise<span class="token punctuation">)</span><span class="token punctuation">;</span>      hare <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>hare<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        tortoise <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tortoise <span class="token operator">!=</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      tortoise <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>tortoise<span class="token punctuation">)</span><span class="token punctuation">;</span>      hare <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>hare<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> tortoise<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Brent’s algorithm</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>  vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">int</span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">this</span><span class="token operator">-></span>nums <span class="token operator">=</span> nums<span class="token punctuation">;</span>        <span class="token keyword">int</span> current_step <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> limited_step <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> tortoise <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hare <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>tortoise <span class="token operator">!=</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>current_step <span class="token operator">==</span> limited_step<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        current_step <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        limited_step <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>        tortoise <span class="token operator">=</span> hare<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      hare <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>hare<span class="token punctuation">)</span><span class="token punctuation">;</span>      current_step<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        tortoise <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    hare <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>current_step<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      tortoise <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>tortoise<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>tortoise <span class="token operator">!=</span> hare<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      tortoise <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>tortoise<span class="token punctuation">)</span><span class="token punctuation">;</span>      hare <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>hare<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> tortoise<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-实际应用"><a href="#4-实际应用" class="headerlink" title="4. 实际应用"></a>4. 实际应用</h3><p>环检测(cycle detection)问题的实际应用有 <em>伪随机数生成器(pseudorandom number generators)强度的度量</em>，比如 <em>线性同余生成器(linear congruential generator)<em>，</em>加密哈希函数的冲突检测</em>，<em>细胞自动机(cellular automaton)的振荡周期配置</em>等</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;前段时间忙于找工作，因而有正大光明的托词和导师说，11月之后再去做课题相关的事情，也就有了一段较为自由的时间。&lt;br&gt;其中诸多准备，免不了在Leetcode上刷题，虽然对于最终的结果来说没有帮助，但刷题过程中遇到了一些解决思路相似的问题，就依次将这些共性问题阐述一遍罢了。&lt;br&gt;本系列的第一篇介绍的是环检测问题，对应的维基百科页面有&lt;a href=&quot;https://en.wikipedia.org/wiki/Cycle_detection&quot;&gt;Cycle detection&lt;/a&gt;。这类问题最常见的求解算法是Floyd Cycle Algorithm&amp;#x2F;Floyd’s Tortoise and Hare，中文名通常为Floyd判圈算法&amp;#x2F;龟兔赛跑算法。&lt;/p&gt;</summary>
    
    
    
    <category term="techonology" scheme="https://blog.xuwei.fun/categories/techonology/"/>
    
    <category term="cs" scheme="https://blog.xuwei.fun/categories/techonology/cs/"/>
    
    
    <category term="algorithm" scheme="https://blog.xuwei.fun/tags/algorithm/"/>
    
    <category term="Cycle Detection" scheme="https://blog.xuwei.fun/tags/Cycle-Detection/"/>
    
    <category term="Floyd Cycle Algorithm" scheme="https://blog.xuwei.fun/tags/Floyd-Cycle-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>日语学习第八讲</title>
    <link href="https://blog.xuwei.fun/2018/06/29/japanese09/"/>
    <id>https://blog.xuwei.fun/2018/06/29/japanese09/</id>
    <published>2018-06-29T13:45:02.000Z</published>
    <updated>2021-03-07T12:23:17.718Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇介绍了敬语系统，这一章主要介绍日语中的复合句。日语中复句的相关概念在维基百科上有複文<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. 複文. Wikipedia, Wikimedia Foundation, 16 Apr. 2018, ja.wikipedia.org/wiki/複文.">[1]</span></a></sup>和節<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. 節 (文法). Wikipedia, Wikimedia Foundation, 18 Apr. 2018, ja.wikipedia.org/wiki/節_(文法).">[2]</span></a></sup>等。<br>区别简单句和复合句的主要标志是看它主谓关系的次数，主谓关系在语法上仅成立一次的句子叫做单句。反之，句中有两层或两层以上主谓关系的就可成为复合句。简单句与复合句的区别决不是以句子长短、单词多少而定。常常是句子很长的是简单句；句子很短，但具有两层以上主谓关系的都是复合句。</p><span id="more"></span><h2 id="1-分类和结构"><a href="#1-分类和结构" class="headerlink" title="1. 分类和结构"></a>1. 分类和结构</h2><p>根据日语复句<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="henry19931224. 日语复句. 百度文库, 16 Nov. 2011, wenku.baidu.com/view/bfe202d0b14e852458fb5731.html.">[3]</span></a></sup>、试论日语的复合句<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="谢秀忱. 试论日语的复合句. 现代外语 3(1982):33-38.">[4]</span></a></sup>和试论日语复句中从属句节的多层立体结构<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="吴春竹. 试论日语复句中从属句节的多层立体结构. 外语学刊 6(2008):49-52.">[5]</span></a></sup>等文献，可以对日语的分类和结构做出相应总结。<br>日语中存在着大量的复合句，其联系手段都是不相同的。根据联系手段的不同，大致可把日语复合句分为三大类。</p><h3 id="1-1-包孕句"><a href="#1-1-包孕句" class="headerlink" title="1.1 包孕句"></a>1.1 包孕句</h3><p>句子中的主谓宾补定状的某一个成份或者某几个成份是用主谓结构形成的，这样的句子叫包孕句。每一个顶替句子成份的主谓结构，称为从句，所以有“主语从句”“谓语从句”“宾语从句”“定语从句”“补语从句”等。其中“主语从句”“宾语从句”“补语从句”等常是主谓结构＋形式体言の构成。<br>形式体言“こと”“もの”“の”虽然本身没有固定的词意，但可充当句中各种成份，可把它们分别放在主语、宾语、补语等位置上，用来充当句中相应的各种不同的成分，不过必须在形式体言前面有其说明内容的句子或词组，相当于汉语的包孕句的结构。下面是不同的从句类型及相关示例，{}为各种从句内容。</p><h4 id="1-1-1-主语从句"><a href="#1-1-1-主语从句" class="headerlink" title="1.1.1 主语从句"></a>1.1.1 主语从句</h4><p>{魚が泳いでいるのが}見えます。<br>{向こうから来るのが}李さんです。<br>{この問題をどうやって解「と」くか}、分かりますか。<br>{私が買いたいのは}これです。</p><h4 id="1-1-2-谓语从句"><a href="#1-1-2-谓语从句" class="headerlink" title="1.1.2 谓语从句"></a>1.1.2 谓语从句</h4><p>即在句子中做述語成分<br>わが国は{土地が広いです}。<br>山田さんは{中国語が上手です}。<br>私は{息子「むすこ」が二人います}。</p><h4 id="1-1-3-宾语从句"><a href="#1-1-3-宾语从句" class="headerlink" title="1.1.3 宾语从句"></a>1.1.3 宾语从句</h4><p>即在句子中做对象语和目的语成分<br>電車が来たらまず{人が降りるのを}待ちます。<br>教師は{学生が一人一人本を読むのを}聞いています。<br>私は{王さんがどこへ行ったか}知りません。</p><h4 id="1-1-4-状语从句"><a href="#1-1-4-状语从句" class="headerlink" title="1.1.4 状语从句"></a>1.1.4 状语从句</h4><p>即在句子中做连用修饰语成分<br>今回の試験は{頭が痛くなるほど}難しいです。<br>私は{王さんが言ったとおり}やりましたが、成功しませんでした。<br>私たちの生活は{国が発展するにしたがって}良くなっていく。</p><h4 id="1-1-5-定语从句"><a href="#1-1-5-定语从句" class="headerlink" title="1.1.5 定语从句"></a>1.1.5 定语从句</h4><p>即在句子中做连体修饰语成分<br>{私が買いたい}辞書はこの日中辞典です。<br>ここは{私が勉強している}大学です。<br>{私が大学を卒業した}時、姉は25歳でした。</p><h4 id="1-1-6-补语从句"><a href="#1-1-6-补语从句" class="headerlink" title="1.1.6 补语从句"></a>1.1.6 补语从句</h4><p>私はその時まで{日本の映画館は全部指定席だと}思っていたのです。<br>私は{子供たちは立派な将来があると}考える。</p><h3 id="1-2-主从句"><a href="#1-2-主从句" class="headerlink" title="1.2 主从句"></a>1.2 主从句</h3><p>在这类复合句中，分句与分句之间的关系不是平等并列的，而是有主有从的。一般从句在前，独立于主句之外，主句在后，形成两层或两层以上的主谓关系，以各种接续助词、助动词、形式体言或用言的各种活用形、惯用形等作为联系手段，把前后两个不同的分句连结起来。根据不同意义的连接手段，可把主从句分为原因、结果、条件等从句。<br>主句和从句可以各有自己的主语，也可以通用一个主语；不同的主语时一般情况下，从句主语用が，主句主语用は（有违反此规则的时候）；通用主语的情况下，主语用は，其位置在句子的最前面。另外，接续助词与从句连接时，不同的接续助词有不同的活用形要求，请注意。</p><h4 id="1-2-1-状态从句"><a href="#1-2-1-状态从句" class="headerlink" title="1.2.1 状态从句"></a>1.2.1 状态从句</h4><p>表示同时发生的状态，“一边…一边…”<br>私は{テレビを見ながら}食事をする。<br>政府「せいふ」は{都市の発展を促進「そくしん」しつつ}、環境「かんきょう」も改善「かいぜん」していく。</p><h4 id="1-2-2-让步从句"><a href="#1-2-2-让步从句" class="headerlink" title="1.2.2 让步从句"></a>1.2.2 让步从句</h4><p>表示“虽然、即使、要是…就好了”等<br>{雨が降っているが}、訓練は中止しない。<br>{雨が降っても}、訓練は中止しない。<br>{君がもう少し早く来たらよかったのに}、バスはもう出てしまった。<br>{自分がいくらできるとも}、油断は大敵「たいてき」だ。<br>彼は{知っているくせに}、知らない振りをしている。</p><h4 id="1-2-3-条件从句"><a href="#1-2-3-条件从句" class="headerlink" title="1.2.3 条件从句"></a>1.2.3 条件从句</h4><p>日语中存在着一些用各种活用形加上不同的助词、助动词连接起来的条件从句。这种句子的意义，相当于汉语的“只要&#x2F;一旦&#x2F;如果&#x2F;假如…就…”。 归纳起来有四种表现方法。</p><h5 id="1-2-3-1-「と」"><a href="#1-2-3-1-「と」" class="headerlink" title="1.2.3.1 「と」"></a>1.2.3.1 「と」</h5><p>主要表示客观上的事实，客观性较强，表示两种动作相继发生。<br>使用条件语「と」的规则:</p><ul><li>把「と」加到条件后面，再跟上满足了条件会发生的结果: [ 条件 ] + と + [ 结果 ]</li><li>状态表示必须显式声明: [ 状态 ] + だと + [ 结果 ]</li></ul><p>例句:</p><ul><li>学校に行かないと友達と会えないよ</li><li>たくさん食べると太るよ</li></ul><h5 id="1-2-3-2「なら-ば-」"><a href="#1-2-3-2「なら-ば-」" class="headerlink" title="1.2.3.2「なら(ば)」"></a>1.2.3.2「なら(ば)」</h5><p>使用前提条件语「なら」的规则:</p><ul><li>把「なら」加在前提条件后面: [ 假设会发生的前提条件 ] + なら + [ 结果 ]</li><li>不能加表陈述的「だ」</li></ul><p>也可以用「ならば」替代「なら」，两者意思完全一样，但前者让人感觉更正式。<br>例句:</p><ul><li>みんなが行くなら私も行く</li><li>アリスさんが言うなら問題ないよ</li></ul><h5 id="1-2-3-3「ば」"><a href="#1-2-3-3「ば」" class="headerlink" title="1.2.3.3「ば」"></a>1.2.3.3「ば」</h5><p>这种条件语是通用的，它不预设条件，也没有蕴含的意思。<br>「ば」条件语的活用规则如下，注意名词和な形容词的活用规则其实是在活用「である」里面的动词「ある」<br>「ば」的活用规则:</p><ul><li>对动词: [ 一类え形活用词根 ] + 「ば」，即把动词最后假名从 &#x2F;u&#x2F; 段改为同行 &#x2F;e&#x2F; 段，再加上「ば」</li><li>对い形容词以及「ない」结尾的未然形: 把最后的「い」换成「ければ」</li><li>对名词和な形容词: 加「であれば」</li></ul><p>例句:</p><ul><li>友達に会えれば、買い物に行きます</li><li>お金があればいいね</li><li>楽しければ、私も行く</li><li>楽しくなければ、私も行かない</li><li>食べなければ病気になるよ</li></ul><h5 id="1-2-3-4-「たら-ば-」完成时条件语"><a href="#1-2-3-4-「たら-ば-」完成时条件语" class="headerlink" title="1.2.3.4 「たら(ば)」完成时条件语"></a>1.2.3.4 「たら(ば)」完成时条件语</h5><p>「たら」的重点在于满足条件后发生的事，主要用来表示对事物完了的假定。<br>「たら」的活用规则:</p><ul><li>首先把名词、形容词或动词活用为过去形，再加上「ら」</li></ul><p>也可以用「たらば」替代「たら」，类似「ならば」，二者意思完全相同，只是前者感觉更正式。<br>例句:</p><ul><li>暇だったら、遊びに行くよ</li><li>学生だったら、学生割引で買えます</li></ul><h5 id="1-2-3-5-「もし」"><a href="#1-2-3-5-「もし」" class="headerlink" title="1.2.3.5 「もし」"></a>1.2.3.5 「もし」</h5><p>「もし」是条件句中常用的一个副词，用来增加一种对假设条件不确定的语气，可以翻译为“要是，如果”。但是必须搭配上述四种条件句的形式使用，「もし」本身是不能构成条件句的语法形式的。<br>例句:</p><ul><li>もしよかったら、映画を観に行きますか？</li><li>もし時間がないなら、明日でもいいよ。</li></ul><h4 id="1-2-4-原因从句"><a href="#1-2-4-原因从句" class="headerlink" title="1.2.4 原因从句"></a>1.2.4 原因从句</h4><p>表示“因为、由于”等原因，一般有以下联系手段。</p><h5 id="1-2-4-1-から"><a href="#1-2-4-1-から" class="headerlink" title="1.2.4.1 から"></a>1.2.4.1 から</h5><p>[ 原因 ] + から + [ 结果 ]<br>如果原因是字典形名词或な形容词，后面必须加「だ」来显式的表示它是原因，即「( 名词 &#x2F; な形容词 ) だから」。如果忘了在「から」前面加表陈述的「だ」的话，听起来「から」就是「从…」的意思了。<br>如果是在用丁宁语的话，应该把「から」当成普通名词，在后面加「です」。<br>有上下文的时候，原因和结果都可以省略掉。省略原因的时候，必须加上表陈述的「だ」或「です」，所以经常会听到「だから」<br>例句:</p><ul><li>時間がなかったからです</li><li>うん、時間がなかったから</li><li>だからパーティーに行かなかったの？</li><li>天気が悪いから、山へ行くのは止めましょう。</li></ul><h5 id="1-2-4-2-ので"><a href="#1-2-4-2-ので" class="headerlink" title="1.2.4.2 ので"></a>1.2.4.2 ので</h5><p>「ので」基本上跟「から」可以互换使用，除了一些微妙的区别。「から」显式的表明了前面的句子是原因，而「ので」这仅仅是把两个句子连了起来，然后把前一个句子变味了解释的口吻。<br>「ので」听起来口气更柔和，也更礼貌，所以在解释做了失礼之事的原因的时候，人们更倾向于用它而非「から」。<br>总体上来看，在说话者的意志和能动性更强时，使用「から」；如果需要较恭敬的表达，或者是表达判断的理由时，用「ので」较多。<br><strong>「の」前面如果是字典形名词或者な形容词的话，一定要加「な」</strong><br>解释口气的「の」可以简写成「ん」，说话的时候「ので」也可以改成「んで」，因为这样可以省略音节 &#x2F; o &#x2F; 的发音，形成连读。<br>例句:</p><ul><li>時間がなかったのでパーティーに行かなかった</li><li>ちょっと忙しいので、そろそろ失礼します</li><li>私は学生なので、お金がないんです</li><li>なので、友達に会う時間がない</li><li>天気が悪いので、山へ行くのは止めました。</li></ul><h5 id="1-2-4-3-ため"><a href="#1-2-4-3-ため" class="headerlink" title="1.2.4.3 ため"></a>1.2.4.3 ため</h5><p>写成汉字应该是「為」。与「から」和「ので」相比，「ため」是一个能够与对方拉开距离的词语。<br>「から」和「ので」都是传达说话者的意志和判断的表达方式，与此相比，「ため」多用于描述发生的事情。<br>正因为此，「ため」多在新闻和论文中被使用，它能给对方一种严肃感，让人觉得情报的来源很可靠。<br>例句:</p><ul><li>大雨のため一時通行止めとなった</li><li>王さんは風邪を引いたために、会社を休みました。</li></ul><h5 id="1-2-4-4-によって"><a href="#1-2-4-4-によって" class="headerlink" title="1.2.4.4 によって"></a>1.2.4.4 によって</h5><p>「に」在表示对象、方向时通常接的是名词，但在表示目的、目标时既可接名词也可接动词简体。<br>「よって」原形为「よる」，可写做「寄る」、「拠る」、「因る」等，「～によって」這個句型在日文中是常见的，用法很多，主要有以下几种:</p><ul><li>名词 + によって(により&#x2F;によりまして&#x2F;による) + 名词。依据前者的条件及选项取舍的不同，結果、情況、作法也会随之改变的句型表现。「AによってB」A只能置入名詞，作为条件依据，而随着A不同B也會改变，中文意思为「依A的不同而B」。</li><li>名词 + によって(により&#x2F;による) + 名词。表示事物、情況成立或发生的理由以及原因之句型表现。「AによってB」A只能置入名词，表理由、原因，因为A而造成B的场面</li><li>名词 + によって(により&#x2F;による) + 名词。表示方法、手段之句型表现。「AによってB」A只能置入名词，表方法、手段，意即透过或运用A作为手段而来做B，有些人会将它与「～によると」的传闻来源表现搞混，需要注意。</li><li>名词 + によって(により&#x2F;による) + 名词。表示消息、传闻的来源或出处的句型表现。「Aによると～」A只能置入名词，表示消息、传闻的来源，「によると」的結尾常与「～そうだ」、「～ということだ」一起使用。</li></ul><p>例句:</p><ul><li>日本人との付き合いによって日本語の会話を練習している</li></ul><h5 id="1-2-4-5-おかげで"><a href="#1-2-4-5-おかげで" class="headerlink" title="1.2.4.5 おかげで"></a>1.2.4.5 おかげで</h5><p>可以译为“托…的福”。<br>规则:</p><ul><li>名词 + 「の」 + 「おかげで」</li><li>形容词基本形 + 「おかげで」</li><li>形容动词 + 「な」 + 「おかげで」</li><li>动词基本形 + 「おかげで」</li></ul><p>例句:</p><ul><li>あなたのおかげで助かりました</li></ul><h5 id="1-2-4-6-せいで"><a href="#1-2-4-6-せいで" class="headerlink" title="1.2.4.6 せいで"></a>1.2.4.6 せいで</h5><p>名词「せい」的汉字是「所为」，「で」是「です」的中顿形式，可以翻译成“是…的所为”，一般是带来不好的结果。<br>规则:</p><ul><li>名词 + 「の」 + 「せいで」</li><li>形容词基本形 + 「せいで」</li><li>形容动词 + 「な」 + 「せいで」</li><li>动词基本形 + 「せいで」</li></ul><p>例句:</p><ul><li>わがままな母親のせいで、彼女は結婚が遅れた</li></ul><h4 id="1-2-5-结果从句"><a href="#1-2-5-结果从句" class="headerlink" title="1.2.5 结果从句"></a>1.2.5 结果从句</h4><p>日语中存在着这样一种句子结构: “…は…が…からです(だ、である)”。相当于汉语的“事情之所以这样，是由于…的缘故”。表示一种因果关系。<br>结果从句的“から”是作为副助词和“だ、です、である”结合起来，接在动词的连体形后面做谓语，先强调其结果，后叙述原因。<br>也可以用另一种惯用型“…のは…が…ためです”来表示</p><p>例句:</p><ul><li>任务を完成するてとができなかったのは计画が十分ではなかったからだ</li></ul><h4 id="1-2-6-目的从句"><a href="#1-2-6-目的从句" class="headerlink" title="1.2.6 目的从句"></a>1.2.6 目的从句</h4><p>表示行为的目的。<br>一般常用惯用形”…ために”、”…には”，是表示达到某种目的的句子。但这种类型的句子，一般做目的状语较多，因为前后两个事项都属于一个主体——主语，如有两层主谓关系者，可看作目的从句。</p><p>例句:</p><ul><li>私たちは{健康「けんこう」を保つために}、毎日運動をします。</li><li>{友人が早く快復「かいふく」するように}心から祈「いの」ります。</li><li>私は{朝起きるのに}目覚「めざ」ましが必要です。</li></ul><h4 id="1-2-6-方式从句"><a href="#1-2-6-方式从句" class="headerlink" title="1.2.6 方式从句"></a>1.2.6 方式从句</h4><p>日语中有这样一种惯用型: “…ように”、”…とおりに”，而这两者的前后都是一个句子形式，又具有两层主谓关系，我们可以把它统称为方式从句。</p><p>例句:</p><ul><li>レーニンが教えたように、共产党はプロレタリアートの前卫である</li></ul><p>除了表示方式以外，也可以利用 “…ように” 这一形式表示祈使目的。<br>例句:</p><ul><li>みなが気持よく休めるように、私にちが部屋をきれいに掃除している</li></ul><h4 id="1-2-7-时间从句"><a href="#1-2-7-时间从句" class="headerlink" title="1.2.7 时间从句"></a>1.2.7 时间从句</h4><p>在日常生活的语言中，经常会遇到这类惯用型: “…たびに”、”…ときに”、”…あとで(に)”、”…てから”、”…うちに” 。这一类型句子的共同点是都表示时间的含义，相当于汉语的“每逢…声”、“在…时候”、“在…之后” 、“在…之中”的意义。试论日语的复合句[4]中认为，如果在这一类惯用型前后有两个句子，又具有两层主谓关系，和前述其他副句一样，把它作为复合句看待，将其归属为时间从句。 </p><p>例句:</p><ul><li>吴先生の家に行くたびに、彼はいろいろなおもしろい話を聞かせてくれます</li><li>父からはじめ手紙が届いた時、私はとてもうれしかった</li><li>私が外出しためとで(に)、陈君があそびに来た</li><li>彼らは大学に入学してから、まだ日があさい</li></ul><h3 id="1-3-并列句"><a href="#1-3-并列句" class="headerlink" title="1.3 并列句"></a>1.3 并列句</h3><p>句中有2层以上的主谓结构，虽然这些主谓结构有某种语法形式上的联系，但是在意义上是并列的，互不依赖的。并列句中的各自的句子称作分句，前面的分句是以中顿形式，或者用接续助词て、し、が等，以及某些惯用形与后面的分句连接。<br>例句：<br>①“河水很清澈，河底看得很清楚。”<br>川の水が綺麗で、川の底「そこ」がよく見えます。（用形容动词的中顿）<br>②“客人来了，就在那里喝茶；孩子回来了，那个房间就变成了学习室。”<br>人が来ればそこでお茶を飲んで、子供が学校から帰ってくると、その部屋は勉強部屋になる。（用接续助词て）<br>③“有的人显得高兴，有的人显得伤心。”<br>嬉しそうな顔をする人もいるし、悲「かな」しそうな顔をする人もいます。（用接续助词し）<br>④ “即有山，又有海。”<br>山もあれば、海もある。（用惯用形……も……ば、……も）<br>⑤“冬天过去，春天来了”<br>冬が過ぎ、春が来た</p><h3 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h3><p>日语的复合句按照基本结构可以分为三大类，包孕句、主从句和并列句，这三者的从属度是逐渐递减的。在实际中，还可以将三者混合起来，构成更为复杂的句式结构。</p><h2 id="2-复句中的时体"><a href="#2-复句中的时体" class="headerlink" title="2. 复句中的时体"></a>2. 复句中的时体</h2><p>日语复句中的时体和英语不同，没有十分标准的研究，相应文章也较少，论日语从句的时态变化<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="林泽清, and 耿铁珍. 论日语从句的时态变化. 日语学习与研究 2(2000):16-21.">[6]</span></a></sup>和浅析日语复句中的“时”和“体”<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="辛宇峰. 浅析日语复句中的“时”和“体”. 外语与翻译 4(2014):54-55.">[7]</span></a></sup>有一些介绍。<br>一般来说，日语复句的时体的基本原则是，主句的时体，以说话者的视角为基准，从句的时体以主句的时间为基准，但也会考虑到说话者的视角。<br>一般来说:</p><ul><li>如果从句的动作、状态发生在主句之前，那么通常从句都是过去时，有时也反映在体上例如完成体等</li><li>如果从句的动作、状态和主句同时发生，那么通常从句的时和主句相同</li><li>如果从句的动作、状态发生在主句之后，此时考虑主句的时间和整个句子在说话者中的视角，若主句是现在时，那从句也就用现在时即可，若主句是过去时，需要考虑从句的动作、状态在说话者视角中是否仍处于过去时，是则也用过去时，否则现在时。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章主要介绍了日语复合句的内容，下一篇将尝试综合考虑已有内容归纳日语句子的改造顺序。</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. 複文. Wikipedia, Wikimedia Foundation, 16 Apr. 2018, ja.wikipedia.org/wiki/複文.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. 節 (文法). Wikipedia, Wikimedia Foundation, 18 Apr. 2018, ja.wikipedia.org/wiki/節_(文法).<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">henry19931224. 日语复句. 百度文库, 16 Nov. 2011, wenku.baidu.com/view/bfe202d0b14e852458fb5731.html.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">谢秀忱. 试论日语的复合句. 现代外语 3(1982):33-38.<a href="#fnref:4" rev="footnote">↩</a></span></li><li id="fn:5"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">吴春竹. 试论日语复句中从属句节的多层立体结构. 外语学刊 6(2008):49-52.<a href="#fnref:5" rev="footnote">↩</a></span></li><li id="fn:6"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">林泽清, and 耿铁珍. 论日语从句的时态变化. 日语学习与研究 2(2000):16-21.<a href="#fnref:6" rev="footnote">↩</a></span></li><li id="fn:7"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">辛宇峰. 浅析日语复句中的“时”和“体”. 外语与翻译 4(2014):54-55.<a href="#fnref:7" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇介绍了敬语系统，这一章主要介绍日语中的复合句。日语中复句的相关概念在维基百科上有複文&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;Wikipedians. 複文. Wikipedia, Wikimedia Foundation, 16 Apr. 2018, ja.wikipedia.org/wiki/複文.
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;和節&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;Wikipedians. 節 (文法). Wikipedia, Wikimedia Foundation, 18 Apr. 2018, ja.wikipedia.org/wiki/節_(文法).
&quot;&gt;[2]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;等。&lt;br&gt;区别简单句和复合句的主要标志是看它主谓关系的次数，主谓关系在语法上仅成立一次的句子叫做单句。反之，句中有两层或两层以上主谓关系的就可成为复合句。简单句与复合句的区别决不是以句子长短、单词多少而定。常常是句子很长的是简单句；句子很短，但具有两层以上主谓关系的都是复合句。&lt;/p&gt;</summary>
    
    
    
    <category term="humanities" scheme="https://blog.xuwei.fun/categories/humanities/"/>
    
    <category term="languages" scheme="https://blog.xuwei.fun/categories/humanities/languages/"/>
    
    
    <category term="japanese" scheme="https://blog.xuwei.fun/tags/japanese/"/>
    
  </entry>
  
  <entry>
    <title>日语学习第七讲</title>
    <link href="https://blog.xuwei.fun/2018/06/18/japanese08/"/>
    <id>https://blog.xuwei.fun/2018/06/18/japanese08/</id>
    <published>2018-06-18T12:00:35.000Z</published>
    <updated>2021-03-07T12:23:26.447Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章介绍了日语的语气，这一篇Kino将要讲解日语的敬语系统。<br>日语敬语是日语中用于表达敬意的表达方式，用来表示说话者、说话对象、话中人物之间的社会阶级、亲疏等关系。出席使用日语的许多社交场合必须使用敬语，以表达适当的身份关系和礼貌。<br>现代日语敬语的分类研究<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="姚莉萍. 现代日语敬语的分类研究. 日语学习与研究 3(1996):6-10.">[1]</span></a></sup> 中介绍了几种日语的分类方式，包括以敬意形式进行的分类和待遇表现进行的分类。而现在常用的分类方法还是按照前者进行分类的，一般可分为丁宁语（礼貌语）、尊敬语和谦逊语三大类。有时丁宁语也可以再另分出郑重语和美化语两类敬语。说话人会根据谈话内容以及对象，而使用相关的辞汇或是动词变形。<br>根据相关参考资料如日语语法指南<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Tae, and Pizza. 敬语和动词词根. 日语语法指南 | Learn Japanese, http://res.wokanxing.info/jpgramma/polite.html.">[2]</span></a></sup>、维基百科<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. 日語敬語. Wikipedia, Wikimedia Foundation, 7 June 2018, https://zh.wikipedia.org/wiki/日語敬語.">[3]</span></a></sup>、日语敬语<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="三吉礼子. 日语敬语. 北京大学出版社, 2006.">[4]</span></a></sup>、试论日语敬语现象<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="桑凤平. 试论日语敬语现象. 外语与外语教学 8(2001):21-23.">[5]</span></a></sup>、日语敬语的常见错误分析<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="杜玲莉. 日语敬语的常见错误分析. 东北亚外语研究 6(2004):7-8.">[6]</span></a></sup>对敬体的几大类进行介绍。</p><span id="more"></span><h2 id="1-丁宁语"><a href="#1-丁宁语" class="headerlink" title="1. 丁宁语"></a>1. 丁宁语</h2><p>表示客气、礼貌、文雅、郑重的语言，叫丁宁语，丁宁语是代表说话人礼貌的敬语，代表尊重听话对象。<br>丁宁语反映在句尾，根据句尾的不同，有以下两种情况:</p><h3 id="1-1-句尾是动词"><a href="#1-1-句尾是动词" class="headerlink" title="1.1 句尾是动词"></a>1.1 句尾是动词</h3><p>将动词变为一类い形活用词根，之后再句尾加「ます」。<br>此外，考虑极性和时轴，「ます」形有相应变化:</p><ul><li>肯定现在: 「ます」</li><li>否定现在: 「ません」</li><li>肯定过去: 「ました」</li><li>否定过去: 「ませんでした」</li></ul><h3 id="1-2-句尾是名词、形容词"><a href="#1-2-句尾是名词、形容词" class="headerlink" title="1.2 句尾是名词、形容词"></a>1.2 句尾是名词、形容词</h3><p>句尾若是有「だ」，将「だ」除去，之后在句尾加「です」。<br>考虑极性和时轴，「です」形也有不同变化。</p><p align="center">表1 い形容词结尾</p><table><thead><tr><th align="center"></th><th align="center">口语</th><th align="center">丁宁语</th></tr></thead><tbody><tr><td align="center">肯定现在</td><td align="center">かわいい</td><td align="center">かわいいです</td></tr><tr><td align="center">否定现在</td><td align="center">かわいくない</td><td align="center">かわいくないです</td></tr><tr><td align="center">肯定过去</td><td align="center">かわいかった</td><td align="center">かわいかったです</td></tr><tr><td align="center">否定过去</td><td align="center">かわいくなかった</td><td align="center">かわいくなかったです</td></tr></tbody></table><p align="center">表2 な形容词或名词结尾</p><table><thead><tr><th align="center"></th><th align="center">口语</th><th align="center">丁宁语</th></tr></thead><tbody><tr><td align="center">肯定现在</td><td align="center">静か（だ）</td><td align="center">静かです</td></tr><tr><td align="center">否定现在</td><td align="center">静かじゃない</td><td align="center">静かじゃないです</td></tr><tr><td align="center">肯定过去</td><td align="center">静かだった</td><td align="center"><strong>静かでした</strong></td></tr><tr><td align="center">否定过去</td><td align="center">静かじゃなかった</td><td align="center">静かじゃなかったです</td></tr></tbody></table><h3 id="1-3-否定情况下的另一种表达"><a href="#1-3-否定情况下的另一种表达" class="headerlink" title="1.3 否定情况下的另一种表达"></a>1.3 否定情况下的另一种表达</h3><p>上述否定形的丁宁语不是「官方」的正确活用。更加「正确」的活用形应该是把「ないです」部分改为「ありません」，理由是动词「ある」的丁宁未然形不是「ないです」而是「ありません」。所以，「かわいくない」应该写作「かわいくありません」，「静かじゃない」则应该是「静かじゃありません」。<br>实际上，这种所谓的「官方」用法听起来太过呆板和正式。在日常对话中，大家基本用的都是上述介绍的形式，虽然在用丁宁语写作时应该用更加正式的活用形，但日常说话几乎用不到。</p><h3 id="1-4-特殊词"><a href="#1-4-特殊词" class="headerlink" title="1.4 特殊词"></a>1.4 特殊词</h3><p>有一些词汇的丁宁语版本完全是另外一个词汇，主要有:</p><ul><li>「ある」: 「ござる」，「ござる」总是以「ます」形出现，即「ございます」</li><li>「です」: 「でございます」，其实就是「でござる」的「ます」形活用，从「である」而来，字面意思是「以…的形式存在」</li><li>「いい」: 「よろしい」是更正式的表达方式</li><li>「さん」: 「様」，这个后缀在口语里面不常用到，即使在说尊敬语或谦逊语。不过，写信的时候一般会用到它，即使对方是熟人也一样。还有服务行业例如收银员或服务员通常会称呼客户为「お客様」。当然了，皇族和神灵一定是会用「様」的，例如「神様」</li></ul><h2 id="2-尊敬语"><a href="#2-尊敬语" class="headerlink" title="2. 尊敬语"></a>2. 尊敬语</h2><p>对他人的行为、状态及有关事物等表示敬意的语言，尊敬语代表尊敬话题里施行行为的人。<br>话题提及社会阶级较高的人，例如长辈、师长、上司、客户等，便会使用尊敬语。提及说话人自身的时候，不用尊敬语。</p><h3 id="2-1-动词的尊敬语形式"><a href="#2-1-动词的尊敬语形式" class="headerlink" title="2.1 动词的尊敬语形式"></a>2.1 动词的尊敬语形式</h3><p>对动作主体表示尊敬有四个方法。</p><h4 id="2-1-1-用特殊尊敬语动词"><a href="#2-1-1-用特殊尊敬语动词" class="headerlink" title="2.1.1 用特殊尊敬语动词"></a>2.1.1 用特殊尊敬语动词</h4><p>和一般用语完全不一样。例如动词「する」，尊敬语动词则为「なさる」。动词「話す」，尊敬语动词则为「おっしゃる」。</p><h4 id="2-1-2-使用「お……になる」句型"><a href="#2-1-2-使用「お……になる」句型" class="headerlink" title="2.1.2 使用「お……になる」句型"></a>2.1.2 使用「お……になる」句型</h4><p>一般没有相应尊敬语的动词，也可以换成「一类い形活用词根」，前加「お」、后加「になる」，使之成为尊敬语。例如「読む」，尊敬语可以用「お読みになる」。<br>也可以用「下さい」替代「になる」。当你想用尊敬语动词请别人做什么的时候，这种表达很有用。</p><h4 id="2-1-3-使用「お……です」句型"><a href="#2-1-3-使用「お……です」句型" class="headerlink" title="2.1.3 使用「お……です」句型"></a>2.1.3 使用「お……です」句型</h4><p>将一般动词换成「一类い形活用词根」，前加「お」、后加「です」，也成为尊敬语。例如「読む」，尊敬语可以用「お読みです」。</p><h4 id="2-1-4-动词被动形也可以当尊敬语使用"><a href="#2-1-4-动词被动形也可以当尊敬语使用" class="headerlink" title="2.1.4 动词被动形也可以当尊敬语使用"></a>2.1.4 动词被动形也可以当尊敬语使用</h4><p>「読みましたか」，尊敬语亦可说成「読まれましたか」</p><h3 id="2-2-名词形容词的尊敬语形式"><a href="#2-2-名词形容词的尊敬语形式" class="headerlink" title="2.2 名词形容词的尊敬语形式"></a>2.2 名词形容词的尊敬语形式</h3><p>除了动词外，部分名词也有尊敬语。例如「その人」，尊敬语是「その方」。一般情况下，大部分名词前可以加上词头表示尊敬。<br>日语固有词即訓読み单词通常加「お」，例如「お顔」、「お話」，汉字词即音読み单词通常加「ご」，例如「ご冗談」、「ご両親」。如写成汉字，两者均作「御」。<br>部分形容词也加上「お」、「ご」做成尊敬语，规则与名词类似。例如「お忙しい」、「お元気」、「ご満足」。</p><h2 id="3-谦逊语"><a href="#3-谦逊语" class="headerlink" title="3. 谦逊语"></a>3. 谦逊语</h2><p>谦逊语又称谦让语，说话人通过谦虚地讲述、甚至是贬低话题中行为主体的动作，用来对接受行为的人表示尊敬。行为主体是说话人自身的时候，也可以用谦让语。</p><h2 id="3-1-用特殊谦逊语动词"><a href="#3-1-用特殊谦逊语动词" class="headerlink" title="3.1 用特殊谦逊语动词"></a>3.1 用特殊谦逊语动词</h2><p>谦逊语可以用特殊词汇来表示，例如自有一套动词。一般例如动词「する」，谦让语动词则为「いたす」。一般动词「話す」，谦让语动词则为「申す」。</p><h2 id="3-2-使用「お-x2F-ご……する-x2F-いたす-x2F-申し上げる」句型"><a href="#3-2-使用「お-x2F-ご……する-x2F-いたす-x2F-申し上げる」句型" class="headerlink" title="3.2 使用「お&#x2F;ご……する&#x2F;いたす&#x2F;申し上げる」句型"></a>3.2 使用「お&#x2F;ご……する&#x2F;いたす&#x2F;申し上げる」句型</h2><p>另外，如果没有相对的谦逊动词，可以使用「お&#x2F;ご……する&#x2F;いたす&#x2F;申し上げる」句型。一般动词换成「一类い形活用词根」，前加「お」或「ご」、后加「する」或「いたす」，便可成为谦让语，「いたす」实际上又是「する」的谦逊语。例如「持つ」，谦让语可以说成「お持ちする」，「案内する」谦让语可以说成「ご案内する」。</p><h2 id="3-3-注意事项"><a href="#3-3-注意事项" class="headerlink" title="3.3 注意事项"></a>3.3 注意事项</h2><p>部分谦逊语已经成为固有短语，例如「いただく」本为「もらう」的谦逊语，但这个动词的丁宁语体「いただきます」则是吃喝之前所说的寒暄话。</p><h2 id="4-特殊动词"><a href="#4-特殊动词" class="headerlink" title="4. 特殊动词"></a>4. 特殊动词</h2><h3 id="4-1-特殊尊敬语和特殊谦逊语"><a href="#4-1-特殊尊敬语和特殊谦逊语" class="headerlink" title="4.1 特殊尊敬语和特殊谦逊语"></a>4.1 特殊尊敬语和特殊谦逊语</h3><p>这里列出一些尊敬语和谦逊语与一般用语完全不一样的动词。</p><p align="center">表3 尊敬语和谦逊语</p><table><thead><tr><th align="center">字典形</th><th align="center">尊敬语</th><th align="center">谦逊语</th></tr></thead><tbody><tr><td align="center">する</td><td align="center">なさる</td><td align="center">致す</td></tr><tr><td align="center">行く</td><td align="center">いらっしゃる／おいでになる</td><td align="center">参る</td></tr><tr><td align="center">来る</td><td align="center">いらっしゃる／おいでになる</td><td align="center">参る</td></tr><tr><td align="center">いる</td><td align="center">いらっしゃる／おいでになる</td><td align="center">おる</td></tr><tr><td align="center">見る</td><td align="center">ご覧になる</td><td align="center">拝見する</td></tr><tr><td align="center">聞く</td><td align="center">－</td><td align="center">伺う</td></tr><tr><td align="center">言う</td><td align="center">おっしゃる</td><td align="center">申す／申し上げる</td></tr><tr><td align="center">あげる</td><td align="center">－</td><td align="center">差し上げる</td></tr><tr><td align="center">くれる</td><td align="center">下さる</td><td align="center">－</td></tr><tr><td align="center">もらう</td><td align="center">－</td><td align="center">いただく</td></tr><tr><td align="center">食べる</td><td align="center">召し上がる</td><td align="center">いただく</td></tr><tr><td align="center">飲む</td><td align="center">召し上がる</td><td align="center">いただく</td></tr><tr><td align="center">知っている</td><td align="center">ご存知（です）</td><td align="center">存じる</td></tr></tbody></table><h3 id="4-2-特殊尊敬语和特殊谦逊语的活用规则"><a href="#4-2-特殊尊敬语和特殊谦逊语的活用规则" class="headerlink" title="4.2 特殊尊敬语和特殊谦逊语的活用规则"></a>4.2 特殊尊敬语和特殊谦逊语的活用规则</h3><p>在使用特殊尊敬语和特殊谦逊语基础之上，还可以对这些动词使用丁宁语的规则。<br>但这些动词很多并不遵循普通的ます活用规则，包括「なさる」、「いらっしゃる」、「おっしゃる」、「下さる」和「ござる」。对这些东西要改写为ます形的话，不是像う动词那样把「る」变为「り」，而是要变为「い」。除了ます形，它们的其他活用规则跟普通う动词一样。</p><p align="center">表4 尊敬语和谦逊语的特殊活用规则</p><table><thead><tr><th align="center">字典形</th><th align="center">ます形</th><th align="center">过去ます形</th><th align="center">未然ます形</th><th align="center">过去未然ます形</th></tr></thead><tbody><tr><td align="center">なさる</td><td align="center">なさいます</td><td align="center">なさいました</td><td align="center">なさいません</td><td align="center">なさいませんでした</td></tr><tr><td align="center">いらっしゃる</td><td align="center">いらっしゃいます</td><td align="center">いらっしゃいました</td><td align="center">いらっしゃいません</td><td align="center">いらっしゃいませんでした</td></tr><tr><td align="center">おっしゃる</td><td align="center">おっしゃいます</td><td align="center">おっしゃいました</td><td align="center">おっしゃいません</td><td align="center">おっしゃいませんでした</td></tr><tr><td align="center">下さる</td><td align="center">下さいます</td><td align="center">下さいました</td><td align="center">下さいません</td><td align="center">下さいませんでした</td></tr><tr><td align="center">ござる</td><td align="center">ございます</td><td align="center">ございました</td><td align="center">ございません</td><td align="center">ございませんでした</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇主要讲解了日语的敬语系统，下一篇将讲解日语中的复合句。</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">姚莉萍. 现代日语敬语的分类研究. 日语学习与研究 3(1996):6-10.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Tae, and Pizza. 敬语和动词词根. 日语语法指南 | Learn Japanese, http://res.wokanxing.info/jpgramma/polite.html.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. 日語敬語. Wikipedia, Wikimedia Foundation, 7 June 2018, https://zh.wikipedia.org/wiki/日語敬語.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">三吉礼子. 日语敬语. 北京大学出版社, 2006.<a href="#fnref:4" rev="footnote">↩</a></span></li><li id="fn:5"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">桑凤平. 试论日语敬语现象. 外语与外语教学 8(2001):21-23.<a href="#fnref:5" rev="footnote">↩</a></span></li><li id="fn:6"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">杜玲莉. 日语敬语的常见错误分析. 东北亚外语研究 6(2004):7-8.<a href="#fnref:6" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇文章介绍了日语的语气，这一篇Kino将要讲解日语的敬语系统。&lt;br&gt;日语敬语是日语中用于表达敬意的表达方式，用来表示说话者、说话对象、话中人物之间的社会阶级、亲疏等关系。出席使用日语的许多社交场合必须使用敬语，以表达适当的身份关系和礼貌。&lt;br&gt;现代日语敬语的分类研究&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;姚莉萍. 现代日语敬语的分类研究. 日语学习与研究 3(1996):6-10.
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt; 中介绍了几种日语的分类方式，包括以敬意形式进行的分类和待遇表现进行的分类。而现在常用的分类方法还是按照前者进行分类的，一般可分为丁宁语（礼貌语）、尊敬语和谦逊语三大类。有时丁宁语也可以再另分出郑重语和美化语两类敬语。说话人会根据谈话内容以及对象，而使用相关的辞汇或是动词变形。&lt;br&gt;根据相关参考资料如日语语法指南&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;Tae, and Pizza. 敬语和动词词根. 日语语法指南 | Learn Japanese, http://res.wokanxing.info/jpgramma/polite.html.
&quot;&gt;[2]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;、维基百科&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;Wikipedians. 日語敬語. Wikipedia, Wikimedia Foundation, 7 June 2018, https://zh.wikipedia.org/wiki/日語敬語.
&quot;&gt;[3]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;、日语敬语&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;三吉礼子. 日语敬语. 北京大学出版社, 2006.
&quot;&gt;[4]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;、试论日语敬语现象&lt;sup id=&quot;fnref:5&quot;&gt;&lt;a href=&quot;#fn:5&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;桑凤平. 试论日语敬语现象. 外语与外语教学 8(2001):21-23.
&quot;&gt;[5]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;、日语敬语的常见错误分析&lt;sup id=&quot;fnref:6&quot;&gt;&lt;a href=&quot;#fn:6&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;杜玲莉. 日语敬语的常见错误分析. 东北亚外语研究 6(2004):7-8.
&quot;&gt;[6]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;对敬体的几大类进行介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="humanities" scheme="https://blog.xuwei.fun/categories/humanities/"/>
    
    <category term="languages" scheme="https://blog.xuwei.fun/categories/humanities/languages/"/>
    
    
    <category term="japanese" scheme="https://blog.xuwei.fun/tags/japanese/"/>
    
  </entry>
  
  <entry>
    <title>日语学习第六讲</title>
    <link href="https://blog.xuwei.fun/2018/06/18/japanese07/"/>
    <id>https://blog.xuwei.fun/2018/06/18/japanese07/</id>
    <published>2018-06-18T04:45:02.000Z</published>
    <updated>2021-03-07T12:23:34.512Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇介绍了日语的语态，这一篇文章开始讲述日语的语气。语气简单来说就是说话者对某一命题的主观意见和心里态度的总称。<br>王忻在日语语气再考(上)<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="王忻. 日语语气再考(上)[J]. 日语学习与研究, 2002(2):18-24.">[1]</span></a></sup>和日语语气再考(下)<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="王忻. 日语语气再考(下)[J]. 日语学习与研究, 2002(3):18-24.">[2]</span></a></sup>中对日语语气进行了详细的研究，刘峰在日语语气概论<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="刘峰. 日语语气概论(モダリティ)[J]. 科教文汇(上旬刊), 2010(2):141-142.">[3]</span></a></sup>中也对日语语气进行了简要说明，日语语法专题教程<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.">[4]</span></a></sup>中有单独一章介绍语气。<br>本篇将结合这些资料，对语气进行相关说明。</p><span id="more"></span><h2 id="1-语气概述"><a href="#1-语气概述" class="headerlink" title="1. 语气概述"></a>1. 语气概述</h2><h3 id="1-1-命题与语气的对立"><a href="#1-1-命题与语气的对立" class="headerlink" title="1.1 命题与语气的对立"></a>1.1 命题与语气的对立</h3><p>日语的句子(话语)在语义和句法结构的关系上，大体呈现出表现客观语义的“叙述素材”和表达主观语义的“句子的叙述方式”两个层面，前者称为“命题内容”，日语为“言表事态”，下文简称为“命题”，后者称为“语气”，日语为“言表态度”，即日语的句子由“命题”与“语气”这两个性质不同的部分构成。具体来说，所谓命题，是指说话人在句中所表述的、与说话人主观思维相分离的客观事实；所谓语气，是指说话人在说话时从说话人的立场出发、主观性地对命题的把握方法和态度。通过两者的对立统一，构成句子的意义结构。</p><h3 id="1-2-命题与语气的界定与位置"><a href="#1-2-命题与语气的界定与位置" class="headerlink" title="1.2 命题与语气的界定与位置"></a>1.2 命题与语气的界定与位置</h3><p>虽说句子是由命题和语气两部分组成的，但并不是说句子等于命题和语气两部分的简单相加。也就是说命题与语气并不是并列关系，而是一种包容关系：{[命题]语气}<br>从作为语气载体的语法形式上来看，命题和语气还是应该能够划分并有自己的位置的。一般说来:</p><ul><li>命题部分包括主语部分和谓语部分中的体、认定方式、态、时等。</li><li>语气部分包括谓语活用形、系词(即“コピュラ”，在传统语法中称为助动词)及形式名词、终助词&#x2F;特提助词&#x2F;陈述副词&#x2F;感叹词和接续词等等。另外敬语表达形式也应包括其中。</li></ul><p>语气的位置是多种多样的，它因种类和词类不同而定。语气表现形式出现在句子尾部的频率大大高于其它位置。<br>王忻在日语语气再考(上)<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="王忻. 日语语气再考(上)[J]. 日语学习与研究, 2002(2):18-24.">[1]</span></a></sup>归纳为: 任意一个句子都应有表现语气的部分(尽管有时可能很难清楚地划分出来)，它在句中的位置不定，但句子的后部必然是语气。<br>此外，一个句子有两处以上出现语气时，就应把它们分为主要语气和次要语气等来考察。</p><h2 id="2-语气的分类"><a href="#2-语气的分类" class="headerlink" title="2. 语气的分类"></a>2. 语气的分类</h2><p>与语气研究有关的分类可归纳为两大类，一种是对各种不同语气的句子类型进行的分类，一种是对语气载体（表现语气的语法形式）的分类。前者是从句子语一气的类型入手，在对这些类型进行分析的过程中涉及到构成这些语气的“构件”——表现语气的语法形式。后者与前者方向相反，是从这些“构件”入手，对这些“构件”构成的语气进行归纳研究的。</p><h3 id="2-1-不同语气类型的分类"><a href="#2-1-不同语气类型的分类" class="headerlink" title="2.1 不同语气类型的分类"></a>2.1 不同语气类型的分类</h3><h4 id="2-1-1-经典分类"><a href="#2-1-1-经典分类" class="headerlink" title="2.1.1 经典分类"></a>2.1.1 经典分类</h4><p>日语语气再考(上)<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="王忻. 日语语气再考(上)[J]. 日语学习与研究, 2002(2):18-24.">[1]</span></a></sup>和日语语法专题教程<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.">[4]</span></a></sup>中列出了已有的几种较为代表性的分类，包括:</p><ul><li>高桥太郎等(2001)编著的《日本語の文法2001》中的分类</li><li>仁田义雄(1997)在《日本語のモダリティと人称》中的分类</li><li>奥田靖雄(1996)在《文のことーその分类をめぐってー》中的分类</li><li>寺村秀夫(1982)在《日本語のシンタクスと意味》中的分类</li><li>益冈隆志(2000)在《日本語の文法诸相》中的分类</li><li>森山卓郎(2000)在《日本語の文法3モダリテイ》中的分类</li><li>井上优在(2006)在《シリーズ方言学2方言の文法》中的分类</li></ul><h4 id="2-1-2-详解两种分类"><a href="#2-1-2-详解两种分类" class="headerlink" title="2.1.2 详解两种分类"></a>2.1.2 详解两种分类</h4><h5 id="2-1-2-1-第一种分类方式"><a href="#2-1-2-1-第一种分类方式" class="headerlink" title="2.1.2.1 第一种分类方式"></a>2.1.2.1 第一种分类方式</h5><p>日语语气概论<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="刘峰. 日语语气概论(モダリティ)[J]. 科教文汇(上旬刊), 2010(2):141-142.">[3]</span></a></sup>中将语气类型分为四类:<br>1. 反映句子所表达内容的功能语气。<br>这是决定句子最基本性质的语气，其有两种类型：信息类与行为类。它们都属于表现类型的语气。<br>信息类语气就承担着向听者传达信息（叙述语气）以及从听者那里获取信息的功能（疑问语气）。</p><blockquote><p>例: 昨日上海に行った(叙述语气，礼貌语气)<br>例: 明日休むか(疑问语气，非礼貌语气)</p></blockquote><p>行为类语气承担着说话者和听话者的行为实现的机能，其中又分为说话者自身行为实现（意志型语气），说话者以自己的行为实现为前提，要求对方也实现某种行为（劝诱语气），要求对方实现某种行为（行为要求语气）。</p><blockquote><p>例: 美味しいな、やっぱり食べようか(意志形语气)<br>例: 仕事もう終わっただろう、じゃ、一緒に帰ろう(劝诱语气)<br>例: 部屋が散らかってるぞ、速く片付けろ(行为要求语气)</p></blockquote><p>2. 针对命题的把握方法的语气。<br>该语气是说话者对于命题内容的把握方式，有两种语气类型：评价语气和认知语气。<br>评价语气是对命题所表达的事象做出的必要、不必要 或者允许、不允许的评价式表达。</p><blockquote><p>例: この仕事を引き受けた以上さ、 最後までやらなくてはならない. 句中的なくてはならない是说话者对やる这个事象是必要的一种评价的表达。<br>例: ここにある飲み物は自由に取ってもいい. 句中的てもいい是表示对取る这个事象是被许可的一种评价的表达。</p></blockquote><p>认知语气在认知的把握方法上，有对命题的基本认知态度，如断 定、推量、对命题成立的可能性、必然性的认知，通过证据来对命题进行把握的表示推断、传闻等语气。</p><blockquote><p>例: 上海は今雪を降っているだろう(推量的语气)<br>例: 今晩、風が吹くかもしれない(可能性的语气)<br>例: 道は濡れているから、 昨夜雨が降っていたようだ(推定的语气)<br>例: 天気予報によると、明日も雨が降るそうだ(传闻的语气)</p></blockquote><p>3. 表示上下文之间关系的语气。<br>该语气称为说明语气，通过提示上下文之间的关系使得听话者对所叙内容更易理解。</p><blockquote><p>例: 遅くなってすみません、 いきなり社長から電話をもらったんだ(说明语气)</p></blockquote><p>4. 表示对听话者的语气。<br>由于语言交流是双方相互进行的，因此，除了说话这自身对命题主观表达外，还有向听话者表示传达的义务，像这类语气称之为对听话者语气。对听话者语气中有两种语气类型：传达态度和礼貌的语气。<br>礼貌体与普通体的选择，要根据双方的年龄、地位、场合等来决定。</p><blockquote><p>例: 昨日、スーパーへ買い物に行った(普通体语气)<br>例: 昨日、スーパーへ買い物に行きました(礼貌体语气)</p></blockquote><p>传达态度语气是向对方传达时在语气上所做的一些细微调整等,传达态度语气通常会用よ、 ね、 わ这种语气终助词来表达。</p><blockquote><p>例: 仕事はストレスがいっぱい溜まっているなあ<br>例: ね、本、ここにあるよ、何で見つからないの?</p></blockquote><p>表示传达的语气既有向对方传达的意图也有自言自语的场合，如なあ多用于自言自语的场合。</p><h5 id="2-1-2-2-第二种分类方式"><a href="#2-1-2-2-第二种分类方式" class="headerlink" title="2.1.2.2 第二种分类方式"></a>2.1.2.2 第二种分类方式</h5><p>日语语法专题教程<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.">[4]</span></a></sup>采用了井上优在「シリーズ方言学2方言の文法」(岩波書店,2006)中对语气的分类。Kino在这里也j简要介绍一下。主要分为两大类: “说话者对命题内容的判断”和“对听话者的发话态度和传递态度”。<br>1. 说话者对命题内容的判断<br>即“判断性语气”、“对事性语气”、“命题指向性语气”，包括“真伪判断性语气”和“价值判断语气”。</p><ul><li>真伪判断语气主要包括断定、推量、概然性判断、证据性判断、当然性判断、传闻、说明等语气</li><li>价值判断语气主要有“适当适度”、“必要”、“容许认可”三类语气</li></ul><p>2. 对听话者的发话态度和传递态度<br>即“发话传递语气”、“对人性语气”、“听话者指向性语气”，包括“描述判断”、“表抒”、“号令”、“疑问、询问、确认”、“强调”等。</p><h3 id="2-2-不同语气载体的分类"><a href="#2-2-不同语气载体的分类" class="headerlink" title="2.2 不同语气载体的分类"></a>2.2 不同语气载体的分类</h3><p>所谓语气载体即表达各种语气的语法形式，如用言活用形、系词、形式名词、特提助词等。<br>在日语语法专题教程<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.">[4]</span></a></sup>中，作者按照语气载体的方式将日语中语气的表达方式主要分为四类:</p><ul><li>述语的活用形及其他附着在述语上的语法形式</li><li>副词的使用</li><li>感叹词和间投助词的使用(这里间投助词的意思是“加在语句和语句、句子中间的助词”，即在句节后通过停顿提示听话者，以表达说话者感叹等语气的助词)</li><li>句尾语调</li></ul><p>而王忻在日语语气再考(上)<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="王忻. 日语语气再考(上)[J]. 日语学习与研究, 2002(2):18-24.">[1]</span></a></sup>和日语语气再考(下)<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="王忻. 日语语气再考(下)[J]. 日语学习与研究, 2002(3):18-24.">[2]</span></a></sup>中将语气载体按与命题的距离分为三个级次。下面简要说明一下。</p><h4 id="2-2-1-第一级语气"><a href="#2-2-1-第一级语气" class="headerlink" title="2.2.1 第一级语气"></a>2.2.1 第一级语气</h4><p>第一级语气是以活用形为手段表现的。具体活用形中的哪种形式表达何种语气基本如图1所示。</p><p><img src="/images/japanese07_1.png" alt="figure 1"></p><p align="center">图1 活用形表达的语气</p><p>本图除动词外还可适用于形容词，只是形容词没有劝诱形和命令形。</p><h4 id="2-2-2-第二级语气"><a href="#2-2-2-第二级语气" class="headerlink" title="2.2.2 第二级语气"></a>2.2.2 第二级语气</h4><p>第二级语气是接在表第一级确切语气的形式后，表明说话人对所述内容的态度的形式。在层次结构上它把命题+第一级语气作为一个整体对其进行包容。它由助动词和形式名词+だ的形式担当。<br>根据表意，本群词可分为表述推断事实的推测语气者、表述解释说明的说明语气者和表说话人心中认为“可否”、“愿否”的语气这三小类。前者主要由助动词担任，中者由“形式体言+だ”的形式担当，后者主要由形容词性短语担当。</p><h4 id="2-2-3-第三级语气"><a href="#2-2-3-第三级语气" class="headerlink" title="2.2.3 第三级语气"></a>2.2.3 第三级语气</h4><p>第三级语气的表现形式由特提(取リ立て)助词，陈述副词、终助词、感叹词、部分接续词和敬语等形式担当<br>其中除特提助词(把句子中某些成分特别提出加以强调来表达某种言外之意为特提)、陈述副词是表示对事性语气以外其余均表示对人性语气。<br>与第一级、第二级语气相比，第三级语气的最大特点是位置相对不稳定，第一级语气活用形处于谓语位置，第二级语气系 词又是紧随活用形之后，位置都比较固定，而第三级语气因成分复杂等原因位置也就不固定了。<br>从词类来看表现对人性语气的终助词、感叹词和接续词位置相对稳定，终助词在句尾，感叹词一 般在句首，接续词则在下句之前。但敬语和表现对事性语气的特提助助词的位置就难以如此简单地划定了。</p><h2 id="3-特殊用法"><a href="#3-特殊用法" class="headerlink" title="3. 特殊用法"></a>3. 特殊用法</h2><p>将一个句子全部用片假名书写，用来表示惊讶、敌意等强烈的语气。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章主要阐述了日语的语气，下一篇将讲解日语中的敬体。</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">王忻. 日语语气再考(上)[J]. 日语学习与研究, 2002(2):18-24.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">王忻. 日语语气再考(下)[J]. 日语学习与研究, 2002(3):18-24.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">刘峰. 日语语气概论(モダリティ)[J]. 科教文汇(上旬刊), 2010(2):141-142.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.<a href="#fnref:4" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇介绍了日语的语态，这一篇文章开始讲述日语的语气。语气简单来说就是说话者对某一命题的主观意见和心里态度的总称。&lt;br&gt;王忻在日语语气再考(上)&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;王忻. 日语语气再考(上)[J]. 日语学习与研究, 2002(2):18-24.
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;和日语语气再考(下)&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;王忻. 日语语气再考(下)[J]. 日语学习与研究, 2002(3):18-24.
&quot;&gt;[2]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;中对日语语气进行了详细的研究，刘峰在日语语气概论&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;刘峰. 日语语气概论(モダリティ)[J]. 科教文汇(上旬刊), 2010(2):141-142.
&quot;&gt;[3]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;中也对日语语气进行了简要说明，日语语法专题教程&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.
&quot;&gt;[4]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;中有单独一章介绍语气。&lt;br&gt;本篇将结合这些资料，对语气进行相关说明。&lt;/p&gt;</summary>
    
    
    
    <category term="humanities" scheme="https://blog.xuwei.fun/categories/humanities/"/>
    
    <category term="languages" scheme="https://blog.xuwei.fun/categories/humanities/languages/"/>
    
    
    <category term="japanese" scheme="https://blog.xuwei.fun/tags/japanese/"/>
    
  </entry>
  
  <entry>
    <title>日语学习第五讲</title>
    <link href="https://blog.xuwei.fun/2018/06/03/japanese06/"/>
    <id>https://blog.xuwei.fun/2018/06/03/japanese06/</id>
    <published>2018-06-03T13:46:33.000Z</published>
    <updated>2021-03-07T12:23:41.818Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇叙述了日语中的体，这篇文章Kino将讲解日语中的态。<br>语态指在动词做述语的句子中，述语动词和主语的关系，即主语所表示的人物、事物是述语动词所表示的动作、作用的执行者还是承受者，是促进动作进行的人还是具备能力进行动作的人。<br>通常认为日语有五种语态<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="yueaegis9. “日语五种语态” 百度文库, 13 Jan 2011, https://wenku.baidu.com/view/ff190636ee06eff9aef807e5.html.">[1]</span></a></sup>, 不过这五种本身是建立在无任何变形的基本语态的基础上, 这种基本语态当然也得算作语态的一种, 可以被称为: 能动态&#x2F;主动态.</p><span id="more"></span><h2 id="1-主动态"><a href="#1-主动态" class="headerlink" title="1. 主动态"></a>1. 主动态</h2><p>从施动者的角度叙述其动作、作用时，使用主动语态。述语动词就是基本形式即可。</p><h2 id="2-被动态"><a href="#2-被动态" class="headerlink" title="2. 被动态"></a>2. 被动态</h2><p>被动态表示主语是动作的承受者。从动作承受者的角度，叙述其受到、遭受的动作、作用时，使用被动语态。<br>被动态由述语动词后续助动词「(ら)れる」构成，不同类型的动词构成方式不同，具体为:</p><ul><li>五段动词的未然形+れる</li><li>一段动词的未然形+られる</li><li>する的被动态: せられる，约音形: される</li><li>くる的被动态: こられる</li></ul><p>示例:</p><ul><li>Eg. 学生は先生に褒められた</li><li>Eg. 雨に降られて、風邪を引いた</li></ul><h2 id="3-使役态"><a href="#3-使役态" class="headerlink" title="3. 使役态"></a>3. 使役态</h2><p>当叙述某个人引起了某个事态或强制、支使、允许他人进行了某个动作时，使用使役态。<br>使役态由述语动词后续助动词「(さ)せる」构成，不同类型的动词构成方式也不同，具体为:</p><ul><li>五段动词的未然形+せる</li><li>一段动词的未然形+させる</li><li>する的使役态: せさせる，约音形: させる</li><li>くる的使役态: こさせる</li></ul><p>示例:</p><ul><li>Eg. わたしは娘を自由に遊ばせました</li><li>Eg. 先生は学生に自由に意見を言わせました</li></ul><h2 id="4-被役态"><a href="#4-被役态" class="headerlink" title="4. 被役态"></a>4. 被役态</h2><p>又叫使役被动态。当叙述某个人受到别人的强迫，不得已、被迫做某事时，使用使役被动态。<br>被役态由述语动词后续助动词「(さ)せられる」构成，不同类型的动词构成方式也不同，具体为:</p><ul><li>五段动词的未然形+せられる</li><li>一段动词的未然形+させられる</li><li>する的被役态: させられる</li><li>くる的被役态: こさせられる</li></ul><p>示例:</p><ul><li>Eg. 私は母に宿題をさせられます</li></ul><h2 id="5-可能态"><a href="#5-可能态" class="headerlink" title="5. 可能态"></a>5. 可能态</h2><p>当叙述某人具有某种能力、技能或某事具有发生的条件、可能性时，使用可能态。可能态的构成方式比较多，主要有以下五种。</p><h3 id="5-1-使用可能助动词"><a href="#5-1-使用可能助动词" class="headerlink" title="5.1 使用可能助动词"></a>5.1 使用可能助动词</h3><p>在述语动词后面接续可能助动词「(ら)れる」，不同类型的动词接续方式也不同，具体为:</p><ul><li>五段动词的未然形+れる</li><li>一段动词的未然形+られる</li><li>くる的可能态: こられる<h3 id="5-2-使用可能动词"><a href="#5-2-使用可能动词" class="headerlink" title="5.2 使用可能动词"></a>5.2 使用可能动词</h3>把五段动词变成对应行的下一段动词，例如把「歩く」变成「歩ける」，把「読む」变成「読める」等。五段动词在实际的使用中多使用其对应的可能动词，而不是后续可能助动词。<h3 id="5-3-使用「できる」"><a href="#5-3-使用「できる」" class="headerlink" title="5.3 使用「できる」"></a>5.3 使用「できる」</h3>包括以下三种情况:</li><li>「する」变为「できる」，「<del>する」变为「</del>できる」</li><li>名词+ができる</li><li>动词原形+ことができる<h3 id="5-4-使用带有可能意义的自动词"><a href="#5-4-使用带有可能意义的自动词" class="headerlink" title="5.4 使用带有可能意义的自动词"></a>5.4 使用带有可能意义的自动词</h3>「分かる」「見える」「聞こえる」等动词本身带有可能的意义，不需要形式变化。<h3 id="5-5-使用接尾动词「うる」"><a href="#5-5-使用接尾动词「うる」" class="headerlink" title="5.5 使用接尾动词「うる」"></a>5.5 使用接尾动词「うる」</h3>在动词的连用形后面接续接尾词「うる」，如「考えうる」「ありうる」等。</li></ul><h2 id="6-自发态"><a href="#6-自发态" class="headerlink" title="6. 自发态"></a>6. 自发态</h2><p>当叙述动作自然发生或感情不可抑制时，使用自发态。<br>自发态的构成方式有三种。</p><h3 id="6-1-使用自发助动词"><a href="#6-1-使用自发助动词" class="headerlink" title="6.1 使用自发助动词"></a>6.1 使用自发助动词</h3><p>在表示感情、思想活动的述语动词后面接续自发助动词「(ら)れる」，不同类型的动词接续方式也不同，具体有:</p><ul><li>五段动词的未然形+れる</li><li>一段动词的未然形+られる</li><li>する的被动态: せられる，约音形: される<h3 id="6-2-使用可能动词"><a href="#6-2-使用可能动词" class="headerlink" title="6.2 使用可能动词"></a>6.2 使用可能动词</h3>「泣ける」「笑える」「思える」等<h3 id="6-3-使用带有可能意义的自动词"><a href="#6-3-使用带有可能意义的自动词" class="headerlink" title="6.3 使用带有可能意义的自动词"></a>6.3 使用带有可能意义的自动词</h3>「見える」「聞こえる」等</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文的例句选自日语五种语态<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="yueaegis9. “日语五种语态” 百度文库, 13 Jan 2011, https://wenku.baidu.com/view/ff190636ee06eff9aef807e5.html.">[1]</span></a></sup>、わかって使える日本語<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="名古屋YWCA教材作成グループ. わかって使える日本語―中級レベル[M]. スリーエーネットワーク, 2004. ">[2]</span></a></sup>等文献.<br>这篇文章主要介绍了日语的语态，可以看出这六种语态在语法上并不完全是平行的，如果从平行关系来考虑，Kino认为可以这样划分:</p><ul><li>主动、被动、自发态三种在一个层级</li><li>使役态单独一个层级</li><li>可能态单独一个层级</li></ul><p>只从语法的构成可能性上来说，这三种是可以自由组合的，比如被动使役态、被动可能态、自发使役态、自发可能态，只不过由于日语的语言习惯以及现实世界的因果关系等限制，最终实际能够组合的就是被动使役态.<br>下一篇文章将介绍日语的语气。</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">yueaegis9. “日语五种语态” 百度文库, 13 Jan 2011, https://wenku.baidu.com/view/ff190636ee06eff9aef807e5.html.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">名古屋YWCA教材作成グループ. わかって使える日本語―中級レベル[M]. スリーエーネットワーク, 2004.<a href="#fnref:2" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇叙述了日语中的体，这篇文章Kino将讲解日语中的态。&lt;br&gt;语态指在动词做述语的句子中，述语动词和主语的关系，即主语所表示的人物、事物是述语动词所表示的动作、作用的执行者还是承受者，是促进动作进行的人还是具备能力进行动作的人。&lt;br&gt;通常认为日语有五种语态&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;yueaegis9. “日语五种语态” 百度文库, 13 Jan 2011, https://wenku.baidu.com/view/ff190636ee06eff9aef807e5.html.
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;, 不过这五种本身是建立在无任何变形的基本语态的基础上, 这种基本语态当然也得算作语态的一种, 可以被称为: 能动态&amp;#x2F;主动态.&lt;/p&gt;</summary>
    
    
    
    <category term="humanities" scheme="https://blog.xuwei.fun/categories/humanities/"/>
    
    <category term="languages" scheme="https://blog.xuwei.fun/categories/humanities/languages/"/>
    
    
    <category term="japanese" scheme="https://blog.xuwei.fun/tags/japanese/"/>
    
  </entry>
  
  <entry>
    <title>日语学习第四讲</title>
    <link href="https://blog.xuwei.fun/2018/06/02/japanese05/"/>
    <id>https://blog.xuwei.fun/2018/06/02/japanese05/</id>
    <published>2018-06-02T11:49:08.000Z</published>
    <updated>2021-03-07T12:23:48.438Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="/2018/06/01/japanese04/">上一篇文章</a>介绍了极性和时轴，这一章主要介绍体的相关语法，体的概念在<a href="/2017/09/16/japanese01/#2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">第一篇文章</a>里已经介绍过，此处再介绍一遍: 体表示某个动作或变化在<strong>说话人所设的时间轴</strong>上处于开始、持续和完成状态中的某一阶段，是从时间角度上对动作和变化的描写或把握。<strong>需要注意的是在日语中体仅仅反映在动词上</strong><br>PS: 日语语法在”体”这方面的变化并不是那么明显, 虽然语法概念上可以分很细, 但实际需要进行特殊的变形转换的并不多, 更多的是靠上下文的时间轴来界定”体”的状态.</p><span id="more"></span><h2 id="1-完整体（完成相）"><a href="#1-完整体（完成相）" class="headerlink" title="1. 完整体（完成相）"></a>1. 完整体（完成相）</h2><p>完整体用以整体来描述某个动作或变化，把动词表示的运动从开始到结束的整个过程完整地表达出来，一般不涉及该动作或变化的中间过程。根据涉及的动作是出于“完了”这一界限达成前还是达成后，完整体被分为未成体和完成体两种。</p><h3 id="1-1-未成体"><a href="#1-1-未成体" class="headerlink" title="1.1 未成体"></a>1.1 未成体</h3><p>表示动作即将完成或者将来完成。动词不用做变化。</p><ul><li>Eg. いま、新聞を読む</li><li>Eg. 明日、新聞を読む<h3 id="1-2-完成体"><a href="#1-2-完成体" class="headerlink" title="1.2 完成体"></a>1.2 完成体</h3>表示动作的完成，但是并不是一定过去时，整个行为可能发生在未来或是一个经常性的动作，只要在说话人设定的时间轴上是完成的动作即可。动词的变化规则和过去时相同。</li><li>Eg. 今朝、新聞を読んだ</li><li>Eg. 今朝、新聞を読んだ後に散歩に出かける</li></ul><h2 id="2-过程体（継続相）"><a href="#2-过程体（継続相）" class="headerlink" title="2. 过程体（継続相）"></a>2. 过程体（継続相）</h2><p>过程体用以描述动作或变化的各个环节，是把这种运动持续过程中的某一个局部表达出来。<br>参考Wasabi网站上的这篇文章<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Admin, Wasabi. Japanese Aspect: the Beginning, Middle, & End of Actions. 20 Aug. 2016, https://www.wasabi-jpn.com/japanese-grammar/japanese-aspect-the-beginning-middle-end-of-actions/.">[2]</span></a></sup>, 即一个动作的开始、现在和结束的阶段.</p><h3 id="2-1-备放体（準備相）"><a href="#2-1-备放体（準備相）" class="headerlink" title="2.1 备放体（準備相）"></a>2.1 备放体（準備相）</h3><p>表示该动作是为下一步做准备的。表现形式有: <strong>一型词根+「ておく」</strong>。其中的动词必须是意志动词。</p><ul><li>Eg. 明日お客さんが来ますから、お菓子をかっておいてください<h3 id="2-2-即将体"><a href="#2-2-即将体" class="headerlink" title="2.2 即将体"></a>2.2 即将体</h3>表示动作、行为、作用等就要发生。表现形式有: 「ようとしている」「ところだ」「しそうだ」「ばかりになっている」「かかる」「かける」<h3 id="2-3-起始体"><a href="#2-3-起始体" class="headerlink" title="2.3 起始体"></a>2.3 起始体</h3>表示动作、行为、作用的开始。表现形式多为复合动词，如「始める」「出す」「かける」等，和「てくる」<h3 id="2-4-持续体"><a href="#2-4-持续体" class="headerlink" title="2.4 持续体"></a>2.4 持续体</h3>表示动作、行为正在进行或者反复进行，要求动词是一种持续性动词。表现形式很多，有: 「ている」「てくる」「ていく」「ているところだ」「つづく」「つづける」「つづある」「一方だ」「ている最中だ」「中」，相当于汉语的“正在…”、“持续…”、“持续…”</li><li>Eg. 日本語を勉強している</li><li>Eg. 森さんが一人で歩いている<h3 id="2-5-完结体"><a href="#2-5-完结体" class="headerlink" title="2.5 完结体"></a>2.5 完结体</h3>表示动作、行为的完成、结束。表现形式多为复合动词，如「終わる」「あがる」「あげる」「尽くす」「切る」「通す」「ぬく」等，和「てしまう」<h3 id="2-6-存续体"><a href="#2-6-存续体" class="headerlink" title="2.6 存续体"></a>2.6 存续体</h3>表示动作或作用完成后的状态的存续。表现形式有: 「ている」「てある」「(ら)れている」「たところだ」「たばかりだ」等，相当于汉语的“…了”、“…着”</li></ul><h2 id="3-特殊体"><a href="#3-特殊体" class="headerlink" title="3. 特殊体"></a>3. 特殊体</h2><h3 id="3-1-完成体的进行意义"><a href="#3-1-完成体的进行意义" class="headerlink" title="3.1 完成体的进行意义"></a>3.1 完成体的进行意义</h3><p>有些动词虽然是“完成体”的形态，但并不表示“完成体”的基本意义，而是表达行进过程中的状态。<br>「いく」「くる」以及类似它们的「むかい」「おく」之类的移动动词，以「していく」「している」的形式出现的动词，以及被「どんどん」「ぐんぐん」等行进性的副词修饰限定的变化动词等属于此类。</p><h3 id="3-2-完成体与持续体相同意义的情况"><a href="#3-2-完成体与持续体相同意义的情况" class="headerlink" title="3.2 完成体与持续体相同意义的情况"></a>3.2 完成体与持续体相同意义的情况</h3><p>表状态时“完成体”和“持续体”两者表达同样事物，“体”未实现其分化。主要有以下两类:</p><ul><li>表说话人以感官感觉到的状态性现象</li><li>表存在</li></ul><h3 id="3-3-整体性无法识别的情况"><a href="#3-3-整体性无法识别的情况" class="headerlink" title="3.3 整体性无法识别的情况"></a>3.3 整体性无法识别的情况</h3><p>在表示说话人内心活动时，是否是整体性处置的状态看不出来。主要有以下两类:</p><ul><li>表说话人的考虑和想法</li><li>表说话人的感觉</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>撰写本文前主要看了以下书籍和文章: 日语语法专题教程<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.">[1]</span></a></sup>, Japanese Aspect-the Beginning, Middle, &amp; End of Actions<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Admin, Wasabi. Japanese Aspect: the Beginning, Middle, & End of Actions. 20 Aug. 2016, https://www.wasabi-jpn.com/japanese-grammar/japanese-aspect-the-beginning-middle-end-of-actions/.">[2]</span></a></sup>, 浅析日语复句中的“时”和“体”<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="辛宇峰. 浅析日语复句中的“时”和“体”. 长沙铁道学院学报:社会科学版 4(2014):54-55.">[3]</span></a></sup>, 日语动词的“体”特征分类<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="孙敦夫. 日语动词的“体”特征分类. 外语教学 2(2008):39-42.">[4]</span></a></sup>, Are Japanese ‘Tenses’ Aspects in Disguise?<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="SweeperSweeper 2, et al. “Are Japanese ‘Tenses’ Aspects in Disguise?” Japanese Language Stack Exchange, 29 Jan. 2017, https://japanese.stackexchange.com/questions/42988/are-japanese-tenses-aspects-in-disguise.">[5]</span></a></sup>, 【中级日语】日语的时态和体，ル形、タ形和ている形的区别<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="日本狸猫田中裕之. “【中级日语】日语的时态和体，ル形、タ形和ている形的区别.” 知乎专栏, 4 June 2019, https://zhuanlan.zhihu.com/p/67847551.">[6]</span></a></sup>。<br>Kino觉得，体的概念在日语中的确存在，但是并不是那么有规律，记住「ている」这种较为常见的用法即可，剩下的主要是能够理解句子的状态。<br>本篇文章主要叙述了体的概念，下一篇将讲解日语中的态。</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Admin, Wasabi. Japanese Aspect: the Beginning, Middle, &amp; End of Actions. 20 Aug. 2016, https://www.wasabi-jpn.com/japanese-grammar/japanese-aspect-the-beginning-middle-end-of-actions/.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">辛宇峰. 浅析日语复句中的“时”和“体”. 长沙铁道学院学报:社会科学版 4(2014):54-55.<a href="#fnref:3" rev="footnote">↩</a></span></li><li id="fn:4"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">孙敦夫. 日语动词的“体”特征分类. 外语教学 2(2008):39-42.<a href="#fnref:4" rev="footnote">↩</a></span></li><li id="fn:5"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">SweeperSweeper 2, et al. “Are Japanese ‘Tenses’ Aspects in Disguise?” Japanese Language Stack Exchange, 29 Jan. 2017, https://japanese.stackexchange.com/questions/42988/are-japanese-tenses-aspects-in-disguise.<a href="#fnref:5" rev="footnote">↩</a></span></li><li id="fn:6"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">日本狸猫田中裕之. “【中级日语】日语的时态和体，ル形、タ形和ている形的区别.” 知乎专栏, 4 June 2019, https://zhuanlan.zhihu.com/p/67847551.<a href="#fnref:6" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;/2018/06/01/japanese04/&quot;&gt;上一篇文章&lt;/a&gt;介绍了极性和时轴，这一章主要介绍体的相关语法，体的概念在&lt;a href=&quot;/2017/09/16/japanese01/#2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5&quot;&gt;第一篇文章&lt;/a&gt;里已经介绍过，此处再介绍一遍: 体表示某个动作或变化在&lt;strong&gt;说话人所设的时间轴&lt;/strong&gt;上处于开始、持续和完成状态中的某一阶段，是从时间角度上对动作和变化的描写或把握。&lt;strong&gt;需要注意的是在日语中体仅仅反映在动词上&lt;/strong&gt;&lt;br&gt;PS: 日语语法在”体”这方面的变化并不是那么明显, 虽然语法概念上可以分很细, 但实际需要进行特殊的变形转换的并不多, 更多的是靠上下文的时间轴来界定”体”的状态.&lt;/p&gt;</summary>
    
    
    
    <category term="humanities" scheme="https://blog.xuwei.fun/categories/humanities/"/>
    
    <category term="languages" scheme="https://blog.xuwei.fun/categories/humanities/languages/"/>
    
    
    <category term="japanese" scheme="https://blog.xuwei.fun/tags/japanese/"/>
    
  </entry>
  
  <entry>
    <title>日语学习第三讲</title>
    <link href="https://blog.xuwei.fun/2018/06/01/japanese04/"/>
    <id>https://blog.xuwei.fun/2018/06/01/japanese04/</id>
    <published>2018-06-01T11:04:23.000Z</published>
    <updated>2021-03-07T12:22:36.814Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>————<strong>更新于2018.06.01</strong>————<br><a href="/2017/09/30/japanese03/">上一篇文章</a>介绍了词类系统和句法成分，这篇文章Kino主要来讲解极性时轴。<br>在语言学中，极性———即Polarity———表示该句是肯定还是否定、判断真还是假，具体细节可参考<a href="https://ja.wikipedia.org/wiki/%E6%A5%B5%E6%80%A7_%28%E8%A8%80%E8%AA%9E%E5%AD%A6%29">極性</a><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. “極性 (言語学).” Wikipedia, Wikimedia Foundation, 14 June 2018, https://ja.wikipedia.org/wiki/極性_(言語学).">[1]</span></a></sup>、<a href="https://en.wikipedia.org/wiki/Affirmation_and_negation">Affirmation and negation</a><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. “Affirmation and Negation.” Wikipedia, Wikimedia Foundation, 19 June 2018, https://en.wikipedia.org/wiki/Affirmation_and_negation.">[2]</span></a></sup>、<a href="https://en.wikipedia.org/wiki/Polarity_item">Polarity item</a><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Wikipedians. “Polarity Item.” Wikipedia, Wikimedia Foundation, 19 June 2018, https://en.wikipedia.org/wiki/Polarity_item.">[3]</span></a></sup>等，时轴在这里指时(tense)，在<a href="/2017/09/16/japanese01/#2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">第一篇文章</a>里已经介绍过，Kino为了凑够四字标题且避免使用时态这种说法，就用了时轴这个词，灵感来源于现在常用时间轴来表示过去、现在、将来，后续为方便大多还是只用“时”这个称谓了。<br>将极性和时轴放在一起且最先介绍的理由为: 这两项较为容易理解，且负极性（否定）搭配过去时的变形经常互相影响。<br>考虑极性、时、体、态、式以及敬体系统，在讨论其中一项或几项的概念规则时，其他几项应该有相应基准作为参考，按照惯例应该是正极性、现在时、一般体、主动态、陈述式、非敬体。</p><span id="more"></span><h2 id="1-极性"><a href="#1-极性" class="headerlink" title="1. 极性"></a>1. 极性</h2><p>如前所述，极性分为肯定和否定。本章将分两大节来讲解极性，一是在句尾变形表示整个句子的极性，二是在句中变形词汇表示修饰语的极性。<br>本章所述均为当前状态，也就是现在时。</p><h3 id="1-1-句尾"><a href="#1-1-句尾" class="headerlink" title="1.1 句尾"></a>1.1 句尾</h3><p>完整句子的句尾肯定是述语，包括名词、形容词和动词，其中句尾是名词、形容词时，表达一种状态、情感等，句尾是动词时，表达一种动作。</p><h4 id="1-1-1-名词"><a href="#1-1-1-名词" class="headerlink" title="1.1.1 名词"></a>1.1.1 名词</h4><p>以“我是学生”、“我不是学生”为例。</p><ul><li>肯定: 句尾名词后加「だ」表示肯定极性，「私は学生だ」</li><li>否定: 句尾名词后加「じゃない」，「私は学生じゃない」</li><li><strong>注意: 肯定极性中的「だ」可以省略。</strong></li></ul><h4 id="1-1-2-形容词"><a href="#1-1-2-形容词" class="headerlink" title="1.1.2 形容词"></a>1.1.2 形容词</h4><p>な形容词和い形容词规则不同，分开来讲。</p><h5 id="1-1-2-1-な形容词"><a href="#1-1-2-1-な形容词" class="headerlink" title="1.1.2.1 な形容词"></a>1.1.2.1 な形容词</h5><p>规则和名词在句尾相同，以“学校安静”、“学校不安静”为例。</p><ul><li>肯定: 句尾な形容词后加「だ」表示肯定极性，「学校が静かだ」</li><li>否定: 句尾な形容词后加「じゃない」，「学校が静かじゃない」</li><li><strong>注意: 肯定极性中的「だ」可以省略。</strong></li></ul><h5 id="1-1-2-2-い形容词"><a href="#1-1-2-2-い形容词" class="headerlink" title="1.1.2.2 い形容词"></a>1.1.2.2 い形容词</h5><p>以“她可爱”、“她不可爱”为例。</p><ul><li>肯定: 不做变化，「彼女は可愛い」</li><li>否定: 句尾い形容词，将「い」变为「くない」，「彼女は可愛くない」</li></ul><h4 id="1-1-3-动词"><a href="#1-1-3-动词" class="headerlink" title="1.1.3 动词"></a>1.1.3 动词</h4><p>一段动词、五段动词和特殊动词不同，分开来讲。</p><h5 id="1-1-3-1-一段动词（る动词）"><a href="#1-1-3-1-一段动词（る动词）" class="headerlink" title="1.1.3.1 一段动词（る动词）"></a>1.1.3.1 一段动词（る动词）</h5><p>以“我吃饭”、“我不吃饭”为例。</p><ul><li>肯定: 不做变化，「私はたべる」</li><li>否定: 句尾一段动词，将「る」变为「ない」，「私はたべない」</li></ul><h5 id="1-1-3-2-五段动词（う动词）"><a href="#1-1-3-2-五段动词（う动词）" class="headerlink" title="1.1.3.2 五段动词（う动词）"></a>1.1.3.2 五段动词（う动词）</h5><p>以“我玩”、“我不玩”、“我买”、“我不买”为例。</p><ul><li>肯定: 不做变化，「私は遊ぶ」、「私は買う」</li><li>否定: 句尾五段动词，将词尾变为同行「あ」段假名，再加上「ない」，也即将 &#x2F;u&#x2F; 音变为 &#x2F;anai&#x2F;，但是以「う」结尾的词需要变成「わ」，「私は遊ばない」、「私は買わない」</li></ul><h5 id="1-1-3-3-特殊动词"><a href="#1-1-3-3-特殊动词" class="headerlink" title="1.1.3.3 特殊动词"></a>1.1.3.3 特殊动词</h5><p>特殊动词する、くる的的变形比较特别，此外还有ある比较特别。对于する、くる、ある，按照顺序规则分别为:</p><ul><li>肯定: 不做变化</li><li>否定: しない、こない、ない</li></ul><h3 id="1-2-句中"><a href="#1-2-句中" class="headerlink" title="1.2 句中"></a>1.2 句中</h3><p>用在句中，即做修饰语用。</p><h4 id="1-2-1-名词"><a href="#1-2-1-名词" class="headerlink" title="1.2.1 名词"></a>1.2.1 名词</h4><p>以“是学生的人”和“不是学生的人”为例。</p><ul><li>肯定: 名词肯定极性没法直接修饰名词，即*<em>不能使用</em>「学生だ人」这种表达方式。事实上，在日语里没有现在时的“是学生的人”这种形式</li><li>否定: 和在句尾做述语的形式相同，「学生じゃな人」</li><li>注意: 名词A与名词B没有修饰关系时，可以并排放置使用，如「国际教育中心」，名词A和名词B是从属关系时，即“A的B”这种关系，可以用「AのB」表达</li></ul><h4 id="1-2-2-形容词"><a href="#1-2-2-形容词" class="headerlink" title="1.2.2 形容词"></a>1.2.2 形容词</h4><h5 id="1-2-2-1-な形容词"><a href="#1-2-2-1-な形容词" class="headerlink" title="1.2.2.1 な形容词"></a>1.2.2.1 な形容词</h5><p>以“有名的人”和“不有名的人”为例。</p><ul><li>肯定: 在词尾加「な」，「有名な人」</li><li>否定: 和在句尾做述语的形式相同，「有名じゃない人」<h5 id="1-2-2-2-い形容词"><a href="#1-2-2-2-い形容词" class="headerlink" title="1.2.2.2 い形容词"></a>1.2.2.2 い形容词</h5>以“可爱的Kino”和“不可爱的Kino”为例。</li><li>肯定: 和在句尾做述语的形式相同，「可愛いキノ」</li><li>否定: 和在句尾做述语的形式相同，「可愛くないキノ」</li></ul><h4 id="1-2-3-动词"><a href="#1-2-3-动词" class="headerlink" title="1.2.3 动词"></a>1.2.3 动词</h4><p>和在句尾做述语完全相同，不赘述。</p><h2 id="2-时轴"><a href="#2-时轴" class="headerlink" title="2. 时轴"></a>2. 时轴</h2><p>关于时轴，日语里只有两种类型，过去时和现在时，上一章所有变形都是在现在时的情况下，下面结束过去时的变形方式。</p><h3 id="2-1-句尾"><a href="#2-1-句尾" class="headerlink" title="2.1 句尾"></a>2.1 句尾</h3><h4 id="2-1-1-名词"><a href="#2-1-1-名词" class="headerlink" title="2.1.1 名词"></a>2.1.1 名词</h4><p>以“我过去是学生”和“我过去不是学生”为例。</p><ul><li>肯定: 句尾名词后加「だった」表示过去肯定，「私は学生いだった」</li><li>否定: 句尾名词后加「じゃなかった」表示过去否定，「私は学生いじゃなかった」</li></ul><h4 id="2-1-2-形容词"><a href="#2-1-2-形容词" class="headerlink" title="2.1.2 形容词"></a>2.1.2 形容词</h4><h5 id="2-1-2-1-な形容词"><a href="#2-1-2-1-な形容词" class="headerlink" title="2.1.2.1 な形容词"></a>2.1.2.1 な形容词</h5><p>以“学校过去是安静的”和“学校过去是不安静的”为例。</p><ul><li>肯定: 句尾な形容词后加「だった」表示过去肯定，「学校は静かだった」</li><li>否定: 句尾な形容词后加「じゃなかった」表示过去否定，「学校は静かじゃなかった」</li></ul><h5 id="2-1-2-2-い形容词"><a href="#2-1-2-2-い形容词" class="headerlink" title="2.1.2.2 い形容词"></a>2.1.2.2 い形容词</h5><p>以“Kino过去是可爱的”和“Kino过去是不可爱的”为例。</p><ul><li>肯定: 句尾い形容词将「い」变为「かった」表示过去肯定，「キノは可愛かった」</li><li>否定: 句尾い形容词将「い」变为「くなかった」表示过去肯定，「キノは可愛くなかった」</li></ul><h4 id="2-1-3-动词"><a href="#2-1-3-动词" class="headerlink" title="2.1.3 动词"></a>2.1.3 动词</h4><p>一段动词、五段动词和特殊动词不同，分开来讲。</p><h5 id="2-1-3-1-一段动词"><a href="#2-1-3-1-一段动词" class="headerlink" title="2.1.3.1 一段动词"></a>2.1.3.1 一段动词</h5><p>以“我过去吃了”和“我过去没吃”为例。</p><ul><li>肯定: 句尾一段动词将「る」变为「た」，「私は食べた」</li><li>否定: 句尾一段动词将「る」变为「なかった」，「私は食べなかった」<h5 id="2-1-3-2-五段动词"><a href="#2-1-3-2-五段动词" class="headerlink" title="2.1.3.2 五段动词"></a>2.1.3.2 五段动词</h5>五段动词的过去时较为复杂，不举具体例子说明。</li><li>肯定: 句尾五段动词的过去肯定变形较为复杂，结尾词不同其形式不同，分别是「す」-&gt;「した」、「く」-&gt;「いた」、「ぐ」-&gt;「いだ」、「む&#x2F;ぶ&#x2F;ぬ」-&gt;「んだ」、「る&#x2F;う&#x2F;つ」-&gt;「った」，<strong>唯一的例外是「行く」-&gt;「行いた」-&gt;「行った」</strong>。</li><li>否定: 在现在时的否定基础上，将「い」变为「かった」<h5 id="2-1-3-3-特殊动词"><a href="#2-1-3-3-特殊动词" class="headerlink" title="2.1.3.3 特殊动词"></a>2.1.3.3 特殊动词</h5>特殊动词する、くる的过去时变形比较特别，按照顺序规则分别为:</li><li>肯定: した、きた</li><li>否定: しなかった、こなかった</li></ul><h3 id="2-2-句中"><a href="#2-2-句中" class="headerlink" title="2.2 句中"></a>2.2 句中</h3><p>所有词性的过去时在句中的形式和句尾是相同的，即所有过去时的名词、形容词、动词都可以直接做修饰语，修饰另一个名词。</p><h2 id="3-时极综合"><a href="#3-时极综合" class="headerlink" title="3. 时极综合"></a>3. 时极综合</h2><p>对于名词、な形容词、い形容词、一段动词和五段动词，综合考虑极性、时轴和在句子的位置，分别得到表1、2、3、4、5、6。</p><p align="center">表1 名词</p><table><thead><tr><th align="center"></th><th align="center">现在肯定</th><th align="center">现在否定</th><th align="center">过去肯定</th><th align="center">过去否定</th></tr></thead><tbody><tr><td align="center">句尾</td><td align="center">だ</td><td align="center">じゃない</td><td align="center">だった</td><td align="center">じゃなかった</td></tr><tr><td align="center">句中</td><td align="center">不存在该用法</td><td align="center">じゃない</td><td align="center">だった</td><td align="center">じゃなかった</td></tr></tbody></table><p align="center">表2 な形容词</p><table><thead><tr><th align="center"></th><th align="center">现在肯定</th><th align="center">现在否定</th><th align="center">过去肯定</th><th align="center">过去否定</th></tr></thead><tbody><tr><td align="center">句尾</td><td align="center">だ</td><td align="center">じゃない</td><td align="center">だった</td><td align="center">じゃなかった</td></tr><tr><td align="center">句中</td><td align="center">な</td><td align="center">じゃない</td><td align="center">だった</td><td align="center">じゃなかった</td></tr></tbody></table><p align="center">表3 い形容词</p><table><thead><tr><th align="center"></th><th align="center">现在肯定</th><th align="center">现在否定</th><th align="center">过去肯定</th><th align="center">过去否定</th></tr></thead><tbody><tr><td align="center">句尾</td><td align="center">原形</td><td align="center">くない</td><td align="center">かった</td><td align="center">くなかった</td></tr><tr><td align="center">句中</td><td align="center">原形</td><td align="center">くない</td><td align="center">かった</td><td align="center">くなかった</td></tr></tbody></table><p align="center">表4 一段动词</p><table><thead><tr><th align="center"></th><th align="center">现在肯定</th><th align="center">现在否定</th><th align="center">过去肯定</th><th align="center">过去否定</th></tr></thead><tbody><tr><td align="center">句尾</td><td align="center">原形</td><td align="center"><del>る</del>ない</td><td align="center"><del>る</del>た</td><td align="center"><del>る</del>なかった</td></tr><tr><td align="center">句中</td><td align="center">原形</td><td align="center"><del>る</del>ない</td><td align="center"><del>る</del>た</td><td align="center"><del>る</del>なかった</td></tr></tbody></table><p align="center">表5 五段动词</p><table><thead><tr><th align="center"></th><th align="center">现在肯定</th><th align="center">现在否定</th><th align="center">过去肯定</th><th align="center">过去否定</th></tr></thead><tbody><tr><td align="center">句尾</td><td align="center">原形</td><td align="center"><del>&#x2F;u&#x2F;</del>&#x2F;a&#x2F;ない</td><td align="center">「す-&gt;した」「く-&gt;いた」、「ぐ-&gt;いだ」、「む&#x2F;ぶ&#x2F;ぬ-&gt;んだ」、「る&#x2F;う&#x2F;つ-&gt;った」</td><td align="center">否定极+过去时</td></tr><tr><td align="center">句中</td><td align="center">原形</td><td align="center"><del>&#x2F;u&#x2F;</del>&#x2F;a&#x2F;ない</td><td align="center">「す-&gt;した」「く-&gt;いた」、「ぐ-&gt;いだ」、「む&#x2F;ぶ&#x2F;ぬ-&gt;んだ」、「る&#x2F;う&#x2F;つ-&gt;った」</td><td align="center">否定极+过去时</td></tr></tbody></table><p align="center">表6 特殊动する、くる</p><table><thead><tr><th align="center"></th><th align="center">现在肯定</th><th align="center">现在否定</th><th align="center">过去肯定</th><th align="center">过去否定</th></tr></thead><tbody><tr><td align="center">句尾</td><td align="center">原形</td><td align="center">しない、こない</td><td align="center">した、きた</td><td align="center">しなかった、こなかった</td></tr><tr><td align="center">句中</td><td align="center">原形</td><td align="center">しない、こない</td><td align="center">した、きた</td><td align="center">しなかった、こなかった</td></tr></tbody></table><p>可以看出，除却名词和な形容词，其余几类在作为述语和作为修饰语的情况下，规则是完全相同的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要讲解了日语中的极性和时，下一篇文章将讲解日语中的动作体貌。</p><h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “極性 (言語学).” Wikipedia, Wikimedia Foundation, 14 June 2018, https://ja.wikipedia.org/wiki/極性_(言語学).<a href="#fnref:1" rev="footnote">↩</a></span></li><li id="fn:2"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Affirmation and Negation.” Wikipedia, Wikimedia Foundation, 19 June 2018, https://en.wikipedia.org/wiki/Affirmation_and_negation.<a href="#fnref:2" rev="footnote">↩</a></span></li><li id="fn:3"><span style="display: inline; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline; vertical-align: top; margin-left: 10px;">Wikipedians. “Polarity Item.” Wikipedia, Wikimedia Foundation, 19 June 2018, https://en.wikipedia.org/wiki/Polarity_item.<a href="#fnref:3" rev="footnote">↩</a></span></li></ol></div></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;————&lt;strong&gt;更新于2018.06.01&lt;/strong&gt;————&lt;br&gt;&lt;a href=&quot;/2017/09/30/japanese03/&quot;&gt;上一篇文章&lt;/a&gt;介绍了词类系统和句法成分，这篇文章Kino主要来讲解极性时轴。&lt;br&gt;在语言学中，极性———即Polarity———表示该句是肯定还是否定、判断真还是假，具体细节可参考&lt;a href=&quot;https://ja.wikipedia.org/wiki/%E6%A5%B5%E6%80%A7_%28%E8%A8%80%E8%AA%9E%E5%AD%A6%29&quot;&gt;極性&lt;/a&gt;&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;Wikipedians. “極性 (言語学).” Wikipedia, Wikimedia Foundation, 14 June 2018, https://ja.wikipedia.org/wiki/極性_(言語学).
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;、&lt;a href=&quot;https://en.wikipedia.org/wiki/Affirmation_and_negation&quot;&gt;Affirmation and negation&lt;/a&gt;&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;Wikipedians. “Affirmation and Negation.” Wikipedia, Wikimedia Foundation, 19 June 2018, https://en.wikipedia.org/wiki/Affirmation_and_negation.
&quot;&gt;[2]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;、&lt;a href=&quot;https://en.wikipedia.org/wiki/Polarity_item&quot;&gt;Polarity item&lt;/a&gt;&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;Wikipedians. “Polarity Item.” Wikipedia, Wikimedia Foundation, 19 June 2018, https://en.wikipedia.org/wiki/Polarity_item.&quot;&gt;[3]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;等，时轴在这里指时(tense)，在&lt;a href=&quot;/2017/09/16/japanese01/#2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5&quot;&gt;第一篇文章&lt;/a&gt;里已经介绍过，Kino为了凑够四字标题且避免使用时态这种说法，就用了时轴这个词，灵感来源于现在常用时间轴来表示过去、现在、将来，后续为方便大多还是只用“时”这个称谓了。&lt;br&gt;将极性和时轴放在一起且最先介绍的理由为: 这两项较为容易理解，且负极性（否定）搭配过去时的变形经常互相影响。&lt;br&gt;考虑极性、时、体、态、式以及敬体系统，在讨论其中一项或几项的概念规则时，其他几项应该有相应基准作为参考，按照惯例应该是正极性、现在时、一般体、主动态、陈述式、非敬体。&lt;/p&gt;</summary>
    
    
    
    <category term="humanities" scheme="https://blog.xuwei.fun/categories/humanities/"/>
    
    <category term="languages" scheme="https://blog.xuwei.fun/categories/humanities/languages/"/>
    
    
    <category term="japanese" scheme="https://blog.xuwei.fun/tags/japanese/"/>
    
  </entry>
  
</feed>
