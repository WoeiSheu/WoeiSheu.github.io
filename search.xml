<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Metaheuristic algorithm —— Concept]]></title>
    <url>%2F2018%2F11%2F19%2FmetaheuristicAlgorithm01%2F</url>
    <content type="text"><![CDATA[前言Kino的课题常需要用到元启发式算法，就在此稍稍总结。元启发式(metaheuristic)，很多时候也被称为智能优化(intelligent optimization)、现代启发式(Modern Heuristic)、智能计算(Intelligent Computation)、自然计算(Natural Computation)等，细分到具体算法有遗传算法、粒子群算法、差分进化算法、蚁群算法等。元启发式(metaheuristic)这个词本身可以拆成两部分来看，元(meta)和启发式(heuristic)，本文主要从这两方面来阐述元启发式的概念，后续文章再介绍各算法的原理、步骤、代码等。 1. Meta首先来解释元(meta)，程序员对这个词并不陌生，学习编程语言到某个阶段总会出来一个元编程(metaprogramming)技术，还会经常见到元数据(metadata)等。与顾名思义的一些概念相比，元的概念就有点晦涩了，初次遇见总是一脸诧异，难以理解。感性上来看，metaXXX就是相比XXX来说更高级的一种概念/理论，是研究超越XXX的存在，玄之又玄，不能理解不是你的错，就像形而上学(metaphysics)一样难以理解。而不去探讨meta哲学性质的意义，只考虑其作为前缀(prefix)的情况，根据meta在Wikipedia的相应词条Meta[1]，meta大多数时候可以理解为X about X，大致翻译为关于X的X，这里的关于在中文语境里通常用实现、描述、编写等动词代替。例如metadata就是data about data，即描述数据的数据，metaprogramming就是programming about programming，即编写程序的程序，诸如此类。如果有需要，这种概念还可以递归，即添加任意多的meta前缀，变身成为metametameta…。在此基础上再去看meta的中文翻译元，就会发现这个翻译其实很巧妙。“元”汉语里有 起源/开始(如元旦/元始天尊)、基本/根本(如元素/元气/元件) 的意思，完美地涵盖了meta想要表达的意思。然而元这个字很少单用，已经融合在最常见的一些词语中，所以当看到用元的前缀生造出的词语时，大多数人还是会难以理解。 这样说完感觉可能还是一片迷茫，就拿上面所说的metadata和metaprogramming作为示例来具体说明。 1.1 Metadata关于Metadata，循序渐进地来举几个栗子。 填写各类登记表时，通常需要填写姓名、性别、爱好等信息，那么我们填写的信息Kino、女、睡觉就是具体需要的data，而姓名、性别、爱好这种描述属性的文字，就属于metadata 对上面的内容稍加扩展，可以认为在进行关系型数据库设计时，我们建立的表结构就可以看作是metadata，而最终记录到表中的内容就是data，而对于K-V数据库来说，也不妨理解为Key是metadata，Value是data，JSON数据自然也可如此理解。 XML数据格式，XML(Extensible Markup Language)作为一种标记语言(Markup Language)，本就是Metadata一种表现形式。可以把XML的tag和property的key作为metadata，而把content和property的value作为data。HTML作为XML的亲戚，也可以如此理解，而至于HTML中的meta标签，又是将整个HTML文件看作data，这个meta标签里的内容就是用来描述这整个HTML的data也就是metadata了，比如&lt;meta name=&quot;google-site-verification&quot; content=&quot;......&quot; /&gt; 1.2 Metaprogramming按照上面的逻辑继续下去，变量声明就是描述变量的类型，难道就是metaprogramming了吗? 显然不会是这么简单的事情。metaprogramming本身还是一个比较宏观的定义，对应到不同编程语言的具体实现上，又各有不同。下面简单叙述几种语言的metaprogramming机制，只要实际使用过其中一种，就不难理解了。 C++：在C++中，可以利用模板实现元编程，在Effective C++中就有关于模板元编程的讨论 Java：在Java中，最为人熟知的反射，就可以用来实现元编程 Python：在Python中，如果一个类继承的不是object而是type，那么它就被成为元类(metaclass)，可以用元类来验证、注册子类，这也可以称为元编程 从上面的例子中总结一下，元编程的实现手段各异，但大多是想解决这几个问题： 设计中出现的相似内容太多，而这些重复内容存在于类层面，已经不能通过类的抽象来解决了，或者解决起来更为复杂(比如引入过于复杂的设计模式等)，这个时候需要更高一层的抽象来处理问题，解决这个问题的过程就可以称为元编程，Python中的metaclass就是典型的应用 面向对象程序的设计中，类的定义是在编译期就确定的，运行时动态生成的是实例，如果想要更高一层，在运行时动态生成类，那么这个实现过程就可以称为元编程，Java中的反射是典型的应用 … 这也提醒了我们，在使用元编程前需要思考这个问题是否必须使用元编程、使用元编程能否简化实现过程，如果可以再尝试使用，否则就需要谨慎对待。元编程更大程度上是一个概念和思想，而不是一个具体方法和手段 1.3 Off topic思维一发散，意识就止不住到处游走，虽然离题万里，但且记录在此吧。 突然想到导师最喜欢提的问题：“你这个效能评估的参数选取标准是什么呢？你怎么证明你这个效能评估的结果是可信的呢？毁伤评估的结果是怎么得来的呢？”似也有点元的意味，而且还可以无限递归，最终变成“评估评估…评估的结果”。如果该项工作有客观的评估标准，评估起来就相对简单可信，如果没有客观标准，靠专家标准或者自己选取的参数标准评估，可信性就大打折扣了，这个时候就可以再追问一句：“你怎么评价你选取的参数是可靠的呢？”。今天刚好看到新闻，国际单位制的七个基本单位重新进行了定义，都改以宇宙的基本常数为基础定义[2]，于是突然想到，所谓度量系统Metric System里的单词metric，在词源上是不是和meta同源的，毕竟metric是用来衡量一切的标准，有种meta的意味在里面，不过事实到底如何，毫无词源学基础的Kino是无法确定了。似乎更能理解那句不是爱因斯坦的名言“越简单越好，但不要过于简单”，过犹不及，繁简之间如何取舍是个永恒的问题，奥卡姆剃刀并不是万能的，更何况繁简也是相互转化的，就像有时想为了简洁不停地添加meta，最终却导致设计模式的臃肿，反而更复杂了。所谓大道至简，是对还是错，还未可知。但是爱因斯坦真的说过这句：“不应否认任何理论的终极目标都是尽可能让不可削减的基本元素变得更加简单且更少，但也不能放弃对任何一个单一经验数据的充分阐释。”这似乎是个比较恰当的说法。 2. Heuristic维基百科也有启发式(Heuristic)的词条[3]，但实际的定义很简单。启发式算法(Heuristic)算法和精确(Exact)算法相对应，它们的求解对象都是运筹优化类问题。区别在于，对于组合优化等非凸优化问题，用精确算法虽可求出其全局最优解，但计算效率低，有时还是NP问题，规模变大则无法在有限时间内求解，而利用启发式算法，可以提高计算效率，但求得的解可能只是较好的次优解，而不能达到全局最优解。针对一个具体的优化问题，提出一个在计算效率和求解质量间取得均衡的具体算法，这个算法就叫做启发式算法。例如需要求解\(y=f(x)\)的最小值，用精确求解可以得到准确值为\(\min{y}=22\)，耗时\(t=10s\)，而使用启发式算法求得的结果是\(\min{y}=22.22\)，但耗时只有\(t=3s\)。对于精确求解法，具体包括穷举法、分支定界法、割平面法、动态规划法等，而对于传统的启发式算法，包括构造型方法、局部搜索算法、松弛方法、解空间缩减法等。 3. Metaheuristic综合以上概念，将meta和heuristic结合得到的所谓元启发(metaheuristic)，理论定义上应该是heuristic about heuristic，但是这种实现启发式的启发式，还是很难直观理解。先回到刚刚说的启发式算法，严格意义上的启发式，是针对某个特定优化问题的，只要是能够取得较好值的算法都可以叫做启发式算法，而元启发，就是给定一套流程/方法论，对不同的问题，只要按照该流程设计，就能实现一个针对具体问题的启发式算法，因此把这个抽象的流程称之为元启发。换句话说，启发式是面向问题的(Problem Oriented)，而元启发是面向方法的(Method Oriented)。最常见的比如遗传算法，它只给定了一个标准流程：编码-&gt;初始化-&gt;选择-&gt;交叉-&gt;变异-&gt;…，而针对一个具体的优化问题，需要设计特定的编码方式、选择特定的适应度函数…，如此设计完成的具体算法才是启发式算法。但是、然而、不过，现在的论文中，大多数时候把元启发和启发式也混着用，在整篇文章中，通常只使用元启发式或启发式其中一个词，所以界限并没有那么分明了，元启发经常被称为启发式、启发式也经常被叫做元启发。元启发也有维基百科页面，戳这里 后记传统的任务分配、组合优化类等运筹学问题，大多都可以抽象成非凸优化的模型，也是NP问题，无法用传统方法求解，同时这些问题大多缺少或不能统计历史数据，因此也无法使用有监督机器学习等算法，这种情况下使用智能优化算法就非常合适。针对这些运筹学问题，只要能够利用元启发算法的思想设计出合理的启发式算法，从而解决问题，其实就是一个很好的工作，但是现在的研究导向是发论文至上，研究智能优化算法的实验室也不例外，一切以发论文为导向，设计全新的元启发式算法实在困难，于是现在的论文大多还是Problem Oriented，通过说动听的故事阐述问题意义，再找出和之前的问题区别，比如多了一个小小的约束条件，这时就可以命名这个问题为XXXXX，以此说明自己定义了一个新问题，再抽象出该问题的数学模型(大多数时候只是在目标函数或约束条件上做些许修改，太简单没有做的意义，太复杂元启发也难以求解)，然后根据元启发算法的流程设计出完整的算法(在流程中的任一处加一点修改即可称之为改进)，编程实现算法做比较，得出结论;当然Method Oriented也还是有的，刚刚提到的一些小的改动、针对经典的TSP等做算法改进、超多目标优化问题的求解方法等。总之一切为了论文，至于这些论文里的问题是否真的有意义、方法是否真的有创新，谁在乎呢。 Footnote1.Wikipedians. (2018, November 12). Meta. Retrieved from https://en.wikipedia.org/wiki/Meta ↩2.Wikipedians. (2018, November 19). 2019 redefinition of SI base units. Retrieved from https://en.wikipedia.org/wiki/2019_redefinition_of_SI_base_units ↩3.Wikipedians. (2014, May 25). Heuristic (computer science). Retrieved from https://en.wikipedia.org/wiki/Heuristic_(computer_science) ↩4.Wikipedians. (2018, November 16). Metaheuristic. Retrieved from https://en.wikipedia.org/wiki/Metaheuristic ↩]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>metaheuristic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Summary 01 — Cycle Detection]]></title>
    <url>%2F2018%2F10%2F29%2Fleetcode01%2F</url>
    <content type="text"><![CDATA[前言前段时间忙于找工作，因而有正大光明的托词和导师说，11月之后再去做课题相关的事情，也就有了一段较为自由的时间。其中诸多准备，免不了在Leetcode上刷题，虽然对于最终的结果来说没有帮助，但刷题过程中遇到了一些解决思路相似的问题，就依次将这些共性问题阐述一遍罢了。本系列的第一篇介绍的是环检测问题，对应的维基百科页面有Cycle detection。这类问题最常见的求解算法是Floyd Cycle Algorithm/Floyd’s Tortoise and Hare，中文名通常为Floyd判圈算法/龟兔赛跑算法。 1. 问题描述在计算机科学中，有一类问题称之为环检测问题，即对于一个由迭代函数(iterated function)值组成的序列，判断该序列是否有环及环出现的位置。关于什么是迭代函数(iterated function)，严格定义可以查看这里，简单来说就是一个函数\(f\)，其定义域和值域都是集合\(X\)，那么对于某个自变量/输入\(a\)，其因变量/输出\(b\)也可以作为函数\(f\)的自变量/输入，如此给定一个初始值\(x\)，将\(f\)的每一次输出作为下一次的输入，如此重复\(n\)次，就称作函数\(f\)的第\(n\)次迭代。 对于上述函数\(f\)，如果其集合\(X\)是有限的，那么对于序列:$$S = \{x_0, x_1 = f(x_0), x_2 = f(x_1), \cdots, x_i = f(x_{i-1}), \cdots\}$$那么必然会有两个位置\(i\)和\(j\)，且\(i &lt; j\)，其\(x_i = x_j\)，一旦出现这种状况，显然在\(j\)位置之后，会重复从\(x_i\)到\(x_{j-1}\)的序列。所谓环检测问题，就是给定\(f\)和\(x_0\)，要求找到\(i\)和\(j\)。当然对于无限集合\(X\)，是有可能不存在环的，这取决于\(f\)和\(x_0\)的共同作用。例如\(f=x^2\)，如果\(X\)的范围是复数域，那么\(x_0=0,1,-1,e^{\frac{2\pi{}mi}{n}}\)，则有环，否则没有。这里\(m\)的取值范围是整数，\(n\)的取值范围是\({1,2,3,4,6,7,8,12,14,15,16,24,28,30,31,32,\cdots}\)，就不仔细推导了，有兴趣的可以自行推导。 2. 求解算法对于上述问题，最常见的算法是Floyd’s Tortoise and Hare，其次还有Brent’s algorithm和Gosper’s algorithm等。最直接的想法是记录每次迭代的值，建立一个hash表，这样可以在重复出现时直接定位，但是这种方法空间复杂度太高，故弃。 2.1 Floyd’s Tortoise and Hare对于问题描述中迭代函数组成的序列，如果存在环，那么对于\(i\ge{}\mu\)，则\(x_i = x_{i+k\lambda}\)，其中\(\lambda\)是环的长度，\(\mu\)是环的第一个元素出现的位置。基于此，可以推出，\(\exists{}i = k\lambda\ge\mu\Longrightarrow{}x_i = x_{2i}\)因此，只要设定两个指针\(P1\)和\(P2\)，其中\(P2\)的步长是2，\(P1\)的步长是1，那么就可以找到两个指针指向值相等的位置，反过来说，即只要存在相等值，就存在环，此时可以得出\(\nu = P2 - P1 = P1 = k\lambda\).显然\(x_{\mu{}+\nu} = x_{\mu}\)，即\(x_{\nu{}+\mu} = x_{\mu}\)，故找到上述位置之后，\(P1\)仍保持原来位置，而\(P2\)放回序列最初位置，此时两个指针的推进步长都设置为1，两指针指向的值再次相等时，就是环开始的位置。找到环开始的位置后，向后迭代找到下一次重复位置，就可以得到环的长度\(\lambda\)了。 2.2 Brent’s algorithmFloyd’s Tortoise and Hare算法很精巧，但是判断环存在、找到环开始位置和确定环长度需要分为三步，Brent’s algorithm效率更高，且只需要两步。Brent’s algorithm也是利用了快慢两个指针的想法，但是它的想法是动态增加步长，加快搜索速度。其基本意图是设立两个指针，尽快让第一个指针到达环内，然后第二个指针以步长1前进，再次相等时走过的步数正好是环的长度\(\lambda\)，具体做法如下。首先，设定两个指针\(P1\)和\(P2\)，\(P2\)第一次先前进\(2^0=1\)步，在前进的过程中若始终\(x_{P2}\ne{}x_{P1}\)，则令\(P1 = P2\)，然后\(P2\)再前进\(2^1=2\)，在前进的过程中若始终\(x_{P2}\ne{}x_{P1}\)，则令\(P1 = P2\)，然后\(P2\)再前进\(2^2=4\)……如此，直到出现相等的位置，在出现相等位置之前，最后一次\(P2\)前进的步数就是环的长度\(\lambda\)。此时，将\(P1\)放于序列开始位置0，\(P2\)放于\(\lambda\)位置，由于\(x_{\mu} = x_{\lambda{}+\mu}\)，故只要让\(P1\)和\(P2\)依次向前前进，等到两者指向值相同时，\(P1\)的位置正好就是环的开始位置。 Brent’s algorithm的效率比Floyd’s Tortoise and Hare要高，最差情况是Floyd’s Tortoise and Hare算法。其主要原因是，步长动态增加，速度提高，以及首次找到相同值时，记录了环的长度，而Floyd’s Tortoise and Hare算法首次找到相同值时，并不知道环的长度，只能知道环长度的整数倍。 2.3 Gosper’s algorithmGosper算法可以参考此处，Kino还没有细看，就不细说了。 3. 相关练习Leetcode上有以下数题与此相关。 3.1 Leetcode 141. Linked List CycleLink Description: Given a linked list, determine if it has a cycle in it. Floyd’s Tortoise and Hare12345678910111213141516171819class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(!head || !(head-&gt;next)) &#123; return false; &#125; ListNode* tortoise = head-&gt;next; ListNode* hare = head-&gt;next-&gt;next; while(hare &amp;&amp; hare-&gt;next) &#123; if(tortoise == hare) &#123; return true; &#125; tortoise = tortoise-&gt;next; hare = hare-&gt;next-&gt;next; &#125; return false; &#125;&#125;; Brent’s algorithm1234567891011121314151617181920212223242526class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(!head || !(head-&gt;next)) &#123; return false; &#125; int current_step = 1; int limited_step = 1; ListNode* tortoise = head-&gt;next; ListNode* hare = head-&gt;next-&gt;next; while(hare &amp;&amp; hare-&gt;next) &#123; if(tortoise == hare) &#123; return true; &#125; if(current_step == limited_step) &#123; current_step = 0; limited_step *= 2; tortoise = hare; &#125; hare = hare-&gt;next; current_step++; &#125; return false; &#125;&#125;; 3.2 Leetcode 142. Linked List Cycle IILink Description: Given a linked list, return the node where the cycle begins. If there is no cycle, return null. Floyd’s Tortoise and Hare12345678910111213141516171819202122232425class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(!head || !(head-&gt;next)) &#123; return NULL; &#125; ListNode* tortoise = head-&gt;next; ListNode* hare = head-&gt;next-&gt;next; while(tortoise != hare) &#123; if(!hare || !(hare-&gt;next)) &#123; return NULL; &#125; tortoise = tortoise-&gt;next; hare = hare-&gt;next-&gt;next; &#125; tortoise = head; while(tortoise != hare) &#123; tortoise = tortoise-&gt;next; hare = hare-&gt;next; &#125; return tortoise; &#125;&#125;; Brent’s algorithm12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(!head || !(head-&gt;next)) &#123; return NULL; &#125; int current_step = 1; int limited_step = 1; ListNode* tortoise = head-&gt;next; ListNode* hare = head-&gt;next-&gt;next; while(tortoise != hare) &#123; if(!hare || !(hare-&gt;next)) &#123; return NULL; &#125; if(current_step == limited_step) &#123; current_step = 0; limited_step *= 2; tortoise = hare; &#125; hare = hare-&gt;next; current_step++; &#125; tortoise = head; hare = head; while(current_step--) &#123; tortoise = tortoise-&gt;next; &#125; while(tortoise != hare) &#123; tortoise = tortoise-&gt;next; hare = hare-&gt;next; &#125; return tortoise; &#125;&#125;; 3.3 Leetcode 202. Happy NumberLink Description: Write an algorithm to determine if a number is “happy”.A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Floyd’s Tortoise and Hare123456789101112131415161718192021222324class Solution &#123;public: bool isHappy(int n) &#123; int tortoise = nextNum(n); int hare = nextNum(nextNum(n)); while(tortoise != hare) &#123; tortoise = nextNum(tortoise); hare = nextNum(nextNum(hare)); &#125; return tortoise == 1; &#125; int nextNum(int n) &#123; int nxt = 0; while(n) &#123; int digit = n%10; nxt += digit*digit; n /= 10; &#125; return nxt; &#125;&#125;; Brent’s algorithm12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool isHappy(int n) &#123; int current_step = 1; int limited_step = 1; int tortoise = nextNum(n); int hare = nextNum(nextNum(n)); while(tortoise != hare) &#123; if(current_step == limited_step) &#123; current_step = 0; limited_step *= 2; tortoise = hare; &#125; hare = nextNum(hare); current_step++; &#125; return tortoise == 1; &#125; int nextNum(int n) &#123; int nxt = 0; while(n) &#123; int digit = n%10; nxt += digit*digit; n /= 10; &#125; return nxt; &#125;&#125;; 3.4 Leetcode 287. Find the Duplicate NumberLink Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Floyd’s Tortoise and Hare123456789101112131415161718192021222324252627282930class Solution &#123;private: vector&lt;int&gt; nums;public: int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) &#123; return -1; &#125; this-&gt;nums = nums; int tortoise = f(nums[0]); int hare = f(f(nums[0])); while(tortoise != hare) &#123; tortoise = f(tortoise); hare = f(f(hare)); &#125; tortoise = nums[0]; while(tortoise != hare) &#123; tortoise = f(tortoise); hare = f(hare); &#125; return tortoise; &#125; int f(int n) &#123; return nums[n]; &#125;&#125;; Brent’s algorithm123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;private: vector&lt;int&gt; nums;public: int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) &#123; return -1; &#125; this-&gt;nums = nums; int current_step = 1; int limited_step = 1; int tortoise = f(nums[0]); int hare = f(f(nums[0])); while(tortoise != hare) &#123; if(current_step == limited_step) &#123; current_step = 0; limited_step *= 2; tortoise = hare; &#125; hare = f(hare); current_step++; &#125; tortoise = nums[0]; hare = nums[0]; while(current_step--) &#123; tortoise = f(tortoise); &#125; while(tortoise != hare) &#123; tortoise = f(tortoise); hare = f(hare); &#125; return tortoise; &#125; int f(int n) &#123; return nums[n]; &#125;&#125;; 4. 实际应用环检测(cycle detection)问题的实际应用有 伪随机数生成器(pseudorandom number generators)强度的度量，比如 线性同余生成器(linear congruential generator)，加密哈希函数的冲突检测，细胞自动机(cellular automaton)的振荡周期配置等]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>Cycle Detection</tag>
        <tag>Floyd Cycle Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日语学习八]]></title>
    <url>%2F2018%2F06%2F29%2Fjapanese09%2F</url>
    <content type="text"><![CDATA[前言上一篇介绍了敬语系统，这一章主要介绍日语中的复合句。日语中复句的相关概念在维基百科上有複文[1]和節[2]等。区别简单句和复合句的主要标志是看它主谓关系的次数，主谓关系在语法上仅成立一次的句子叫做单句。反之，句中有两层或两层以上主谓关系的就可成为复合句。简单句与复合句的区别决不是以句子长短、单词多少而定。常常是句子很长的是简单句；句子很短，但具有两层以上主谓关系的都是复合句。 1. 分类和结构根据日语复句[3]、试论日语的复合句[4]和试论日语复句中从属句节的多层立体结构[5]等文献，可以对日语的分类和结构做出相应总结。日语中存在着大量的复合句，其联系手段都是不相同的。根据联系手段的不同，大致可把日语复合句分为三大类。 1.1 包孕句句子中的主谓宾补定状的某一个成份或者某几个成份是用主谓结构形成的，这样的句子叫包孕句。每一个顶替句子成份的主谓结构，称为从句，所以有“主语从句”“谓语从句”“宾语从句”“定语从句”“补语从句”等。其中“主语从句”“宾语从句”“补语从句”等常是主谓结构＋形式体言の构成。形式体言“こと”“もの”“の”虽然本身没有固定的词意，但可充当句中各种成份，可把它们分别放在主语、宾语、补语等位置上，用来充当句中相应的各种不同的成分，不过必须在形式体言前面有其说明内容的句子或词组，相当于汉语的包孕句的结构。下面是不同的从句类型及相关示例，{}为各种从句内容。 1.1.1 主语从句{魚が泳いでいるのが}見えます。{向こうから来るのが}李さんです。{この問題をどうやって解「と」くか}、分かりますか。{私が買いたいのは}これです。 1.1.2 谓语从句即在句子中做述語成分わが国は{土地が広いです}。山田さんは{中国語が上手です}。私は{息子「むすこ」が二人います}。 1.1.3 宾语从句即在句子中做对象语和目的语成分電車が来たらまず{人が降りるのを}待ちます。教師は{学生が一人一人本を読むのを}聞いています。私は{王さんがどこへ行ったか}知りません。 1.1.4 状语从句即在句子中做连用修饰语成分今回の試験は{頭が痛くなるほど}難しいです。私は{王さんが言ったとおり}やりましたが、成功しませんでした。私たちの生活は{国が発展するにしたがって}良くなっていく。 1.1.5 定语从句即在句子中做连体修饰语成分{私が買いたい}辞書はこの日中辞典です。ここは{私が勉強している}大学です。{私が大学を卒業した}時、姉は25歳でした。 1.1.6 补语从句私はその時まで{日本の映画館は全部指定席だと}思っていたのです。私は{子供たちは立派な将来があると}考える。 1.2 主从句在这类复合句中，分句与分句之间的关系不是平等并列的，而是有主有从的。一般从句在前，独立于主句之外，主句在后，形成两层或两层以上的主谓关系，以各种接续助词、助动词、形式体言或用言的各种活用形、惯用形等作为联系手段，把前后两个不同的分句连结起来。根据不同意义的连接手段，可把主从句分为原因、结果、条件等从句。主句和从句可以各有自己的主语，也可以通用一个主语；不同的主语时一般情况下，从句主语用が，主句主语用は（有违反此规则的时候）；通用主语的情况下，主语用は，其位置在句子的最前面。另外，接续助词与从句连接时，不同的接续助词有不同的活用形要求，请注意。 1.2.1 状态从句表示同时发生的状态，“一边…一边…”私は{テレビを見ながら}食事をする。政府「せいふ」は{都市の発展を促進「そくしん」しつつ}、環境「かんきょう」も改善「かいぜん」していく。 1.2.2 让步从句表示“虽然、即使、要是…就好了”等{雨が降っているが}、訓練は中止しない。{雨が降っても}、訓練は中止しない。{君がもう少し早く来たらよかったのに}、バスはもう出てしまった。{自分がいくらできるとも}、油断は大敵「たいてき」だ。彼は{知っているくせに}、知らない振りをしている。 1.2.3 条件从句日语中存在着一些用各种活用形加上不同的助词、助动词连接起来的条件从句。这种句子的意义，相当于汉语的“只要/一旦/如果/假如…就…”。 归纳起来有四种表现方法。 1.2.3.1 「と」主要表示客观上的事实，客观性较强，表示两种动作相继发生。使用条件语「と」的规则: 把「と」加到条件后面，再跟上满足了条件会发生的结果: [ 条件 ] + と + [ 结果 ] 状态表示必须显式声明: [ 状态 ] + だと + [ 结果 ] 例句: 学校に行かないと友達と会えないよ たくさん食べると太るよ 1.2.3.2「なら(ば)」使用前提条件语「なら」的规则: 把「なら」加在前提条件后面: [ 假设会发生的前提条件 ] + なら + [ 结果 ] 不能加表陈述的「だ」 也可以用「ならば」替代「なら」，两者意思完全一样，但前者让人感觉更正式。例句: みんなが行くなら私も行く アリスさんが言うなら問題ないよ 1.2.3.3「ば」这种条件语是通用的，它不预设条件，也没有蕴含的意思。「ば」条件语的活用规则如下，注意名词和な形容词的活用规则其实是在活用「である」里面的动词「ある」「ば」的活用规则: 对动词: [ 一类え形活用词根 ] + 「ば」，即把动词最后假名从 /u/ 段改为同行 /e/ 段，再加上「ば」 对い形容词以及「ない」结尾的未然形: 把最后的「い」换成「ければ」 对名词和な形容词: 加「であれば」 例句: 友達に会えれば、買い物に行きます お金があればいいね 楽しければ、私も行く 楽しくなければ、私も行かない 食べなければ病気になるよ 1.2.3.4 「たら(ば)」完成时条件语「たら」的重点在于满足条件后发生的事，主要用来表示对事物完了的假定。「たら」的活用规则: 首先把名词、形容词或动词活用为过去形，再加上「ら」 也可以用「たらば」替代「たら」，类似「ならば」，二者意思完全相同，只是前者感觉更正式。例句: 暇だったら、遊びに行くよ 学生だったら、学生割引で買えます 1.2.3.5 「もし」「もし」是条件句中常用的一个副词，用来增加一种对假设条件不确定的语气，可以翻译为“要是，如果”。但是必须搭配上述四种条件句的形式使用，「もし」本身是不能构成条件句的语法形式的。例句: もしよかったら、映画を観に行きますか？ もし時間がないなら、明日でもいいよ。 1.2.4 原因从句表示“因为、由于”等原因，一般有以下联系手段。 1.2.4.1 から[ 原因 ] + から + [ 结果 ]如果原因是字典形名词或な形容词，后面必须加「だ」来显式的表示它是原因，即「( 名词 / な形容词 ) だから」。如果忘了在「から」前面加表陈述的「だ」的话，听起来「から」就是「从…」的意思了。如果是在用丁宁语的话，应该把「から」当成普通名词，在后面加「です」。有上下文的时候，原因和结果都可以省略掉。省略原因的时候，必须加上表陈述的「だ」或「です」，所以经常会听到「だから」例句: 時間がなかったからです うん、時間がなかったから だからパーティーに行かなかったの？ 天気が悪いから、山へ行くのは止めましょう。 1.2.4.2 ので「ので」基本上跟「から」可以互换使用，除了一些微妙的区别。「から」显式的表明了前面的句子是原因，而「ので」这仅仅是把两个句子连了起来，然后把前一个句子变味了解释的口吻。「ので」听起来口气更柔和，也更礼貌，所以在解释做了失礼之事的原因的时候，人们更倾向于用它而非「から」。总体上来看，在说话者的意志和能动性更强时，使用「から」；如果需要较恭敬的表达，或者是表达判断的理由时，用「ので」较多。「の」前面如果是字典形名词或者な形容词的话，一定要加「な」解释口气的「の」可以简写成「ん」，说话的时候「ので」也可以改成「んで」，因为这样可以省略音节 / o / 的发音，形成连读。例句: 時間がなかったのでパーティーに行かなかった ちょっと忙しいので、そろそろ失礼します 私は学生なので、お金がないんです なので、友達に会う時間がない 天気が悪いので、山へ行くのは止めました。 1.2.4.3 ため写成汉字应该是「為」。与「から」和「ので」相比，「ため」是一个能够与对方拉开距离的词语。「から」和「ので」都是传达说话者的意志和判断的表达方式，与此相比，「ため」多用于描述发生的事情。正因为此，「ため」多在新闻和论文中被使用，它能给对方一种严肃感，让人觉得情报的来源很可靠。例句: 大雨のため一時通行止めとなった 王さんは風邪を引いたために、会社を休みました。 1.2.4.4 によって「に」在表示对象、方向时通常接的是名词，但在表示目的、目标时既可接名词也可接动词简体。「よって」原形为「よる」，可写做「寄る」、「拠る」、「因る」等，「～によって」這個句型在日文中是常见的，用法很多，主要有以下几种: 名词 + によって(により/によりまして/による) + 名词。依据前者的条件及选项取舍的不同，結果、情況、作法也会随之改变的句型表现。「AによってB」A只能置入名詞，作为条件依据，而随着A不同B也會改变，中文意思为「依A的不同而B」。 名词 + によって(により/による) + 名词。表示事物、情況成立或发生的理由以及原因之句型表现。「AによってB」A只能置入名词，表理由、原因，因为A而造成B的场面 名词 + によって(により/による) + 名词。表示方法、手段之句型表现。「AによってB」A只能置入名词，表方法、手段，意即透过或运用A作为手段而来做B，有些人会将它与「～によると」的传闻来源表现搞混，需要注意。 名词 + によって(により/による) + 名词。表示消息、传闻的来源或出处的句型表现。「Aによると～」A只能置入名词，表示消息、传闻的来源，「によると」的結尾常与「～そうだ」、「～ということだ」一起使用。 例句: 日本人との付き合いによって日本語の会話を練習している 1.2.4.5 おかげで可以译为“托…的福”。规则: 名词 + 「の」 + 「おかげで」 形容词基本形 + 「おかげで」 形容动词 + 「な」 + 「おかげで」 动词基本形 + 「おかげで」 例句: あなたのおかげで助かりました 1.2.4.6 せいで名词「せい」的汉字是「所为」，「で」是「です」的中顿形式，可以翻译成“是…的所为”，一般是带来不好的结果。规则: 名词 + 「の」 + 「せいで」 形容词基本形 + 「せいで」 形容动词 + 「な」 + 「せいで」 动词基本形 + 「せいで」 例句: わがままな母親のせいで、彼女は結婚が遅れた 1.2.5 结果从句日语中存在着这样一种句子结构: “…は…が…からです(だ、である)”。相当于汉语的“事情之所以这样，是由于…的缘故”。表示一种因果关系。结果从句的“から”是作为副助词和“だ、です、である”结合起来，接在动词的连体形后面做谓语，先强调其结果，后叙述原因。也可以用另一种惯用型“…のは…が…ためです”来表示 例句: 任务を完成するてとができなかったのは计画が十分ではなかったからだ 1.2.6 目的从句表示行为的目的。一般常用惯用形”…ために”、”…には”，是表示达到某种目的的句子。但这种类型的句子，一般做目的状语较多，因为前后两个事项都属于一个主体——主语，如有两层主谓关系者，可看作目的从句。 例句: 私たちは{健康「けんこう」を保つために}、毎日運動をします。 {友人が早く快復「かいふく」するように}心から祈「いの」ります。 私は{朝起きるのに}目覚「めざ」ましが必要です。 1.2.6 方式从句日语中有这样一种惯用型: “…ように”、”…とおりに”，而这两者的前后都是一个句子形式，又具有两层主谓关系，我们可以把它统称为方式从句。 例句: レーニンが教えたように、共产党はプロレタリアートの前卫である 除了表示方式以外，也可以利用 “…ように” 这一形式表示祈使目的。例句: みなが気持よく休めるように、私にちが部屋をきれいに掃除している 1.2.7 时间从句在日常生活的语言中，经常会遇到这类惯用型: “…たびに”、”…ときに”、”…あとで(に)”、”…てから”、”…うちに” 。这一类型句子的共同点是都表示时间的含义，相当于汉语的“每逢…声”、“在…时候”、“在…之后” 、“在…之中”的意义。试论日语的复合句[4]中认为，如果在这一类惯用型前后有两个句子，又具有两层主谓关系，和前述其他副句一样，把它作为复合句看待，将其归属为时间从句。 例句: 吴先生の家に行くたびに、彼はいろいろなおもしろい話を聞かせてくれます 父からはじめ手紙が届いた時、私はとてもうれしかった 私が外出しためとで(に)、陈君があそびに来た 彼らは大学に入学してから、まだ日があさい 1.3 并列句句中有2层以上的主谓结构，虽然这些主谓结构有某种语法形式上的联系，但是在意义上是并列的，互不依赖的。并列句中的各自的句子称作分句，前面的分句是以中顿形式，或者用接续助词て、し、が等，以及某些惯用形与后面的分句连接。例句：①“河水很清澈，河底看得很清楚。”川の水が綺麗で、川の底「そこ」がよく見えます。（用形容动词的中顿）②“客人来了，就在那里喝茶；孩子回来了，那个房间就变成了学习室。”人が来ればそこでお茶を飲んで、子供が学校から帰ってくると、その部屋は勉強部屋になる。（用接续助词て）③“有的人显得高兴，有的人显得伤心。”嬉しそうな顔をする人もいるし、悲「かな」しそうな顔をする人もいます。（用接续助词し）④ “即有山，又有海。”山もあれば、海もある。（用惯用形……も……ば、……も）⑤“冬天过去，春天来了”冬が過ぎ、春が来た 1.4 小结日语的复合句按照基本结构可以分为三大类，包孕句、主从句和并列句，这三者的从属度是逐渐递减的。在实际中，还可以将三者混合起来，构成更为复杂的句式结构。 2. 复句中的时体日语复句中的时体和英语不同，没有十分标准的研究，相应文章也较少，论日语从句的时态变化[6]和浅析日语复句中的“时”和“体”[7]有一些介绍。一般来说，日语复句的时体的基本原则是，主句的时体，以说话者的视角为基准，从句的时体以主句的时间为基准，但也会考虑到说话者的视角。一般来说: 如果从句的动作、状态发生在主句之前，那么通常从句都是过去时，有时也反映在体上例如完成体等 如果从句的动作、状态和主句同时发生，那么通常从句的时和主句相同 如果从句的动作、状态发生在主句之后，此时考虑主句的时间和整个句子在说话者中的视角，若主句是现在时，那从句也就用现在时即可，若主句是过去时，需要考虑从句的动作、状态在说话者视角中是否仍处于过去时，是则也用过去时，否则现在时。 总结本篇文章主要介绍了日语复合句的内容，下一篇将尝试综合考虑已有内容归纳日语句子的改造顺序。 Footnote1.Wikipedians. 複文. Wikipedia, Wikimedia Foundation, 16 Apr. 2018, ja.wikipedia.org/wiki/複文. ↩2.Wikipedians. 節 (文法). Wikipedia, Wikimedia Foundation, 18 Apr. 2018, ja.wikipedia.org/wiki/節_(文法). ↩3.henry19931224. 日语复句. 百度文库, 16 Nov. 2011, wenku.baidu.com/view/bfe202d0b14e852458fb5731.html. ↩4.谢秀忱. 试论日语的复合句. 现代外语 3(1982):33-38. ↩5.吴春竹. 试论日语复句中从属句节的多层立体结构. 外语学刊 6(2008):49-52. ↩6.林泽清, and 耿铁珍. 论日语从句的时态变化. 日语学习与研究 2(2000):16-21. ↩7.辛宇峰. 浅析日语复句中的“时”和“体”. 外语与翻译 4(2014):54-55. ↩]]></content>
      <categories>
        <category>humanities</category>
        <category>languages</category>
      </categories>
      <tags>
        <tag>japanese</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日语学习七]]></title>
    <url>%2F2018%2F06%2F18%2Fjapanese08%2F</url>
    <content type="text"><![CDATA[前言上一篇文章介绍了日语的语气，这一篇Kino将要讲解日语的敬语系统。日语敬语是日语中用于表达敬意的表达方式，用来表示说话者、说话对象、话中人物之间的社会阶级、亲疏等关系。出席使用日语的许多社交场合必须使用敬语，以表达适当的身份关系和礼貌。现代日语敬语的分类研究[1] 中介绍了几种日语的分类方式，包括以敬意形式进行的分类和待遇表现进行的分类。而现在常用的分类方法还是按照前者进行分类的，一般可分为丁宁语（礼貌语）、尊敬语和谦逊语三大类。有时丁宁语也可以再另分出郑重语和美化语两类敬语。说话人会根据谈话内容以及对象，而使用相关的辞汇或是动词变形。根据相关参考资料如日语语法指南[2]、维基百科[3]、日语敬语[4]、试论日语敬语现象[5]、日语敬语的常见错误分析[6]对敬体的几大类进行介绍。 1. 丁宁语表示客气、礼貌、文雅、郑重的语言，叫丁宁语，丁宁语是代表说话人礼貌的敬语，代表尊重听话对象。丁宁语反映在句尾，根据句尾的不同，有以下两种情况: 1.1 句尾是动词将动词变为一类い形活用词根，之后再句尾加「ます」。此外，考虑极性和时轴，「ます」形有相应变化: 肯定现在: 「ます」 否定现在: 「ません」 肯定过去: 「ました」 否定过去: 「ませんでした」 1.2 句尾是名词、形容词句尾若是有「だ」，将「だ」除去，之后在句尾加「です」。考虑极性和时轴，「です」形也有不同变化。 表1 い形容词结尾 口语 丁宁语 肯定现在 かわいい かわいいです 否定现在 かわいくない かわいくないです 肯定过去 かわいかった かわいかったです 否定过去 かわいくなかった かわいくなかったです 表2 な形容词或名词结尾 口语 丁宁语 肯定现在 静か（だ） 静かです 否定现在 静かじゃない 静かじゃないです 肯定过去 静かだった 静かでした 否定过去 静かじゃなかった 静かじゃなかったです 1.3 否定情况下的另一种表达上述否定形的丁宁语不是「官方」的正确活用。更加「正确」的活用形应该是把「ないです」部分改为「ありません」，理由是动词「ある」的丁宁未然形不是「ないです」而是「ありません」。所以，「かわいくない」应该写作「かわいくありません」，「静かじゃない」则应该是「静かじゃありません」。实际上，这种所谓的「官方」用法听起来太过呆板和正式。在日常对话中，大家基本用的都是上述介绍的形式，虽然在用丁宁语写作时应该用更加正式的活用形，但日常说话几乎用不到。 1.4 特殊词有一些词汇的丁宁语版本完全是另外一个词汇，主要有: 「ある」: 「ござる」，「ござる」总是以「ます」形出现，即「ございます」 「です」: 「でございます」，其实就是「でござる」的「ます」形活用，从「である」而来，字面意思是「以…的形式存在」 「いい」: 「よろしい」是更正式的表达方式 「さん」: 「様」，这个后缀在口语里面不常用到，即使在说尊敬语或谦逊语。不过，写信的时候一般会用到它，即使对方是熟人也一样。还有服务行业例如收银员或服务员通常会称呼客户为「お客様」。当然了，皇族和神灵一定是会用「様」的，例如「神様」 2. 尊敬语对他人的行为、状态及有关事物等表示敬意的语言，尊敬语代表尊敬话题里施行行为的人。话题提及社会阶级较高的人，例如长辈、师长、上司、客户等，便会使用尊敬语。提及说话人自身的时候，不用尊敬语。 2.1 动词的尊敬语形式对动作主体表示尊敬有四个方法。 2.1.1 用特殊尊敬语动词和一般用语完全不一样。例如动词「する」，尊敬语动词则为「なさる」。动词「話す」，尊敬语动词则为「おっしゃる」。 2.1.2 使用「お……になる」句型一般没有相应尊敬语的动词，也可以换成「一类い形活用词根」，前加「お」、后加「になる」，使之成为尊敬语。例如「読む」，尊敬语可以用「お読みになる」。也可以用「下さい」替代「になる」。当你想用尊敬语动词请别人做什么的时候，这种表达很有用。 2.1.3 使用「お……です」句型将一般动词换成「一类い形活用词根」，前加「お」、后加「です」，也成为尊敬语。例如「読む」，尊敬语可以用「お読みです」。 2.1.4 动词被动形也可以当尊敬语使用「読みましたか」，尊敬语亦可说成「読まれましたか」 2.2 名词形容词的尊敬语形式除了动词外，部分名词也有尊敬语。例如「その人」，尊敬语是「その方」。一般情况下，大部分名词前可以加上词头表示尊敬。日语固有词即訓読み单词通常加「お」，例如「お顔」、「お話」，汉字词即音読み单词通常加「ご」，例如「ご冗談」、「ご両親」。如写成汉字，两者均作「御」。部分形容词也加上「お」、「ご」做成尊敬语，规则与名词类似。例如「お忙しい」、「お元気」、「ご満足」。 3. 谦逊语谦逊语又称谦让语，说话人通过谦虚地讲述、甚至是贬低话题中行为主体的动作，用来对接受行为的人表示尊敬。行为主体是说话人自身的时候，也可以用谦让语。 3.1 用特殊谦逊语动词谦逊语可以用特殊词汇来表示，例如自有一套动词。一般例如动词「する」，谦让语动词则为「いたす」。一般动词「話す」，谦让语动词则为「申す」。 3.2 使用「お/ご……する/いたす/申し上げる」句型另外，如果没有相对的谦逊动词，可以使用「お/ご……する/いたす/申し上げる」句型。一般动词换成「一类い形活用词根」，前加「お」或「ご」、后加「する」或「いたす」，便可成为谦让语，「いたす」实际上又是「する」的谦逊语。例如「持つ」，谦让语可以说成「お持ちする」，「案内する」谦让语可以说成「ご案内する」。 3.3 注意事项部分谦逊语已经成为固有短语，例如「いただく」本为「もらう」的谦逊语，但这个动词的丁宁语体「いただきます」则是吃喝之前所说的寒暄话。 4. 特殊动词4.1 特殊尊敬语和特殊谦逊语这里列出一些尊敬语和谦逊语与一般用语完全不一样的动词。 表3 尊敬语和谦逊语 字典形 尊敬语 谦逊语 する なさる 致す 行く いらっしゃる／おいでになる 参る 来る いらっしゃる／おいでになる 参る いる いらっしゃる／おいでになる おる 見る ご覧になる 拝見する 聞く － 伺う 言う おっしゃる 申す／申し上げる あげる － 差し上げる くれる 下さる － もらう － いただく 食べる 召し上がる いただく 飲む 召し上がる いただく 知っている ご存知（です） 存じる 4.2 特殊尊敬语和特殊谦逊语的活用规则在使用特殊尊敬语和特殊谦逊语基础之上，还可以对这些动词使用丁宁语的规则。但这些动词很多并不遵循普通的ます活用规则，包括「なさる」、「いらっしゃる」、「おっしゃる」、「下さる」和「ござる」。对这些东西要改写为ます形的话，不是像う动词那样把「る」变为「り」，而是要变为「い」。除了ます形，它们的其他活用规则跟普通う动词一样。 表4 尊敬语和谦逊语的特殊活用规则 字典形 ます形 过去ます形 未然ます形 过去未然ます形 なさる なさいます なさいました なさいません なさいませんでした いらっしゃる いらっしゃいます いらっしゃいました いらっしゃいません いらっしゃいませんでした おっしゃる おっしゃいます おっしゃいました おっしゃいません おっしゃいませんでした 下さる 下さいます 下さいました 下さいません 下さいませんでした ござる ございます ございました ございません ございませんでした 总结本篇主要讲解了日语的敬语系统，下一篇将讲解日语中的复合句。 Footnote1.姚莉萍. 现代日语敬语的分类研究. 日语学习与研究 3(1996):6-10. ↩2.Tae, and Pizza. 敬语和动词词根. 日语语法指南 | Learn Japanese, http://res.wokanxing.info/jpgramma/polite.html. ↩3.Wikipedians. 日語敬語. Wikipedia, Wikimedia Foundation, 7 June 2018, https://zh.wikipedia.org/wiki/日語敬語. ↩4.三吉礼子. 日语敬语. 北京大学出版社, 2006. ↩5.桑凤平. 试论日语敬语现象. 外语与外语教学 8(2001):21-23. ↩6.杜玲莉. 日语敬语的常见错误分析. 东北亚外语研究 6(2004):7-8. ↩]]></content>
      <categories>
        <category>humanities</category>
        <category>languages</category>
      </categories>
      <tags>
        <tag>japanese</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日语学习六]]></title>
    <url>%2F2018%2F06%2F18%2Fjapanese07%2F</url>
    <content type="text"><![CDATA[前言上一篇介绍了日语的语态，这一篇文章开始讲述日语的语气。语气简单来说就是说话者对某一命题的主观意见和心里态度的总称。王忻在日语语气再考(上)[1]和日语语气再考(下)[2]中对日语语气进行了详细的研究，刘峰在日语语气概论[3]中也对日语语气进行了简要说明，日语语法专题教程[4]中有单独一章介绍语气。本篇将结合这些资料，对语气进行相关说明。 1. 语气概述1.1 命题与语气的对立日语的句子(话语)在语义和句法结构的关系上，大体呈现出表现客观语义的“叙述素材”和表达主观语义的“句子的叙述方式”两个层面，前者称为“命题内容”，日语为“言表事态”，下文简称为“命题”，后者称为“语气”，日语为“言表态度”，即日语的句子由“命题”与“语气”这两个性质不同的部分构成。具体来说，所谓命题，是指说话人在句中所表述的、与说话人主观思维相分离的客观事实；所谓语气，是指说话人在说话时从说话人的立场出发、主观性地对命题的把握方法和态度。通过两者的对立统一，构成句子的意义结构。 1.2 命题与语气的界定与位置虽说句子是由命题和语气两部分组成的，但并不是说句子等于命题和语气两部分的简单相加。也就是说命题与语气并不是并列关系，而是一种包容关系：{[命题]语气}从作为语气载体的语法形式上来看，命题和语气还是应该能够划分并有自己的位置的。一般说来: 命题部分包括主语部分和谓语部分中的体、认定方式、态、时等。 语气部分包括谓语活用形、系词(即“コピュラ”，在传统语法中称为助动词)及形式名词、终助词/特提助词/陈述副词/感叹词和接续词等等。另外敬语表达形式也应包括其中。 语气的位置是多种多样的，它因种类和词类不同而定。语气表现形式出现在句子尾部的频率大大高于其它位置。王忻在日语语气再考(上)[1]归纳为: 任意一个句子都应有表现语气的部分(尽管有时可能很难清楚地划分出来)，它在句中的位置不定，但句子的后部必然是语气。此外，一个句子有两处以上出现语气时，就应把它们分为主要语气和次要语气等来考察。 2. 语气的分类与语气研究有关的分类可归纳为两大类，一种是对各种不同语气的句子类型进行的分类，一种是对语气载体（表现语气的语法形式）的分类。前者是从句子语一气的类型入手，在对这些类型进行分析的过程中涉及到构成这些语气的“构件”——表现语气的语法形式。后者与前者方向相反，是从这些“构件”入手，对这些“构件”构成的语气进行归纳研究的。 2.1 不同语气类型的分类2.1.1 经典分类日语语气再考(上)[1]和日语语法专题教程[4]中列出了已有的几种较为代表性的分类，包括: 高桥太郎等(2001)编著的《日本語の文法2001》中的分类 仁田义雄(1997)在《日本語のモダリティと人称》中的分类 奥田靖雄(1996)在《文のことーその分类をめぐってー》中的分类 寺村秀夫(1982)在《日本語のシンタクスと意味》中的分类 益冈隆志(2000)在《日本語の文法诸相》中的分类 森山卓郎(2000)在《日本語の文法3モダリテイ》中的分类 井上优在(2006)在《シリーズ方言学2方言の文法》中的分类 2.1.2 详解两种分类2.1.2.1 第一种分类方式日语语气概论[3]中将语气类型分为四类:1. 反映句子所表达内容的功能语气。这是决定句子最基本性质的语气，其有两种类型：信息类与行为类。它们都属于表现类型的语气。信息类语气就承担着向听者传达信息（叙述语气）以及从听者那里获取信息的功能（疑问语气）。 例: 昨日上海に行った(叙述语气，礼貌语气)例: 明日休むか(疑问语气，非礼貌语气) 行为类语气承担着说话者和听话者的行为实现的机能，其中又分为说话者自身行为实现（意志型语气），说话者以自己的行为实现为前提，要求对方也实现某种行为（劝诱语气），要求对方实现某种行为（行为要求语气）。 例: 美味しいな、やっぱり食べようか(意志形语气)例: 仕事もう終わっただろう、じゃ、一緒に帰ろう(劝诱语气)例: 部屋が散らかってるぞ、速く片付けろ(行为要求语气) 2. 针对命题的把握方法的语气。该语气是说话者对于命题内容的把握方式，有两种语气类型：评价语气和认知语气。评价语气是对命题所表达的事象做出的必要、不必要 或者允许、不允许的评价式表达。 例: この仕事を引き受けた以上さ、 最後までやらなくてはならない. 句中的なくてはならない是说话者对やる这个事象是必要的一种评价的表达。例: ここにある飲み物は自由に取ってもいい. 句中的てもいい是表示对取る这个事象是被许可的一种评价的表达。 认知语气在认知的把握方法上，有对命题的基本认知态度，如断 定、推量、对命题成立的可能性、必然性的认知，通过证据来对命题进行把握的表示推断、传闻等语气。 例: 上海は今雪を降っているだろう(推量的语气)例: 今晩、風が吹くかもしれない(可能性的语气)例: 道は濡れているから、 昨夜雨が降っていたようだ(推定的语气)例: 天気予報によると、明日も雨が降るそうだ(传闻的语气) 3. 表示上下文之间关系的语气。该语气称为说明语气，通过提示上下文之间的关系使得听话者对所叙内容更易理解。 例: 遅くなってすみません、 いきなり社長から電話をもらったんだ(说明语气) 4. 表示对听话者的语气。由于语言交流是双方相互进行的，因此，除了说话这自身对命题主观表达外，还有向听话者表示传达的义务，像这类语气称之为对听话者语气。对听话者语气中有两种语气类型：传达态度和礼貌的语气。礼貌体与普通体的选择，要根据双方的年龄、地位、场合等来决定。 例: 昨日、スーパーへ買い物に行った(普通体语气)例: 昨日、スーパーへ買い物に行きました(礼貌体语气) 传达态度语气是向对方传达时在语气上所做的一些细微调整等,传达态度语气通常会用よ、 ね、 わ这种语气终助词来表达。 例: 仕事はストレスがいっぱい溜まっているなあ例: ね、本、ここにあるよ、何で見つからないの? 表示传达的语气既有向对方传达的意图也有自言自语的场合，如なあ多用于自言自语的场合。 2.1.2.2 第二种分类方式日语语法专题教程[4]采用了井上优在「シリーズ方言学2方言の文法」(岩波書店,2006)中对语气的分类。Kino在这里也j简要介绍一下。主要分为两大类: “说话者对命题内容的判断”和“对听话者的发话态度和传递态度”。1. 说话者对命题内容的判断即“判断性语气”、“对事性语气”、“命题指向性语气”，包括“真伪判断性语气”和“价值判断语气”。 真伪判断语气主要包括断定、推量、概然性判断、证据性判断、当然性判断、传闻、说明等语气 价值判断语气主要有“适当适度”、“必要”、“容许认可”三类语气 2. 对听话者的发话态度和传递态度即“发话传递语气”、“对人性语气”、“听话者指向性语气”，包括“描述判断”、“表抒”、“号令”、“疑问、询问、确认”、“强调”等。 2.2 不同语气载体的分类所谓语气载体即表达各种语气的语法形式，如用言活用形、系词、形式名词、特提助词等。在日语语法专题教程[4]中，作者按照语气载体的方式将日语中语气的表达方式主要分为四类: 述语的活用形及其他附着在述语上的语法形式 副词的使用 感叹词和间投助词的使用(这里间投助词的意思是“加在语句和语句、句子中间的助词”，即在句节后通过停顿提示听话者，以表达说话者感叹等语气的助词) 句尾语调 而王忻在日语语气再考(上)[1]和日语语气再考(下)[2]中将语气载体按与命题的距离分为三个级次。下面简要说明一下。 2.2.1 第一级语气第一级语气是以活用形为手段表现的。具体活用形中的哪种形式表达何种语气基本如图1所示。 图1 活用形表达的语气 本图除动词外还可适用于形容词，只是形容词没有劝诱形和命令形。 2.2.2 第二级语气第二级语气是接在表第一级确切语气的形式后，表明说话人对所述内容的态度的形式。在层次结构上它把命题+第一级语气作为一个整体对其进行包容。它由助动词和形式名词+だ的形式担当。根据表意，本群词可分为表述推断事实的推测语气者、表述解释说明的说明语气者和表说话人心中认为“可否”、“愿否”的语气这三小类。前者主要由助动词担任，中者由“形式体言+だ”的形式担当，后者主要由形容词性短语担当。 2.2.3 第三级语气第三级语气的表现形式由特提(取リ立て)助词，陈述副词、终助词、感叹词、部分接续词和敬语等形式担当其中除特提助词(把句子中某些成分特别提出加以强调来表达某种言外之意为特提)、陈述副词是表示对事性语气以外其余均表示对人性语气。与第一级、第二级语气相比，第三级语气的最大特点是位置相对不稳定，第一级语气活用形处于谓语位置，第二级语气系 词又是紧随活用形之后，位置都比较固定，而第三级语气因成分复杂等原因位置也就不固定了。从词类来看表现对人性语气的终助词、感叹词和接续词位置相对稳定，终助词在句尾，感叹词一 般在句首，接续词则在下句之前。但敬语和表现对事性语气的特提助助词的位置就难以如此简单地划定了。 3. 特殊用法将一个句子全部用片假名书写，用来表示惊讶、敌意等强烈的语气。 总结本篇文章主要阐述了日语的语气，下一篇将讲解日语中的敬体。 Footnote1.王忻. 日语语气再考(上)[J]. 日语学习与研究, 2002(2):18-24. ↩2.王忻. 日语语气再考(下)[J]. 日语学习与研究, 2002(3):18-24. ↩3.刘峰. 日语语气概论(モダリティ)[J]. 科教文汇(上旬刊), 2010(2):141-142. ↩4.马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016. ↩]]></content>
      <categories>
        <category>humanities</category>
        <category>languages</category>
      </categories>
      <tags>
        <tag>japanese</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日语学习五]]></title>
    <url>%2F2018%2F06%2F03%2Fjapanese06%2F</url>
    <content type="text"><![CDATA[前言上一篇叙述了日语中的体，这篇文章Kino将讲解日语中的态。语态指在动词做述语的句子中，述语动词和主语的关系，即主语所表示的人物、事物是述语动词所表示的动作、作用的执行者还是承受者，是促进动作进行的人还是具备能力进行动作的人。 1. 主动态从施动者的角度叙述其动作、作用时，使用主动语态。述语动词就是基本形式即可。 2. 被动态被动态表示主语是动作的承受者。从动作承受者的角度，叙述其受到、遭受的动作、作用时，使用被动语态。被动态由述语动词后续助动词「(ら)れる」构成，不同类型的动词构成方式不同，具体为: 五段动词的未然形+れる 一段动词的未然形+られる する的被动态: せられる，约音形: される くる的被动态: こられる 3. 使役态当叙述某个人引起了某个事态或强制、支使、允许他人进行了某个动作时，使用使役态。使役态由述语动词后续助动词「(さ)せる」构成，不同类型的动词构成方式也不同，具体为: 五段动词的未然形+せる 一段动词的未然形+させる する的使役态: せさせる，约音形: させる くる的使役态: こさせる 4. 被役态又叫使役被动态。当叙述某个人受到别人的强迫，不得已、被迫做某事时，使用使役被动态。被役态由述语动词后续助动词「(さ)せられる」构成，不同类型的动词构成方式也不同，具体为: 五段动词的未然形+せられる 一段动词的未然形+させられる する的被役态: させられる くる的被役态: こさせられる 5. 可能态当叙述某人具有某种能力、技能或某事具有发生的条件、可能性时，使用可能态。可能态的构成方式比较多，主要有以下五种。 5.1 使用可能助动词在述语动词后面接续可能助动词「(ら)れる」，不同类型的动词接续方式也不同，具体为: 五段动词的未然形+れる 一段动词的未然形+られる くる的可能态: こられる5.2 使用可能动词把五段动词变成对应行的下一段动词，例如把「歩く」变成「歩ける」，把「読む」变成「読める」等。五段动词在实际的使用中多使用其对应的可能动词，而不是后续可能助动词。5.3 使用「できる」包括以下三种情况: 「する」变为「できる」，「~する」变为「~できる」 名词+ができる 动词原形+ことができる5.4 使用带有可能意义的自动词「分かる」「見える」「聞こえる」等动词本身带有可能的意义，不需要形式变化。5.5 使用接尾动词「うる」在动词的连用形后面接续接尾词「うる」，如「考えうる」「ありうる」等。 6. 自发态当叙述动作自然发生或感情不可抑制时，使用自发态。自发态的构成方式有三种。 6.1 使用自发助动词在表示感情、思想活动的述语动词后面接续自发助动词「(ら)れる」，不同类型的动词接续方式也不同，具体有: 五段动词的未然形+れる 一段动词的未然形+られる する的被动态: せられる，约音形: される6.2 使用可能动词「泣ける」「笑える」「思える」等6.3 使用带有可能意义的自动词「見える」「聞こえる」等 总结这篇文章主要介绍了日语的语态，下一篇文章将介绍日语的语气。 Footnote]]></content>
      <categories>
        <category>humanities</category>
        <category>languages</category>
      </categories>
      <tags>
        <tag>japanese</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日语学习四]]></title>
    <url>%2F2018%2F06%2F02%2Fjapanese05%2F</url>
    <content type="text"><![CDATA[前言上一篇文章介绍了极性和时轴，这一章主要介绍体的相关语法，体的概念在第一篇文章里已经介绍过，此处再介绍一遍: 体表示某个动作或变化在说话人所设的时间轴上处于开始、持续和完成状态中的某一阶段，是从时间角度上对动作和变化的描写或把握。需要注意的是在日语中体仅仅反映在动词上 1. 完整体（完成相）完整体用以整体来描述某个动作或变化，把动词表示的运动从开始到结束的整个过程完整地表达出来，一般不涉及该动作或变化的中间过程。根据涉及的动作是出于“完了”这一界限达成前还是达成后，完整体被分为未成体和完成体两种。 1.1 未成体表示动作即将完成或者将来完成。动词不用做变化。Eg. いま、新聞を読むEg. 明日、新聞を読む 1.2 完成体表示动作的完成，但是并不是一定过去时，整个行为可能发生在未来或是一个经常性的动作，只要在说话人设定的时间轴上是完成的动作即可。动词的变化规则和过去时相同。Eg. 今朝、新聞を読んだEg. 今朝、新聞を読んだ後に散歩に出かける 2. 过程体（継続相）过程体用以描述动作或变化的各个环节，是把这种运动持续过程中的某一个局部表达出来。 2.1 备放体（準備相）表示该动作是为下一步做准备的。表现形式有: 一型词根+「ておく」。其中的动词必须是意志动词。Eg. 明日お客さんが来ますから、お菓子をかっておいてください 2.2 即将体表示动作、行为、作用等就要发生。表现形式有: 「ようとしている」「ところだ」「しそうだ」「ばかりになっている」「かかる」「かける」 2.3 起始体表示动作、行为、作用的开始。表现形式多为复合动词，如「始める」「出す」「かける」等，和「てくる」 2.4 持续体表示动作、行为正在进行或者反复进行，要求动词是一种持续性动词。表现形式很多，有: 「ている」「てくる」「ていく」「ているところだ」「つづく」「つづける」「つづある」「一方だ」「ている最中だ」「中」，相当于汉语的“正在…”、“持续…”、“持续…” 2.5 完结体表示动作、行为的完成、结束。表现形式多为复合动词，如「終わる」「あがる」「あげる」「尽くす」「切る」「通す」「ぬく」等，和「てしまう」 2.6 存续体表示动作或作用完成后的状态的存续。表现形式有: 「ている」「てある」「(ら)れている」「たところだ」「たばかりだ」等，相当于汉语的“…了”、“…着” 3. 特殊体3.1 完成体的进行意义有些动词虽然是“完成体”的形态，但并不表示“完成体”的基本意义，而是表达行进过程中的状态。「いく」「くる」以及类似它们的「むかい」「おく」之类的移动动词，以「していく」「している」的形式出现的动词，以及被「どんどん」「ぐんぐん」等行进性的副词修饰限定的变化动词等属于此类。 3.2 完成体与持续体相同意义的情况表状态时“完成体”和“持续体”两者表达同样事物，“体”未实现其分化。主要有以下两类: 表说话人以感官感觉到的状态性现象 表存在 3.3 整体性无法识别的情况在表示说话人内心活动时，是否是整体性处置的状态看不出来。主要有以下两类: 表说话人的考虑和想法 表说话人的感觉 总结本篇文章主要叙述了体的概念，下一篇将讲解日语中的态。 Footnote]]></content>
      <categories>
        <category>humanities</category>
        <category>languages</category>
      </categories>
      <tags>
        <tag>japanese</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日语学习三]]></title>
    <url>%2F2018%2F06%2F01%2Fjapanese04%2F</url>
    <content type="text"><![CDATA[前言————更新于2018.06.01————上一篇文章介绍了词类系统和句法成分，这篇文章Kino主要来讲解极性时轴。在语言学中，极性———即Polarity———表示该句是肯定还是否定、判断真还是假，具体细节可参考極性[1]、Affirmation and negation[2]、Polarity item[3]等，时轴在这里指时(tense)，在第一篇文章里已经介绍过，Kino为了凑够四字标题且避免使用时态这种说法，就用了时轴这个词，灵感来源于现在常用时间轴来表示过去、现在、将来，后续为方便大多还是只用“时”这个称谓了。将极性和时轴放在一起且最先介绍的理由为: 这两项较为容易理解，且负极性（否定）搭配过去时的变形经常互相影响。考虑极性、时、体、态、式以及敬体系统，在讨论其中一项或几项的概念规则时，其他几项应该有相应基准作为参考，按照惯例应该是正极性、现在时、一般体、主动态、陈述式、非敬体。 1. 极性如前所述，极性分为肯定和否定。本章将分两大节来讲解极性，一是在句尾变形表示整个句子的极性，二是在句中变形词汇表示修饰语的极性。本章所述均为当前状态，也就是现在时。 1.1 句尾完整句子的句尾肯定是述语，包括名词、形容词和动词，其中句尾是名词、形容词时，表达一种状态、情感等，句尾是动词时，表达一种动作。 1.1.1 名词以“我是学生”、“我不是学生”为例。 肯定: 句尾名词后加「だ」表示肯定极性，「私は学生だ」 否定: 句尾名词后加「じゃない」，「私は学生じゃない」 注意: 肯定极性中的「だ」可以省略。 1.1.2 形容词な形容词和い形容词规则不同，分开来讲。 1.1.2.1 な形容词规则和名词在句尾相同，以“学校安静”、“学校不安静”为例。 肯定: 句尾な形容词后加「だ」表示肯定极性，「学校が静かだ」 否定: 句尾な形容词后加「じゃない」，「学校が静かじゃない」 注意: 肯定极性中的「だ」可以省略。 1.1.2.2 い形容词以“她可爱”、“她不可爱”为例。 肯定: 不做变化，「彼女は可愛い」 否定: 句尾い形容词，将「い」变为「くない」，「彼女は可愛くない」 1.1.3 动词一段动词、五段动词和特殊动词不同，分开来讲。 1.1.3.1 一段动词（る动词）以“我吃饭”、“我不吃饭”为例。 肯定: 不做变化，「私はたべる」 否定: 句尾一段动词，将「る」变为「ない」，「私はたべない」 1.1.3.2 五段动词（う动词）以“我玩”、“我不玩”、“我买”、“我不买”为例。 肯定: 不做变化，「私は遊ぶ」、「私は買う」 否定: 句尾五段动词，将词尾变为同行「あ」段假名，再加上「ない」，也即将 /u/ 音变为 /anai/，但是以「う」结尾的词需要变成「わ」，「私は遊ばない」、「私は買わない」 1.1.3.3 特殊动词特殊动词する、くる的的变形比较特别，此外还有ある比较特别。对于する、くる、ある，按照顺序规则分别为: 肯定: 不做变化 否定: しない、こない、ない 1.2 句中用在句中，即做修饰语用。 1.2.1 名词以“是学生的人”和“不是学生的人”为例。 肯定: 名词肯定极性没法直接修饰名词，即*不能使用「学生だ人」这种表达方式。事实上，在日语里没有现在时的“是学生的人”这种形式 否定: 和在句尾做述语的形式相同，「学生じゃな人」 注意: 名词A与名词B没有修饰关系时，可以并排放置使用，如「国际教育中心」，名词A和名词B是从属关系时，即“A的B”这种关系，可以用「AのB」表达 1.2.2 形容词1.2.2.1 な形容词以“有名的人”和“不有名的人”为例。 肯定: 在词尾加「な」，「有名な人」 否定: 和在句尾做述语的形式相同，「有名じゃない人」1.2.2.2 い形容词以“可爱的Kino”和“不可爱的Kino”为例。 肯定: 和在句尾做述语的形式相同，「可愛いキノ」 否定: 和在句尾做述语的形式相同，「可愛くないキノ」 1.2.3 动词和在句尾做述语完全相同，不赘述。 2. 时轴关于时轴，日语里只有两种类型，过去时和现在时，上一章所有变形都是在现在时的情况下，下面结束过去时的变形方式。 2.1 句尾2.1.1 名词以“我过去是学生”和“我过去不是学生”为例。 肯定: 句尾名词后加「だった」表示过去肯定，「私は学生いだった」 否定: 句尾名词后加「じゃなかった」表示过去否定，「私は学生いじゃなかった」 2.1.2 形容词2.1.2.1 な形容词以“学校过去是安静的”和“学校过去是不安静的”为例。 肯定: 句尾な形容词后加「だった」表示过去肯定，「学校は静かだった」 否定: 句尾な形容词后加「じゃなかった」表示过去否定，「学校は静かじゃなかった」 2.1.2.2 い形容词以“Kino过去是可爱的”和“Kino过去是不可爱的”为例。 肯定: 句尾い形容词将「い」变为「かった」表示过去肯定，「キノは可愛かった」 否定: 句尾い形容词将「い」变为「くなかった」表示过去肯定，「キノは可愛くなかった」 2.1.3 动词一段动词、五段动词和特殊动词不同，分开来讲。 2.1.3.1 一段动词以“我过去吃了”和“我过去没吃”为例。 肯定: 句尾一段动词将「る」变为「た」，「私は食べた」 否定: 句尾一段动词将「る」变为「なかった」，「私は食べなかった」2.1.3.2 五段动词五段动词的过去时较为复杂，不举具体例子说明。 肯定: 句尾五段动词的过去肯定变形较为复杂，结尾词不同其形式不同，分别是「す」-&gt;「した」、「く」-&gt;「いた」、「ぐ」-&gt;「いだ」、「む/ぶ/ぬ」-&gt;「んだ」、「る/う/つ」-&gt;「った」，唯一的例外是「行く」-&gt;「行いた」-&gt;「行った」。 否定: 在现在时的否定基础上，将「い」变为「かった」2.1.3.3 特殊动词特殊动词する、くる的过去时变形比较特别，按照顺序规则分别为: 肯定: した、きた 否定: しなかった、こなかった 2.2 句中所有词性的过去时在句中的形式和句尾是相同的，即所有过去时的名词、形容词、动词都可以直接做修饰语，修饰另一个名词。 3. 时极综合对于名词、な形容词、い形容词、一段动词和五段动词，综合考虑极性、时轴和在句子的位置，分别得到表1、2、3、4、5、6。 表1 名词 现在肯定 现在否定 过去肯定 过去否定 句尾 だ じゃない だった じゃなかった 句中 不存在该用法 じゃない だった じゃなかった 表2 な形容词 现在肯定 现在否定 过去肯定 过去否定 句尾 だ じゃない だった じゃなかった 句中 な じゃない だった じゃなかった 表3 い形容词 现在肯定 现在否定 过去肯定 过去否定 句尾 原形 くない かった くなかった 句中 原形 くない かった くなかった 表4 一段动词 现在肯定 现在否定 过去肯定 过去否定 句尾 原形 るない るた るなかった 句中 原形 るない るた るなかった 表5 五段动词 现在肯定 现在否定 过去肯定 过去否定 句尾 原形 /u//a/ない 「す-&gt;した」「く-&gt;いた」、「ぐ-&gt;いだ」、「む/ぶ/ぬ-&gt;んだ」、「る/う/つ-&gt;った」 否定极+过去时 句中 原形 /u//a/ない 「す-&gt;した」「く-&gt;いた」、「ぐ-&gt;いだ」、「む/ぶ/ぬ-&gt;んだ」、「る/う/つ-&gt;った」 否定极+过去时 表6 特殊动する、くる 现在肯定 现在否定 过去肯定 过去否定 句尾 原形 しない、こない した、きた しなかった、こなかった 句中 原形 しない、こない した、きた しなかった、こなかった 可以看出，除却名词和な形容词，其余几类在作为述语和作为修饰语的情况下，规则是完全相同的。 总结这篇文章主要讲解了日语中的极性和时态，下一篇文章将讲解日语中的动作体貌。 Footnote1.Wikipedians. “極性 (言語学).” Wikipedia, Wikimedia Foundation, 14 June 2018, https://ja.wikipedia.org/wiki/極性_(言語学). ↩2.Wikipedians. “Affirmation and Negation.” Wikipedia, Wikimedia Foundation, 19 June 2018, https://en.wikipedia.org/wiki/Affirmation_and_negation. ↩3.Wikipedians. “Polarity Item.” Wikipedia, Wikimedia Foundation, 19 June 2018, https://en.wikipedia.org/wiki/Polarity_item. ↩]]></content>
      <categories>
        <category>humanities</category>
        <category>languages</category>
      </categories>
      <tags>
        <tag>japanese</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链学习一]]></title>
    <url>%2F2018%2F03%2F24%2Fblockchain01%2F</url>
    <content type="text"><![CDATA[前言最近在协助一个团队做一个和区块链相关的项目，虽然比较边缘性，和区块链联系没那么紧密，但区块链本身还是需要了解一下的。 花了一天阅读了一下区块链技术指南[1] 1. 区块链思想的诞生与概念这一章从数字货币入手，比较了传统纸币和数字货币之间的优劣，概述了设计数字货币时需要解决的技术难点，进而引入了区块链的概念。其中一些以前不了解的细节有: 严格来讲, 货币（money）不等于现金或通货（cash，currency），货币的范围更广，维基百科里的相关解释: Money: Money is any item or verifiable record that is generally accepted as payment for goods and services and repayment of debts in a particular country or socio-economic context. Currency: A currency is a system of money (monetary units) in common use, especially in a nation. Cash: In economics, cash is money in the physical form of currency, such as banknotes and coins. In bookkeeping and finance, cash is current assets comprising currency or currency equivalents that can be accessed immediately or near-immediately (as in the case of money market accounts). 去中心化场景下，数字货币的实现存在的难点: 货币的防伪:谁来负责验证货币 货币交易:如何确定货币从一方转移到另外一方 避免双重支付:如何避免出现双重支付 区块链技术雏形最早出现在比特币项目中，作为比特币背后的分布式记账平台，从记账的角度来看，区块链是首个自带对账功能的数字记账技术实现。跟传统的记账技术相比，其特点应该包括: 维护一条不断增长的链，只可能添加记录，而发生过的记录都不可篡改 去中心化，或者说多中心化，无需集中的控制而能达成共识，实现上尽量分布式 通过密码学的机制来确保交易无法抵赖和破坏，并尽量保护用户信息和记录的隐私性 当前区块链技术的三种典型应用场景: 比特币为代表的公信的数字货币 以太坊为代表的公信的交易处理 Hyperleger为代表的带权限的交易处理 区块链的基本概念: 交易(Transaction):一次操作，导致账本状态的一次改变，如添加一条记录 区块(Block):记录一段时间内发生的交易和状态结果，是对当前账本状态的一次共识 链(Chain):由一个个区块按照发生顺序串联而成，是整个状态变化的日志记录 nonce: In cryptography, a nonce is an arbitrary number that can only be used once. It is similar in spirit to a nonce word, hence the name. It is often a random or pseudo-random number issued in an authentication protocol to ensure that old communications cannot be reused in replay attacks. They can also be useful as initialization vectors and in cryptographic hash functions. 分类: 根据参与者的不同，可以分为公开(Public)链、联盟(Consortium)链和私有(Private)链 根据使用目的和场景的不同，又可以分为以数字货币为目的的货币链，以记录产权为目的的产权链，以众筹为目的的众筹链等 借(Debit): 意味着债务，表示从其他方转移到本科目内; 贷(Credit): 意味着债权，代表从该科目转移出去 2. 区块链技术的价值、挑战和展望 从技术特点上，区块链一般被认为具有: 分布式容错性:网络极其鲁棒，容错 1/3 左右节点的异常状态 不可篡改性:一致提交后的数据会一直存在，不可被销毁或修改 隐私保护性:密码学保证了未经授权者能访问到数据，但无法解析 随之带来的业务特性将可能包括: 可信任性:区块链技术可以提供天然可信的分布式账本平台，不需要额外第三方中介机构 降低成本:跟传统技术相比，区块链技术可能带来更短的时间、更少的人力和维护成本 增强安全:区块链技术将有利于安全可靠的审计管理和账目清算，减少犯罪可能性，和各种风险 能否最终带来成本的降低，将是一项技术能否被深入应用的关键 所有跟信息、价值（包括货币、证券、专利、版权、数字商品、实际物品等）、信用等相关的交换过程，都将可能从区块链技术中得到启发或直接受益 涉及领域: 分布式、存储、密码学、心理学、经济学、博弈论、网络协议、系统安全等, 相关限制: 处理性能、扩展性等 常见的分布式系统，可以通过增加节点来扩展整个系统的处理能力。区块链并非如此。 3. 应用场景 有直接或间接依赖于第三方担保信任机构的活动，均可能从区块链技术中获益 金融服务 银行金融管理 证券交易 征信和权属管理 资源共享 投资管理 物联网与供应链 制约区块链技术进一步应用的因素: 首先就是谁来为区块链上的合同担保？特别在金融、法律等领域，实际执行的生活往往还得是由人来做 另外就是物品的数字化。非数字化的物品很难放到数字世界中进行管理。 一些对于上述观点的补充: 做任何应用层面的东西，都要意识到这个社会中最重要的永远是人的存在，所以人性永远在考虑范围内，而区块链的应用脱离了人只考虑数字世界必然是行不通的，需要对人性有所分析，对区块链应用涉及的社会活动所影响到的人的心理都要有充分估计，否则只是空谈而已。 关于物品的数字化，的确是个问题，主要体现在物联网与供应链应用上，因为无法完全数字化，就必然会涉及到人，比如物流过程中从一级到另一级，一个物流人员将一个商品掉包如何确认？肯定不能够通过商品上贴的二维码来保证吧。其实就相当于得找到一个Hash算法，将实际物体映射到数字世界，或者思维转变，不考虑实际物体的数字化，而是着手与供应链过程中涉及到的人的信任保证。 是不是区块链、叫不叫区块链，其实都不重要，主要是利用技术解决在没有”中介”的情况下如何促成一项交易的完成，确保一件物品的归属。减少交易环节是一个实实在在的需求，能够通过一项技术去减少交易环节，最好是P2P且能够保证双方信任的，这项技术的综合成本比原先的交易流程中间过程成本低，就是有价值的，而技术本身的实现并不唯一，但是技术必然需要实现以上需求的核心要求，其中最重要的就是去中心化，反观现在很多产品是打着区块链幌子的积分制而已，根本没有去中心化。 以上观点都是一时的想法… 接触了更多知识有了更多思考之后应该有很多地方需要更正吧 4. 分布式系统的核心问题 一致性问题: 概念: 在分布式系统中，一致性(Consistency，早期也叫 Agreement)是指对于系统中的多个服务节点，给定一系列操作，在协议（往往通过某种共识算法）保障下，试图使得它们对处理结果达成某种程度的一致。 解决分布式系统一致性问题的核心思想是: 将可能引发不一致的并行操作进行串行化 一致性需要满足的要求: 可终止性(Termination): 一致的结果在有限时间内能完成 共识性(Consensus): 不同节点最终完成决策的结果应该相同 合法性(Validity): 决策的结果必须是其它进程提出的提案 强一致性: 顺序一致性(Sequential Consistency)、线性一致性(Linearizability Consistency) 弱一致性 关于一致性问题，在学习多智能体协同控制相关知识的时候，也是重点研究的，其实本质上都是相似的，因为多智能体系统也是一个分布式系统，只是在多智能体问题中，一致性通常是更为严格地被数学模型所表达，最简单的就是多个智能体之间某一变量的一致，如位置、速度、加速度等，以方便最后理论证明提出的控制算法是否满足一致性，而计算机分布式系统中将所有进程看成一个序列，考虑序列的一致性，通常是保证序列元素的执行顺序。 共识算法: 保障系统满足不同程度的一致性的解决方法。即便在网络通信可靠情况下，一个可扩展的分布式系统的共识问题的下限是无解。 FLP不可能原理: 在网络可靠，存在节点失效(即便只有一个)的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性算法。PS: 如果套用多智能体系统里的概念，相当于，若节点间组成的网络拓扑是不连通的，则系统无法达到一致性，但是如果长时间来看，即使某一时间段某个节点down掉了，只要下一时间段可以恢复，从而保证连续时间上的连通性，系统最终还是可以达到一致的。 CAP原理: 分布式计算系统不可能同时确保一致性(Consistency)、可用性(Availablity)和分区容忍性(Partition)，设计中往往需要弱化对某个特性的保证。 一致性(Consistency): 任何操作应该都是原子的，发生在后面的事件能看到前面事件发生导致的结果，注意这里指的是强一致性 可用性(Availablity): 在有限时间内，任何非失败节点都能应答请求 分区容忍性(Partition): 网络可能发生分区，即节点之间的通信不可保障 ACID原则: 即Atomicity(原子性)、Consistency(一致性)、Isolation(隔离性)、Durability(持久性)。ACID原则描述了对分布式数据库的一致性需求，同时付出了可用性的代价。 BASE原则: Basic Availiability，Soft state，Eventually Consistency，牺牲掉对一致性的约束(最终一致性)，来换取一定的可用性。 PAXOS算法: 三种节点: proposer, acceptor, learner 两个阶段: 准备阶段、提交阶段 Raft算法: Paxos算法的一种简化实现，包括三种角色: leader、candidate和follower，其基本过程为: Leader选举: 每个candidate随机经过一定时间都会提出选举方案，最近阶段中得票最多者被选为leader 同步log: leader会找到系统中log最新的记录，并强制所有的follower来刷新到这个记录 拜占庭问题: 讨论的是允许存在少数节点作恶(消息可能被伪造)场景下的一致性达成问题 PBFT算法: 包括三个阶段来达成共识, Pre-Prepare、Prepare 和 Commit PoW算法 5. 密码学与安全技术 工程领域从来没有黑科技；密码学不是工程。目的是保证信息的机密性、完整性、认证性和不可抵赖性 Hash算法与数字摘要 加解密算法: 保证机密性 数字签名: 用于证实某数字内容的完整性(integrity)和来源(或不可抵赖，non-repudiation) HMAC(Hash-based Message Authentication Code): 即”基于 Hash 的消息认证码”，HMAC(K, H, Message)，其中，K为提前共享的对称密钥，H为提前商定的Hash算法，Message为要处理的消息内容。HMAC 一般用于证明身份的场景 盲签名: 主要是为了实现防止追踪(unlinkability)，签名者无法将签名内容和结果进行对应，且消息的内容对签名者是不可见的 多重签名: 想象成一份文件被n个人管理，需要m个人签名才有效，这就是多重签名。可以用于电子商务、财产分割、资金监管等场景中，实际上类似电子商务这种需要中介担保的场景都可以用到多重签名 群签名 环签名: 属于一种简化的群签名 数字证书: 用来证明某个公钥是谁的，并且内容是正确的 PKI体系: 在非对称加密中，公钥则可以通过证书机制来进行保护，如何管理和分发证书则可以通过 PKI(Public Key Infrastructure)来保障。PKI至少包含以下组件: CA(Certification Authority): 负责证书的颁发和作废，接收来自RA的请求，是最核心的部分 RA(Registration Authority): 对用户身份进行验证，校验数据合法性，负责登记，审核过了就发给CA 证书数据库: 存放证书，一般采用LDAP目录服务，标准格式采用X.500系列 Merkle树，其特点是，底层数据的任何变动，都会传递到其父亲节点，一直到树根。典型应用场景包括: 快速比较大量数据 快速定位修改 零知识证明 同态加密，函数加密: 相关内容可以参考这里 零知识证明(zero knowledge validation): 证明者在不向验证者提供任何有用的信息的前提下，使验证者相信某个论断是正确的 6. 比特币项目 以前以为比特币交易是没有下限的，原来是有的，交易的最小单位是”聪”，即10exp-8比特币 原理和设计、挖矿、工具、共识机制、闪电网络、侧链 7. Ethereum(以太坊项目) 智能合约 8. Hyperledger(超级账本项目) Fabric 9. 区块链服务平台设计 区块链即服务（Blockchain as a Service，BaaS），是部署在云计算基础设施之上，对外提供区块链网络的生命周期管理和运行时服务管理等功能的一套工具 IBM Bluemix云区块链服务 微软Azure云区块链服务 使用超级账本Cello搭建区块链服务 一个看法是，若是区块链应用都建立在少数厂商的云上，那岂不是该云厂商就是实际的中心，区块链要解决的去中心化就不复存在了，私以为还是有一定道理的 10. 一些想法区块链实际需要解决的还是去中心化(多中心化)场景下的信任问题，而涉及到现实世界中时，事情总不是那么容易解决的。一方面现实世界中永远是少部分人掌握大多数资源(生产资料)，无论是号称哪种体制，进行何种革命，到头来不过是一个轮回，而区块链目前看来也不可能是革命的手段，毕竟现在控制人类社会运转的资源并不会因为区块链而进行转移和改变，所以区块链若要大规模应用，如何避免其变成实际上的中心化是个很重要的问题，而这个问题很有可能无解，需要找到一种大多数人都有且数量级相当的资源来作为惩罚或奖励，Kino能想到的是生命值，不过这是不可能的。另一方面就是现在都是靠博弈来保证利益的最大化，保证实际结果的可信，而这些独立于数字世界之外的问题会对现实生活产生的影响有多少，也没有充分论证，博弈某种程度上也许就是把人类的恶拿了出来，而整个世界的社会实验，把整个社会的恶都反映了出来，会有什么情况，也是未知的。所以对于区块链技术将会革命整个现有生产关系的说法，Kino觉得不可能，或者保守点，近几十年年不可能。区块链当前最可能的应用大概还是资源相当的企业间的相关应用，其涉及的相关方需要数量偏少且资源没有数量级上的差别，比如汽车行业供应链上的资金流转。 Footnotes1.区块链技术指南 ↩2.比特币官网 ↩3.以太坊官网 ↩]]></content>
      <categories>
        <category>techonology</category>
        <category>blockchain</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
        <tag>cryptocurrency</tag>
        <tag>digital currency</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用音乐逃离尘世]]></title>
    <url>%2F2017%2F11%2F19%2Flistening03%2F</url>
    <content type="text"><![CDATA[前言以前的文章写到了最爱的十张专辑, 但十张是远不能记录自己的喜好滴. 就把自己硬盘里躺着的歌手、专辑列出来, 顺便按照喜爱程度评个分… 内容 Adele ★★★★★★★★★★高三毕业之后听了Adele…有一次和好友A聊天,A突然说到:”我们当初是怎么熟悉的啊?” 我回答说我也忘了… 其实是假装的,因为莫名感觉有点不好意思哈哈哈毕业那个假期大抵有点寂寞,高中才接触网络,却汲汲于学业和种种琐事,于是毕业就成了一个网瘾少年,每天就玩游戏、聊天,在学校的时候对A很好奇却无机会接触,毕业不知哪来的勇气找人聊天了。最开始聊天的内容基本全忘了,只记得A推荐了Adele的Someone like you,果然音乐才是永恒… 此后Adele一直躺在我的歌单里,也就让我记得了这件小事…然而对Adele的评价却无关这些小事,一切只是因为Adele的声音太好了,前两张专辑太对我胃口了. 19 ★★★★★★★★★★ 21 ★★★★★★★★★★ Amy Winehouse ★★★★★★★★☆☆死亡升华了毒后. 她的生平曾经加重了我对这个世界的绝望、不过对于爵士乐,我好像一直兴趣平平,曾经Norah Jones火遍全球时,也是无法欣赏,小野丽莎是为数不多我能听下去的爵士歌手 Back to Black ★★★★★★★★☆☆ Angelic Foe Oppressed By The Heavens Ankhagram Where Are You Now Anne-Sophie Mutter Carmen Fantasy Anúna Omnis (1997) Bach非专业古典爱好者,若要说一首巴赫的名曲出来,我能记得起来名字的就只有地狱中的奥菲欧了 100 Best Bach (6CD) Glenn Gould - The Complete Bach Collection (38CD) Bang Gang Ghosts from the Past Beethoven [DG 453 700-2]Complete Beethoven Edition (20VOL) Bette Midler Experience The Divine Greatest Hits Birdy96年的小姐姐、啊不对,是小妹妹… Birdy Björk Vespertine Black Box Recorder England Made Me Passionoia The Worst Of Black Box Recorder Black Sabbath Paranoid Bright eyes I’M Wide Awake It’S Morning Buckethead发专辑成瘾的桶头、然而我完整听过的只有一张专辑 1998 - Colma Cat Power Dark End of The Street Moon Pix Myra Lee Sun The Greatest The Greatest(JP Edition) What Would The Community Think Chopin Chopin. Complete Edition (DG 2009) Chris De Burgh Footsteps (2008) Cigarettes after Sex Cigarettes After Sex Cinderella Heartbreak Station Club 8 Best Wishes - Best Of Club 8 Pleasure Cocteau Twins Treasure Corde Oblique A Hail Of Bitter Almonds Respiri Volonta D’Arte Dark Lunacy Devoid Forget Me Not Dark the Suns The Dead End Devil Doll记不清从哪得知这个歌手了,也许是落网推荐的?只记得是和Estatic Fear放一起说的 1989 - The Girl Who Was… Death最早的时候无法欣赏,某天耐着性子听完了,自那以后就不定时拿出来重听一遍. 1990 - Eliogabalus 1992 - Sacrilegium 1993 - The Sacrilege Of Fatal Arms 1996 - Dies Irae Diana Boncheva Beethoven Virus Dido Greatest Hits (Deluxe Edition) Dishwalla Opaline Dreamtale Beyond Reality (2002)序曲是魔兽玩家的记忆、 Duffy Rockferry(Deluxe Edition) Dvar Deii El Mariil Dvořák Dvořák _ The Masterworks, CD40 Eric Clapton Basel, Switzerland (Baloise Session) Layla And Other Assorted Love Songs Estatic Fear A Sombre Dance Gin Wigmore Gravel &amp; Wine Guns N’ Roses Appetite for Destruction 1987 Chinese democracy 2008 Greatest Hits 2004 Lies 1989 (Remastered MFSL) Live Era 1999 The Spaghetti Incident 1993 Use Your Illusion I 1991 Use Your Illusion II 1991 Gwen Stefani Love.Angel.Music.Baby Gérard Darmon On S’aime H.I.M Razorblade Romance Haggard Eppur Si Muove [Limited Edition] Tales of Ithiria ICY Wanderlust流浪癖 住在春天 南澜掌 哼一首歌等日落 比天空还远 浅彩虹 遇见我 黑色香水 Iggy Pop Préliminaires Imperium Dekadenz Dämmerung der Szenarien James Blake Overgrown Jennifer Warnes Famous Blue Raincoat Joan Jett The Hit List Joe Satriani Is There Love in Space Super Colossal The Complete Studio Albums Collection(Additional Creations and Bonus Tracks) The Essential John Lennon Imagine Josh Vietti Best Of Both Worlds Joy Division Closer Substance(1977-1980) Unknown Pleasures Kalmah 2010 - 12 Gauge Kate Bush Hounds of Love Never for Ever The Kick Inside The Whole Story Lana Del Rey Born to die Leonard Cohen Ten New Songs The Essential Leonard Cohen Lisa Ekdhal Give me that slow knowing smile Lou Reed Transformer Lush Hypocrite Lovelife Lynyrd Skynyrd (Pronounced.Leh-Nerd.Skin-Nerd) Second Helping Mac DeMarco Some Other Ones Mazzy Star Among my swan Seasons of Your Day She Hangs Brightly So Tonight That I Might See Michael Jackson The Ultimate Collection (Japanese) Mono Inc After The War Viva Hades Voices Of Doom Monta Always Altamont Good Morning Stranger The Brilliant Masses Where Circles Begin Mozart Mozart_225 (200CD) Mr. Big Bump Ahead Lean Into It Muse Showbiz(1999) Mylène Farmer Innamoramento Nick Colionne Best Of Both Worlds Oasis Don’t Look Back in Anger Let There Be Love Wonderwall Ozzy Osbourne Blizzard Of Ozz Blizzard Of Ozz (Expanded Edition) Paloma Faith Do You Want the Truth or Something Beautiful Paramore Riot (Deluxe Version) Pat Metheny Group 1987 - Still Life (Talking) 1989 - Letter From Home Upojenie Pink Floyd Animals The Dark Side Of The Moon The Dark Side Of The Moon (Immersion Box Set) The Wall Wish You Were Here Portishhead Dummy (1994) Priscilla Ahn A Good Day Where You Grow Up Rachmaninoff Rachmaninov - The Complete Works (2014) FLAC Radiohead A Moon Shaped Pool Shostakovich Shostakovich Edition _ Symphonies - Concertos - Suites - String Quartets - Chamber Music (27CD) SOAK Before We Forgot How To Dream Standfast Standfast Steelheart Tangled in Reins Suede Coming Up SymphonyOrchestra Marco Beasley, Accordone - Morini - Solve et Coagula (2014) Tchaikovsky (60CD) The Cranberries Bury The Hatchet (The Complete Sessions 2002) Everybody Else is Doing It, So Why Can’t We Gold Wake Up And Smell The Coffee The Hampdens The Last Party The Velvet Underground Loaded The Velvet Underground(1969) The Verve Urban Hymns The Weepies (2006)Say I Am You The Who Who’s Next This Mortal Coil 1983-1991 (1993) Bloody Dust &amp; Guitars Filigree &amp; Shadow It’ll End In Tears Tiamat Amanethes Tori Amos Little Earthquake Tracy Chapman Crossroads Let It Rain Matters of the Heart New Beginning Our Bright Future Telling Stories Tracy Chapman Where You Live Vangelis The Best of Instrumental Works Various Artists Beautiful Field[2007] とある科学の超電磁砲 クレヨンしんちゃん TV?映画 主題歌集だゾ デュラララ!! Vivaldi Antonio.Vivaldi.-.[Vivaldi.masterworks(40CD)] WANDS 『SLAM DUNK』 ED 02「世界が終わるまでは」 Xandria Now&amp;Forever Yellow Magic Orchestra Solid State Survivor[1979] Yuhki Kuramoto Winter Holidays вечность.слушать.ветер вечность.слушать.ветер 万能青年旅店 万能青年旅店 何韵诗 First（EP） 诗与胡说（EP） 无名·诗（国语） Awakening Coexistence 刘忻 发光曲线 (Glow Curve) 迷航 (Dedicate To Mind) (2013) 吉森信 DuRaRaRa!!x2 Shou Original Soundtrack[320K] DuRaRaRa!!x2 Ten Soundtrack CD[320K] OST ベストヒット池袋 サイケデリミックス对デュラララ!!爱得太深,也是它的歌曲让我坚持看了下去,没有最开始就放弃… 相辅相成 周杰伦 JAY 范特西 范特西 PLUS-EP 八度空间 叶惠美 七里香 十一月的肖邦 依然范特西 霍元甲 我很忙 魔杰座 跨时代 惊叹号 十二新作 哎呦，不错哦 声音碎片乐队 优美的低于生活 把光芒洒向更开阔的地方 小野リサ 2005-Romance Latino Vol.3 张国荣 I Am What I Am 宠爱 张悬 (2009)城市 戸川純 TOGAWA LEGEND SELF SELECT BEST &amp; RARE 1979-2008 李志 你好,郑州 梵高先生 这个世界会好吗 杨乃文 应该 林宥嘉 神秘嘉宾 林忆莲 回忆莲莲 海がきこえるSoundtrack 海龟先生 海龟先生 燕池 燕歌行 王若琳 Start From Here (Stereo SACD) The Things We Do For Love 王菲 敷衍 浮躁 田馥甄 My Love To Hebe 渺小 細野晴臣 Flying Saucer 1947 Heavenly Music ハリー細野 &amp; TIN PAN ALLEY IN CHINATOWN ホソノバ 細野晴臣 STRANGE SONG BOOK 范晓萱 国语真经典 蔡健雅 呼吸 记念 陌生人 若你碰到他 说到爱 天使与魔鬼的对话 袁泉 孤独的花朵 孤独的花朵 EP 郝蕾 关于TA的伤心事 陈粒 如也 陈绮贞 华丽的冒险 響け！ユーフォニアム オリジナルサウンドトラック「おもいでミュージック」 黄耀明 CROSS OVER(EP) 拂了一身还满]]></content>
      <categories>
        <category>life</category>
        <category>listening</category>
      </categories>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[升级Ubuntu 17.10之后]]></title>
    <url>%2F2017%2F11%2F19%2Fubuntu02%2F</url>
    <content type="text"><![CDATA[前言之前写过一篇安装Ubuntu 15.04之后. 基本上14.04到17.04应该都可以参照, 在自己电脑上这些版本基本都用过, 没什么大问题.前两天在实验室把Ubuntu更新到了17.10, 可能是太久没用Gnome桌面了, 比想象中的好、那就用下去呗 不过也带来了一些问题, 需要一步一步解决 1. Root登录预警: 一般还是遵循医嘱, 不要学我这种野路子默认root登录…两个地方, 一是/etc/gdm3/custom.conf处, 在[Security]下添加AllowRoot=true; 二是/etc/pam.d/gdm-password处, 将auth required pam_succeed_if.so user != root quiet_success注释 2. Root使用ChromeUnity下使用root登录chrome只需要指定user-data-dir就可以了, gnome不行, 还需要额外指定--no-sandbox, 为了使用以前的user-data-dir和指定no-sandbox, 执行了两步. 将Chrome的默认配置位置软链接到以前的Data保存位置: ln -s &lt;your-user-data-dir&gt; /root/.config/google-chrome 修改google-chrome可执行文件/usr/bin/google-chrome, 将exec -a &quot;$0&quot; &quot;$HERE/chrome&quot; &quot;$@&quot;改为:12345if [[ $EUID -ne 0 ]]; then exec -a "$0" "$HERE/chrome" "$@"else exec -a "$0" "$HERE/chrome" "$@" --no-sandboxfi 3. 解决出现Invalid MIT-MAGIC-COOKIE-1 key的问题该问题出现在和X桌面相关的程序中, 比如vim运行之后退出就会出现该信息. 解决方法是删除用户目录下的.Xauthority文件即可, 笔者顺手还删了.xsession-errors和.xsession-errors.old 4. 更改源更新系统之后, /etc/apt/sources.list.d/里添加的第三方源默认会被注释掉, 取消注释, 顺便把冗余文件删除.清华的Tuna源很好用, 在上一篇没有提到, 现在改用. 5. 卸载Unityapt remove unity]]></content>
      <categories>
        <category>techonology</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一起来学Haskell啦]]></title>
    <url>%2F2017%2F11%2F12%2Fhaskell01%2F</url>
    <content type="text"><![CDATA[前言函数式语言Haskell听闻已久, 但是没看过, 最近两周看learn you a haskell for great good![1], 有种相见恨晚的感觉, 现在如果让我一个编程入门者学习的话, 我可能会推荐C++和Haskell吧… Haskell里的思想看完, 再看Python, JS ES2015/16/17引入的一些新特性, 一眼就能理解了. learn you a haskell for great good!这本书看完一遍, 再重新看一遍目录, 从中找到自己印象不深的章节, 稍作记录于此. 1. 安装工具个人推荐用Stack, 官方文档查询步骤就好, 值得注意的是由于G*F*W的存在, stack setup时竟然没法下载GHC, 这里推荐:中科大镜像:http://mirrors.ustc.edu.cn/help/hackage.htmlhttp://mirrors.ustc.edu.cn/help/stackage.html清华Tuna镜像:https://mirrors.tuna.tsinghua.edu.cn/help/hackage/https://mirror.tuna.tsinghua.edu.cn/help/stackage/ 2. 自定义Type和TypeclassFootnotes1.learn you a haskell for great good! ↩]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>programming language</tag>
        <tag>haskell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记十一]]></title>
    <url>%2F2017%2F11%2F12%2Freading11%2F</url>
    <content type="text"><![CDATA[前言毛选4卷版本买了有一年了，还是只看了前两卷，最近又补了下，深感只读一遍是无法理解其中的很多思想的。至于流传的五卷版本，网上找了mobi格式的放kindle上看了。 1. 关于阶级// To do// 都是草稿, 先存着… Footnotes 毛泽东选集]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>毛泽东</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记十]]></title>
    <url>%2F2017%2F11%2F12%2Freading10%2F</url>
    <content type="text"><![CDATA[前言被梁启超致徐志摩函里的几句话启发了, 就找了找原文. 原文颇难寻, 饮冰室合集[1]应该是有的, 只是太过厚重网上无资源, Kino网上搜索后在爱眉小札-志摩日记、书信集[2]找到了.不过也因此想读读梁公的文章, 还将粱公所云以今日之我与昨日之我战作为Kino新的签名. 查阅资料了解到饮冰室合集[1]是最全的, 可是太长必然没法看完吧, 看到还有饮冰室文集[3], 较短, 就找了Kindle版本的来看. 1. 梁启超致徐志摩函嘛, 这一篇不是饮冰室文集里的, 虽然文集里的文章气势磅礴的多, 思想深刻的也有, 此时此刻Kino却最爱粱公这篇梁启超致徐志摩函. 君劢濒行之前两夕，语及弟事，令吾颇起异感。吾昔以为吾弟与夫人(此名或不当，但吾愿姑用之)实有不能相处者存，故不忍复置一词。今闻弟归后尚通信不绝，且屡屡称誉，然则何故有畴昔之举？真神秘不可思议矣。吾初又疑弟亦如君劢然，喜作独身生活，今据劢所云，似又不然，吾益用迷惑。兹事自非局外人所能参末议，然以吾与弟之交，有两事不能为弟忠告者：其一，人类恃有同情心以自贵于万物，义不容以他人之苦痛易自己之快乐，弟之此举，其以弟将来之快乐能得与否，殆茫如捕风，然先已予多数人以无量之苦痛，重闱之悲诧，微，君劢言吾亦可以推想得之，君劢家之老人，当亦同兹感。夫人或与弟同怀抱所痛灭杀(？)然最难堪者两儿，弟既已育之，胡能置之，兹事恐弟将终身受良心上之重罚无以自宁也。其二，恋爱神圣为今之少年所最乐道，吾于兹义固不反对，然吾以为天下神圣之事亦多矣，以兹事为唯一之神圣，非吾之所敢闻，且兹事尽可遇而不可求，非可谓吾欲云云即云云也。况多情多感之人，其幻象起落鹘突，而得满足得宁贴也极难，所梦想之神圣境界，恐终不可得，徒以烦恼终其身已耳。呜呼。志摩，天下岂有圆满之宇宙若尔尔者？孔子赞易无取，以未济终矣，当知吾侪以不求圆满为生活态度。斯可以领略生活之妙味矣。吾以为人类对于两性间相互最好是以“无着落”之态度行之(君劢最能如此，吾亦颇如此。)，则最少亦可以减无量苦痛。吾固知弟为富于情感之人，未易语此，然吾自审吾之情感并不视弟为贫弱，吾固有与弟言此之资格也。呜呼。志摩，当知人生树立甚难，消磨甚易，如志摩之年，实一生最可贵之时期，亦最危险之时期也，若沉迷于不可必得之梦境，挫折数次，生意尽矣，郁邑侘傺以死，死为无名；死犹可也，最可畏者，不死不生，而堕落至不复能自拔，呜呼。志摩，可无愧耶!可无惧耶!吾与志摩相处之日殊浅，吾所虑者或皆不衷于事实，然吾之爱惜吾志摩者至厚，自闻君劢言后，耿耿于中，无一时能释。顷辍课来沪，夜中思此，不复成寐，披衣起，作此数纸。或非志摩所乐闻，然吾终望志摩知我对志摩用情之深，虽今日不寝，终有日能寝也。旬日后即北归，当约志摩就我，再罄其怀抱耳。惓惓之极，不尽欲言，专上志摩爱弟启超 一月二日夜三时上海沧洲旅馆《政治思想史》全部脱稿矣，甚盼，弟能迻译也。 若谈及为何此时此刻最爱这篇信件, 主要是因为这篇信的背景和粱公关于恋爱的论述.彼时, 徐志摩已与张幼仪离婚, 正与林徽因爱恋, 这时粱公写了这封信给徐志摩, 随后徐志摩的回信中有那句著名的得之我幸,不得我命通篇最喜其二，恋爱神圣为今之少年所最乐道，吾于兹义固不反对，然吾以为天下神圣之事亦多矣，以兹事为唯一之神圣，非吾之所敢闻，且兹事尽可遇而不可求，非可谓吾欲云云即云云也。况多情多感之人，其幻象起落鹘突，而得满足得宁贴也极难，所梦想之神圣境界，恐终不可得，徒以烦恼终其身已耳。呜呼。志摩，天下岂有圆满之宇宙若尔尔者？孔子赞易无取，以未济终矣，当知吾侪以不求圆满为生活态度。斯可以领略生活之妙味矣, 论及其中原因, 便是这段话最能麻醉Kino了, 让Kino不要继续陷在难过之中了, 也能用多情多感之人的说辞为对方开脱, 好让彼此心安.PS: 徐志摩的爱情观与Kino当前观念，恰好对立 Footnotes1.饮冰室合集 ↩2.爱眉小札-志摩日记、书信集 ↩3.饮冰室文集 ↩]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>梁启超</tag>
        <tag>徐志摩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记九]]></title>
    <url>%2F2017%2F10%2F08%2Freading09%2F</url>
    <content type="text"><![CDATA[前言想重新认真地读一读鲁迅的文章，就买了鲁迅小全集[1]共5册在此摘录一些句子，颓废的时候用于警醒自己（或者暗示自己接着颓，毕竟鲁迅也曾颓废过 1. 小说全集先从较能吸引人的小说全集开始读起 所谓回忆者，虽说可以使人欢欣，有时也不免使人寂寞，使精神的丝缕还牵着己逝的寂寞的时光，又有什么意味呢，而我偏苦于不能全忘却…… 凡有一人的主张，得了赞和，是促其前进的，得了反对，是促其奋斗的，独有叫喊于生人中，而生人并无反应，既非赞同，也无反对，如置身毫无边际的荒原，无可措手了，这是怎样的悲哀呵，我于是以我所感到者而寂寞评：这句一直到“独有叫喊于生人中”还是积极的，在生活中一个人也确是须先得把自己的想法说出来，才能有进步，无论是被人赞同还是反对，闭门造车总是行不通的 喵喵 Footnotes1.鲁迅小全集 ↩]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>鲁迅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金融交易过程]]></title>
    <url>%2F2017%2F10%2F08%2Feconomics02%2F</url>
    <content type="text"><![CDATA[前言接着挖坑吧、、想着哪个假期或者什么时候闲下来再填上，现在连Kino自己都开始怀疑了、上一篇说的是个人理财与投资，主要是大局观的建立和一些大概的原则，具体到交易过程上，需要做的就是技术性的分析与工程上的实现了，其实目前有的投资不过是货币基金和股票配置，也都是买着玩，主要是通过这个过程使自己被动地关注市场的变化，了解一些交易规则，总结一些经验、其实最终目标是想做一个可以稳定盈利的投资工具（目前只考虑股票了）关于理论方面的内容，主要参阅了”投资心理学”[1]，这主要是源自Kino个人的偏执，Kino以为股票投资最核心的问题是心理问题，在一些投资人的口中就是所谓的投资情绪分析股票某种意义上就是赌博，然而与赌博的不同的是股票投资中你能得到的数据足够多，而普通意义上的赌博大多是”信息非常不完全信息博弈”（Kino编的词），而股票投资中的对于博弈多方的交易数据大多都是可以查到的，只是专业机构可以通过分析或者内幕消息提前获知某些消息，这就是优势。也有看法是信息是投资中最核心的问题，这么说也没错，但是Kino认为信息也是用来驱动情绪的，影响投资人的心理，以此影响多还是空，小的信息用来影响个人投资者的情绪，大的信息会影响机构投资者的情绪，然而不止是实体行业的信息可以影响情绪，只用资金也可以做到影响情绪，这就反应在主力资金在K线上的拉升与打压，这一点上更接近赌博一点，像是赌博中的诈胡。所以说所谓的大牛市，其实就是所有主力资金的情绪都是积极状态，达到了一致性，个人投资者不用管啦，反正会随大流，而熊市来临也是因为所有投资者的情绪都变为消极了，因为羊毛薅完了啊，才不是什么分析文章里忽悠的国际形势又变差了、国家政策又要变了，如果信息属实那的确是有影响，当然也是影响了情绪，但是很多时候都是假信息，所以说信息也不能全信。 理论与应用结合方面参阅了”金融投资系统交易原理与应用”[2]这本书，其实主要还是看原理部分了。因为Kino一直都是靠直觉在写代码啊。 1. 分析流派2. 投资心理3. 工程实现这方面其实自己一直在维护一个工程，到现在连个可以用的Demo都没有做出来、、、计划是做一个网页应用，前端用的框架是最近流行的Vue、考虑到处理的数据量和库的丰富性，后端肯定用Python啊，在Django和Flask之间纠结了一会还是用了Flask，前者太重Kino觉得没必要，网页应用Kino还是习惯做前后端完全分离的，后端只返回JSON数据就好，以及处理大数据。数据库用的PostgreSQL，大多数数据是从网易财经爬的，国庆期间主要就忙活这个了，初步算了下，只考虑A股的话，历史数据大概也得有5000*3000=1500万条，数据库写的不好、校园网爆炸、电脑间歇性崩溃，导致Kino已经放弃了这个假期把数据爬完的想法，寒假回去用台式机跑数据好了 Footnotes1.投资心理学（双语版）（原书第5版）-约翰R·诺夫辛格 ↩2.金融投资系统交易原理与应用-吴军 ↩]]></content>
      <categories>
        <category>humanities</category>
        <category>economics</category>
      </categories>
      <tags>
        <tag>finance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人投资与理财]]></title>
    <url>%2F2017%2F10%2F08%2Feconomics01%2F</url>
    <content type="text"><![CDATA[前言这个国庆假期没有出游，总不能一直看小说、动画度日啊（虽然最终还是变成了这样、、、）花了半天时间在图书馆，挑了一些个人理财与投资类的书籍主要阅读了”个人理财”[1]、”工资是靠不住的”[2]、”简单的投资学”[3]这三本书，第二本书的名字听起来尤其像是劣质书籍，但是在书架前站着随手翻的十几页写得倒是和Kino近期炒股得出的经验挺相符，就也借阅了。整体来看，第一本属于教科书类别，内容齐全，可以让人对自己一生的理财有个大局观，后两本就是个人投资的一些技巧性内容，如果更具体的想要系统地学习证券投资的知识，Kino手头还有本吴晓求的证券投资学，只看了前两章，私以为还可以本来是想国庆期间有空就把这些内容整理整理，现在看来又是挖了一个新坑不知道什么时候才能填上了、、 1. 理财规划的基础2. 基础资产理财3. 信贷管理4. 保险管理5. 投资管理6. 退休与遗产规划Footnotes1.个人理财（第3版）-劳伦斯·J·吉特曼 ↩2.工资是靠不住的-卫志民 ↩3.简单的投资学-藤泽数希 ↩]]></content>
      <categories>
        <category>humanities</category>
        <category>economics</category>
      </categories>
      <tags>
        <tag>finance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日语学习二]]></title>
    <url>%2F2017%2F09%2F30%2Fjapanese03%2F</url>
    <content type="text"><![CDATA[前言————更新于2018.05.25————上一篇文章介绍了发音系统和书写系统，这一篇文章主要介绍词类系统和句法成分。词类在语法系统中属于传统语法的范畴，英文为Part of speech，可以参考维基百科词条解释[1]。而句法成分(sentence element)应该属于功能语言学的范围，可以参考这些词条: Sentence element[2]、Grammar relation[3]、Functional theories of grammar-Wiki[4]。 1. 词类系统词类，即把单词按其意义、型态或职能加以分类所得的种别，日语的词类被称为品詞，维基百科上也有对品詞[5]的解释和划分。一般常见的一种划分方式是十二品词[6]，无论什么划分方式大体上都相似，Kino对其做了一点小改动而已。本章只是对日语的词类系统进行介绍，并不涉及任何具体的变形。下面在对每种词类概念进行介绍时，可能会涉及到尚未提及的概念，暂时先不用理解，只是为了概念的完整性将其置于此。 1.1 自立語（独立词、实词）1.1.1 可以活用——用言1.1.1.1 动词表示事物的存在、动作或临时状态。根据不同的分类方法可以有不同的分类方式。 日语里的动词可以分为自动词和他动词，类似于英语里的不及物动词和及物动词，其具体说明可参考自動詞[7]和他動詞[8]，简单介绍如下: 自动词: 动词本身能完整地表达主语的某种动作的词，多用于陈述一些客观结果、动作状态。主语可以是生命体，也可以是非生命体，自动词不能带直接对象，但当地点是动作动词的直接对象，表示离开某地或者经过某地时时有例外，例如部屋を出た。 他动词: 动词本身不能完整地表达主语的某种动作的词，多用于表述人为的动作。主语通常是生命体，重点在于表达主语做了什么，所以需要加上名词表示主语的一个动作对象。对于日语中的一个自/他动词来说，根据其是否有对应的他/自动词，以及形式是否相同，又可以归类为: 绝对自动词: 即只有自动词没有相对应的他动词。 绝对他动词: 即只有他动词没有相对应的自动词。 自他同形词: 即该词本身既是自动词又是他动词。 有对自他词: 即该词有成对出现的另一个动词，这也是最令初学者头疼的一类。首先需要记住，自他动词的意思和汉字都是相同的，只是词尾不同表示不同的自他性。虽然规律不明显，但是有对自他词还是有一些常见规律的。 「れる」结尾的都是自动词（例外: 入れる、忘れる） 「す」结尾的是他动词 「aru」结尾的都是自动词，「aru」变成「eru」就变成了他动词。注意此处Kino并没有用平假名表示，看几个例子就可以明白为何这样表示了: 「始まる、始める」、「まとまる、まとめる」、「かかる、かける」 还有一些其他规律，但是Kino认为如果规律细节条目太多，就容易陷入单纯背诵规律之中，故不一一列举了，不妨日常多背单词、多使用。进行归类不是目的，目的是为了学习者最终流畅地运用，如果只记住了规律，而连单词都没记住几个，就是纸上谈兵了。对于自他动词，Kino认为规律并不重要，多背多读多用，很容易掌握其本质。 按照意义，动词还可以分为意志动词、非意志动词。 反映按人或“有情物”的意志去完成的动作行为，主要分为自控动作（指大脑能够控制的动作）、自控心理活动（指大脑能够控制的心理活动）两类。 反映人的自发性动作、生理心理现象、能力、以及“非情物”的运动。 而和语法最相关的分类方式是根据变形规则上的区别将动词分为三大类，每一类有自己独特的变形规则，会影响到后续时/体/态/式等的说明，这三大类是: 特殊动词: する、~する、くる 五段动词（う动词）: 不是以「る」结尾的动词肯定是五段动词。对于以「る」结尾的动词，如果「る」音前的假名包含/a/、/u/或者/o/元音，那它就是五段动词。 一段动词（る动词）: 以「る」结尾，前面是/i/或者/e/元音的，大多数情况下就是一段动词，一段动词中以/i/结尾叫做上一段动词，以/e/结尾的叫下一段动词。但是也有一些例外，常见的例外如表1。 表1 初级 中级 高级 要る 煎る 嘲る 帰る 焦る 覆る 返る 限る 茂る 切る 蹴る 遮る しゃべる 滑る 罵る 知る 握る 捻る 入る 練る 翻る 走る 参る 蘇る 減る 散る 漲る 照る 交じる 湿る 混じる 滅入る 动词的活用词根Kino主要按照五段动词的变形形式，大体上将动词按照活用形式分为以下几类活用词根: あ形活用词根。由于该词根常用于动词的否定形式中，故在其他文献中都被称为未然形。 五段动词: 词尾变成其所在行的あ段字。 一段动词: 把「る」去掉。例: 「食べる」变为「食べ」 「する」变为「し」，「くる」变为「こ」 一类い形活用词根，Kino还把它简称为一型词根，简化后续说明。因其常用于连接用言，故在其他文献中都被称为连用形: 五段动词: 把最后的假名从う段换成同行的い段假名，也叫一般连用形。例: 「遊ぶ」变为「遊び」 一段动词: 把「る」去掉。例: 「食べる」变为「食べ」 「する」变为「し」，「くる」变为「き」 二类い形活用词根，Kino还把它简称为二型词根，简化后续说明。因其常用于连接用言，故在其他文献中都被称为连用形: 五段动词: 结尾词不同其形式不同，分别是「す」-&gt;「し」、「く」-&gt;「い」、「ぐ」-&gt;「い」、「む/ぶ/ぬ」-&gt;「ん」、「る/う/つ」-&gt;「っ」，唯一的例外是「行く」-&gt;「行い」-&gt;「行っ」。也叫特殊连用形或音便形 一段动词: 把「る」去掉 「する」变为「し」，「くる」变为「き」 う形活用词根: 就是动词原型，由于其可以用在句子结尾处，故被称为终止形，又因为其可用于修饰体言作定语，故也被称为连体形。 一类え形活用词根: 该词根变化规律不分类，任何动词只须将词最后一个假名由「う」段变为「え」段即可。由于其常用于假定语气中(如条件句等)，故被称为假定形。 二类え形活用词根，由于其常用于命令语气中(一般用于军队口令、训诉等场合)，故被称为命令形。 五段动词: 将词尾假名由「う」段变为「え」段 一段动词: 将词尾最后一个假名「る」去掉，并后续「ろ」或「よ」 「する」有两种变形方式，即「し」和「せ」，二者还要分别后续「ろ」和「よ」，即「しろ/せよ」。「来る」变为「来い」 お形活用词根，由于主要用于表示第一人称的意志、愿望、决心或表示第一人称对他人的劝诱等场合，故称为推量形: 五段动词: 将词尾假名由「う」段变为「お」段，然后附上助动词「う」 一段动词: 将词尾最后一个假名「る」去掉，然后附上助动词「よう」 「する」变为「しよう」，「来る」变为「こよう」 1.1.1.2 形容词说明体言（名词）的性质或固定状态，在语义上，形容词多表示性质、状态、属性、描述等含义，如大小、长短、高低、新旧、恶劣、好坏、色彩等。根据变形的形式不同，可以将形容词划分为两类: 一类形容词/い形容词: 以平假名「い」结尾的形容词被称为一类形容词，注意用汉字结尾，汉字的尾音是「い」的不算作一类形容词，例如: 「有名（ゆうめい）」、「綺麗（きれい）」等。例外情况极少，唯一常见的只有「嫌い（きらい）」。 二类形容词/な形容词/形容动词: 不是一类形容词的就是二类形容词咯。 1.1.2 不可以活用1.1.2.1 名词——体言表示事物名称的单词。 一般: 通常用于表示特定物体，如物体、物质、人物、地点等。 代词: 用来代替一般名词或名词短语的术语。代词又可以分为人称代词、指示代词、反身代词等。除第一人称外，其他人称代词在日语中较少使用。 数词: 是代表数字的单词。通常可以用数词修饰的一般名词可以被归类为可数名词，否则被归类为不可数名词，但是日语和汉语一样对此要求并不严格。在英语中，数词可以分为基数词（描述事物数量的多少的数词）和序数词（描述顺序的数词），在汉语和日语中都是通过在基数词上附加特殊词汇表示顺序，但通常还会涉及到后续才会提及的量词，日语里通过在量词后面加上「目」（读作「め」）来表示顺序，如「一回目」表示「第一次」基数词的词根如表2，组合方式和汉语相同，但组合之后某些读音有变化，如图3。其他一些常用的和数量相关的表达方式: 小数用「点（てん）」来表达，如: 0.4「れいてんよん」 分数用「～分（ぶん）の」的形式表示，如: 1/3「さんぷんのいち」 倍数用基数词加接尾词「倍（ばい）」表示，如: 3.5倍「さんてんごばい」 分数用「パーセント」表示，如: 1%「いちパーセント」 负数用「マイナス」加基数词表示，如: -3「マイナスさん」 表2 基本数词词根 – – – – – 一 二 三 四 五 いち に さん し／よん ご 六 七 八 九 十 ろく しち／なな はち きゅう じゅう 百 千 万 億 兆 ひゃく せん まん おく ちょう 表3 一些特殊读音 漢字 ひらがな 三百 さんびゃく 六百 ろっぴゃく 八百 はっぴゃく 三千 さんぜん 八千 はっせん 一兆 いっちょう 量词: 也叫助数词/分类词，用于区别在数词之后附加的一般名词的类型。量词直接加在数词后即可，但日语里比较复杂的一点是，数词后面接不同量词时，某些特定数词的读音可能会变化，这些例外情况有时太多，甚至要专门记忆，通过下面这些常用量词说明表可见一斑。量词可以参考日文量詞[9]和助数詞[10]，以及如果有标日第二版，初级上的P.362-P.365也有相应表格。需要注意的一点是0不用数，因为没东西可数，直接用「ない」或「いない」就行。 表4 与时间相关的量词 日本語 例外 用法 年(ねん) 无 表示年份 月(がつ) 四月(しがつ)、七月(しちがつ)、九月(くがつ) 表示月份 日(にち) 太多，下面单独列表 表示日期 時(じ) 四時(よじ)、七時(しちじ)、九時(くじ) 表示小时 分(ふん) 「一/三/四/六/八/十」分(「いっ/さん/よん/ろっ/はっ/じゅっ」ぷん) 表示分钟和分钟的跨度 秒(びょう) 无 表示秒数和秒数的跨度 週(しゅう) 无 表示星期 年間(ねんかん) 无 表示年份跨度 ヶ月/箇月(かげつ) 「一/六/十」ヶ月(「いっ/ろっ/じゅっ」かげつ) 表示月份跨度 日間(にちかん) 一日(いちにち) 表示日期跨度 時間(じかん) 无 表示小时跨度 週間(しゅうかん) 「一/八」週間(「いっしゅう/はっしゅう」かん) 表示星期跨度 表5 表示日期的量词的例外 序号 汉字 读音 ? 何日 なん・にち 1 一日 ついたち 2 二日 ふつ・か 3 三日 みっ・か 4 四日 よっ・か 5 五日 いつ・か 6 六日 むい・か 7 七日 なの・か 8 八日 よう・か 9 九日 ここの・か 10 十日 とお・か 14 十四日 じゅう・よっ・か 17 十七日 じゅう・しち・にち 19 十九日 じゅう・く・にち 20 二十日 はつ・か 24 二十四日 に・じゅう・よっ・か 27 二十七日 に・じゅう・しち・にち 29 二十九日 に・じゅう・く・にち 表6 其他常用量词的用法 日本語 何时使用 ～人 用来数人 ～本 用来数长的或圆柱形的物体，例如瓶子或筷子 ～枚 用来数薄的物体，比如纸或是衬衫 ～冊 用来数带封面的物体，一般是书 ～匹 用来数小动物，例如阿猫阿狗 ～歳 用来数岁数，注意!有时为了方便写作「才」，且20岁一般读作「はたち」而非「にじゅっさい」 ～個 用来数小（通常是圆的）物体 ～回 用来数次数 ヶ所（箇所） 用来数地点 ～つ 1~9岁的年龄，立体的物品，抽象的事物。注意!不用于10以上的数字 ～杯 用作容量单位，杯、碗、桶匙 ～台 用来数车辆或机器等，台、辆、架 ～頭 用来数大型四蹄动物 ～羽 用来数鸟、兔等，只、头 ～着 用来数衣服数量，件、套 ～番 顺序 ～足 用来数成对物品如鞋、袜等，双 ～度 角度、次数、度数 ～キロ 千、千克、千米 表7 部分量词从1到10的变化 - 人 本 枚 冊 匹 歳 個 回 ヶ所（箇所） つ 1 ひとり いっぽん いちまい いっさつ いっぴき いっさい いっこ いっかい いっかしょ ひとつ 2 ふたり にほん にまい にさつ にひき にさい にこ にかい にかしょ ふたつ 3 さんにん さんぼん さんまい さんさつ さんびき さんさい さんこ さんかい さんかしょ みっつ 4 よにん よんほん よんまい よんさつ よんひき よんさい よんこ よんかい よんかしょ よっつ 5 ごにん ごほん ごまい ごさつ ごひき ごさい ごこ ごかい ごかしょ いつつ 6 ろくにん ろっぽん ろくまい ろくさつ ろっぴき ろくさい ろっこ ろっかい ろっかしょ むっつ 7 しちにん ななほん ななまい ななさつ ななひき ななさい ななこ ななかい ななかしょ ななつ 8 はちにん はちほん はちまい はっさつ はっぴき はっさい はっこ はちかい はっかしょ やっつ 9 きゅうにん きゅうほん きゅうまい きゅうさつ きゅうひき きゅうさい きゅうこ きゅうかい きゅうかしょ ここのつ 10 じゅうにん じゅっぽん じゅうまい じゅっさつ じゅっぴき じゅっさい じゅっこ じゅっかい じゅっかしょ とお 「とお」写的时候是「十」，而不是「十つ」 1.1.2.2 副词修饰用言（动词、形容词）的状态、程度等。副词也可以分为两类，一类是形容词变形成的副词，一类是本身就是副词。其中形容词变为副词的规则为: 一类形容词/い形容词: 把「い」换成「く」。例: 早い → 早く 二类形容词/な形容词/形容动词: 后面加「に」。例: きれい → きれいに 表8列举了一些本身就是副词的词汇。 表8 部分示例副词 日本語 汉语 日本語 汉语 日本語 汉语 すぐ 马上，立即 間もなく 马上，不久 もうすぐ 马上 ずいぶん 相当，非常 なかなか 相当，很 とても 非常，很 ちゃんと 好好地，的确 ゆっくり 好好地，安静地 十分 好好地，充足地 皆 全都 全部 全部 沢山 很多 更に 更加，更 もっと 更加，更 ぜひ 一定 できるだけ 尽可能 ずっと ~得多 ちょうど 正好，恰好 たまり 偶尔，很少 よく 经常 また 还，再，又 こう 这样，如此 まっすぐ 径直地 まず 首先 前に 以前 今度 下次，这回 そろそろ 快要 1.1.2.3 连体词日语特有的一种词类，可以直接用来连接体言（名词）。其实Kino认为连体词的划分不是很必要，通过后续的助词以及各类变形，可以解释大部分连体词了。连体词主要有以下几种形式: 「-の」型: 名词+の的形式，对所修饰的名词起限定作用，如「その」「どの」「この」「かの」「くだんの」「ほんの」「当の」「例の」 「-が」型: 名词+が的形式，对所修饰的名词起限定作用，が在古语中相当于格助词の，如「我が」 「-る」型: 可看作是动词的变形，对所修饰的名词起限定作用，「ある」「さる」「きたる」「あくる」「とある」「かかる」「いわゆる」「いかなる」「あらゆる」 「-な」型: 可看作是形容词的变形，通常表示被修饰名词的属性，如「こんな」「そんな」「あんな」「どんな」「おおきな」「ちいさな」「おかしな」「ひょんな」「いろんな」「異な」「あじな」「ろくな」 「-た（だ）」型: 可看作是动词的变形，通常表示被修饰名词的属性，如「とんだ」「ふとした」「大それた」「れっきとした」 「-ぬ」型: 不常用 「-き」型: 不常用 「-いう」型: 不常用 1.1.2.4 接续词连接句和句，表示前后句顺接，逆接，并列，转换等各种关系的词。一般来说可以分为7类: 顺接、逆接、並列、添加、説明、選択、転換。可以参考接续词总结[11] 1.1.2.5 感叹词表示感叹、回应等，可以单独成句，口语中较常使用。表9给出了一些常见的感叹词。还可以参考这里[12]。 表9 常用感叹词 分类 感動詞 感動詞 感動詞 感動詞 意义 感動（表示感叹） あ ああ ええと おお 啊，哦，哎呀 – あら まあ おや やあ … – いや やれやれ これはこれは それはそれは … – ははあ どれ … 呼び掛け（表示呼唤） あの ねえ あのね おい 喂，嗨，我说 – これ これこれ それ さあ … – よう さて そら こら … – ちょっと もしもし ほら … 応答（表示回答） はい はあ そう うん 行，嗯，不行 – いいえ いや ええ … 挨拶（表示寒暄） ありがとう いらっしゃい おはよう お待ち度様 谢谢，您好 – おやすみ こんにちは こんばんは さようなら … – はじめまして おめでとう ごめんなさい ごきげんよう … 掛け声（表示口号） えっさ よいさ よいしょ どっこいしょ 嗨哟… 1.2 付属語（附属词」虚词）1.2.1 不可以活用——助词决定单词在句中的地位、和其他单词的关系、句子的时态、或是表示特殊的意义等。下面是对各类助动词的分类总结，初次接触有个印象就行，并不是需要全部记忆，助词后续很多内容都是相关的，后续看到可以返回再查阅。更具体的助词分类汇总解释可以查阅这里[13] 1.2.1.1 格助詞连接体言，在文中表示意思关系。 が: 最基本的格助詞，表动作状态的主体，要求愿望的对象等。 の: 表连用修饰语的动作状态的主体，所有格和連体詞的标志。 を: 表动作直接的对象、思考感觉的对象、移动时所经过的路径等。另外可表示移动的起点和经由点，即在此场合中未想定到达点的状况。 に: 连接名詞和動詞的连用形和连体形等。可表现：物体的存在场所或移动的目标点/到达点、动作或物品接受的一方、动作开始或结束时间、動詞的目的、物品存在的场所、基准或频率的标准、变化的结果、使动句的动作主体等，是个用处很广的助詞。 へ: 用法较少，仅表示移动的目标和到达点。与「に」的区别比较暧昧。 と: 表示共同的对象、作用的结果、引用、并列。 から: 表示动作、移动或时刻的起点，物品的原料或最开始的状态，动作或物品授予的一方，因果关系中表示原因理由。连接動詞时表达几个动作的相继发生；在被动句中表动作主体。 より: 主要作为比较的基准而使用。在文章语，尤其是信件中与「から」的意思相仿，表示来自于或起点。 で: 表示复数和团体的范围、动作发生的场所和时间、动作的手段或媒介物、由材料到完成品外观变化较小时可表示原料或材料、动作或状态持续的时间等等，是个用处很广的助詞。 や: 表达列举的并列关系。 1.2.1.2 並立助詞表示两个或以上的并列关系。 の: 表并列或列举，表示程度很糟糕很不堪忍受的语气。比较少用。 と: 连接体言，列举几个事物。 や: 用于名詞或带準体助詞「の」的相当于名詞的结构后、表达事物并列或列举。 やら: 接在体言或活用語的連体形后，表达列举很难决定的两件事，或单纯列举事物时使用。 か: 列举几个事物并从中选择一个或一部分、疑问、和某个动作同时进行或接下来进行另一动作时使用。 なり: 表达列举的事物中的任意一个。有时也作副助詞用。 だの: 接在体言或用言的終止形后，用于在全体中列举几个事物或事件。一般用「…だの…だの」或「…だの…など」的形式。 1.2.1.3 副助词接在体言、副詞、格助詞等的后面，使其产生副词的作用。 ばかり: 接在体言或副詞、活用語的連体形、格助詞等后面，和「だけ」一样表达将物事、程度、原因限定到一个范围内，和「くらい」一样表达物事大概的程度、分量、时刻、距离。另外，也表达马上要做的动作，或刚刚完成的动作或结束的状态。另外接在表否定的「ぬ（ん）」后可表示没做却表现得很明显想做的样态。漢字记为「許り」。 まで: 接在名詞和活用語的連体形后，表示事情、动作在距离上或时间上的限度、范围或到达点。也用于对程度和动作进行限定。还可用于举极端的例子或类推到另一物事。漢字记为「迄」。 だけ: 接在名詞和活用語的連体形或格助詞的后面。表示对分量、程度、限度及范围的限定。漢字记为「丈」。 ほど: 表示动作、物事及状态的阶段。漢字记为「程」，接在名詞和活用語的連体形后，表示大概的分量、程度、動作、状態的程度，也可与否定相呼应表程度的比較。另外「～ば～ほど」的用法表示“越来越…”的意思。 くらい: 表示大概的分量、程度、基准、事态，以强调其程度。漢字记为「位」。 など: 接在名詞及活用語的連体形后面，用于在众多相似物中举一例，总括其他相似物时使用。也可用作委婉语。漢字记为「等」。 なり: 接在名詞、副詞、活用形的終止形、助詞等后面，表示作为几个可选之物的例子。 やら: 接在体言或相当于体言的结构、一部分的副詞、助詞等后面，表达不确定的意思（仅限疑问句或句）。还可在模棱两可无法清楚说明的时候，下接否定语无法确定是哪个的时候使用。 1.2.1.4 係助詞对前面的词进行叙述或表示强调的词。 は: 接在词语、短语、活用語的連用形后，表达从很多物事中取出一个进行说明、提示主题、决定叙述的范围、叙述内容的成立条件等等意义。另外，可接在格助詞和副詞后加强语气；也用于对两个或以上的物事进行比较判断。 も: 可用于提出类似事物，列举或添加，接在程度、感動、強調、不定称語后进行全面的否定和肯定。 こそ: 可用在词语后面进行强调，接在動詞的仮定形和接続助詞「ば」之后进行强调并提出自己想说的重点。 でも: 断定的助動詞「だ」の連用形「で」+係助詞的「も」构成。接在名詞和其他助詞后使用，用于提出一个极端条件（即使…也…）、举一个极端例子并类推到一般场合时（连…也…）、举一例以提议时（譬如…）使用。 しか: 接在名詞和動詞的連体形、形容詞和形容動詞的連用形后，表示特定的物事以外全部否定。后加否定，表示“仅、只”的概念。 さえ: 对已有的事物基础上又进行了追加（除…外，还…多用于负面事物），举一极端例子并暗示其他也是当然的时候（连…都…），与仮定表现一起用表示条件（只要…就）时使用。 だに ：与「さえ」大致相同。但现在多用于固定搭配。 1.2.1.5 接続助詞用于句与句的连接，表现句与句的关系。 や: 用在動詞和助動詞「れる・られる」和「せる・させる」的動詞形活用語的終止形之后，表示動作和作用进行时又进行其他動作和作用。 が: 接在活用語的終止形之后，表示单纯的接续或逆接。 けれども: 接在活用語的終止形后，对内容矛盾的事件进行対比，和放在句前和前文进行逆接时使用。另外「あれも好きだけれどもこれも好き」（也喜欢那个也喜欢这个）这样单纯的接续也可使用。 ところが: 由形式名詞的「ところ」+格助詞的「が」构成，接在过去时态助動詞「た」的終止形后，在对前述事态的发生和事实的确认后表示逆接的假定状态。和「けれども」同样，也能变为接続詞，表示本想干什么却发生了与预想相反的事情。 のに: 由格助詞（準体助詞）「の」+「に」构成，连接内容矛盾的两个句子，表达意外、不平、不満、不服的语气。 から: 接在活用語的終止形后，除了表原因理由之外，还与終助詞的用法相似，表达强烈主張和决意。 ので: 由準体助詞「の」+格助詞「で」构成，接在活用語的連体形后，表示原因、理由、根据、动机。 て: 接在活用語的連用形后，表示继续。 1.2.1.6 终助词用在句末表疑问、禁止、感动等的语气。 か: 用在句末表提问、疑问、反语、责问、反驳、劝诱、请求等等语气。也可表达惊讶和感动的心情。 かしら: 表示怀疑、疑问的语气，也可用在否定的「ない」和「ぬ」后面表愿望、请求的语气。现在多为女性用语，比较文雅的说法。 な: 接在動詞或助動詞的終止形之后表禁止的意思，也可用在終止形和助詞后表轻微的断定和主张、确认、赞叹等语气。可用かな，以表自己不确定的推断。 の: 可用于活用語的連体形之后，表缓和的断定语气（和「かしら」一样意义的女性用语）。也可表达提问、疑问或较强命令的语气。另外也可表感动；近年来常见于表古风的语言方式。 とも: 接在活用語的終止形之后，口语中表达对对方强烈的肯定。不太常用。 ぞ: 对自己及对方的说法的确认，也与疑问词相呼应表达反语及强调的意思。男性用语。 や: 接在形容詞及形容詞型活用的助動詞、助動詞「う、よう」的終止形、動詞及動詞形活用的助動詞命令形后面，表达对同辈或晚辈的轻微催促、希望使某种事态得以实现的心情，或是表现随便说说、轻率随便的语气。另外也有表达疑问和反语的意思，但是很少用。 わ: 用于活用語的終止形之后，表达轻微的决意、主张、赞叹等语气，多为女性用语。 1.2.1.7 間投助詞用在句末用于调整语调，增加感动之类的语气。 さ: 调整语调同时有吸引对方注意的功能，多为男性用语。 よ: 用于号召和强调时。常用「だよ」「ですよ」「ますよ」。 ね: 用于调整语气语调，有种寻求对方认同和回应的功能。常用よね。 1.2.1.8 準体助詞指接在用言后用变为与体言相当的词，如「彼に聞くのがいい」「あちらに着いてからが大事だ」的「の」和「から」。这个功能与形式名詞（「こと」「もの」「ところ」等）相似，叫作準体助詞（準体言助詞）。 1.2.2 可以活用——助动词接续在动词后面，表达时/体/态/式等语法功能。下面列举了一些分类助动词，和助词一样，也不需要刻意记忆，后续其他语法涉及到时有印象即可。具体细节可参考此处[14] 断定助动词: だ、です、である 过去助动词:た 否定助动词: ない、ぬ 敬体助动词: ます 使役助动词: せる、させる、しめる 被动助动词: れるられる 可能助动词: れる、られる 敬语助动词: れる、られる 自发助动词: れる、られる 推量助动词: う、よう、まい 愿望助动词: たい、たがる 推定助动词: らしい 比况助动词: ようだ、ようです、みたいだ、みたいです 样态助动词: そうだ 传闻助动词: そうだ 1.3 复合词除了上述的基本词类，日语中还可以通过将不同词类组合，以此形成复合词，复合后的词属于哪种词类，这决定于复合词的后半部词性。主要内容来源于说说日语复合词[18]，关于日语词汇更详细的构词法可以参考此处[19] 1.3.1 复合名词1.3.1.1 动词一型词根+名词例: 買い物、贈り物、食べ物、読み方、食べ放題、足し算 1.3.1.2 名词+动词一型词根例: 北京行き、トンボ帰り、横殴り、交通止め、共稼ぎ、田植え 1.3.1.3 动词一型词根+动词一型词根例: 買い食い、立ち読み、出入り、食べ残し、すれ違い 1.3.1.4 名词+名词例: 日本全土、高層ビル、万年床 1.3.1.5 一类形容词词干+名词例: 近頃、遠回り、長生き、久しぶり、無駄遣い、悪口 1.3.2 复合形容词1.3.2.1 动词一型词根+一类形容词例: 使いにくい、聞きづらい、待ち遠い、み苦しい 1.3.2.2 名词+一类形容词例: 情け深い（なさけぶかい）、欲深い（よくぶかい）、生臭い（なまくさい）、真ん丸い（まんまるい）、心細い（こころぼそい）、心強い（こころづよい） 1.3.2.3 一类形容词或形容词词干+一类形容词例: 面倒くさい（めんどくさい）、青白い（あおしろい）、薄暗い（うすくらい）、薄べったい（うすべったい） 1.3.3 复合动词常用复合动词的整理可以参考此处[20] 1.3.3.1 动词一型词根+动词例: 立ち上がる（たちあがる）、立ち止まる（たちどある）、立て替える（たてかえる）、辿り着く（たどりつく）、付け加える（つけくわえる）、出来上がる（できあがる）、出迎える（でむかえる）、取り扱う（とりあつかう）、引っ張る（ひっぱる）、引っ越す（ひっこす）、引き受ける（ひきうける） 1.3.3.2 动词二型词根+「て」+动词后面的动词常是「行く」、「来る」例: 連れて行く、連れて来る、持って行く 1.3.3.3 名词、形容词词干+动词例: 近付く、長引く（ながびく）、心得る（こころえる）、腰掛ける（こしかける）、首切る（くびきる）、平謝る（ひらあやまる） 2. 句法成分学习句法成分可以快速分析一句话的构成，更容易理解句子的意思，其有很多不同的划分方式，可以参考文の成分[15]和日本語文の成分[16]。还有一点值得注意的是，日语的句法成分划分主要看格，也就是说常用格助词来区分句法成分。可以看出这些概念是有耦合的。 2.1 主語（しゅご）主语是表示动作、作用状态、性质的主体。 2.2 述語（じゅつご）即谓语，用来说明主语的动作、作用、状态、性质等。 2.3 同格語在相邻的句子成分之间存在修饰、限定或说明关系的结构，通常是两个独立的词，在意义上指同一个事物，在结构上作同一个成分，若是A修饰B，则A叫同位语，B叫本位语。 2.4 目的語（もくてきご）表示句子中他动词所涉及的对象。类似于英语中的宾语。 2.5 対象語（たいしょうご）用来说明主体的感情、可能、愿望、好恶等意识的对象时。 2.6 補語（ほご）表示时间、地点、方向、手段、场所等的成分。 2.7 付加語是插在句子中作补充说明的句节，它与前面的句节没有直接联系。类似于汉语中用“破折号——”插入的短语。 2.8 修飾語（しゅうしょくご）修饰语是对主语和谓语进行详细说明的词语，其中又分为连体修饰语和连用修饰语，连体修饰语是说明体言的性质、状态等，连用修饰语是说明用言的状态、程度等，类似英语语法中所说的定语和状语。 2.9 独立語主语、谓语、修饰语之间都有相互关联的关系，独立语则与这些成分没有之间的关联，是一个相对独立的成分。一般位于句首，表示感叹、应答或连接句子。 2.10 成分与词类句法成分通常都有固定的词类，多个词组成的句节表示的句法成分除外，大部分语言都是如此（然而Kino最熟悉的汉语作为分析语在这方面没那么严格，句法成分和词类对应极其复杂）。表10给出了日语的句子成分和词类的对应关系，但不是绝对对应的，只是大多数情况下都是如此而已。 表10 句法成分和词类 句法成分 词类 主語 名词（包括一般名词、代词、数词） 述語 名词、形容词、动词 同格語 一般名词 目的語 一般名词 対象語 一般名词 補語 一般名词 付加語 通常用句节（短语）表示 連体修飾語 形容词、连体词 連用修飾語 副词 独立語 感叹词、名词 2.11 成分顺序英语和汉语最简单的句子顺序都是主+谓+宾，日语的顺序与此不同，日语的基本语序是主語+目的語+述語。可以参考語順[17]的介绍。 2.12 成分衔接是否按照上述组成顺序，将各个成分简单堆砌在一起就构成了一个完成的句子了呢？当然不是啦，在日语中，句子的成分与成分之间通常还需要用助词实现衔接。主语后常用的助词有「は」、「も」，述语通常在句子最末尾，后常用助动词有「だ」、「ます」等，目的语后常用的助词有「を」，对象语后常用的助词有「が」，补语后常用的助词有「で」。其他几种不是严格通过添加助词表示句子成分。 2.13 成分省略日语和汉语一样，根据上下文可以省略很多句子成分，基本上没有什么是不能省略的，这就需要多看多读多听了。 总结本篇主要介绍了词类系统和句法成分，下一篇将介绍极性时态。 Footnote1.Wikipedians. “Part of Speech.” Wikipedia, Wikimedia Foundation, 22 June 2018, https://en.wikipedia.org/wiki/Part_of_speech. ↩2.Wikipedians. “Sentence Element.” Servent - Wiktionary, https://en.wiktionary.org/wiki/sentence_element. ↩3.Wikipedians. “Grammatical Relation.” Wikipedia, Wikimedia Foundation, 19 June 2018, https://en.wikipedia.org/wiki/Grammatical_relation. ↩4.Wikipedians. “Functional Theories of Grammar.” Wikipedia, Wikimedia Foundation, 19 June 2018, https://en.wikipedia.org/wiki/Functional_theories_of_grammar. ↩5.Wikipedians. “品詞.” Wikipedia, Wikimedia Foundation, 19 Apr. 2018, https://ja.wikipedia.org/wiki/品詞. ↩6.洋渔 . “日文词语分为十二种品词(品词,ひんし).” 豆瓣, https://www.douban.com/note/640814003/. ↩7.Wikipedians. “自動詞.” Wikipedia, Wikimedia Foundation, 18 Apr. 2018, https://ja.wikipedia.org/wiki/自動詞. ↩8.Wikipedians. “他動詞.” Wikipedia, Wikimedia Foundation, 3 Feb. 2017, https://ja.wikipedia.org/wiki/他動詞. ↩9.Wikipedians. “日文量詞.” Wikipedia, Wikimedia Foundation, 20 June 2018, https://zh.wikipedia.org/wiki/日文量詞. ↩10.Wikipedians. “助数詞.” Wikipedia, Wikimedia Foundation, 20 June 2018, https://ja.wikipedia.org/wiki/助数詞. ↩11.日语单词本 . “史上最全的日语接续词总结！考试不再是难题！.” 搜狐网, 10 Sept. 2017, https://www.sohu.com/a/191048812_209715. ↩12.精樱日语 . “日语中常见的一些感叹词.” 豆瓣, 19 Oct. 2015, https://www.douban.com/note/521188596/. ↩13.chexiaomeng. “日语全部助词分类及汇总.” 百度文库, 7 May 2011, https://wenku.baidu.com/view/9e0204ecaeaad1f346933fd6. ↩14.荷塘垚 . “常用日语助动词总汇.” 百度文库, 23 Apr. 2012, https://wenku.baidu.com/view/b0be1a24192e45361066f5a5.html. ↩15.Wikipedians. “文の成分.” Wikipedia, Wikimedia Foundation, 10 May 2018, https://ja.wikipedia.org/wiki/文の成分. ↩16.Wikipedians. “日本語#文の成分.” Wikipedia, Wikimedia Foundation, https://ja.wikipedia.org/wiki/日本語#文の成分. ↩17.Wikipedians. “語順.” Wikipedia, Wikimedia Foundation, 10 June 2018, https://ja.wikipedia.org/wiki/語順. ↩18.日语考试 . “说说日语复合词.” 丫丫日语, 31 Jan. 2015, http://www.yayajp.com/index.php?a=shows&amp;catid=6&amp;id=190. ↩19.ASH9750. “日语语法（九）：日语的构词法.” CSDN博客, 20 June 2017, https://blog.csdn.net/sinat_29315627/article/details/73484302. ↩20.秋谷 . “二级复合动词整理.” 沪江日语, 17 Mar. 2006, https://jp.hjenglish.com/new/p3338/. ↩]]></content>
      <categories>
        <category>humanities</category>
        <category>languages</category>
      </categories>
      <tags>
        <tag>japanese</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开始使用Podcast吧]]></title>
    <url>%2F2017%2F09%2F24%2Flistening02%2F</url>
    <content type="text"><![CDATA[前言近日看见某友玩兴大发，在荔枝读了几首诗，想起来Kino很久前在podcast订阅了一些节目，可能是当时挑的节目不够有趣或是超出Kino的欣赏水平，渐渐就荒废了，既然又想起它了，那就重新开始玩一玩吧 1. 订阅列表鉴于上一次的经验，决定在订阅之前先想明白自己的需求是什么，再去找合适的podcast channels主要分为了以下几个方向: 诗歌 音乐理论 日语 英语 那就逐个寻找吧、诗歌: 为你读诗每天一位特别来宾为你读诗，虽然请来的人朗诵水平不一，但大多数还是可以听的，情感也挺饱满 每日英语诗歌English Poem英语发音挺好，可是没什么情感，也找不到更好的纯粹读英文诗歌的channel 音乐理论: 逗喵音乐教室找遍全网也没有像样地讲解音乐理论的podcast，这是唯一涉及乐理内容且质量也不错的了 日语: myrcella的日语corner语法的部分还不错，上一次玩podcast的时候也听了，但是后期的内容不是很感兴趣 桃子的日语朗读声音很好听，而且也是我想要找的类型，纯粹的读一些日语文章，可以锻炼一下听感吧 未来授業看到推荐的，当作练习听感了，还是因为喜欢发音所以加入了列表 英语: The English We Speak足够简单 Planet Money内容喜欢，毕竟也是一直在看经济学相关的内容 The New Yorker: Fiction小说还是可以听听的 The New Yorker: Poetry回到诗歌 2. 使用工具android上好用的podcast的app不多，以前用的豌豆荚上的盗版pocket casts，现在有了万事达信用卡，想着上google play买个正版的好咯，然而绑定信用卡的时候google play上的地区没有China选项，选了自己google voice所在的美国地区，添加结束，购买却一直失败，和google support的工作人员聊了很久，也没有解决，只好去淘宝买的礼品卡、、、顺便也买了pocket casts的网页版，同步起来方便，不想换其他的产品了，界面足够简洁，但是功能有些缺失，没法添加list是硬伤]]></content>
      <categories>
        <category>life</category>
        <category>listening</category>
      </categories>
      <tags>
        <tag>poetry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日语学习番外篇一]]></title>
    <url>%2F2017%2F09%2F19%2Fjapanese02%2F</url>
    <content type="text"><![CDATA[前言在学习日语比较相关内容时，看到了“花より団子”这句谚语，直译过来就是“与其花，不如团子”，这种生涩绕口的翻译，却瞬间让Kino想起了一个朋友的签名：“比起花，还是青春”，她曾告诉过Kino这是她在某部韩剧里看到的，但是韩剧名我却已经忘了，也不想再去追问。不过还是无意识地点开了一个又一个搜索结果，漫无目的，不知道自己在想什么，却无意间发现了“花より男子”这部漫画，漫画名应该就是套用的“花より団子”，而这部漫画又先后被日本和韩国改编成电视剧“花样男子”，也许，她所说的“比起花，还是青春”正是来自“花样男子”这部剧吧。这样想着，好像就回忆起来当初被告知的那部剧就是“花样男子”一样，不过这些记忆已经变得不真切了，连Kino自己都不敢相信，没必要记住的事就随风散了也挺好说到随风散去，又想起某个盆友说ta很喜欢”Gone with the wind”、、、（Kino内心戏太足了、、） 好吧，其实就是因此突然生出一个想法，以此文记录一些日本谚语、作家作品里的名句、喜欢的歌词、动画里的戳中自己的句子，如此种种，并对其语法结构进行分析，也许还会有感而发写些不成熟的想法，也都算作学习的一环吧。 内容 花より団子 这里的语法主要体现在助词より上，其用于比较，意义是“比，较之，甚于”AよりB（のほうがC）：比起A，B更C。其中C是动词形容词等由于日语语序的灵活性，也可以写成：（Bのほうが）AよりC 生まれて,すみません]]></content>
      <categories>
        <category>humanities</category>
        <category>languages</category>
      </categories>
      <tags>
        <tag>japanese</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日语学习一]]></title>
    <url>%2F2017%2F09%2F16%2Fjapanese01%2F</url>
    <content type="text"><![CDATA[前言————更新于2017.09.16————种种原因（其实是一时冲动），报了12月份的JLPT N2，明知时间很紧，难以通过，但这正是我需要的吧，有个短期内想要完成的目标，为此花上所有胡思乱想的时间，这样就好了。语法和单词是并行着学的，虽然有标准日本语的书籍，但是没有使用，语法主要是参考日语语法指南[1]学习的，单词目前使用的是沪江开心词场。以及自以为学日语过程中还是听日语歌更好，于是将以前收藏的歌汇总做了个歌单。 本文主要整理了九月上半月的语法学习知识。 ————更新于2018.05.20————对于日语的学习，有了新的思考和认识，就推倒原来的结构重新写了一遍。首先介绍下语言学，语言学是有一个不断发展的过程的，在语言学成为科学之前的那一阶段，语法研究的方法和观念通常被概括为传统语法，而语言学成体系之后形成了各种学派，其对语法的研究方式、分类方式也各有不同，例如有新语法学派、结构主义学派和功能主义学派等。当然语言学也并不只是包括语法内容，如音韵、词法、句法等，当然这根据不同的分类方法有不同的结果，广义的语法也可以把词法、句法包含在内。彻底系统地学习这些内容太过繁杂，Kino也并不是语言理论专业的，故建立的日语学习体系肯定没那么严谨，可能跨越了多个学派的方法，杂糅了多学派间的内容，涉及了不同学派的术语，后续的文章中，因为当时的写作状态、相应信息的查询难易度等影响，不是每一章的内容都考察了其学派出处，若有知情者可以给Kino提出建议，Kino会尽快修改。 Kino的整个日语学习系统划分如下图所示： 1. 学习工具本章主要介绍一些日语学习中可能用到的工具。 1.1 日语单词专门学习日语的app大多数都不提供记忆曲线功能，不提供记忆曲线但有自己独特优势的app有最最日语、标准日本语、Japanese、NHK日本語，可以辅助用。提供记忆曲线的日语单词记忆app有souka、卡卡日语，但是总觉得设计不太合理，Kino用的不是特别习惯。不专门针对日语学习的记忆卡片类应用anki，用来自己随手制作卡片很好，但是想拿到直接使用需要找到合适的词库。此外，还可以下载一些日语母语者常用的app玩耍，如新闻类的SmartNews，可以设置只看日语新闻，菜谱类的Delish Kitchen(Google play上不经意间看到的)等。 1.2 语法还是有参考之前的日语语法指南[1]，随手查阅和复习还是很实用的，进一步的语法学习参考了维基百科相关内容和参考书[2]。 2. 基本概念这一章Kino挑选了一些重点概念进行介绍，主要是为了方便对后续文章的理解。 2.1 语法范畴这一节介绍了维基中文上的语法范畴[3]词条的内容，当然从参考文献看该内容的最原始出处该是Features: Perspectives on a key notion in linguistics。语法范畴的常见归类有: 性(genus): 是指一个名词或代词的类别，以及形容词、冠词或动词在与名词或代词搭配时发生的屈折变化。英文对照参考 数(number): 在语言学中，名词、代词、形容词、动词都有数的区别。一般分为单数和众数（复数），但是部分的语言亦具有双数（例如阿拉伯语），更有少数的语言具有三数（例如多罗马科语）、微数（Paucal，代表“少数的”）等。英文对照参考 格(casus): 也叫语义格，是名词或代名词因语义角色不同而变化。英文对照参考 时(tempus): 是表示行为发生的时间和说话时的关系。一般分为过去时、现在时、将来时，通常也有与表示动作进行或终止的进行式和完成式等体貌一起相连用的情况。注意时态和句式是两个概念，过去时、现在时、将来时不能写为“过去式”、“现在式”、“将来式”。英文对照参考 体(aspect): 也叫体貌/动貌，表示事件的内部时间结构，例如关于该动作的开始、持续、完成或重复等方面的情况，但不涉及该动作发生的时间。注意区分, Grammatical aspect 是指”貌”，而 Lexical aspect 是指”体”。英文对照参考 式(modus): 也叫语气/语式，指通过一定的语法形式，说明动作或过程的进行方式，也就是说话者对行为或动作的态度。英文对照参考 态(genus verbi): 也叫语态，在语法学中描述句子中动词和参与此动作之主语之间关系的一个术语。英文对照参考) 身(person): 也叫人称，是与语言中的行为动作相关的话语角色。英文对照参考 级(comparison): 是关于形容词和副词的性质、状态在用于比较时的不同程度的语法范畴，属于比较常见的一类语法范畴。英文对照参考 如果想了解更丰富的相关语法特性的分类，可以参考Grammatical category[4] 2.2 相关易混淆概念 时态: 在英语学习时，国内英语教材一般并不会对这些概念进行介绍和区分，然而英语语法学习过程中又经常提到时态，这里所说的时态其实是时(tense)和体(aspect)的综合，不是单纯的表示时(tense)，也不是时(tense)和态(voice)的综合，但是tense又常被翻译为时态，所以需要在细分这些语法概念时，区分清楚这些概念，否则就容易在学习过程中混淆。 2.3 Kino的碎碎念Kino看过的大多日语语法介绍，总觉得都不够成体系，从词形变化入手，以词形变化驱动语法概念的讲解，有种学习语法就是为了方便记忆词汇变形、常用句型等的错觉，对于Kino来说这种方式容易抓不住重点，不能形成自己的理解，记忆深度也不够。在Kino的理解中，语言最先出现时自然是无所谓语法概念的，在语言的发展进化过程中，渐渐出现了一些规则，提炼出这些规则就形成了语法体系，从这个角度上说，主张学习语言不需要先学习语法的说法也有其道理，语言学到了一定程度自然会对语法有所理解。但是既然语言规则已经被提炼出来，形成了系统化的语法，Kino认为，在一门第二语言的学习过程中，尽早地掌握其语法体系，可以起到事半功倍的效果，也正因如此才有了这一系列的文章。Kino尝试着根据自己已经掌握的内容，和自己当前对日语的理解，构建自己的日语学习系统，对日语学习进行了系统化的划分，当然主要内容还是语法部分，希望实现以语法概念驱动词形变化等细节，使得各种变化规则是自然而然出现的。 3. 发音系统本章介绍了日语的发音系统，Kino根据自己当下的理解，将发音系统主要分为基本音、变化音、词调、语调四部分内容。 3.1 基本音基本音是构成日语发音的最基本单位，分为元音、拨音和辅音，其中辅音可以细分为几类。 3.1.1 元音a、i、u、e、o 3.1.2 拨音n（ん） 3.1.3 清辅音k、s、t、n、h、m、y、r、w 3.1.4 浊辅音g、z、d、b, 分别由k、s、t、h浊化形成 3.1.5 半浊辅音p, 由h半浊化形成 3.2 五十音图及其扩展基本音中的元音、拨音和清辅音构成了五十音图，五十音图有两种书写方式，分别是平假名和片假名。 3.2.1 五十音图的平假名(Hiragana)表示 w r y m h n t s k ん わ ら や ま は な た さ か あ a ゐ* り み ひ に ち し き い i る ゆ む ふ ぬ つ す く う u ゑ* れ め へ ね て せ け え e を ろ よ も ほ の と そ こ お o 3.2.2 五十音图的片假名(Katakana)表示 w r y m h n t s k ン ワ ラ ヤ マ ハ ナ タ サ カ ア a ヰ* リ ミ ヒ ニ チ シ キ イ i ル ユ ム フ ヌ ツ ス ク ウ u ヱ* レ メ ヘ ネ テ セ ケ エ e ヲ* ロ ヨ モ ホ ノ ト ソ コ オ o 3.2.3 浊/半浊辅音和元音/拨音构成的扩展音图考虑基本音中的浊辅音、半浊辅音和元音、拨音的结合，可以够成一个扩展音图。既然已经了解了平假名和片假名，这里就将两者综合在一起书写了。 p b d z g ん ン ぱ パ ば バ だ ダ ざ ザ が ガ あ ア a ぴ ピ び ビ ぢ ヂ じ ジ ぎ ギ い イ i ぷ プ ぶ ブ づ ヅ ず ズ ぐ グ う ウ u ぺ ぺ べ ベ で デ ぜ ゼ げ ゲ え エ e ぽ ポ ぼ ボ ど ド ぞ ゾ ご ゴ お オ o 3.3 变化音3.3.1 长音长音是将假名发音延长一拍的音，基本构成规则为: Hiragana规则: / a /后加あ，/ i / e /后加い，/ u / o /后加う Katagana规则: 都加 ー 3.3.2 促音促音っ为小写的つ，在单词中不发音，但是占一拍时间，发音到此时作一拍停顿，然后接后面的假名。促音っ一般只出现在か行、さ行、た行、ぱ行前面 3.3.3 拗音拗音是将「い」段假名（い除外）和复元音「や」、「ゆ」、「よ」三个音相拼而成，在「い」段假名后面右下角加小写的「や」、「ゆ」、「よ」表示，每个拗音合起来只占一拍 3.3.4 外来音为了解决日语里本不存在的外来词带来的音，发明了一些新的组合。 v w f ch d t j sh ヴァ ワ ファ チャ ダ タ ジャ シャ ヴィ ウィ フィ チ ディ ティ ジ シ ヴ ウ フ チュ ドゥ トゥ ジュ シュ ヴェ ウェ フェ チェ デ テ ジェ シェ ヴォ ウォ フォ チョ ド ト ジョ ショ 3.4 词调和汉语类似，日语中的发音也有调性，不过汉语是每个字有自己的声调，而日语的声调主要体现在词语上，当然句子上也有体现，故Kino在此将调性分为词调和句调的两大部分，这样更顾名思义。本节介绍词调，句调在下一节讲解。日语用⓪、①、②、③、④、⑤等带圈数字标注词调的调型，调型的具体解释和相关注意点如下: ⓪型，即平板式，全部平读，表示只有第一拍低，其他各拍都高，无下降处。后续的助词也高 ①型，也叫头高型。表示只有第一拍高，以下各拍都低。 ②型，表示只有第二拍高，第一拍和第三拍以下各拍都低。后续的助词也低。 ③型，表示第二拍，第三拍高，第一拍和第四拍以下各拍都低。后续的助词也低。 …… 其中②型及其之后的调型，若尾拍是高音，称之为尾高型,否则为中高型。 可以看出尾高型和平板型在单个词时的音调变化是相同的，区别在于其后续接助词时，尾高型需要把单词的最后一拍重读，助词降调，而平板型后的助词不需要降调。 当两个单词组成一个合成词时，第二个单词的第一个假名常常用重读。 即词调圈中的数字是N，就表示[0,1]拍为低音，[2,N]拍为高音，[N+1,~]为低音。其中N=0和N=1比较特殊。 实际发音可以参考OJAD辞書[5] 更多细节和注意事项可参考日本語のアクセント[6]、日语声调[7]和日语声调应该如何掌握[8] 3.5 句调对每个句子来说，也有特定的调性，一般叫做语调，这里称之为句调。日语中的句子通常都是开始高，往后整体音高有逐渐降低的倾向。 短语和陈述句的语调按照开始高后面逐渐下降的原则变化，但是其中单词的词调还需要保持。此外，对于想要强调的地方，需要提高语调。 疑问句的语调疑问句的句尾读升调。 4. 书写系统本章主要介绍日语书面语常用的书写方式，主要包括汉字、假名和标点符号三部分。若想了解更多详细内容可以参考表記ガイド[9] 4.1 汉字日语里，名词、形容词词干、动词和副词基本都是用汉字写的。联系到上一章，汉字在发音上，通常对应两种读法:音読み（おんよみ）和訓読み（くんよみ） 音読み: 音読み是根据汉字的中国发音演变的读法。组合出现的汉字（熟語）通常用音読み发音。参考音読み[10] 訓読み: 訓読み是利用日本固有的音来读的方法（另一种说法是訓読み为日本自创的读法，这种说法其实是错误的，就好像日本人学了汉字之后再创造了一个对应的音，但实际上日语与汉语完全是两种语言，日本出现日语之后没有文字，于是将直接将汉字引入，汉字只是日语的一种表达方式而已）。单独的汉字一般用訓読み发音，此外形容词和动词也会用訓読み发音，但后面一般都会跟着一些假名（称为「送假名」）。参考訓読み[11] 4.2 假名第三章所有用于注音的假名同时也都可以作为书面文字使用，平假名通常用于体现语法功能，片假名通常用于外来词。但是片假名还有一些特殊用法，将一句话全部用片假名书写还有加强语气（如强烈的敌意等）、表示人物大叫、强调等功能。 4.3 标点符号（約物コード）全面的日语标点符号在約物[12]中可以查阅，该小节主要讲解常用的标点符号的常见用法。 4.3.1 句読点（くとうてん） 句点。: 标在句末。会话文中的半截话（后半部省略），也标句号。需要注意的是，会话文中的句子如果在引号内，最后的句号通常不标，以及在引用简单语句时不用句号。 読点、: 现在日语横写时也常写作”，”（コンマ）。用于清楚地表示出词语、短语、句节间的关系，以及连接两个句子时。 4.3.2 中黒 ・ 用来表示并列的体言 用来隔开两个单词构成的外来语、西洋人的名和姓 竖写时表示数字的小数点 4.3.3 疑問符・感嘆符这两个符号都属于外来符号。 疑問符？: 用于表示疑问、发问、质问和反问等句子的句末。但在普通的文章中，原则上基本不用问号，而是用句号代替。 感嘆符！: 用于语调强烈的句子中表示感叹。 4.3.4 括弧類 鉤括弧「」: 用于表示引用部分或要求特别注意的词语。 丸括弧（）: 对语句加注解。 二重鉤括弧『』: 用于表示书名或报纸、杂志等的标题；在单引号内需要用引号表示的部分用双引号表示。即日语是鉤括弧套二重鉤括弧，「『』」，不要想当然地受双引号套单引号影响 4.3.5 3点リーダー …一般两个连用构成二倍三点リーダー …… 表示会话过程中的无声状态。如: 「なるほど。……そうなのか。」 在行文结尾留有余韵，表达相应情感。如: そして、山へ向かった…… 表示省略 …… 4.3.6 長音符号 ー在片假名表示长音 4.3.7 波ダッシュ ～表示地点、时间、数量等的区间范围。 4.3.8 踊り字这是一类特殊的符号，表示代替相同文字，简化书写，具体可以参考踊り字[13]。 々（同の字点）: 用于代替前面的一个汉字，也是用的最多的。 ゝ（一の字点）: 用于代替前面的一个假名 〻（二の字点）: 不是用来重复前一个汉字，而是前一个汉字是训读的情况下用此强调或消歧，用于竖写排版中，写于前一个字的右下方而非正中。如 “屡”作为一个汉字就读作”しばしば”，”屡〻”并不是用来表示”屡屡”，而就是”屡”，只不过多加了一个符号。 〱（くの字点）: 重复两个字以上的情况，用于竖写排版的情况下，如”見る見る”的重复等 总结本篇主要对日语语法进行了总结，系统讲解了发音系统和书写系统。下一篇文章里Kino将会介绍词类系统和句法成分的内容。 Footnotes1.Tae. “平假名.” 日语语法指南 | Learn Japanese, http://res.wokanxing.info/jpgramma/hiragana.html. ↩2.马兰英, 孙海英, and 徐莲. 日语语法专题教程. 浙江工商大学出版社, 2016. ↩3.Wikipedians. “语法范畴.” Wikipedia, Wikimedia Foundation, 29 Apr. 2018, https://zh.wikipedia.org/wiki/语法范畴. ↩4.Wikipedians. “Grammatical Category.” Wikipedia, Wikimedia Foundation, 19 June 2018, https://en.wikipedia.org/wiki/Grammatical_category. ↩5.“Online Japanese Accent Dictionary.” Keikichi Hirose &amp; Nobuaki Minematsu Laboratory, the University of Tokyo, http://www.gavo.t.u-tokyo.ac.jp/ojad/. ↩6.Wikipedians. “日本語のアクセント.” Wikipedia, Wikimedia Foundation, https://ja.wikipedia.org/wiki/アクセント#日本語のアクセント. ↩7.Wikipedians. “日语.” Wikipedia, Wikimedia Foundation, zh.wikipedia.org/wiki/日语#声调. ↩8.Zhihuer. “日语声调应该如何掌握？.” 知乎, 27 Nov. 2014, https://www.zhihu.com/question/26810278. ↩9.Wikipedians. “表記ガイド.” Wikipedia, Wikimedia Foundation, 1 June 2018, https://ja.wikipedia.org/wiki/Wikipedia:表記ガイド. ↩10.Wikipedians. “音読み.” Wikipedia, Wikimedia Foundation, 21 Oct. 2017, ja.wikipedia.org/wiki/音読み. ↩11.Wikipedians. “訓読み.” Wikipedia, Wikimedia Foundation, 1 June 2018, ja.wikipedia.org/wiki/訓読み. ↩12.Wikipedians. “約物.” Wikipedia, Wikimedia Foundation, 24 June 2018, ja.wikipedia.org/wiki/約物. ↩13.Wikipedians. “踊り字.” Wikipedia, Wikimedia Foundation, 14 June 2018, ja.wikipedia.org/wiki/踊り字. ↩]]></content>
      <categories>
        <category>humanities</category>
        <category>languages</category>
      </categories>
      <tags>
        <tag>japanese</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Schedule]]></title>
    <url>%2F2017%2F08%2F29%2Fbreakup%2F</url>
    <content type="text"><![CDATA[Time Weekdays Weekend 06:00~06:50 Get up 06:50~07:30 Run &amp; breakfast 07:30~08:00 Make coffee 08:00~08:30 JLPT 08:30~11:30 Read paper &amp; other things For fun 11:30~13:50 Lunch &amp; nap For fun 13:00~17:15 Read paper &amp; other things For fun 17:15~18:00 Run &amp; dinner For fun 18:00~19:00 Shower &amp; rest 19:00~22:00 Coding(PLUTUS, Leetcode) Chat with sb. 22:00~23:40 JLPT &amp; patent agent Movie &amp; animation JLPT N2: 12/03/2017Patent agent: 03/01/2018 ~ 11/04/2018JLPT N1: 12/03/2018]]></content>
      <categories>
        <category>life</category>
        <category>love</category>
      </categories>
      <tags>
        <tag>breakup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么大学过的比高中还累]]></title>
    <url>%2F2016%2F06%2F10%2FchickenSoup01%2F</url>
    <content type="text"><![CDATA[1. 前言本科毕业, 觉得碌碌无为, 又恰在知乎发现了一篇文章, 看完一阵怅然, 留存一份于此, 若是在迷茫时能再给自己一点激励, 也算是有用了。原文由 小鸟 发表于知乎, 原答案戳此 2. 原文谈三点感受： 2.1 大多数人都只不过是在用战术上的勤奋掩盖战略上的懒惰罢了在大学，你每天能够和室友一起去上课，一边玩手机一边听老师讲几句，在那里可以坐几个小时，中午挤食堂吃一顿可口的饭菜，下午没课有时候去参加社团，学生会，班级，学校（依据个人口味不同）各种大大小小的活动和会议，晚上把作业做一下 或者刷最近大家都在看的电视剧，晚上睡觉前发条朋友圈：今天做了。。。。，很开心，很充实，明天继续加油。你觉得自己过得好累，事情好多，忙不过来。你不是忙不过来，你只是在瞎忙活，你不能为自己规划一条适合自己的道路，有时候你也会想想这个问题，但是现实的安逸让你妥协了，大多数时候你都在逃避，你让自己默认不去选择，你不愿意承担选择后会出错的后果，你明明清楚无二的知道自己该做什么，可你就是管不住自己，在遇到想要努力的领域的大牛的时候你会为自己打一针强心剂：我也要像他这样厉害。可是三天之后你还是原来的那个你可是你根本就不明白，不做出选择就是你的选择，就算你得到一个很受伤的结局之后还是不悔过。这种情况不同程度的在每个人身上都发生过，打球的人可能都有过这样的经历你宁愿刻苦的重复练习一个动作而不愿意纠正这个动作做出正确的姿势；高中的时候你更愿意做那些自己有优势科目的作业，而不是那些你急需补救的弱势科目，还会美其名曰：那些有优势的科目是自己感兴趣的。大多数时候你不是感兴趣，你只是在当时的环境下选择了一种让自己更舒适的选项，乍看起来你确实也很勤奋，但是这种勤奋能不能解决问题就要另当别论了 2.2 成就感阈值上升在高中你只需要学习好就够了，学习好都能有坐公交车不用投币的错觉，老师会围着你转，父母也对你呵护备至，周围的亲朋好友也会夸你，爸妈也很有面子，而且在中国人的价值观里品德这种东西居然也是跟学习成绩成正比的，评价标准是如此的单一，老师说的都是”如果不学习你的人生就完了“这样的论调，所以在这样的环境里，你要做的就只是学习，让自己在这个评价标准中得A，这样的生活虽然也累，但是你只要成绩能进步，考试考好了，家长老师都会夸你，会有很强的满足感，你也会有更强大的动力，你会逼自己更加努力去获得来自外界的下一次夸奖，下一次成就感，其他的事情有人替你安排，而且你还很心安理得，你会觉得做学习之外的任何事都是在浪费时间。但是大学里的评价每个人的标准太多了，你一下子应接不暇，高中那么优秀的你，在大学里当然也要不干示弱，贪心的你想包揽对你有利的每一件事，你要做班干部，要做社团骨干，要进学生会，要入党，要拿奖学金，要巴结老师，要积累给别人吹牛逼的资本，要搞好和同学之间的关系，要有女朋友，好像你不和室友打游戏都能把你归为不合群，你要得到各种你想要的利益，你要取悦各种人群，你什么都想要。你活得这么累，神仙也救不了你 他们是希望回到高三，那种得心应手的状态，那种解出一道题就能获得满足感的状态，那种盲目地相信“熬过高三什么都会好的”状态，那种以为世界真的可以凭借一张卷子创造的状态，那种因为面前只有一条路而走得格外笃定的状态，那种做错了不过擦掉考砸了不过重来的状态，那种大学永远也没有办法给你的状态。 大学的可恶之处或许在于，它看似给你提供了种种可能，各色社团各类选修通识，但事实上又有一套评价体系限制着你的选择。或许更可恶之处在于，我们都变得实际而精明起来，知道结识什么样的人脉可以把未来的天堑变通途，也知道选什么样的课老师给分很水什么样的社团加入后可以有更多的资源，于是我们活得如履薄冰生怕翘掉的哪一节课会给未来抹上污点，也生怕得罪的哪一个人会让日子变得寸步难行。 2.3 大多数人都是平庸的”乌合之众”我们被安排了18年，到了大学得到了 苦苦寻求的自由，却发现这并不是自己想要的生活，我们要的还是那种被别人安排的井井有条的生活，就像《肖申克的救赎》中的詹姆斯.惠特摩 饰演的老布已经习惯了监狱中体制化的生活，50年的服刑结束后，不能适应外面的生活只能选择自杀一样，我们也不过如此大多数人在进入大学之前都没有形成独立的价值观再加上自己学识和能力上的浅薄，平庸的根本驾驭不了这突如其来的自由，你拥有的自由只能让你更空虚，更一无是处，你对任何事都失去了以前的那种归属感，再加上你平庸的能力，不能全力以赴的你在任何事情的尝试上都失去了成就感，自卑，空虚，恶性循环。所以我们就尽量让自己合群，跟随别人把体制要你做的事情做得中规中矩，不做出头鸟，用这种合群做挡箭牌掩饰自己的无能：反正周围的人都是这样做的。难道那些为自己真正喜欢的事情努力的人不累吗？当然累，但是这种累和那种茫然无措的累是完全不同的 。极致的成功，极致的痛苦，有些人可以每天睡觉4小时，其他时间都用来做那一件事，但如果给你，可能两天就放弃了, 这并不可爱，那些做着不被周围人认同的事情的人可能还要承受来自外界质疑的压力，他们的生活有时也会混乱不堪，但他们很快就会让自己走上正轨，他们有清晰的方向，伟大的人都是执拗的，特立独行的，就是这样。在绝大多数时候努力与否和能不能成功没有必然联系，就像有人说的: 功夫负不负有心人本该没有那么重要，”有心”的价值是不能用负与不负来衡量的。 真要比起来，有些人的起点你可能穷尽一生都够不到，成名与成功都应该是顺其自然，水到渠成的事情。我不在乎自己是否能逆袭成一个高富帅，或者得到一举成名对的机会，我相信我所涉及的这些领域能为我铺就一条独一无二的道路你选择为什么事情所累和被生活推着往前走所累是完全不同的 2.4 大学四年应当如何度过这里有很全面的一些解答，但就我个人来说，我觉得其实很简单，就是生活热情和自律的问题： 为自己规划一个清晰的职业方向（学术，从政，商界），默默朝着那个方向努力 为自己培养几个关于音乐，运动，艺术的爱好，一定要保持自己对生活本身的激情，提升自己对美的欣赏水平 时间充裕的同学一定要健身，锻炼身体，护肤，虽不用过分着重自己的外表，但一定要精神干练，别人看到起码要舒服 广泛阅读，学有专攻，广泛涉猎，尝试静下心来读一些经典著作 远离寝室，远离寝室，远离寝室，寝室真的是时间的黑洞，意志力的坟墓，屌丝的培养皿，就算是看电影也请你离开寝室看 忘掉：合群，你有更重要的事情去做，如果你真的足够优秀，你肯定会有很多朋友 生活中兼顾当下的乐趣和对未来的功效 想象自己像一个追求卓越者一样去行动和约束自己 把生活观念从马拉松式的“长跑”变成“短跑”，冲刺，休整，冲刺，休整 内向的人一定要锻炼自己开口讲话，这也是我的缺陷，共勉吧 警告: 如果你正在阅读本文，那么这个警告正是为你准备的。你所读到的本文中的每个词都是你生命中又一秒钟的浪费。你没有别的事情可以做吗？你的生命真的如此空虚以至于你怎么都想不出另一个打发时间的方法吗？或许，你只是对自己所尊敬和信任的所谓权威者们过于信服，以至于无法移开你的目光。你只会习惯性地阅读别人告诉你你应该读的？你只会思考那些别人告诉你应该思考的？还有购买那些别人告诉你应该拥有的东西？滚出你的房间，去寻找真正志趣相投的朋友，停止没有必要的购物和猥琐的自慰。完成你手上的任务，开始一场战斗和搏击，证明你还是活生生的人类。如果你不释放和找回你身上的人性，你将只是屏幕和数据上一个统计值。你已经被警告了……Tyler.]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>struggle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux琐记六]]></title>
    <url>%2F2016%2F06%2F07%2Flinux06%2F</url>
    <content type="text"><![CDATA[1. renamerename &#39;s/(0-9).txt/file_$1.txt/&#39; *.txt 2. 查看硬件信息123456lscpulshwhwinfolspcilsusblsblk 3. 查找文件locate file_path 4. 制作iso文件mkisofs -l -J -L -r -o filename.iso path_to_folder 5. 查看主机开放端口nmap your-domain-ip 6. ffmpeg 剪切拼接视频 剪切: 1ffmpeg -ss START -i input.mp4 -t TIME -acodec copy -vcodec copy output.mp4 其中 START/TIME 的格式有两种: 以秒为单位计数 80, 时:分:秒 00:01:20 拼接: 1ffmpeg -i "concat:input1.mpg|input2.mpg|input3.mpg" -c copy output.mpg 也可以将要拼接的视频放在一个文件list.txt里: 123file '/path/to/file1'file '/path/to/file2'file '/path/to/file3' 之后ffmpeg -f concat -i list.txt -c copy output.mp4 7. Ubuntu 安装特定版本package某个包依赖pkg-config，而pkg-config依赖的一个包始终安装不上，因为版本对不上，手动指定版本降级之后可以apt install package=version]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HLA 入门三]]></title>
    <url>%2F2016%2F05%2F28%2Fhla03%2F</url>
    <content type="text"><![CDATA[1. 问题在创建新的联邦时, 将Thesis.xml换成了Test.xml去create, 但CRC端实际显示的还是Thesis.xml, 以为是前端问题或是后端创建时传参问题, 检查没有发现错误 2. 解决在CRC服务器上关闭了Pitch RTI, 重新打开, 新创建的联邦显示的FOM就是Test.xml了。。。]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>distributed simulation</tag>
        <tag>hla</tag>
        <tag>pitch rti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RESTful推送与异步通信]]></title>
    <url>%2F2016%2F05%2F20%2Fweb02%2F</url>
    <content type="text"><![CDATA[1. 服务器-浏览器通信技术服务器-浏览器通信也可以称为服务器端推送技术, 是一种当服务器端的业务数据、资源状态发生改变时, 服务器可以主动将这一信息通知给相关的浏览器的通信技术。如果服务器与客户端使用TCP/IP协议建立连接, 这样的Socket通信并无特别之处, 一旦连接建立, 在这样的双向通信链路中随时都可以发送通知. 然而REST通信是基于HTTP的通信, 而HTTP是无状态的通信协议, 每一次请求-响应都是基于一个新建立的HTTP的连接, 这就是使服务器主动通知浏览器成为一个难点. 这是因为在基于请求-响应的模式下, 服务器的角色是主动应答, 无法主动通知浏览器; 另一个原因是每次请求后HTTP连接断开, 服务器无法再获取客户端的地址, 也就无法将通知发送给浏览器端 1.1 Polling(客户端轮询) 技术即浏览器周期性地主动访问服务器的特定地址, 以获取服务器端数据状态的变化优点: 易于实现 对设计没有注入性污染缺点: 如果服务器的业务数据在两次定时任务发起的请求过程中没有变化, 后一次请求的做功实际为负数——浪费了服务器的带宽, 而且没有获得有效负载 浏览器端的定时器间隔时间参数的设置比较尴尬, 过短频发第一个问题, 过长无法及时获取服务器端数据, 且该值往往难以抽象出来, 不同业务的定时间隔都是一个独立的经验值 1.2 Comet技术Comet是反向AJAX技术集, 包括长轮训(Long Polling)和流(Streaming)两种技术.反向AJAX(Reverse AJAX)技术从请求方向上看并没有反向, 该”反向”是从结果上看的, 即从服务器端(通过保持连接的HTTP通道)向客户端发送数据, 以实现低延迟地通知客户端的技术, 其底层实现依赖于HTTP连接不能断开这一前提条件. 长轮询和流技术是反向AJAX的两种技术手段. 如图所示, 长轮询通过KeepAlive使HTTP连接得以保持连接. 为何需要保持连接? 因为在请求发出后的一段时间内, 服务器一直没有做出响应, 该连接会因连接超时而断开. Comet利用HTTP1.1的keepAlive的持久性连接技术, 在浏览器发出请求后, 通过keepAlive保存服务器向浏览器做出响应的通信, 如此解决了连接超时断开的问题. 那么连接的关闭只有两种情况, 一种是浏览器主动断开, 一种是服务器端特定数据发生变化， 并将这一信息响应给浏览器, 主动断开连接来完成请求-响应模式的一次请求 相比Polling, 实现Comet困难许多, 服务器和浏览器都需要第三方库来支持. Atmosphere和CometD库是实现Comet技术的第三方工具包 优点: 解决了Polling的低效性, 且有很好的低延迟性缺点: 需要额外的技术实现支持, 引入第三方包, 较为复杂 1.3 SSE技术SSE是HTML5技术集的一部分, 定义了服务器推送技术的标准规范SSE规范地址可以点此. 其核心是基于EventSource接口的事件监听机制, 包括onopen、onmessage和onerror三个事件监听器. SSE服务器响应数据的媒体类型(Content-Type)是text/event-stream. 优点: 是HTML5标准一部分, 具备编程语言无关性, 且支持跨语言的调用缺点: 和Comet一样, 浏览器无法在同一条连接上做出二次请求或者对服务器的响应做出”响应” 1.4 WebSocket技术WebSocket是HTML5技术集一部分, 提供了一个双向的、在一条TCP信道中的客户端和服务端全双工的通信WebSocket消除了所有与HTTP连接的无状态特性相关的限制 优点: 是HTML5标准之一, 逐渐流行,功能强大,性能突出,双向、双工通信缺点: 相对于SSE实现较为复杂 2. SSE通信模式Java的Jersey框架的SSE支持包提供两种通信模式, 发布-订阅模式和广播模式. 前者是一种端到端的通信, 后者是多播通信 3. 异步通信3.1 Polling异步通信该技术结合了HATEOAS和Web Link, 以及Polling技术 3.2 Web Hook异步通信该解决方案是指在客户端发送请求时, 将一个回调地址同时发送给服务器, 服务器接收响应后, 异步处理请求并对此次请求即刻做出响应, 客户端随即处理其他业务并监听回调. 服务器在响应客户端后, 继续以异步的方式处理刚才的请求, 在处理完毕后, 通过回调地址通知客户端处理结果优点是覆盖了Polling方案并且没有Polling方案中无效的轮询负载. 但是, 这种方案无法在浏览器作为客户端的场景中实施, 因为浏览器无法提供一个回调地址给服务器. 因此该方案适用于另外一个服务器作为客户端的场景. 另外, 和后面的解决方案比起来, 该方案还是多出了一次服务器回调客户端的HTTP连接 3.3 Comet异步通信Comet技术在服务器推送业务中的处理流程同样适用于这里的异步通信, 客户端发送请求后可以继续执行后续业务并监听服务器返回的处理结果的通知, 优点是异步通信可以在一次请求-响应的模型中完成 3.4 HTML5异步通信包含SSE和Web Socket, 均有处理异步通信的能力 Footnotes1.Mastering Web Application Development with AngularJS ↩]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>communicate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux琐记五]]></title>
    <url>%2F2016%2F05%2F09%2Flinux05%2F</url>
    <content type="text"><![CDATA[1. No such file or directory./pwn1执行后出现错误信息:./pwn1: No such file or directory, 可执行权限Kino已经加上了, 查了查可能是因为库的原因, 直接cat pwn1看到需要/lib/ld-linux.so, 查了下系统的确没有, 用readelf去查看pwn1的各项信息, 反而没有看到. ld-linux.so这个库是Linux下进行动态库链接的链接器, 无它其他动态库就都无法成功链接, 详细说明可以戳这里查看怎么安装这个库, 32位系统下是libc6, 64位是libc6-i386, 这是因为64位中默认安装了/lib64/ld-linux-x86-64.so.2 2. dmesgdmesg用来显示内核环缓冲区(kernel-ring buffer)内容, 内核将各种消息存放在这里. 在系统引导时, 内核将与硬件和模块初始化相关的信息填到这个缓冲区中. 内核环缓冲区中的消息对于诊断系统问题非常有用 3. ls硬件信息lsmod lscpu lspci lsusb等 4. 时间参考1参考2参考3参考4参考512cat /boot/config-`uname -r` | grep HZcat /proc/interrupts | grep timer &amp;&amp; sleep 1 &amp;&amp; cat /proc/interrupts | grep timer]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学方法二]]></title>
    <url>%2F2016%2F04%2F16%2FmethodologyOfMath02%2F</url>
    <content type="text"><![CDATA[1. 构建数学知识的常用数学方法1.1 数学表示方法1.2 等价变换方法 自反性(Reflactive): 对任何a ϵ A, 必有aRa(R条件) 对称性(Symmetry): 对任何a ϵ A, b ϵ A, 若有aRb, 必有bRa(S条件) 传递性(Transitive): 设a、b、c均在A中, 若有aRb,bRc, 则必有aRc(T条件) 1.3 公理化方法和结构主义公理系的三性: 独立性, 即各条公理相互独立, 不能由一条推出另外一条 无矛盾性, 即各条公理之间没有矛盾, 从一条公理推出的结果不能与另一条矛盾 完备性, 即通过它能推出该学科已有的全部重要命题, 不能随便省略公理 公理化的近代发展是”结构主义”. 例如代数结构, 群、环、域、线性空间等都是可以用满足一定公理来定义的代数结构; 还有序结构, 包括半序和全序半序集E: 若E的元素之间定义了一个关系”≤”, 它具有以下性质: 自反性: 若xϵE, 则x≤x 反对称性: 若x,yϵE, x≤y且y≤x, 则x=y 传递性: 若x,y,zϵE, x≤y且y≤z, 则x≤z则称E为半序集 全序是在半序基础上加上: 可比性条件: 任何一对元素a、b, 在a≤b或b≤a中至少有一个成立 复数可以按照字典建立全序关系, 但是不能定义复数的大小, 因为按照大小关系和代数运算协调性要求, 必须有”加法保序”和”乘正数保序”的原则, 故复数只能有全序而不能有大小布尔巴基学派: 数学学科是按代数结构、序结构和拓扑结构的不同的不同, 以及它们的各种组合而加以区别的 1.4 同构方法 一般来说, 若X和Y是两个代数结构, 其间存在一个对一个的满射 f:X→Y, 且f能保持运算, 则称f是同构映射, X与Y同构. 设X中的运算是”·”, Y中的运算是”*“, 保持运算的意思是: f(a·b)=f(a)*f(b) 1.5 不变量与不变性质2. 数学应用中的常用数学方法2.1 概率统计方法 概率统计是研究随机性现象的数学. 随机现象指: 在条件相同的情况下, 做重复试验, 试验结果却不确定, 以至于在试验之前无法预料是哪一个结果出现. 我们把这时的试验结果称为”随机事件” 数据的集中趋势与离中程度 统计方法用数据说话 2.2 函数分析方法2.3 优化决策方法2.4 近似方法与计算机方法小学的科普文章里就有吴文俊的故事, 当时只知道他获得了国家最高科学技术奖, 一般书中还会说到袁隆平的故事、、、今天才了解了吴文俊所做数学工作的一小部分, 就是几何定理的机器证明方法 3. 形式化原则 数学的形式化 中学数学里的半形式化系统 数学概念的形式化 数学问题的各种不同形式之间的转换 运用形式化原则指导数学解题教学 4. 简单性原理 简单性原理的含义 中学数学内容由简到繁的发展 用简单性原理指导解题 5. 等价变换原则 等价变换原则的含义 中学数学中的等价变换 用等价变换原则指导解题 6. 映射反演原则 映射反演原则的含义 中学数学中的映射类型 用映射反演原则指导解题 7. 逐次逼近渐进原则 逐次逼近渐进原则的含义 中学数学解题中的逐次逼近渐进思想 8. 系统化原理 从发生的角度看数学方法的系统化原理 从联系与区别的角度看数学方法的系统化原理 从发展的角度看数学方法的系统化原理 从运用的角度看数学方法的系统化原理]]></content>
      <categories>
        <category>science</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学趣话二]]></title>
    <url>%2F2016%2F04%2F16%2FinterestingMath02%2F</url>
    <content type="text"><![CDATA[1. 数学符号Wiki上有所有数学符号的一个list, 点击每个数学符号link可以查看其具体内容, 然而Kino只是想看一下其Unicode值 2. 分形理论Benoit Mandelbrot 创立了 分形理论(fractal theory), 基础是分形几何(fractal geometry)]]></content>
      <categories>
        <category>science</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学方法一]]></title>
    <url>%2F2016%2F04%2F16%2FmethodologyOfMath01%2F</url>
    <content type="text"><![CDATA[1. 前言Methodology of Mathematics主要记录了《数学方法论稿》[1] 的内容 2. 钱学森对于数学的分类钱学森在《关于思维科学》中用过一张表进行科学的分类(然而这是Kino在数学方法论稿书中看到的): 3. 重大数学方法与哲学范畴3.1 数学方法·形式与内容数学的研究对象是形式化的思想材料, 整个数学是一个形式化的思想体系. 数学要形式化, 但是不可局限于形式化, 形式是为内容服务的. 因为形式不能更好的表示内容, 因而很多数学论文中的方法被冷落和扬弃了, 或者被更好的数学形式所代替 3.2 数理逻辑方法·原因与结果“原因”和”结果”是一对哲学范畴, 它反映事物之间的相互联系和相互制约. 当我们把事物从普遍联系中抽象出来, 就会看到有序的、不断更替的运动, 一种现象会引起另一种现象. 前者为原因, 后者为结果, 这种因果观念是人们一切自觉活动必不可少的逻辑条件数学的表示一个命题, 要用谓词和八个逻辑常量, 即∀, Ǝ, V, Λ, =, ¬(非), →(蕴涵), ⇔(if and only if). 我们用⇒表示”推出”, 谓词S(a)、P(b)即a是S, b是P 3.3 几何方法·时间与空间时间与空间是运动着的物质的基本属性和存在形式, 从数学范畴研究时间范畴和空间范畴, 便构成了各种几何学几何方法, 说到底是为了描写、表示、反映现实时空, 为各种时空观提供数学模型 3.4 微积分方法·运动和静止“运动”是标志事物、现象变化和过程的哲学范畴, “静止”则是特殊的运动状态. 从数学角度观察运动过程, 分析它的数量方面, 就会得出变量和常量的观念, 以及对剧烈变化和相对稳定等进行数学处理的方法. 函数是描写运动的有力工具.运动和静止的研究还和稳定性问题联系在一起 3.5 概率方法·偶然和必然“偶然”和”必然”是反映事物间必然联系和偶然联系的一对范畴, 是对因果范畴的进一步深化. 数学中的概率论就是从数量上研究必然性和偶然性的学科. 它从所考察的偶然性因素和影响中寻找必然的、本质的、数量的规律, 并对这些偶然性影响进行数量的刻画和分析必然性和偶然性现象, 在数学上称为确定性现象和随机性现象, 相应就有确定性数学和随机性数学之分.确定性数学正在随机化, 随机微分方程, 随机积分方程, 随机算子理论, 随机幂级数, 随机整函数, 以至随机微分几何也诞生了 3.6 模糊数学方法·同一与差异哲学上把”对立”与”同一”当作一对范畴. 从数学上看, 更重要的是研究”差异”与”同一”. 正与负, 微分与积分, 加与减都是对立物, 是从数量上刻画”对立”规律的学问. 如果从更广的意义上理解, “对立”是从”差异”开始的, 当差异发生到极点时, 就会产生对立. 所以事物间的同一与差异也许是更为普遍的研究课题康托(G.Cantor)集合论 -&gt; 模糊集合 -&gt; 模糊数学康托集合语言可以廓清”白马非马”的诡辩 3.7 分析方法·局部与整体“整体”和”局部”也是一对哲学范畴, 全局由各个局部组成, 但并非各个局部的简单总和, 它高于局部. 局部是整体的一部分, 但有时局部会影响整体, 甚至起主要的决定性作用微积分学提供了分析局部的手段. 可以理解”芝诺悖论”数学上的局部是指一点的领域 3.8 计算方法·量,质,度任何事物都有”质”和”量”两方面, 是”质”和”量”的统一体, 作为”质”和”量”统一的”度”, 就是保持事物本”质”的量的限度、幅度和范围数学是关于”量”的科学, 但也要反映”质”. 因为当量变发展到质变时, 量往往发生跳跃. 从函数图像上看就是跳跃和间断, 或者发生转折(R.Thom)创立的突变理论, 可参考 3.9 控制论方法·可能与现实客观事物处于普遍联系中, 系统科学正是对它的描述. 一个系统的存在1是现实的, 但人们关心的是预示各种发展前途的可能性. 发挥人的主观能动性, 使得某种可能性转变为人们想要实现的现实, 这便是研究”可能”与”现实”这一对哲学范畴的意义数学上研究系统是否可能控制以及如何控制的学科, 称为控制论. 控制理论为现实系统的描述、分析综合和设计、预测和决策等问题提供了成套的理论和方法控制论不是直接研究现实世界的受控对象, 而是研究受控对象的数学模型. 在控制论中, 能观性和能控性是两个基本概念. 一个系统是能控的, 是指输入信号u(t)能对系统的每一状态变量施加独立的影响, 使之能从任意的初态x0出发, 经有限时间后总能到达预先期望的任意值. 一个系统能观是指输出信号受每个状态变量的独立影响, 使之能从观测一段时间的输出值来唯一确定状态变量在某一时刻的值 3.10 数学模型方法·实践与认识“实践”和”认识”, 是认知论中的哲学范畴. “认识”是主体对客体的能动反映, 而”实践”则是认识的基础, 它对认识起着决定的作用数学模型方法正是基于实践之上的一种数学认识, 人们用以认识世界和改造世界 4. 数学中使用的一般科学方法 数学中的观察与实验 数学方法不等于逻辑方法·数学直觉 设定数学猜想的一般方法·归纳与类比 数学证明方法曼宁(Manin): “一个证明只有当它通过’被接纳为证明’这项社会时,它才算被证明”数学证明有助于核实真理, 数学证明最重要的价值是增进理解, 只有弄懂了一个定理的证明, 才能真正该定理的内容 数学证明方法的一般方法·化归与逻辑 Footnotes1.数学方法论稿 ↩]]></content>
      <categories>
        <category>science</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HLA 入门二]]></title>
    <url>%2F2016%2F04%2F11%2Fhla02%2F</url>
    <content type="text"><![CDATA[1. RTI中time management相关问题1.1 在创建Federate之后如何修改其时间控制策略想要在创建Federate后改变其时间控制策略, 且同时修改其前瞻量, 这时会出现相关问题, 当然, 我们先假设三个Federate, A、B、C初始都是Regulating状态, 且A前瞻量2, 步长2, 当前时间为20, B前瞻量4, 步长4, 当前时间60, C前瞻量5, 步长5, 当前时间100 先修改C为 Regulating and Constrained, 这时若先rtiAmbassador.enableTimeRegulation(lookahead);会throw一个TimeRegulationAlreadyEnabled的异常, 若我们捕获它并在catch中rtiAmbassador.disableTimeRegulation(); rtiAmbassador.enableTimeRegulation(lookahead);, 看似并没有什么问题。于是接下来执行rtiAmbassador.enableTimeConstrained();, 此时查看Pitch pRti的界面发现A的Constrained也没有启用, 看上去不知解决, 其实这时Constrained处于pending状态, 没有什么影响, 后续再说 再修改B为 Regulating and Constrained, 同上操作, 执行到rtiAmbassador.disableTimeRegulation();这句时, 观察Pitch pRti的时间管理界面发现其GALT增大为B的当前时间加其前瞻量, 即100+5, 之后抛出的异常也都相同, 不赘述 最后修改A为 Regulating and Constrained, 开始同上, 之后执行rtiAmbassador.enableTimeRegulation(lookahead);, 发现A的当前时间突然跳到了64, 这不是希望的结果, Orz… 这时我们如果我们观察B, 会发现其启用了constrained, 所以说ConstrainedPending状态不需要关心, 只是因为有其他Regulating状态的Federate限制了而已, 当其推进超过自己的当前时间即可, 回到A, 继续执行rtiAmbassador.enableTimeConstrained(); 这样虽然最后可以将所有Federate都改为 Regulating and Constrained 状态, 但是过程不是我们想要的结果 所以我们修改lookahead时不能先disable再enable, 那怎么解决这个问题? 很简单、、、查一下发现rtiAmbassador有modifyLookahead(lookahead);这个方法, 用它代替就好啦]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>distributed simulation</tag>
        <tag>hla</tag>
        <tag>pitch rti</tag>
        <tag>time management</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My 10 favorite albums]]></title>
    <url>%2F2016%2F04%2F10%2Flistening01%2F</url>
    <content type="text"><![CDATA[1. 前言无新歌可听, 翻了翻收藏的专辑, 一直打算把自己最爱的10张专辑挑出来, 但是总觉得有更好的音乐, 不过还是留存一份当前最喜欢的几张专辑吧 2. List The Dark Side of the Moon —— Pink Floyd The Girl Who Was… Death —— Devil Doll Famous Blue Raincoat —— Jennifer Warnes A Sombre Dance —— Estatic Fear 21 —— Adele Laurie Blue Adkins Where You Live —— Tracy Chapman 万能青年旅店 —— 万能青年旅店 Born to Die —— Lana Del Rey 浮躁 —— 王菲 Diana Ross —— Diana Ross]]></content>
      <categories>
        <category>life</category>
        <category>listening</category>
      </categories>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux琐记四]]></title>
    <url>%2F2016%2F04%2F10%2Flinux04%2F</url>
    <content type="text"><![CDATA[1. Ubuntu ssh 登录提示信息修改/etc/issue和/etc/motd前者的内容显示在login提示符之前, 后者显示在用户成功登录系统后, 一般都是希望修改后者 2. curl post json数据curl -H &quot;Content-Type: application/json&quot; -X POST -d &#39;{&quot;id&quot;:&quot;1&quot;,&quot;password&quot;:&quot;miao&quot;}&#39; http://api在post的data中使用变量:123currentTime=`date +%s`curl -i -H "Accept:application/json" -H "Content-Type:application/json" -X POST \--data '&#123;"time":"'"$currentTime"'","message":"hypocrisy"&#125;' "https://yourhost:port/api" 循环post:12345678910#!/bin/bashi=10while [ $i -gt 0 ]do curl -d '&#123;"data":"message"&#125;' http://host:port/api i=$(( $i-1 )) echo $i #let i=i-1done 3. Linux权限-rwxr-xr-x 中rwx不是最高权限, 还有sudo权限 -rwsr-xr-x, 方法是:chmod u+s /usr/bin/someprogram 4. sh和bash差距很大吗在crontab中加入* * * * * sh /home/hypocrisy/myshell.sh, 一直无法运行, 执行到i=60显示60 not found, 我也没有加空格, 改为* * * * * bash /home/hypocrisy/myshell.sh, 竟然好了、、默认就是bash为何sh和bash结果还不同? 5. 设置系统时间树莓派没有硬件时钟, 局域网环境无法联网导致Linux系统时间也不对123date -s 04/10/16`date -s 10:10:10date -s 0410161010.10 # MMDDhhmmYYYY.ss 更改时区:tzselect得到命令, 将其添加到.profile或.bashrc中 6. Python post data123456789import jsonimport urllib2data = &#123;'id': 1, 'message': 'hypocrisy'&#125;req = urllib2.Request('http://example.com/api/posts/create')req.add_header('Content-Type', 'application/json')response = urllib2.urlopen(req, json.dumps(data)) 7. shell获取本机ip地址并保存在变量中ip -o -4 addr list eth0 | awk &#39;{print $4}&#39; | cut -d/ -f1ifconfig eth0 | grep -E &quot;inet\b&quot; | awk &#39;{print $2}&#39; | cut -d: -f2]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Raspberry PI 3 折腾小记二]]></title>
    <url>%2F2016%2F04%2F09%2Fraspberry02%2F</url>
    <content type="text"><![CDATA[1. 安装Java安装的raspbian-jessie-lite系统没有自带Javaapt-get install oracle-java7-jdk 2. 安装tomcat7出现Size mismatchwget http://mirrors.ustc.edu.cn/raspbian/raspbian/pool/main/j/java-common/java-common_0.52_all.debdpkg -i java-common_0.52_all.deb再次apt-get install tomcat7安装成功提示: Creating config file /etc/default/tomcat7 with new versionAdding system user tomcat7&#39; (UID 109) ... Adding new usertomcat7’ (UID 109) with group tomcat7&#39; ... Not creating home directory/usr/share/tomcat7’.Creating config file /etc/logrotate.d/tomcat7 with new version vim /etc/tomcat/server.xml 修改默认webapp位置, mv /var/lib/tomcat7/webapps new_loc 解压war包jar xvf some.war, 将解压出的内容mv * ROOT, 即可根目录访问]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>raspberrypi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Raspberry PI 3 折腾小记一]]></title>
    <url>%2F2016%2F04%2F09%2Fraspberry01%2F</url>
    <content type="text"><![CDATA[1. 安装下载官方/第三方镜像压缩包, 解压, SD卡插入手机或其他读卡器, dd命令或者Win32DiskImager写入镜像, Over之后将SD卡插入树莓派, 供电 2. ssh连接树莓派插上网线, 会自动联网分配一个ip, 可以通过路由器管理界面查看ip地址(如果网线接在路由器上)之后ssh pi@192.168.0.104 password:raspberry, 即可连接成功, 默认用户名密码参考官方文档 官方文档还提到了很多其他远程连接方式, 自行参考 3. SD卡扩容Kino安装的是raspbian-jessie-lite系统, 占有空间更小一点, 但是、、、进入系统后df -h和fdisk -l, 发现16G的SD卡只显示了1.2G, 查找解决方案, 如下:12345678910111213141516cat /sys/block/mmcblk0/mmcblk0p2/start # 查看第二分区的起始地址sudo fdisk /dev/mmcblk0 # 用fdisk对磁盘进行操作# 以下步骤在fdisk的交互下操作d # 删除分区2 # 选择删除第二分区n # 创建一个新分区p # 创建主分区2 # 分区2131072 # 第一个sector的地址, 填入刚刚得到的第二分区的起始地址31116287 # 最后一个sector的地址, 使用默认值即可w # 将操作写入分区表sudo init 6 # 重启系统df -h # 查看发现存储大小没有变化fdisk -l # 可以显示14.8G空间了sudo resize2fs /dev/mmcblk0p2 # 操作完成df -h # 此时可以显示SD卡所有空间 4. root 权限sudo passwd root 设置新密码即可顺便允许root用户ssh登录12345vi /etc/ssh/sshd_config找到 PermitRootLogin without-password 并注释添加PermitRootLogin yesservice ssh restart # 重启ssh 5. 连接Wifi不使用显示器, 想要连接到Wifi123456iwconfig # 查看无线接口名, 通常为wlan0ip link set wlan0 up # 启动此接口服务iw dev wlan0 scan # 扫描无线网络# iwlist wlan0 scan # 该命令也可扫描iw dev wlan0 scan | grep -n 'ssid' # 用你想要得到的ssid代替, 找到在多少行iw dev wlan0 scan | head -113 | tail -58 # 截取一段显示 找到或确认了自己的SSID之后, wpa_passphrase your_ssid your_password, 会生成12345network=&#123; ssid=&quot;your_ssid&quot; #psk=&quot;your_password&quot; psk=d262144b57c9bce488ca56cdc02344eefe62cb7705f9cea45747a55d022da722&#125; vi /etc/wpa_supplicant/wpa_supplicant.conf在末尾添加刚刚生成的内容之后执行123wpa_supplicant -i wlan0 -c /etc/wpa_supplicant/wpa_supplicant.conf &amp; # 若失败根据提示执行 rm /var/run/wpa_supplicant/wlan0dhcpcd wlan0iwconfig # 确认连接成功 或者每次都手动连接, 该方法未经测试1234ifconfig wlan0 upiwconfig wlan0 essid your_ssid key s:your_key # 不加s: 使用加密后的hex值dhclient wlan0ifconfig wlan0 down # 关闭Wifi 6. 更改软件源1234567# deb http://mirrordirector.raspbian.org/raspbian/ jessie main contrib non-free rpi# Uncomment line below then 'apt-get update' to enable 'apt-get source'# deb-src http://archive.raspbian.org/raspbian/ jessie main contrib non-free rpideb http://mirrors.ustc.edu.cn/raspbian/raspbian/ jessie main contrib non-free rpi# Uncomment line below then 'apt-get update' to enable 'apt-get source'# deb-src http://mirrors.ustc.edu.cn/raspbian/raspbian/ jessie main contrib non-free rpi 查看中科大树莓派镜像说明, Here 7. 设置静态IP地址为了防止每次重启会获得不同的IP地址vim /etc/dhcpcd.conf, 对于有线网卡, 在末尾添加:1234interface eth0static ip_address=192.168.1.200/24 #用CIDR的格式配置地址static routers-192.168.1.1 #配置网关static domain_name_servers=192.168.1.1 #这里配置域名服务器地址 对于无线网卡, 在末尾添加:1234interface wlan0static ip_address=192.168.1.20/24static routers=192.168.1.1static domain_name_servers=119.29.29.29 8.8.8.8 8.8.4.4 以下是较老版本系统或者未使用dhcpcd软件系统的配置:vim /etc/network/interfaces如果设置有线网卡地址:1234iface eth0 inet staticaddress 192.168.1.200 # 设定的静态IP地址netmask 255.255.255.0 # 网络掩码gateway 192.168.1.1 # 网关 若是无线网卡:123456iface wlan0 inet static wpa-conf /etc/wpa_supplicant/wpa_supplicant.confaddress 192.168.1.200 # 设定的静态IP地址netmask 255.255.255.0 # 网络掩码gateway 192.168.1.1 # 网关network 192.168.1.1 # 网络地址]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>raspberrypi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HLA 入门一]]></title>
    <url>%2F2016%2F04%2F09%2Fhla01%2F</url>
    <content type="text"><![CDATA[1. What is hla?HLA 即 High Level A rchitecture 2. Why do we use it?3. About pitch]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>distributed simulation</tag>
        <tag>hla</tag>
        <tag>pitch rti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何发表论文]]></title>
    <url>%2F2016%2F04%2F01%2FpaperPublishing%2F</url>
    <content type="text"><![CDATA[1. 前言逛学校论坛时看到网友xiaoyaoyou对于如何发SCI的看法, 觉得有参考价值, 就记录下来 2. 内容 多看看，同一领域内别人文章是怎么写的，怎么个思路、新颖在哪里，甚至是格式和每一部分的篇幅 多思考，平时有些想法就随时记录下来，方便整理 多尝试，想法多了，就多去试，找一些可行性高又能很方便模拟或者容易用简单方法实验的去试，多试试可能成功，或者有更新的点子出来，即使不成功，也可以在此基础上想改进 多交流，经常和导师、同学交流，导师经验更丰富些，和其他同学交流也可以给你很多提示，尤其是其他专业的同学，多交流也可以最大限度地避免自己陷入一个坑里 做实验的时候，有时一个人难以完成，适当请师弟师妹帮忙，请他们帮你一起完成实验，实验也会更顺利；写成论文时记得把他们的名字和所做的工作写上，即使是第三、第四作者，对他们多少也有帮助，他们也会很开心，于己于人都有好处 实验前尽量想得周全一些，多记录数据和图片 实验完成后，多做一些相关延伸部分的思考，比如实验分析、应用分析等等，都可以丰富在未来的论文里，这部分我觉得挺重要的，不亚于一个很好的想法 多搜索些SCI期刊的信息，选择契合文章内容而又性价比高的期刊有时候比写文章更重要，同时还需要综合考虑期刊每年的录用数目和回复速度 确定了期刊之后就搜索些之前的文章，模仿他们的写法（开头、结尾、中间每一部分的内容，甚至排版），仔细的编排图片以及文字 仔细对待审稿人的回复，如果需要修改或增加内容，不要怕麻烦，认认真真的把相应的内容加上，该补做实验的就抓紧时间补做 3. 创新点问题最重要的是要明确问题，针对问题描绘清楚模型，明确需求研究的方向：提出新问题，或者是公共问题你提出更优的方法 创新一：别人没用过的方法，你用了创新二：别人没思考的角度，你看了创新三：别人的参数或者分布不同创新四：你的模型融合了好多个已有模型，取长补短创新五：稍微把其它领域的知识使用一点，开辟了新的领域]]></content>
      <categories>
        <category>science</category>
        <category>acadamic</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学趣话一]]></title>
    <url>%2F2016%2F03%2F25%2FinterestingMath01%2F</url>
    <content type="text"><![CDATA[1. 前言读过不少数学趣闻, 未成体系, 记录下来仅供娱乐 2. 秒差距(Parsec,pc)和光年一样, 是一种长度单位, 不过更大, 1pc=3.26ly, 天文学这些单位也是奇怪。Wiki 3. 不老蠕虫爬长绳假设一条蠕虫，以1cm/s的速度在一根长1m的橡皮绳上从一端爬向另一端。每当蠕虫爬完1cm，橡皮绳就瞬间伸长1m。如果橡皮绳可以无限伸长，蠕虫也“长生不老”，试问：蠕虫能爬到绳子的另一端吗？乍一想，这蠕虫似乎永远也爬不到绳子的另一端，因为橡皮绳增长的速度远大于蠕虫爬行的速度。不过我们还是先别下结论，算算再说。首先，橡皮绳每秒钟伸长1m，这种伸长是均匀的，而绳子伸长时，虫子爬过的那段也随之伸长。这样：第一秒末，绳子长1m，蠕虫爬1cm即绳长的1/100第一秒末，绳子长2m，蠕虫在这一秒又爬1cm即绳长的1/200，当然此时第一秒蠕虫爬的长度也随之变长，而且它所占绳子的比例1/100不变……类似，蠕虫在第n秒爬了绳子长度的1/(100n)于是，前n秒内蠕虫总共爬了绳子长的$$\frac{1}{100}+\frac{1}{200}+\cdots+\frac{1}{100n}=\frac{1}{100}(1+\frac{1}{2}+\cdots+\frac{1}{n})$$显然，如果蠕虫爬的长度\(l_n \geq 1\)，那就说明蠕虫已经爬到了绳子的另一端。由于调和级数是发散的，所以其大于100是有可能的。一位学者经过计算，得到n在\(2^{143}\sim 2^{144}\)秒之间的结果，当然这是个天文数字，但蠕虫是“长生不老”的另一位学者将调和级数变成：$$\begin{equation}\begin{split}1+\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{2^k} &amp;= (1+\frac{1}{2})+(\frac{1}{3}+\frac{1}{4})+(\frac{1}{5}+\frac{1}{6}+\frac{1}{7}+\frac{1}{8})+\cdots+(\frac{1}{2^{k-1}+1}+\frac{1}{2^{k-1}+2}+\cdots+\frac{1}{2^k}) \\&amp;&gt; (1+\frac{1}{2}) + (\frac{1}{4}+\frac{1}{4}) + (\frac{1}{8}+\frac{1}{8}+\frac{1}{8}+\frac{1}{8}) + \cdots + \left(\frac{1}{2^k}+\frac{1}{2^k}+\cdots+\frac{1}{2^k}\right) \\&amp;= 1+\left(\frac{1}{2}+\frac{1}{2}+\cdots+\frac{1}{2}\right)\end{split}\nonumber\end{equation}$$ 4. 超越数(Transcendental number)WikiIn mathematics, a transcendental number is a real or complex number that is not algebraic—that is, it is not a root of a non-zero polynomial equation with rational coefficients. 5. 正态数(Normal number)Wiki 6. 交错级数的悖论研究交错级数\(\sum_{i=1}^{\infty}(-1)^{i+1}a_i\)中的$$\begin{equation}1-1/2+1/3-1/4+1/5-1/6+1/7-1/8+\cdots=? \tag{6.1}\end{equation}$$正确答案不难找到：结果是\(\ln 2\)把\(1-1/2+1/3-1/4+1/5-1/6+1/7-1/8+\cdots=\ln 2\)两边乘以1/2，就得到$$\begin{equation}1/2-1/4+1/6-1/8+1/10-1/12+1/14-1/16+\cdots=(\ln 2)/2 \tag{6.2}\end{equation}$$把6.1和6.2两边分别相加就得到$$\begin{equation}1/1+1/3-1/2+1/5+1/7-1/4+1/9+1/11-1/6+\cdots=3(\ln 2)/2 \tag{6.3}\end{equation}$$可以看到6.3和6.1左边完全一样，只是排列顺序不同，然而6.3的值却是6.1的3/2倍，这样我们会得出3/2=1的结论显然这是一个悖论，对此，美籍德国数学家柯朗在他的微积分学论文中写到：“很容易想象出，这种明显的悖论发现对18世纪的数学家带来什么样的影响，他们习惯于运算无穷级数而不考虑它们的收敛。”出现这种悖论现象的原因是：级数\(1-1/2+1/3-1/4+\cdots\)之所以收敛，只是因为它的项有交替变化的正负号，因此可以部分地相互“补偿”。但是如果我们取这些项的绝对值的时候，将会得到发散的调和级数。这是两类收敛收敛级数之间的一个主要区别：收敛过程与各项的正负号无关的级数——绝对收敛级数，以及收敛仅仅是因为各项的正负号交替变化的级数——条件收敛级数。正是前一类级数代表了收敛的较强类型，因为在这里之所以发生收敛，是因为它的自身可足够快地逼近零。微积分学已经证明，如果级数\(\sum_{i=1}^{\infty}(-1)^{i+1}a_i\)满足条件\(a_n&gt;a_{n+1}\)和\(\lim\limits_{n\rightarrow \infty}a_n=0\)，那么这个级数收敛。这就是著名的莱布尼茨判别法。只有在绝对收敛级数中，各项的任意重排才不会影响它的和。这就是著名的狄利克雷定理。 7. 素数定理Primzahlen unter a(=∞) a/ln(a)当a趋近于无穷大时, 小于a的素数个数越来越接近于a除以ln(a)的值 8. 1+1=2罗素和怀特海德(Bertrand Russell and Alfred North Whitehead), 在数学原理(Principia_Mathematica)一书中, 证明了为何1+1=2 9. 欧拉zeta(ζ)函数本质是整数级数到素数级数的一种等价方法\(\zeta\)函数可以表示成将所有整数加起来恰好等于包含所有素数的项相乘所得的另一个函数\(\zeta(s)=\sum \frac{1}{n^2}=\prod \frac{p^s}{p^s-1}\)假设s=2，则$$\begin{equation}\begin{split}\zeta(s)&amp;=\frac{1}{1^2}+\frac{1}{2^2}+\frac{1}{3^2}+\cdots \\&amp;=\frac{2^2}{2^2-1}\times\frac{3^2}{3^2-1}\times\frac{5^2}{5^2-1}\times\frac{7^2}{7^2-1}\times\cdots\end{split}\nonumber\end{equation}$$ 10. 整数N的拆分方式种数1 = 1 p(1) = 12 = 2 = 1+1 p(2) = 23 = 3 = 1+2 = 1+1+1 p(3) = 3对于整数n, p(n) = ?, 哈代(Godfrey Harold)和拉马努金(Srinivasa Ramanujan)在某论文中得出了其公式:$$\frac{1}{2\sqrt{2}}\sum_{q=1}^{\nu} \sqrt{q}A_q(n)\varphi_q(n)$$其中\(A_q(n)=\sum\omega_{p,q}\exp(-2np\pi i/q)\)，和是对p来求的，p与q互素且小于q，\(\omega_{p,q}\)是1的某个24q次方根，\(\nu\)具有\(\sqrt{n}\)的阶数$$\varphi_q(n)=\frac{d}{dn}\left(\exp\left(C\sqrt{n-\frac{1}{24}}/q\right)\right),C=\pi \sqrt{\frac{2}{3}}$$ 关于1的n次方根其实是有n个不同的值的, 这个需要考虑到复数 11. 黎曼zeta(ζ)函数用复数代替欧拉\(\zeta\)函数中的指数s, 即可得到黎曼\(\zeta\)函数:$$\zeta(s)=\sum\frac{1}{n^s}=1+\frac{1}{2^{(a+ib)}}+\frac{1}{3^{(a+ib)}}+\frac{1}{4^{(a+ib)}}+\cdots$$ 对于某些s, 该函数值为0, 如s = 1/2 + 14.135i, 1/2 + 21.022i 12. 100%不是全部正如0%不是没有, 有理数占实数比重可以说是 0%, 但是你不能够说没有有理数。所以即时1985年证明了费马大定理对于100%的指数都成立, 但是不能说对于所有的指数 13. 复数的对数没有确定的值思考一下欧拉公式, 很容易得出结论]]></content>
      <categories>
        <category>science</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[postgreSQL]]></title>
    <url>%2F2016%2F03%2F23%2Fpostgresql%2F</url>
    <content type="text"><![CDATA[1. 前言以前只用过数据库MySQL和Rails自带的sqlite3, 最近打算在一个项目里使用postgreSQL, 简要记录下。 2. 安装去官网找对应版本下载, 不喜欢exe文件,感觉不在可控范围内, 于是下载了zip版本 解压之后, 设置路径:1234path = %path%;D:\Programs\pgsql\binset pghost=localhostset pglib=D:\Programs\pgsql\libset pgdata=D:\Programs\pgsql\data 在解压目录下123mkdir datacd datainitdb . 成功之后console会显示: WARNING: enabling “trust” authentication for local connections. You can change this by editing pg_hba.conf or using the option -A, or –auth-local and –auth-host, the next time you run initdb. Success. You can now start the database server using: “pg_ctl” -D “.” -l logfile start 按照提示,pg_ctl.exe -D . -l logfile start, 显示 “server starting”, 若要停止, pg_ctl.exe -D . stop注意若不在安装目录下, 则将上述 . 改为data的绝对/相对路径 3. 注册为Windows服务pg_ctl.exe register -N postgreSQL -D .注册成为服务后, net start postgreSQL即可 4. 用户权限之后运行postgres.exe会告诉你不能使用管理员权限登录, 故:12net user postgres your_password /addrunas /user:postgres cmd.exe # 我用的是cmder.exe 之后可以通过whoami查询运行该程序的当前用户 5. 目录设置再次运行 postgres.exe, 发现提示You must specify the –config-file or -D invocation option or set the PGDATA environment variable.再次set pgdata=D:\Programs\pgsql\data 6. 用户不存在提示此错误, role &quot;postgres&quot; does not exist, 因为我们最开始initdb是在默认账户下,应当runas postgres之后再initdb 7. 运行重启一下服务, 运行psql.exe即可或者不启动服务,直接postgres.exe, 再另开一个窗口执行psql.exe, 执行\?可以得到帮助 8. 操作注意windows下大多数操作关键字前面都有”\”之后查看文档, 运行一些操作, 如:12345678910111213CREATE database hlademo; # 创建数据库, 或使用createdb命令\l # 列出所有数据库\c hlademo; # 连接到数据库DROP DATABASE [ IF EXISTS ] hlademo; # 删除数据库,也可以使用dropdb create table tank( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, time TEXT); # 创建表DROP TABLE tank; # 删除表INSERT INTO tank(ID,name,time) VALUES(1, 'apollo', '20160323'); # 插入, 注意用单引号select * from tank; # 查询表 9. 其他命令模式(schema)实际上一个命名表的集合。也可以包含一个schema视图、索引、序列、数据类型、运算符和函数。Schema是满足类似于在操作系统级别的目录,但该模式不能嵌套。CREATE SCHEMA PostgreSQL语句创建一个模式(schema)1234567create schema enemy;create table enemy.missile ( ID INT PRIMARY KEY NOT NULL, NAME TEXT NOT NULL, time TEXT);select * from enemy.missile; 10. 修改密码12su - postgres -c psqlALTER USER "user_name" WITH PASSWORD 'new_password']]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>postgresql</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ruby 琐记二]]></title>
    <url>%2F2016%2F03%2F21%2Fruby02%2F</url>
    <content type="text"><![CDATA[1、单例类单例类这个概念存在于很多编程语言中,包括Java,其基本要求有: 1、单例类只能有一个实例 2、单例类必须自己创建自己的唯一实例 3、单例类必须给所有其他对象提供这一实例 详细的单例模式讲解可以戳这里在Ruby中创建一个单例类的方法是:12345678class AendobjA = A.newclass &lt;&lt; objA # 打开objA的单例类 def to_s "Object A, Woooo" endend objA.to_s即可调用 因为Ruby中类本身也是对象,类对象自然也有自己的单例类12345678class Aendclass &lt;&lt; A def to_s "Hahahaha" endend A.to_s即可调用,结果显然是”Hahahaha”, 但是如果我们在此基础上接着:12345678objA1 = A.newobjA2 = A.newclass &lt;&lt; objA2 def to_s "Miao" endendp objA1.to_s 输出结果则类似: &quot;#&lt;A:0x30a4070&gt;&quot;, 这是由于我们只是在类A的单例类中进行了to_s的重定义,它只对类A自身的对象有效,是类A对象的一个单例类方法。用图来表示上述类和对象实例间的关系为: 所有指向Class的klass指针都省略了 由于类或模块的定义中,self总是指向类或模块对象,故也可以采用这种写法:1234567class A class &lt;&lt; self def to_s "Hahahaha" end endend 2、实例变量,类变量类变量以@@开头,可被定义它的类以及其子类访问,也可被定义它的类和子类的实例访问。即类变量被共享在整个继承链中,在子类改变一个类变量时其父类的类变量值也改变在类对象上定义的变量是实例变量,以@开头,实例变量因为存在于在对象上,所以整个对象的类的继承链都可以使用。父类里定义的实例变量,子类方法可以使用;子类里定义的变量,父类方法也可以使用。类本身也是一种对象,它是Class类的实例,在类上定义的变量,叫类实例变量。类实例变量只能被类方法访问。类实例变量因为存放在类对象上,所以能够被继承链上的类方法访问到。比如子类定义的类实例变量,父类的类方法也能访问 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class A @v1 = "Variable 1" # 类实例变量 @@v2 = "Variable 2" def var1 # 实例方法无法访问类实例变量 @v1 end def var2 # 实例方法可访问类变量 @@v2 end def A.var3 # 类方法可访问类实例变量 @v1 end def A.var4 # 类方法可访问类变量 @@v2 end def var5 @v3 = "Variable 3" # 实例变量,定义在类对象上 endendclass B &lt; A def var6 # 子类的实例方法可以访问父类的实例变量 @v3 end def B.var7 @v3 endend#p A.var1#p A.var2p A.var3p A.var4objA = A.newp objA.var1p objA.var2#p objA.var3#p objA.var4#p B.var6p B.var7objB = B.newobjB.var5 # 先定义实例变量@v3p objB.var6#p objB.var7 输出结果是123456&quot;Variable 1&quot;&quot;Variable 2&quot;nil&quot;Variable 2&quot;nil&quot;Variable 3&quot; 3、闭包在代码块或者过程访问定义在其作用范围以外的变量时,就会创建闭包(Closure),即使包含原始变量的代码块已经超出作用范围了,但那些被其他块和过程引用的变量也会被一直保留着,直到引用他们的块和过程全部超出作用范围 闭包的概念是通用的,就像Javascript里也有闭包的概念 4、生成式编程: 在运行中编写代码5、ContinuationContinuation是一种强大的控制流机制。一个Continuation代表了调用栈和词法变量的特定状态,它是Ruby代码执行过程中特定点的一个快照 Continuations其实就是一些对象。它们可以被传递在函数间 可以从任何位置调用Continuations。只要持有对Continuations的引用,就可以对其进行调用 Continuations是可重入的。可以使用Continuations从一个函数多次返回 6、Array12[1,2,3] * '; ' =&gt; "1; 2; 3"[0] * 5 =&gt; [0,0,0,0,0]]]></content>
      <categories>
        <category>techonology</category>
      </categories>
      <tags>
        <tag>programming language</tag>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 琐记三]]></title>
    <url>%2F2016%2F03%2F15%2Fwindows03%2F</url>
    <content type="text"><![CDATA[1. cmd下设置字符集123456chcp 437 // set english environmentchcp 932 // set japanese environmentchcp 936 // set chinese(sim) environmentchcp 949 // set chinese(tra) environmentchcp 950 // set korean environmentchcp 65001 // set utf-8 environment 改成437后可以解决一些乱码问题, 奇怪的是明明装的是英文系统竟然默认是936]]></content>
      <categories>
        <category>techonology</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>cmd</tag>
        <tag>charset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rails Session]]></title>
    <url>%2F2016%2F03%2F07%2FrubyOnRails01%2F</url>
    <content type="text"><![CDATA[1. 相关概念1.1 session多数Web框架都有某种形式的Session管理: 为特定于某个客户端浏览会话的数据提供一个持久化的服务器端存储机制Rails session存储方法提供了如下特性: 机密性(Confidentiality): 除了服务器无人能读取在session中的数据 完整性(Integrity): 服务器端之外无人能修改存储在session中的数据,除非抛弃旧的session再获取一个新的 Rails可以将所有session数据存储在服务器端,或者是基于cookies的session存储方案 2.2 csrf跨站请求伪造(Cross-Sire Reuqest Forgery)攻击的步骤如下: 通过被攻破的服务器或者攻击者在第三方Web站点上的script/img标签(很可能是通过XSS放置的),客户端可以从攻击者处接收代码。代码引用了目标应用程序上执行某个action的URI 客户端请求来自目标应用程序的URI,发送认证cookies(因为客户端已经通过了目标站点的认证)。目标站点会执行客户端要的action,即使最终用户没有授权该action 用图表示: 2. 问题redirect_to 到 某页面认证,之后post数据回来, session为null. 具体过程是用户访问A站点, A站点会验证用户的session, 若空session, 则跳转到B站点登录, 在B站点登录成功后, B站点后端会post登录用户的信息到A站点的一个api, 同时B站点再跳转回A, A站点通过B Post过来的数据进行用户验证, 保存Session, 于是用户愉快地登录了。然而我的问题是 B站点跳转回A的时候发现Session仍然是null, 于是陷入了无限跳转过程中。 3. 解决假设B Post数据到A 的api是 http://hostofa:port/user, 而A在UserController的create方法中处理该事件, 则12345class SafeController &lt; ApplicationControllerlayout falsedef create// code to dispose data from B, then save sessionend 以上为原代码, 无法生成session, 调试发现根本无法进入cretae方法修改后的代码为:123456class SafeController &lt; ApplicationControllerprotect_from_forgery :except =&gt; :createlayout falsedef create// code to dispose data from B, then save sessionend 问题得以解决。其实原因就是由于ApplicationController中会默认启用protect_from_forgery, 由于csrf的机制, A站点无法处理B站点Post过来的数据, 所以只要针对性的开放某api即可]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>ruby</tag>
        <tag>rails</tag>
        <tag>session</tag>
        <tag>csrf-token</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Movie Projector 01]]></title>
    <url>%2F2016%2F02%2F12%2Fwatching01%2F</url>
    <content type="text"><![CDATA[1. Planet Earth EP01 At this stage, the odds are even. Midsummer on the tundra and the sun does not set. The character of the forest changes as you descend, becoming ever darker and damper, faouring different kinds of animals amd plants. It’s hard not to feel deflated when even your best isn’t good enough. Its richest parts are those where waves and currents bring fertilising nutrients to surface waters that are bathed in sunlight. The strike of a great white shark lasts a mere second, slowing it down 40 times reveals the technique and immense strength of this massive predator. it’s agility versus power. It’s a seasonal feast for animals of all kinds. The lives of these elephants are.dominated by the annual rhythm of wet and dry, a seasonal cycle created by sun.]]></content>
      <categories>
        <category>life</category>
        <category>watching</category>
      </categories>
      <tags>
        <tag>documentary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ruby 琐记一]]></title>
    <url>%2F2016%2F01%2F01%2Fruby01%2F</url>
    <content type="text"><![CDATA[1、嵌入字符串在字符串中使用#{…}这样的写法, 可以把通过计算得到的值嵌入到字符串中, 输出结果除了可以嵌入变量名也可以嵌入公式1puts "Area = #&#123;area&#125;" 2、times循环次数固定使用times方法会更简单12310.times do puts 'hahaha'end 3、symbol符号(symbol)与字符串对象相似,符号也是一种对象,一般作为名称标签来使用,用来表示方法等对象的名称可以将符号简单理解为一种轻量级的字符串12symbol1 = :foo #表示符号:foosymbol2 = :"foo" #意义同上 4、变量变量的命名决定了变量的种类 + 局部变量: 以英文字母或\_开头 + 全局变量: 以$开头 + 实例变量: 以@开头 + 类 变 量 : 以@@开头 5、多重赋值一些小技巧:12345a, b, *c = [1,2,3,4,5] # a=1,b=2,c=[3,4,5]a, *b, c = [1,2,3,4,5] # a=1,b=[2,3,4],c=5a, b = 1,2b, a = a,b 只要左边的变量结构与数组结构一致, 即使再复杂的结构, 多重赋值都可以轻松解决 6、比较的方法== === equal? eql? 7、定义带块的方法yield是定义带块的方法时最重要的关键字,调用方法时通过块传进来的处理会在yield定义的地方执行 8、zip方法zip方法可以将接收器和参数传来的数组元素逐一取出,而且每次都会启动块. 参数可以是一个也可以是多个123456789arr1 = [1,2,3,4,5]arr2 = [10,20,30,40,50]arr3 = [100,200,300,400,500]result = []arr1.zip(arr2,arr3) do |a,b,c| result &lt;&lt; a+b+cendp result]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>programming language</tag>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑学入门二]]></title>
    <url>%2F2016%2F01%2F01%2Ftopology02%2F</url>
    <content type="text"><![CDATA[前言江辉有《拓扑学》的内容很全面, 以后再看拓扑学大概就可以对照这这本书的目录来了 点集拓扑学拓扑空间之间的连续映射与同胚 连续映射的定义 连续映射的性质 同胚映射 嵌入与嵌入映射 拓扑基与Tychonoff积空间 拓扑基与子基 乘积空间 分离性公理与可数性公理 分离性公理 可数性公理 拓扑性质的可遗传性与可乘性 Uryshon引理及其应用 Uryshon引理 Tietze扩张引理 Uryshon度量化定理 拓扑空间的紧致性与列紧性 紧致与列紧的定义 列紧空间的性质 紧致空间的性质 局部紧性与仿紧性 局部紧性 仿紧性 连通性与道路连通性 连通性的定义及例子 连通空间的性质 连通分支 局部连通性 道路及其运算 道路连通空间 道路连通分支 局部道路连通 商空间与商映射 商空间 拓扑锥 贴空间 映射柱与映射锥 商映射 闭曲面及其分类 拓扑流形的概念 闭曲面 两类闭曲面 闭曲面分类定理 点网、滤子与收敛性概念的扩张 点网 滤子 函数空间 点态收敛拓扑 X上的一致收敛拓扑 紧开拓扑 k-空间与Ascoli定理 代数拓扑学映射的同伦与基本群的定义 映射的同伦 道路类的逆与乘积 道路类的运算性质 空间的基本群定义 连续映射诱导的基本群同态 基本群与基点的关系 球面Sn的基本群 S1的基本群 n≥2时Sn是单连通的 T2的基本群 基本群的同伦不变性 同伦的映射所诱导的基本群的同态之间的关系 拓扑空间的同伦等价 形变收缩核 可缩空间 基本群的计算 Seifert-VanKampen定理 Seifert-VanKampen定理应用举例 轨道空间与基本群 基本群的若干应用 闭曲面分类定理证明的完成 Brouwer不动点定理2维情形的证明 代数基本定理的证明 曲面的边界问题 扭结群的Wirtinger表示 平面的分离问题 复叠空间及其基本性质 复叠映射与复叠空间 映射的提升问题 复叠空间的基本群 复叠空间的分类 复叠变换与正则复叠空间 复叠变换 正则复叠空间 泛复叠空间 四元数简介 单纯复形的同调群 单纯形 单纯复(合)形 多面体与可剖分空间 承载单形 单形的定向 链群 边缘同态 同调群 同调群的简单性质、G系数同调群 同调群的简单性质 0维同调群 1维同调群与基本群的关系 Euler Poincare公式 以交换群G为系数群的同调群 同调群的基本计算单纯映射与单纯逼近 单纯映射 单纯映射诱导的同调群的同态 单纯逼近 重心重分 单纯逼近存在定理 连续映射诱导的同调群同态 链复形、链映射和链同伦 同调群的重分不变性 诱导同调f*q的定义 多面体与可剖分空间的同调群 同调群的同伦不变性 同调群的同伦不变性 同调群计算再举例 Mayer-Vietoris同调序列 简约同调群 相对同调群 同调代数的基本知识，正合同调序列 Mayer？Vietoris同调序列 球面自映射的映射度及其应用 球面自映射的映射度的定义和性质 对径映射的映射度及其应用 保径映射的映射度 Borsuk-Ulam定理 Lefschetz不动点定理 代数准备 有限复形K的迹数 可剖分空间的Lefschetz数 拓扑群基础拓扑群的基本概念与基本性质 拓扑群的概念 拓扑群的性质 拓扑群的子群、商群与拓扑变换群 拓扑群的子群 拓扑群的商群 拓扑变换群 拓扑群的可乘性、分离性、连通性与逆极限 拓扑群的积 拓扑群的分离性 拓扑群的连通性 逆极限]]></content>
      <categories>
        <category>science</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>topology</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dancing Links]]></title>
    <url>%2F2015%2F11%2F20%2FdancingLinks%2F</url>
    <content type="text"><![CDATA[1. 简介参考维基百科 2. 分析实现参考这里, 写的很详细]]></content>
      <categories>
        <category>techonology</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>dancing links</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Graph DFS]]></title>
    <url>%2F2015%2F11%2F19%2Fgraph%2F</url>
    <content type="text"><![CDATA[dfs添加顶点到集合在调用dfs的过程中，有四种添加顶点到集合的顺序： Pre-Order，在递归调用dfs之前将当前顶点添加到queue中 Reverse Pre-Order，在递归调用dfs之前将当前顶点添加到stack中 Post-Order，在递归调用dfs之后将当前顶点添加到queue中 Reverse Post-Order，在递归调用dfs之后将当前顶点添加到stack中]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Union-Find Structure]]></title>
    <url>%2F2015%2F11%2F17%2FunionFind%2F</url>
    <content type="text"><![CDATA[并查集这篇文章写的很好懂]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>union find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux琐记三]]></title>
    <url>%2F2015%2F11%2F01%2Flinux03%2F</url>
    <content type="text"><![CDATA[1. who命令who命令查询utmp文件并报告当前登录的每个用户。Who的缺省输出包括用户名、终端类型、登录日期及远程主机。 2. w命令执行这项指令可得知目前登入系统的用户有那些人，以及他们正在执行的程序。单独执行linux w命令会显示所有的用户，您也可指定用户名称，仅显示某位用户的相关信息。 3. 查看端口使用情况netstat -anp | grep portno比如netstat –apn | grep 8080 4. cat命令高级用法搭配EOF和输入输出流&gt;&gt;及&lt;&lt;使用，例如Haskell的官方安装教程：1234cat &gt;&gt; ~/.bashrc &lt;&lt;EOFexport PATH="\$HOME/.cabal/bin:/opt/cabal/1.20/bin:/opt/ghc/7.10.3/bin:\$PATH"EOFexport PATH=~/.cabal/bin:/opt/cabal/1.22/bin:/opt/ghc/7.10.3/bin:$PATH=" 以上可以实现文件追加功能，在.bashrc文件最后追加两句环境变量。 5. Linux命令行下引号echo &quot;$PATH&quot;与echo $PATH的结果相同，输出PATH变量的值，而echo &#39;$PATH&#39;输出的结果就是$PATH这个字符串 6. 修改ssh 端口号vim /etc/ssh/sshd_config 找到port修改即可，当然还是注意尽量不要使用1024以下的端口，即使你是root用户。之后重启：service ssh restart 7. 修改用户所属用户组usermod -g newgroup username 8. 禁止用户登录主要使用nologin，用户不可以ssh登录但可以使用ftp等登录 Method 1:usermod -s /usr/sbin/nologin username and echo &quot;/usr/sbin/nologin&quot; &gt;&gt; /etc/shells Method 2:lock the user: passwd -l usernameif we want to unlock: passwd -u username Method 3:vim /etc/passwdthen change test:x:1001:1000:,,,:/home/test:/bin/bash to test:x:1001:1000:,,,:/home/test:/usr/sbin/nologin Method 4:touch /etc/nologin, this will deny all users except root to login. Method 5:We can deny the way to login with username and passwd, just edit /etc/ssh/sshd_config, find PasswordAuthentication yes, change it to PasswordAuthentication no, then service sshd restart 9. 文件夹权限与文件权限的区别 权限 对文件的作用 对文件夹的作用 r 查看文件内容 列出文件夹中的文件(ls) w 修改文件内容 在文件夹中删除、添加或重命名文件(夹) x 文件可以作为程序执行 cd 到文件夹 10. 将某用户加入sudo权限中visudo命令直接加入username ALL=(ALL) ALL]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++琐记三]]></title>
    <url>%2F2015%2F10%2F30%2Fcpp03%2F</url>
    <content type="text"><![CDATA[1. C++堆与栈的区别和大神一起从良乡回来, 地铁上突然想起了这个问题就问了下, 大神解释之后茅塞顿开、、、回来又查了查网上的东西, 再看发现理解起来轻松了许多 具体可以参考这篇文章, 还有这个问题 2. NULL在C++中0是NULL]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>programming language</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++琐记二]]></title>
    <url>%2F2015%2F10%2F27%2Fcpp02%2F</url>
    <content type="text"><![CDATA[1. vector1.1 erase以前用vector时只是使用push_back(),pop_back(),begin(),end(),front(),back()等，没用过erase(), 今天搭配iterator用了一下, 才发现很神奇。比如删除一个vector上指定值为val的元素:1234567for(vector&lt;int&gt;::iterator it = nums.begin(); it != nums.end(); ) &#123; if( nums[i] == val ) &#123; nums.erase(it++); &#125; else &#123; it++; &#125;&#125; 上面这段代码是错误的，而且只要改一处就可以正确。修改后为:1234567for(vector&lt;int&gt;::iterator it = nums.begin(); it != nums.end(); ) &#123; if( nums[i] == val ) &#123; nums.erase(it); &#125; else &#123; it++; &#125;&#125; 区别就是erase之后it没有自增，也就是将nums某个元素erase之后，并不需要将iterator自增，nums会自动调整整个结构，将后一个元素放到当前指针指的位置。 1.2 iteratoriterator某种程度上可以当作指针来使用，上述程序还可以这样:1234567while( it != nums.end() ) &#123; if( *it == val ) &#123; nums.erase(it); &#125; else &#123; it++; &#125;&#125; 1.3 初始化我通常不初始化vector, 但如果需要初始化分配一定空间, 可以使用vector&lt;int&gt; num(100); vector&lt;int&gt; num(100,0)，前者是包含100个值默认初始化值的元素，后者是包含100个0。此外，C++11新增了一个array类，是固定长度的数组，使用起来可能更方便和安全，有兴趣可以再仔细看下。 2. GCC编译器的问题在CodeBlocks里输入vector&lt;vector&lt;int&gt;&gt; s竟然会编译出错，‘&gt;&gt;’ should be ‘&gt; &gt;’ within a nested template argument list，改成 vector&lt; vector&lt;int&gt; &gt; s才好, 而在VS里并没有问题, CodeBlocks自带的MinGW中的GCC编译器在某些方面还是比不上VS的编译器的 3. Console输入C++中输入字符串我一般常用string str; cin &gt;&gt; str;，然而今天要输入一个字符串，中间带有空格，发现上述写法不对，会自动滤除所有空格，搜了下，使用getline(cin,str);即可。 4. Struct与Classstruct与class在C++者两者基本相同, 区别仅在以下几点: struct的成员默认权限是public，而class的成员默认权限是private struct的默认继承方式为public，而class的默认继承为private 只有class可用模板template定义参数，而struct不可以 5. 关于sizeof首先声明: sizeof不是函数,是操作符 sizeof是C/C++中的一个操作符(operator)，其作用就是返回一个对象或者类型所占的内存字节数 sizeof的计算发生在编译时刻，所以它可以被当作常量表达式使用 指针记录了另一个对象的地址，既然是来存放地址的，那么必然等于计算机内部地址总线的宽度，所以在32位计算机中，一个指针变量的返回值是4字节，在64位系统中指针变量的sizeof结果为8，当然与编译器的版本有关，如果在64位系统上运行32位编译器自然还是4。注意sizeof(NULL) = 4 数组的sizeof值等于数组所占用的内存字节数 每个类的实例，在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类隐含的加一个字节，这样空类在实例化后在内存得到了独一无二的地址，因此空类默认会占用1个字节。如：12class a &#123;&#125;;sizeof(a); //为1]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>programming language</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 与 Gradle]]></title>
    <url>%2F2015%2F10%2F23%2Fandroid05%2F</url>
    <content type="text"><![CDATA[1. 描述 以前是用IntelliJ IDEA直接玩安卓程序的, 但是自从Google根据IDEA开发了新的ide后, 很多开发者都转向Android Studio了, 网络上的有些源代码无法直接在IDEA上编译, 于是下了个Android Studio折腾, 用过IntelliJ IDEA后安装、配置环境都很简单, 不太相同的地方是Google采用Gradle作为Android app开发的包管理器之后, 其自家推出的Android Studio自然得默认下载它, 于是在新建工程的最后一步, 提醒你可能需要配置一下代理才能使用成功的下载安装Gradle, 使用SS代理, 成功下载安装 2. 项目结构新建空白项目的结构: 3. Gradle简介 Gradle是一种依赖管理工具, 基于Groovy语言, 面向Java应用为主, 它抛弃了基于XML的各种繁琐配置, 取而代之的是一种基于Groovy的内部领域特定(DSL)语言。其优点有很多: 像Ant一样，通用灵活的构建工具可以切换的，基于约定的构建框架强大的多工程构建支持基于Apache Ivy的强大的依赖管理支持maven, Ivy仓库支持传递性依赖管理，而不需要远程仓库或者是pom.xml和ivy.xml配置文件。对Ant的任务做了很好的集成基于Groovy，build脚本使用Groovy编写有广泛的领域模型支持构建 缺点么, 我觉得就是又增加了入门者的学习成本 4. Gradle配置新建空白工程的里根目录和app目录下各有一个build.gradle文件，文件内容分别是: 4.1 build.gradle12345678910111213141516171819202122// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:1.3.0&apos; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125; 4.2 app/build.gradle123456789101112131415161718192021222324252627apply plugin: &apos;com.android.application&apos;android &#123; compileSdkVersion 23 buildToolsVersion &quot;22.0.1&quot; defaultConfig &#123; applicationId &quot;info.hypocrisy.test&quot; minSdkVersion 15 targetSdkVersion 23 versionCode 1 versionName &quot;1.0&quot; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) testCompile &apos;junit:junit:4.12&apos; compile &apos;com.android.support:appcompat-v7:23.1.0&apos; compile &apos;com.android.support:design:23.1.0&apos;&#125; 4.3 直观认识在./build.gradle中的task clean中加入println &#39;test gradle.&#39;, 那么每次运行gradle时都会在Gradle Console里显示出test gradle, 当然, 显示的东西太多, 这一条不是很好找, 命令行下新建一个test.gradle文件:123task test &#123; println &apos;test gradle.&apos;&#125; 之后gradle -b test.gradle -q test即可在terminal中看到test gradle. 4.4 解释说明从上述build.gradle文件可以很轻松的看出在android中使用gradle基本上就是各种配置选项, 对于不同目录下都可以建立build.gradle文件, 其作用域自然也就是当前目录, 比如./目录下的作用域就是整个project, 而./app目录下的作用范围就是app目录下的这些源文件。这样理解的话, 无论gradle怎么变, 都可以很轻松的快速掌握它, 与以前的android结构相比, 现在的gradle近似相当于其AndroidManifest.xml文件, 虽然现在此XML仍然存在。而gradle的功能更为强大, 至于其更多配置选项可以以后慢慢接触。 4.5 setting.gradle在根目录下，还有一个setting.gradle文件。这个文件是全局的项目配置文件, 里面主要声明一些需要加入gradle的module(比如上述我们的app目录, 这个类似于java的结构com.xxx.xxx, 最终存放代码的部分都可以作为一个module, 而每个dot分隔开来的部分在android studio的结构里看就是一个目录), 这个Test程序的setting.gradle内容为: include &#39;:app&#39;, 如果我们加入了一个新的module叫做gaea, 那么setting.gradle内容就变为: include &#39;:app&#39;, &#39;:gaea&#39;, 如果我们再加入了一个extra/hecate的module, 类似于extra.hecate, 那么setting.gradle内容就变为：include &#39;:app&#39;, &#39;:test&#39;, &#39;:extra:hecate&#39; 5. gradlew了解了gradle的基本知识，以及android studio里一个project的配置信息，就很容易想到，如果我们从网上down了一份源码，别人虽然也是用gradle配置的，但是如果gradle版本不一样，那么由于其配置的一些语法不同，可能就无法正常编译打包了。我们注意到项目结构的根目录下有gradlew的文件，gradlew代表 gradle wrapper，相当于本地封装了gradle，在/gradle/wrapper/gralde-wrapper.properties文件中声明了它指向的目录和版本。在Android Studio下的terminal下运行 gradlew -v，若是第一次运行则显示Downloading如图：下载的目录为C:\Users\[Username]\.gradle\wrapper\dists\gradle-2.4-all\3i2gobhdl0fm2tosnn15g540i0\因为下载过程有点慢，也可以去https://services.gradle.org/distributions下载其他版本然后放到C:\Users\[Username]\.gradle\wrapper\dists相应目录下解压即可。 下载成功后即可用grdlew wrapper的命令代替全局的gradle命令，再次运行gradlew -v，结果如下： 再次执行gradlew build可以编译并打包成apk文件，如果依赖不全会自动下载gradle的一些依赖，一般下载到C:\Users\[Username]\.gradle\caches\modules-2\files-2.1\目录下。下载成功会出现：Terminal上可以看出编译成功与否。编译成功后可以在Test\app\build\outputs\apk\文件夹下找到apk文件，如下图： 最后可以运行gradlew clean，其作用是清除/app目录下的build文件夹，依赖不全也会下载gradle的一些依赖。以上在下载过程中可以看到https://jcenter.bintray.com/这个网址一直在出现，其实所有通过gradle导入的jar包都是从此网站的仓库上Downlad的。如果你需要的jar包在这个网站上没有，那就无法通过gradle的方式来导入。至于怎么确定是从这个网站Download，其实在根目录下的build.gradle中指定了：12345allprojects &#123; repositories &#123; jcenter() &#125;&#125; gradlew的其他用法和参数搭配可以通过gradlew -h查看。 6. 其他建议除了以上命令行的做法, 还可以在将工程导入Android Studio后, 查看每个Module下的 build.gradle 下的buildToolsVersion, 然后通过 SDK Manager 查看本地你安装的 SDK Build-tools, 如果相应版本没有安装先下载安装; 之后, 更新build.gradle和gralde-wrapper.properties相应的部分, 然后使用Android Studio的Make build或Run app即可也可以不使用Android Studio调用安卓模拟器, 手动打开Android Emulator, 之后将app-debug.apk拷到android-sdk\platform-tools目录下, cmd下cd到该目录执行adb install app-debug.apk即可将打包后的apk安装到正在运行的Emulator上了。顺便说下创建新的模拟器时勾选Use Host GPU效果应该会好点。]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>android studio</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统六]]></title>
    <url>%2F2015%2F10%2F22%2FoperatingSystem06%2F</url>
    <content type="text"><![CDATA[1. 进程同步和P、V操作若有三个并发进程互斥，如果利用信号灯方式控制其同步关系，那么三个进程的同步过程如下图： 2. Linux系统功能调用的实现机制2.1 Linux系统调用的进入Linux系统的软中断指令是汇编语言指令int 0x80，执行该指令会发生中断，处理机的状态由用户态自陷到内核态(在更新的芯片中添加了sysenter汇编语言指令等)。int 0x80指令使用的异常向量号是128(即16进制的80)，该异常向量包含了内核系统调用程序的入口地址。在内核初始化时，已将系统调用处理程序的入口地址送入向量128的中断描述符表表项中，设置段地址为内核开始的地方，段内偏移则指向系统调用处理程序system_call()。当应用程序请求操作系统服务，发出int 0x80指令时，就会从用户态自陷到内核态，并从system_call()开始执行系统调用处理程序。当系统调用处理完毕后，通过iret汇编语言指令返回到用户态。 2.2 系统调用号和系统调用表2.2.1 系统调用号在Linux中，每个系统调用被赋予一个唯一的系统调用号。用户空间的进程通过系统调用号指明要执行的具体系统调用系统调用号定义在include/asm-i386/unistd.h头文件中，这个头文件定义了该系统所有的系统调用号。格式如下：123456789#define _NR_restart_syscall 0#define _NR_exit 1#define _NR_fork 2#define _NR_read 3#define _NR_write 4#define _NR_open 5............#define _NR_mq_getsetattr 282 该文件中的每一行表示为#define_NR_name NNN，其中，”_NR_”是一种约定，name为系统调用的名称，而NNN则是该系统调用对应的号码。该文件的最后，还定义了几个与系统调用相关的关键的宏。 2.2.2 系统调用表系统调用表记录了内核中所有已注册的系统调用，它是系统调用的跳转表，实际上是一个函数指针数组，表中依次保存所有系统调用的函数指针，以方便总的系统调用处理函数system_call进行索引。Linux系统调用表保存在arch/i386/kernel/下的entry.S中，其形式如下：12345678910ENTRY(sys_call_table).long sys_restart_syscall /* 0 */.long sys_exit /* 1 */.long sys_fork /* 2 */.long sys_read /* 3 */.long sys_write /* 4 */.long sys_open /* 5 */.............long sys_mq_getsetattr /* 6 */ 文件中有许多.long SYMBOL_NAME(sys_ni_syscall)的结构，”.”代表当前地址，”sys_call_table”代表数组首地址 2.3 系统调用处理程序系统调用处理程序是system_call()，该函数的主要工作如下。 通过宏SAVE_ALL保护异常处理程序中要用到的所有寄存器到寄存器到内核堆栈中，其中，指令地址和处理机状态已在中断进入过程中保护(eflags、cs、eip、ss、esp寄存器除外) 进行系统调用正确性检查，如对用户态进程传递来的系统调用号进行有效性检查，若该号大于或等于系统调用表的表项数，系统调用处理程序就终止 根据eax中所包含的系统调用号，调用其对应的服务例程 系统服务例程结束时，通过宏RESTORE_ALL恢复寄存器，最后通过iret指令返回 3. 增加一个新的系统调用方法如果需要扩充Linux系统的功能，增加一个新的系统调用需要做的工作包括以下几个方面： 描述新增加功能的服务例程 增加一个新的系统调用号 在系统调用表中登记新的系统调用号以及对应的服务例程 新增加的服务例程要被Linux系统接受，必须重新编译内核，生成新的包含新增服务例程的内核 当要增加一个新的系统调用时，首先要确定新增的服务例程的名字，因为确定了这个名字后，在系统调用中的几个相关的名字也就确定了。如: 新增加的系统调用名为mysyscall 系统调用的编号名字为_NR_mysyscall 内核中系统调用服务例程的名字为sys_mysyscall 3.1 添加新的服务例程编写新增的服务例程加到内核中去，即在/usr/src/linux/kernel/sys.c文件中增加一个新的函数，该函数的名字是sys_mysyscall。函数体内是新增加的功能描述，在Linux系统增加一个新的系统调用时，首先要保证整个控制过程正确，所以在开始调试时，新增功能尽量简单，如下例，其功能是返回一个整形值。123asmlinkage int sys_mycall(int number) &#123; return number;&#125; 3.2 增加新的系统调用号定义系统调用号，在文件include/asm-i386/unistd.h中添加一项#define _NR_mysyscall XXXX 为增加的系统调用号，此数字选一未用值，一般在已定义的系统调用号的最后增加一项，如下所示：12345678910#define _NR_restart_syscall 0#define _NR_exit 1#define _NR_fork 2#define _NR_read 3#define _NR_write 4#define _NR_open 5............#define _NR_mq_getsetattr 282#define _NR_mysyscall 283 3.3 修改系统调用表在文件/arch/i386/kernel/entry.S中的系统调用表 sys_call_table中添加新增的系统调用，sys_call_table数组包含指向内核中每个系统调用的指针，这样就在数组中增加了新的内核函数的指针。在清单最后添加一行。如下所示：1234567891011ENTRY(sys_call_table).long sys_restart_syscall /* 0 */.long sys_exit /* 1 */.long sys_fork /* 2 */.long sys_read /* 3 */.long sys_write /* 4 */.long sys_open /* 5 */.............long sys_mq_getsetattr /* 6 */.long sys_mysyscall /* 7 */ 3.4 重新编译内核并启动新内核为使新的系统调用生效，需要重建Linux的内核。对于不同的计算机配置、Linux不同的版本等，重新编译内核命令可能会有所不同。]]></content>
      <categories>
        <category>science</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>operating system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑学入门一]]></title>
    <url>%2F2015%2F10%2F21%2Ftopology01%2F</url>
    <content type="text"><![CDATA[前言读江辉有《拓扑学》[1]笔记 1. 引言1.1 一笔画问题和哥尼斯堡七桥问题1.2 欧拉(Euler)示性数1.3 图的可平面化处理问题 对于由顶点和线构成的图，如果每个顶点间都有线相连，则这样的图称之为完全图。下图中的K5是完全图，K33不是完全图 所谓图的可平面化问题就是：一个图应当满足什么条件，才可以在平面上不自交的被画出来?这也就是通常说的可嵌入平面的问题。这里说的不自交指的是不同的线不会相交，至于线如何回还转曲不加限制。 Kuratowsky定理 一个图G可以嵌入平面当且仅当G不含有K5或K33同构的子图 有意思的是，K33虽然不能嵌入平面，却可以嵌入Mobius带。 1.4 扭结论(Knot theory)研究1.5 四色问题2. 点集拓扑学2.1 预备知识2.1.1 集合代数与关系 X所有子集构成的集族，称为X的幂集，用2^X表示 笛卡尔积: \(X\times Y=\{(x,y):x\in X,y\in Y\}\). \(X\times Y\)的任一子集R称为X到Y的一个关系。若\((x,y)\in R\)，则称x与y是R-相关的，也记为xRy。若R是X到Y的一个关系，则其定义集为\(\{x\in X: \exists y\in Y, xRy\}\)(为方便也常记为DR)，也称为定义域。而其值集则定义为\(\{y\in Y: \exists x\in X, xRy\}\)。 2.1.2 函数与等价关系 包含映射(含入映射) 自反&amp;对称&amp;传递\(\Rightarrow\)等价关系 商集, 自然映射 划分 2.1.3 序关系与选择公理 设R是X上的一个关系，如果\(xRy\wedge yRx\)，则必有x=y，那么我们称R在X上是反对称的。X上的一个自反、反对称且传递的关系R就称为X上的一个偏序。当R是X上的一个偏序时，偶对(X,R)称为一个偏序集。在偏序关系R明确的情况下，有时也简称X为一个偏序集。偏序关系常用≤来表示 全序(也称线性序)；全序集(或线性序集)，也称为链 良序；良序集 闭区间，左闭右开区间，开区间，闭右射线，开右射线，区间，诱导偏序，偏序子集 选择公理\(\Leftrightarrow\)Zermelo良序定理\(\Leftrightarrow\)Teichmuller-Tukey引理\(\Leftrightarrow\)Kuratowski-Zorn引理 2.1.4 集合的可数性如果集合A的元素是只有有限个，就称它是有限集，否则为无限集。如今我们把能与自然数集形成一一对应的集合称为可数无限集(也称可列集)，而把有限集和可数无限集统称为可数(countable)集，也就是说，能够与自然数集的某个子集形成一一对应的集合都称为可数集。不是可数集的集合不可数 2.1.5 基数简介 定义：如果在集合A和集合B之间存在一一对应\(f: A\rightarrow B\)，则称集合A和集合B是等势的，记为A~B。如果存在自然数n使得A~{1,2,…,n}，则称集合A是有限的；不是有限的集合就是无限的。如果A~N(正整数集)，则称A是可数无限的(或者可列的)；有限的或可数无限的统称为可数的。 定理：集合间的等势关系是一个等价关系，即对任意集合A,B,C，有： \(A\sim A\) \(A\sim B \Rightarrow B\sim A\) \((A\sim B)\wedge (B\sim C)\Rightarrow A\sim C\) 定义：对于每个集合A，对应一个符号|A|，称为A的基数，它满足以下条件： 如果A~B，则|A|=|B| \(|\varnothing| = 0\) 如果有自然数n使得A~{1,2,…,n}，则|A|=n 显然基数就是通常个数概念的推广 …… 3. 拓扑空间的基本概念3.1 拓扑空间的定义设X是一个非空集合，其子集族\(\Im \subset 2^X\)称为X上的一个拓扑，如果它满足： \(X,\varnothing\)均为\(\Im\)中元素 \(\Im\)中任意多个元素的并集仍为\(\Im\)中元素(也称\(\Im\)对并运算封闭) \(\Im\)有限个元素的交集仍为\(\Im\)中元素(也称\(\Im\)对有限交运算封闭) 此外，偶对\((X,\Im)\)称为一个拓扑空间，通常简记为X 这时拓扑空间的每一个元叫做开集，同样还可以定义闭集(后续会说)，所以也可以用闭集来定义拓扑空间。 3.2 度量拓扑 非空集合X上的一个度量d是指一个满足如下三条度量公理的映射\(d: X\times X \rightarrow R\) 1) 非负性：\(d(x,y)\geq 0,\forall x,y\in X\), 等号当且仅当x=y时成立 2) 对称性：\(d(x,y)=d(y,x),\forall x,y\in X\) 3) 三角不等式：\(d(x,z)\leq d(x,y)+d(y,z),\forall x,y\in X\) 示例： 1) 在n维欧式空间\(\mathbb{R}^n\),如下定义的映射\(d:\mathbb{R}^n \times \mathbb{R}^n\),\(d(x,y)=\parallel x-y\parallel =\sqrt{\sum_{i=1}^{n}(x_i-y_i)^2},\forall x=(x_1,x_2,\cdots,x_n),y=(y_1,y_2,\cdots,y_n)\in \mathbb{R}^n\)是一个度量，称为欧式度量 2) 在\(C[a,b]\)上，对于两个函数\(f,g\in C[a,b]\)，由\(d(f,g)=\int_a^b|f-g|dx\)定义的映射给出了\(C[a,b]\)上的一个变量 3) 在任意一个非空集X上，\(d(x,y)=\begin{cases} 0,x=y\\1,x\neq y \end{cases}\forall x,y\in X\)定义了一个度量，这个度量通常称为离散度量 4) 在集合\(H=\left\{x=(x_1,x_2,\cdots,x_n,\cdots)|\sum_{i=1}^{\infty}x_i^2&lt;+\infty,x_i\in \mathbb{R}\right\}\)上，定义\(d(x,y)=\sqrt{\sum_{i=1}^{\infty}(x_i-y_i)^2},\forall x=(x_1,x_2,\cdots),y=(x_1,y_2,\cdots)\in H\)，则d是H上的一个度量 度量空间：对于定义了度量\(d:X\times X\rightarrow \mathbb{R}\)的集合X而言，\(\forall x_0\in X,\forall \epsilon &gt;0\)，称\(B(x_0,\epsilon)=\{x\in X|d(x,x_0)&lt;\epsilon\}\)为以\(x_0\)为中心，\(\epsilon\)为半径的球形领域(开球)，再令\(\Im_d=\{U\subset X|U是X中若干个球形领域的并集\}\)，则很容易验证：\(\Im_d\)是X上的一个拓扑，称为由度量d诱导的拓扑（简称度量拓扑）。此时，拓扑空间\((X,\Im_d)\)通常简记为(X,d)，甚至在不引起混乱的情况下直接记为X，称为度量空间 3.3 拓扑空间的几个基本概念 闭集：拓扑空间中的一个集合F，如果其补集为开集，则称它为闭集 在一个拓扑空间中，能表示为可数多个闭集的并集的集合称为\(F_\sigma -\)集 在一个拓扑空间中，能表示为可数多个闭集的并集的集合称为\(G_\sigma -\)集 集合X的一个非空子集族\(\Sigma\)称为一个\(\sigma -\)环，是指它满足： 1) 对余运算封闭：\(A\in \Sigma\Rightarrow A^C\in \Sigma\) 2) 对可数交运算封闭：\(A_i\in \Sigma(i\in \mathbb{N})\Rightarrow \bigcap_{i\in \mathbb{N}}A_i\in \Sigma\) 邻域、内点和内部 聚点与闭包 序列的收敛性 3.4 子空间Footnotes1.拓扑学 ↩]]></content>
      <categories>
        <category>science</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>topology</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bootstrap小记一]]></title>
    <url>%2F2015%2F10%2F19%2Fbootstrap01%2F</url>
    <content type="text"><![CDATA[1. 前言把车队主页给换了, 其实就是直接把discuz下的index.php给删了换成自己的, 然而自以为做的差不多了, 没想到好多以前的设计都错了, 其中就有一些关于bootstrap的使用上的错误 2. Collapse 功能导航栏的collapse, 以前测试用的网站写的简陋, 没注意导航栏的手机端兼容, 实际上导航栏的使用如下:12345678910111213141516171819&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Test&lt;/a&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-navbar&quot; data-toggle=&quot;collapse&quot; data-target=&quot;.navbar-collapse&quot;&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; &lt;div id=&quot;navbar&quot; class=&quot;navbar-collapse collapse&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li id=&quot;ftp&quot;&gt;&lt;a href=&quot;ftp://10.1.166.197&quot; target=&quot;_blank&quot;&gt;FTP&lt;/a&gt;&lt;/li&gt; &lt;li id=&quot;Wiki&quot;&gt;&lt;a href=&quot;http://10.1.166.197:8080/xwiki/bin/view/&quot; target=&quot;_blank&quot;&gt;Wiki&lt;/a&gt;&lt;/li&gt; &lt;li id=&quot;forum&quot;&gt;&lt;a href=&quot;http://10.1.166.197/forum.php&quot; target=&quot;_blank&quot;&gt;Forum&lt;/a&gt;&lt;/li&gt; &lt;li id=&quot;contact&quot;&gt;&lt;a href=&quot;#contact&quot;&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 以前定义了class为navbar-collapse collapse的标签, 但是未定义拥有属性data-toggle=&quot;collapse&quot; data-target=&quot;.navbar-collapse&quot;的标签, 故用手机登陆时并没有好的效果, 现在则可以。看网上源码, 似乎这样写就可以了, 但是以上实现导致其button标签在电脑端浏览也显示, 不够美观, 于是在css里添加@media使button仅在小屏幕才显示出来, 并且设置right:6px使其显示在右侧, 当然还得指定position属性。 3. BootStrap 不兼容 IE11因为不想兼容IE6/7/8，所以直接使用jQuery2.x版本，没想到的是搭配BootStrap使用连IE11都不兼容，网页全面崩溃，IE下F12: Object doesn’t support property or method ‘addEventListener’ Bootstrap’s JavaScript requires jQuery The value of the property ‘$’ is null or undefined, not a Function object 而我的jQuery引用必然是在Bootstrap之前的, Chrome和Edge上都可以理想的呈现, 只能是IE11的问题了。Google了一些方法尝试了下, 都不是很满意, 直到看到下面这句&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot; &gt;, 也很有趣, 既然Edge兼容的话，那就将页面设置为Edge兼容模式就好了。当然这也有可能有其他问题, 比如非Win10的系统, 因为Win10以前的系统并没有自带Edge, 手边暂时也没有其他电脑测试, 所以也不明白是否支持这个兼容模式。]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾车队服务器]]></title>
    <url>%2F2015%2F10%2F17%2Fdiscuz%2F</url>
    <content type="text"><![CDATA[1. 前言飞思卡尔车队有一台服务器一直闲置, 开学没那么多事就帮忙给服务器添加一些功能, 这个过程中有些以前在自己电脑上没有的问题都冒出来了、 2. Apache2.1 缺少msvcr110.dll首先是httpd -k install时直接提示缺少msvcr110.dll, 安装了vcredist_x64.exe还是不行, 想着直接装.net库, 然而并不可以。最后想起来当时下的apache是32位的, 安装了vcredist_x86.exe之后apache安装成功。 2.2 Servername错误之后出现了ServerName错误，直接将#ServerName: localhost:80注释去了，改为自己需要的。 3. Discuz3.1 无法连接数据库安装discuz时，显示无法连接数据库，不支持mysqli_connect，建议advice_mysqli_connect，但是php的配置文件里绝对是修改过的，搜了搜发现是extension_dir使用相对路径有时会出错，改为绝对路径后成功 3.2 网站间隔性无法访问安装之后即可查看了，但是网站会经常无法访问一段时间，查看日志错误信息为: AH00341 指定的网络名不再可用，找到的解决方法有: 在httpd.conf里添加： 123ThreadsPerChild 1000MaxRequestsPerChild 10000Win32DisableAcceptEx 在httpd.conf里添加： 1234AcceptFilter http noneAcceptFilter https noneEnableSendfile Off EnableMMAP off 使用第二种方法解决问题，但是只添加了前两句即可。 3.3 Child: Starting 64 worker threadserrors.log里还有AH00354: Child: Starting 64 worker threads的提醒，这个应该是和分配给Apache的线程数有关，倒是可以用上述方法解决:在httpd.conf找到：12345&lt;IfModule mpm_winnt.c&gt; ThreadsPerChild 64 MaxRequestsPerChild 1000 Win32DisableAcceptEx&lt;/IfModule&gt; 将ThreadsPerChild的数目改大点，当然这和硬件关联很大。 3.4 无法上传附件discuz的头像和附件都无法上传，开始以为只是头像无法上传，提示错误是cannot write data/tmp，感觉是权限问题，就把整个目录权限提升了一番，但是还是不行，最后将#upload_tmp_dir =注释去了，加入discuz的ucenter_server/data/tmp目录，解决问题。 4. Filezilla还用filezilla搭了个ftp服务器，配置好后无法通过其他地址访问，查阅资料将filezilla添加到防火墙允许通过]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>discuz</tag>
        <tag>filezilla</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常软件配置]]></title>
    <url>%2F2015%2F10%2F15%2FdailyConfig%2F</url>
    <content type="text"><![CDATA[1. Foobar 20001.1 插件: foo_ui_columns //this component is used for better ui.foo_input_monkey //this component is used for playing music whose postfix is “ape”foo_uie_lyrics3 //this component is used for displaying lyrics 拖曳窗口最后调整过后是这样:columns_ui的插件一个没用，就觉得已经不错了，而且现在的插件大多也支持default_ui，故觉得并不需要多改动。 1.2 编码器lame3.99.2.3和flac-1.3.1-win以及oggenc2 1.3 搭配使用为了自动创建cue下过软件CueTools，非常好用。以及该软件还有为了验证一个文件是不是真无损的功能。 2. uTorrent1.1 限制带宽options-&gt;preferences-&gt;Bittorrent-&gt;Limit local peer bandwidthoptions-&gt;preferences-&gt;bandwidth 1.2 限制ip范围]]></content>
      <categories>
        <category>life</category>
        <category>tools</category>
      </categories>
      <tags>
        <tag>foobar2000</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统五]]></title>
    <url>%2F2015%2F10%2F06%2FoperatingSystem05%2F</url>
    <content type="text"><![CDATA[文件系统文件系统概述 文件 文件的定义与分类 文件名及文件属性 文件系统文件系统是操作系统中负责管理和存取文件信息的软件结构，它由负责文件操作和管理的程序模块、所需的数据结构(如目录表、文件控制块、存储分配表)以及访问文件的一组操作所组成 文件的组织 文件组织的两种结构 物理文件 逻辑文件 逻辑记录和块 逻辑记录 物理记录 文件的逻辑结构和存取方法 文件的逻辑结构 流式文件 记录式文件 文件的存取方法 文件的物理结构 连续文件 什么是连续文件 连续文件中存取记录的操作 连续文件的特点 串联文件 串联文件结构 文件映照结构 索引文件 直接索引 一级间接索引 二级间接索引 文件物理结构比较 文件存储空间的管理 空闲文件目录 空闲块链 位示图 分配策略 文件目录 文件目录及其内容 什么是文件目录 文件目录及其内容 以及文件目录及缺点 多级文件目录 共享与安全 文件共享与安全性的关系 存取权限的类型及其验证 访问控制矩阵 存取控制表 用户权限表 口令 密码 用文件路径名加快文件的查找 建立当前目录 链接技术 文件操作与文件备份 文件操作 常用的文件操作命令 打开文件和关闭文件的操作 文件备份 UNIX文件系统的主要结构和实现 UNIX文件系统的特点 树型层次结构 可安装卸载的文件系统 文件是无结构的字符流式文件 UNIX文件系统把外部设备和文件目录作为文件处理 UNIX系统的索引文件结构 文件索引节点 目录项 索引节点结构 UNIX 7版本文件索引结构 小型文件 大型文件 巨型文件 UNIX system V的索引结构 UNIX系统文件目录结构 文件目录结构 文件目录结构中的勾链 UNIX系统的打开文件机制 活动节点表 主存索引节点状态—反映主存索引节点的使用情况 设备号、索引节点号 引用计数 系统打开文件表 用户文件描述符 用户文件描述符表、系统打开文件表与主存索引节点表的关系 文件存储器空闲块的管理 文件卷和卷管理块 空闲磁盘块的管理 空闲盘块的分配 空闲盘块的释放 UNIX文件系统调用 文件系统调用与底层算法的关系 缓冲区分配算法 底层文件系统算法 系统调用open 系统调用create 系统调用close 系统调用read 系统调用write]]></content>
      <categories>
        <category>science</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>operating system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统四]]></title>
    <url>%2F2015%2F10%2F02%2FoperatingSystem04%2F</url>
    <content type="text"><![CDATA[设备管理设备管理概述 设备管理的功能 状态跟踪 设备分配 设备控制 设备独立性 设备独立性概念 设备独立性的实现 软通道实现设备独立性 通过指派命令实现设备独立性 逻辑设备描述器 设备独立性的优点 方便用户 提高设备的利用率 提高系统的可适应性和可扩展性 设备控制块 设备控制块结构 命令转换表 缓冲技术 缓冲概述 什么是缓冲 利用缓冲技术进行I/O操作 缓冲技术解决的问题 常用的缓冲技术 双缓冲 双缓冲用于数据输入 双缓冲用于数据输出 缓冲池 UNIX系统的缓冲区管理 缓冲首部 队列结构 空闲缓冲区队列 设备缓冲区队列 缓冲管理算法缓冲区管理总的思路分析如下： 一个缓冲区被分配用于读/写某设备上的字符块时 当需要一个缓冲区时 当一个标有延迟写的缓冲区时移到空闲队列头时 缓冲区的检索 分配一个缓冲区 释放一个缓冲区 读磁盘块和写磁盘块 读磁盘块 写磁盘块 高度缓存的优点和缺点 优点 提供了统一的磁盘存取方法 减少访盘次数 确保文件系统的完整性 简化用户程序 缺点 设备分配 设备分配概述 静态分配和动态分配 I/O设备分配算法 先请求先服务 优先级最高者优先 独享分配 共享分配 虚拟分配 虚拟设备和虚拟分配 Spool(假脱机系统) 虚拟打印功能 输入/输出控制 输入/输出硬件 端口(port) 总线(bus) 控制器(cobtroller) 输入/输出控制方式 循环测试I/O方式 I/O中断方式 通道方式 DMA方式 输入/输出子系统 输入/输出控制子系统概述 各类设备的接口 块设备接口 主存映射接口 字符流设备接口 网络套接字接口 输入/输出子系统功能 解释用户的I/O系统调用 设备驱动 中断处理 调用I/O核心模块的方式 设备处理进程方式 文件操作方式 输入/输出控制的例子 通用形式的系统调用 1)实现使用设备的转换 2)合法性检查 3)形成I/O请求块，发消息给相应的设备处理进程 设备处理进程]]></content>
      <categories>
        <category>science</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>operating system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记八]]></title>
    <url>%2F2015%2F10%2F02%2Freading08%2F</url>
    <content type="text"><![CDATA[1. 前言图书馆再读舒婷 2. 致橡树 我如果爱你——绝不像攀援的凌霄花，借你的高枝炫耀自己：我如果爱你——绝不学痴情的鸟儿，为绿荫重复单调的歌曲；也不止像泉源，常年送来清凉的慰籍；也不止像险峰，增加你的高度，衬托你的威仪。甚至日光。甚至春雨。不，这些都还不够！我必须是你近旁的一株木棉，做为树的形象和你站在一起。根，紧握在地下，叶，相触在云里。每一阵风过，我们都互相致意，但没有人听懂我们的言语。你有你的铜枝铁干，像刀，像剑，也像戟，我有我的红硕花朵，像沉重的叹息，又像英勇的火炬，我们分担寒潮、风雷、霹雳；我们共享雾霭、流岚、虹霓，仿佛永远分离，却又终身相依，这才是伟大的爱情，坚贞就在这里：爱——不仅爱你伟岸的身躯，也爱你坚持的位置，足下的土地。 3. 这也是一切以前读过北岛的《一切》，内涵如何自然是见仁见智了，我只觉得太过悲凉，不过当时正是喜欢那种情绪的年纪，可是人的思想总是在不断变化的，渴望积极-&gt;享受消极-&gt;向往奋斗-&gt;安于现状-&gt;… 谁又能料到下一刻的自己处于何种状态呢。今天又看到了舒婷的《这也是一切》，虽气势上没有《一切》来得汹涌，却是更加给人以鼓舞。单纯从诗歌形式上来说，为了表达自己的观点自然需要使用一些绝对化的表述来增强感染力，所以有了北岛的《一切》，大概是因为觉得这“一切”不完美，舒婷又作此诗来补充吧，至少不是批判，舒婷在散文《生活、书籍与诗》中写到：“我非常喜欢他的诗，尤其是《一切》。”总之，这两首诗结合起来看，让我感受到一切的消极与绝望，而又给我以勇气渴望冲破这绝望，大抵如此。 不是一切大树 都被暴风折断，不是一切种子， 都找不到生根的土壤；不是一切真情 都流失在人心的沙漠里；不是一切梦想 都甘愿被折掉翅膀。不，不是一切 都像你说的那样！不是一切火焰， 都只燃烧自己 而不把别人照亮；不是一切星星， 都仅指示黑夜 而不报告曙光；不是一切歌声， 都只掠过耳旁 而不留在心上。不，不是一切 都像你说的那样！不是一切呼吁都没有回响；不是一切损失都无法补偿；不是一切深渊都是灭亡；不是一切灭亡都覆盖在弱者头上；不是一切心灵 都可以踩在脚下，烂在泥里；不是一切后果 都是眼泪血印，而不展现欢容。一切的现在都孕育着未来，未来的一切都生长于它的昨天。希望，而且为它斗争，请把这一切放在你的肩上。 4. 中秋夜前几天刚过完中秋，此时看到舒婷的这首《中秋夜》倒也还算应景。 海岛八月中秋芭蕉摇摇龙眼熟坠不知有“花朝月夕”只因年来风雨见多当激情招来十级风暴心，不知在哪里停泊道路已经选择没有蔷薇花并不曾后悔过人在月光里容易梦游渴望得到也懂得温柔要使血不这样奔流凭二十四岁的骄傲显然不够要有坚实的肩膀能靠上疲惫的头需要有一双手来支持最沉重的时刻尽管明白生命应当完全献出去留多少给自己就有多少忧愁 5. 会唱歌的鸢尾花这个诗名会让我联想到十年前元若蓝的一首歌“绿袖子” 我的忧伤因为你的照耀升起一圈淡淡的光轮 ——题记​一 在你的胸前 我已变成会唱歌的鸢尾花 你呼吸的轻风吹动我 在一片丁当响的月光下 用你宽宽的手掌 暂时 覆盖我吧 二 现在我可以做梦了吗 雪地。大森林 古老的风铃和斜塔 我可以要一株真正的圣诞树吗 上面挂满 溜冰鞋、神笛和童话 焰火、喷泉般炫耀欢乐 我可以大笑着在街上奔跑吗 三 我那小篮子呢 我的丰产田里长草的秋收啊 我那旧水壶呢 我的脚手架下干渴的午休啊 我的从未打过的蝴蝶结 我的英语练习：I love you，love you 我的街灯下折叠而又拉长的身影啊 我那无数次 流出来又咽进去的泪水啊 还有 还有 不要问我 为什么在梦中微微转侧 往事，像躲在墙角的蛐蛐 小声而固执地呜咽着 四 让我做个宁静的梦吧 不要离开我 那条很短很短的街 我们已经走了很长很长的岁月 让我做个安详的梦吧 不要惊动我 别理睬那盘旋不去的鸦群 只要你眼中没有一丝阴云 让我做个荒唐的梦吧 不要笑话我 我要葱绿地每天走进你的诗行 又绯红地每晚回到你的身旁 让我做个狂悖的梦吧 原谅并且容忍我的专制 当我说：你是我的！你是我的 亲爱的，不要责备我…… 我甚至渴望 涌起热情的千万层浪头 千万次把你淹没 五 当我们头挨着头 像乘着向月球去的高速列车 世界发出尖锐的啸声向后倒去 时间疯狂地旋转 雪崩似地纷纷摔落 当我们悄悄对视 灵魂像一片画展中的田野 一涡儿一涡儿阳光 吸引我们向更深处走去 寂静、充实、和谐 六 就这样 握着手坐在黑暗里 听任那古老而又年轻的声音 在我们心中穿来穿去 即使有个帝王前来敲门 你也不必搭理 但是…… 七 等等？那是什么？什么声响 唤醒我血管里猩红的节拍 当我晕眩的时候 永远清醒的大海啊 那是什么？谁的意志 使我肉体和灵魂的眼睛一齐睁开 你要每天背起十字架 跟我来 八 伞状的梦 蒲公英一般飞逝 四周一片环形山 九 我情感的三角梅啊 你宁可生生灭灭 回到你风风雨雨的山坡 不要在花瓶上摇曳 我天性中的野天鹅啊 你即使负着枪伤 也要横越无遮拦的冬天 不要留恋带栏杆的春色 然而，我的名字和我的信念 已同时进入跑道 代表民族的某个单项纪录 我没有权利休息 生命的冲刺 没有终点，只有速度 十 向 将要做出最高裁决的天空 我扬起脸 风啊，你可以把我带去 但我还有为自己的心 承认不当幸福者的权利 十一 亲爱的，举起你的灯 照我上路 让我同我的诗行一起远播吧 理想之钟在沼地后面敲响，夜那么柔和 灯光和城市簇在我的臂弯里，灯光拱动着 让我的诗行随我继续跋涉吧 大道扭动触手高声叫嚷：不能通过 泉水纵横的土地却把路标交给了花朵 十二 我走过钢齿交错的市街，走向广场 我走进南瓜棚、走出青稞地、深入荒原 生活不断铸造我 一边是重轭、一边是花冠 却没有人知道 我还是你的不会做算术的笨姑娘 无论时代的交响怎样立刻卷去我的呼应 你仍然能认出我那独一无二的声音 十三 我站得笔直 无畏、骄傲，分外年轻 痛苦的风暴在心底 太阳在额前 我的黄皮肤光亮透明 我的黑头发丰洁茂盛 中国母亲啊 给你应声而来的儿女 重新命名 十四 把我叫做你的桦树苗儿 你的蔚蓝的小星星吧，妈妈 如果子弹飞来 就先把我打中 我微笑着，眼睛分外清明地 从母亲的肩头慢慢滑下 不要哭泣了，红花草 血，在你的浪尖上燃烧 …… 十五 到那时候，心爱的人 你不要悲伤 虽然再没有人 扬起浅色衣裙 穿过蝉声如雨的小巷 来敲你的彩色玻璃窗 虽然再没有淘气的手 把闹钟拨响 着恼地说：现在各就各位 去，回到你的航线上 你不要在玉石的底座上 塑造我朴素的形象 更不要陪孤独的吉他 把日历一页一页往回翻 十六 你的位置 在那旗帜下 理想使痛苦光辉 这是我嘱托橄榄树 留给你的 最后一句话 和鸽子一起来找我吧 在早晨来找我 你会从人们的爱情里 找到我 找到你的 会唱歌的鸢尾花]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>poetry</tag>
        <tag>舒婷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统三]]></title>
    <url>%2F2015%2F09%2F27%2FoperatingSystem03%2F</url>
    <content type="text"><![CDATA[主存管理主存管理概述 主存分片共享 程序的组织逻辑 一维地址结构 二维地址结构 主存管理的功能 虚拟存储器 提供虚拟存储器的必要性 虚存的定义 地址映射 什么是地址映射 地址映射方式 编程或编译时确定地址映射关系 静态地址映射 动态地址映射 主存分配主存管理存储器的策略有以下三种： 放置策略 调入策略 淘汰策略 存储保护 分区存储管理及存在的问题 动态分区存储管理技术 分区分配机构 分区分配与放置策略 分区分配 放置策略 按地址增加或减少的次序分类排序 按区的大小增加或减少的次序分类排序 这样就形成了不同的选择空闲区的策略，称为放置策略。常见的有： 首次匹配(首次适应算法) 最佳适应算法 最坏适应算法 碎片问题及拼接技术 页式存储管理 页式系统应解决的问题 页式系统的地址映射 请调策略 放置策略 淘汰策略 页式地址变换 1) 页表 2) 虚地址结构 3) 页式地址变换 4) 联想存储器 请调页面的机制 扩充页表功能 缺页判断与处理 淘汰机制与策略 页面淘汰机制 置换算法 颠簸 几种置换算法 最佳算法(OPT算法) 先进先出淘汰算法(FIFO算法) 最久未使用淘汰算法(LRU, Least Recent Used算法) 段式和段页式存储管理 段式地址结构 段式地址变换段式地址变换的步骤如下： 取出程序地址(s, w) 用s检索段表 如w&lt;0或w&gt;=L, 则主存越界 (b+w)即为所需主存地址 扩充段表功能 段页式存储管理功能]]></content>
      <categories>
        <category>science</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>operating system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统二——资源分配与调度]]></title>
    <url>%2F2015%2F09%2F16%2FoperatingSystem02%2F</url>
    <content type="text"><![CDATA[1. 资源管理概述1.1 资源管理的目的和任务 资源的静态分配和动态分配 资源的静态分配 系统对作业一级采用资源静态分配方法。 系统在调度作业时，根据作业所需资源进行分配；并在作业运行完毕时，收回所分配的全部资源。称为资源的静态分配。 资源的动态分配 系统对进程一级采用资源动态分配方法。 系统在进程运行中，根据进程提出的资源需求，进行资源的动态分配和回收。称为资源的动态分配。 资源管理的目的 目的：为用户提供一种简单而有效地使用资源的方法，充分发挥各资源的作用。 应达到的目标： 保证资源的高利用率 在”合理”时间内使所有顾客有获得所需资源的机会 对不可共享的资源实施互斥使用 防止由资源分配不当而引起死锁 资源管理的任务 任务：解决资源分配问题，防止死锁；解决对资源的存取、使用方法问题 资源管理的功能 资源数据结构的描述 确定资源的分配原则和调度原则 执行资源分配 存取控制和安全保护 1.2 资源的分类方法 物理资源和程序资源(处理器、外设等；消息或文件等) 单一访问入口资源(不可重入，只能为一个进程使用)和多访问入口资源(可以为多个进程共享使用) 等同资源(多个完全相同的设备) 虚拟资源(cpu、一定容量的主存、数量有限的外设)，如虚拟存储器 1.3 虚拟资源虚拟资源是用户使用的逻辑资源，是经过操作系统改造的、使用方便的虚拟资源，而不是那些物理的实际的资源，这样做的目的，一是要提高资源利用率，二是为了方便用户的使用 2. 资源管理的机制和策略机制：进行资源分配的必需的基本设施和部件，它包括描述资源状态的数据结构、保证资源互斥的同步机构及资源请求排队的手段。策略：这些机构所使用的方法，资源分配的原则 2.1 资源分配机制 资源描述器 什么是资源描述器描述各类资源的最小分配单位的数据结构称为资源描述器 RD (resource descriptor)。如： 主存最小分配单位：在分区分配中—主存分区 磁盘最小分配单位：磁盘面中的一个扇区 描述器的组织方式取决于资源分配单位的数量和这一数量是固定不变的、还是可以变化的这一特征。 资源描述器的内容 资源名 资源类型 最小分配单位的大小 最小分配单位的地址 分配标志 描述器链接信息 存取权限 密级 最后一次存取时间 记账信息 资源信息块 什么是资源信息块(rib)描述某类资源的请求者、可用资源和该类资源分配程序等必要信息的数据结构。 对于每一类可利用的资源，可将其组织成可利用资源队列。在资源信息块中有指向这两个队列的队列指针，另外还有一项为该类资源分配程序的入口地址 。 资源分配程序是接收分配命令把资源分配给请求者的例程。 资源分配程序包括：分配程序和回收程序。 资源信息块的内容 资源分配的方式取决于设计者所选择的目标，以及与应用每一类资源相联系的特定限制。目的是使吞吐率尽可能地高，响应时间尽可能地短，即既要充分地利用系统各种资源，又要尽可能地满足用户要求。 一个资源进行分配的问题，在一般情况下，是由这样两个方面组成的：管理请求的排队站（分配策略）与在等同资源间选择资源。 分配程序可以用不同的策略选择进程请求 按照请求来到的次序进行查看 将进程请求者的优先权结合到每一个请求中 满足能更合理地应用这一资源的那个请求 2.2 资源分配策略 1)先请求先服务(FIFO(First In First Out)) 排序原则：按请求的先后次序排序。 每一个新产生的请求均排在队尾，而当资源可用时，资源分配程序则从队列中选取第一个请求，并满足其需要。 这种策略可用于对进程或作业的调度，或外设、主存分配 2)优先调度 在优先调度策略下，对于每一个进程要指定一个优先级，优先级反映了进程要求处理的紧迫程度。 排序原则：按优先级的高低排序。 每一个新产生的请求，按其优先级的高低插到相应的位置上。而当资源可用时，选取队列中第一个请求，并满足其需要。 3)针对设备特性的调度对具有高速度、大容量的存储设备(如磁盘)而言，在繁重的输入输出负载下，会有大量的I/O请求在等待。操作系统应该采取有效的调度策略从众多的请求中按最佳的排序原则去选择。确定最佳排序的目标是降低为完成这些I/O请求服务的总时间，从而提高系统效率。 移臂调度所谓移臂调度是指在满足某一个磁盘请求时，总是选取与当前移动臂前进方向上最近的那个请求，使移臂距离最短。针对设备特性的调度是I/O调度。I/O调度程序是在磁盘硬件层实施的，磁盘硬件看到的是磁盘面、磁道、块号(对磁盘组为: 柱面号、盘面号、块号)。如下例所示，若磁盘组同时有5个访问请求，它们按请求的先后次序排序，要求访问的盘区位置如表1所示：如果当前移动臂处于1号柱面上，若按上述次序访问磁盘，移动臂将从1号柱面移动到6号柱面，再移至48号柱面，然后回到3号柱面。显然这样移臂很不合理。若按表2次序访问则可节省移动臂时间(注：当前移动臂方向是由外向里，即柱面号由小到大) 旋转调度所谓旋转调度是指在满足一个磁盘请求时，总是选取与当前读写头旋转方向上最近的那个请求，使旋转圈数最少。对于上述示例，使用表3排序则旋转次数更少： 4)几种移臂调度算法 最短寻道时间优先算法 扫描算法 柱面号 盘面号 块号 6 3 2 6 5 9 6 5 4 48 8 16 3 9 28 表1 柱面号 盘面号 块号 3 9 28 6 3 2 6 5 9 6 5 4 48 8 16 表2 柱面号 盘面号 块号 3 9 28 6 3 2 6 5 4 6 5 9 48 8 16 表3 3. 死锁3.1 死锁的定义与例子操作系统的基本特征是并发与共享。系统允许多个进程并发执行，并且共享系统的软、硬件资源。为了最大限度地利用计算机系统的资源，操作系统应用动态分配系统各资源的策略。然而，采用这种策略时，若分配不当，一旦出现对某类资源的申请数目超过了这类资源的入口数目时，就是造成进程相互封锁的危险。事实上，不同进程对资源的申请可能按某种先后次序得到部分满足，这就可能造成其中的两个或几个进程彼此间相互封锁的情况。即每个进程“抓住”一些为其它进程所等待的资源不放，其结果谁也得不到它所申请的全部资源，所有这些进程都无法继续运行。 例子： OS系统中的死锁例子 I/O设备共享时的死锁情况此图可描述I/O设备共享时的死锁情况。方框代表资源，圆圈表示进程；从资源到进程的箭头(有向边)，表示该资源分配给进程，过程资源分配边；而从进程到资源的箭头表示进程请求边。由图可见，进程P1、P2的资源分配边和资源请求边形成一个环路。 存储器共享时的死锁情况我们可以这样说，如系统中由一个包含有m个分配单位的存贮器，它为n个进程所共享，且每个进程都要求I个分配单位，当m&lt;=n(I-1)时，可能发生死锁。上图绘出了一个大大简化了的存贮器共享的情况，其中m=5,n=3,I=3。当P1、P2分别获得2个单元、P3获得1个单元时，内存被分配完毕。此时，系统进入一个不安全状态，因为在它们要求下一个所需要的单元资源时，便发生死锁(此时，它们都指望其它进程释放出内存空间，但谁都也不能再向前推进一步)。 死锁的定义： 若一个进程集合中的每一个进程都在等候只能由本集合中的另一进程才能引发的时事件则这种情况被视为死锁。 死锁是并发进程彼此互相等待对方拥有的资源，且这些并发进程在得到对方的资源之前不会释放自己所拥有得资源，这就造成了各并发进程想得到不可能得到的资源，从而不能继续向前推进进程的状态。 3.2 产生死锁的原因和必要条件 死锁产生的原因并发进程共享系统资源，在竞争资源时可能会产生称为死锁的附带后果。产生死锁的根本原因是系统能够提供的资源个数比要求该资源的进程数要少。所以，当系统中两个或多个进程没能力进一步执行时，系统就发生死锁。资源竞争现象是具有活力的、是需要的，虽然它存在着发生死锁的危险，但是，竞争并不等于死锁。在并发进程的活动中，存在着一种合理的联合推进路线，这种推进路线可使每个进程都运行完毕。但如果进程推进不合理则会出现死锁。由此可知，产生死锁的原因是： a. 系统资源不足 b. 进程推进顺序非法。 死锁发生的必要条件 a. 互斥条件，每一资源或者被分配给一个进程，或者空闲。 b. 部分分配条件，已分配到了一些资源的进程可以申请新的资源。 c. 非剥夺条件，已分配给一进程的资源不可剥夺，只能被占有它的进程显式地释放。 d. 循环等待条件，存在一种进程的循环链，链中的每一个进程以获得的资源同时被链中下一个进程所请求。 3.3 死锁模型资源分配图的成分：用资源分配图分析死锁例：用资源分配图分析无死锁例： 3.4 解决死锁的策略并发进程共享系统资源时如处理不当可能发生死锁。死锁不仅会在两个进程之间发生，也可能在多个进程之间、甚至在系统全部进程之间发生。此外，死锁不仅在动态使用外设时发生，也可能在动态使用存贮器和数据库时发生，或在进程通信过程中以及在利用信号灯作同步工具时由于p操作顺序不当而产生。在早期的操作系统中，系统规模较小，结构简单，而且资源的分配常常采用静态方法，使得操作系统尚未暴露死锁问题的严重性。但是，随着系统规模的增大，软件系统变得异常庞大而复杂，系统资源的种类亦日益增多，因而，死锁的可能性将大大增加。由于死锁的发生会给系统带来严重的后果，因此，处理系统死锁问题引起了人们的普遍注意，并对它进行了深入的研究。但某些类别的死锁问题的发生概率极小，这时大多数用户宁可承受在极偶然情况下发生的死锁，也不愿使其工作不便或系统性能受损–因解决这类死锁要花费很大的代价。所以，在设计上，我们不得不在方便性与正确性之间作出折衷，即象驼鸟一样对此类死锁视而不见,这就是驼鸟算法。 为了使系统不发生死锁，必须设法破坏产生死锁的四个必要条件之一。可以采用下列策略之一来解决死锁问题： 1)采用静态分配方法来预防死锁 2)采用有控分配方法来避免死锁 3)当死锁发生时检测出死锁，并设法修复 3.5 死锁的预防基本思想：静态防止发生死锁的方法。预先分配所有共享资源是预防死锁的一种安全而由简单的方法。这种方法的基本思想是：每个用户向系统提交作业时，需一次说明它所需要的资源；并且作业调度程序只能在满足该作业所需的全部资源的前提下才能将它投入运行。当资源一旦分配给该作业后，在其整个运行期间这些资源为它独占。这样就摒弃”部分分配”了条件,摒弃”不剥夺”了条件 ,摒弃”环路等待”了条件 。死锁预防的缺点： a.一个用户在作业运行之前可能提不出他的作业时间、将要使用的全部设备。 b.用户作业必须等待，直到所有资源满足时才能投入运行。 c.一个作业运行期间，对某些设备的使用时间很少，甚至不会用到。故这种分配技术对系统来说是浪费的。 3.6 死锁的避免基本思想：动态防止发生死锁的方法预防死锁和避免死锁的不同在于，前者所采用的分配策略本身就否定了必要条件之一，这样来保证死锁不可能发生；而后者是在动态分配资源的策略下采用某种算法来预防可能发生的死锁，从而拒绝可能引起死锁的某个资源请求。 有序资源分配法系统若采用有序资源分配法，则需要为系统中的每一类资源分配唯一的号码，且系统要求每个进程： 对它所必须使用的而且属于某一类的所有资源，必须一次性申请完 在申请不同类的资源时，必须按照各类的编号依次申请。优缺点： 缺点：进程实际需要资源的顺序不一定与资源的编号相一致，因而仍然会造成资源的浪费。 优点：对资源进行合理的排序，这种方法是有一定实用价值的。 银行家算法：存在一种算法总能作出正确的选择从而避免死锁单种资源的银行家算法(Dijkstra,1965) 问题描叙：一个领域的银行家，他向一群客户分别承若了一定的货款额度，具体而言，假设有4个客户，每个客户都有一个货款额度，银行家知道不可能所有客户同时都需要最大贷款额，所以他只能保留10个单位的资金来为客户服务，而不是22个单位。这里的背景是，将客户比作进程，货款比作设备，银行家比作OS。 问题图示 算法：对每一个请求进行检查，检查如果满足它是否会导致不安全状态，若是，则不满足该请求；否则便满足。检查状态是否安全的方法是看他是否有足够的资源满足一个跟最大需求最近的客户，如果可以，则这笔投资认为是能够收回的，然后接着检查下一个跟最大需求最接近的客户，如此反复下去。如果所有投资最终都被收回，则该状态是安全的，最初的请求可以批准。 3.7 死锁的检测与忽略 检测死锁并恢复 a.基本思想：检测系统是否发生死锁,检测出死锁之后,寻找排除死锁的方法，使系统恢复正常的工作状态。本策略的指导原则是允许死锁产生，且当死锁发生时能检测出死锁，并有能力实现恢复。本策略的价值取决于死锁发生的频率和能够修复的程度。发现死锁的原理是考查某一时刻系统状态是否合理，即是否存在一组可以实现的系统状态，能使所有进程都得到它们所申请的资源而运行结束。 b.检测死锁算法的基本思想：得到某时刻t时，系统中各类可利用资源得数目向量w(t)对于系统中的一组进程｛P1,P2,…Pi,…,Pn｝,找出那些对各类资源请求数目均小于系统现在所拥有的各类资源数目的进程。并认为这样的进程可以获得它们所需要的全部资源 并运行结束。当它们运行结束后释放所占有的全部资源，从而使可用资源数目增加，这样的进程加入到可运行结束的进程序列之中，然后对剩下的进程再作上述考查，如果一组进程｛P1,P2,…,Pn｝中有几个进程不属于序列L中，则它们会被死锁。 c.排除死锁的实用办法 ： 将那些陷于死锁的全部进程一律撤消。 逐个作废死锁进程，直至不再存在死锁为止。 从死锁进程中逐个地强迫强占一些资源,直至死锁不再存在。 死锁的忽略如果系统可能发生死锁，且不提供进行死锁的预防的方法、死锁的检测与恢复的机制，那么可能会出现这种情况：系统已经出现死锁，而又不知道发生了什么。这种情况下，死锁的发生会导致系统性能的下降，因为资源被不能运行的进程锁占有，而越来越多的进程会因为申请资源而进入死锁状态。最后整个系统停止工作需要人工重新启动。由于检测死锁的算法太复杂，系统开销大，所以使用很少。实际中对死锁的检测常常由计算机操作员来处理。而不是由系统本身来完成。通常修复方法是人工抽去一些作业，释放它们占的资源，再重新启动系统。]]></content>
      <categories>
        <category>science</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>operating system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 琐记二]]></title>
    <url>%2F2015%2F09%2F14%2Fwindows02%2F</url>
    <content type="text"><![CDATA[1. 修复U盘以前用U盘制作Linux启动盘时，制作之后windows下都无法读取了，必须格式化，而格式化之后的U盘容量骤减为几M……磁盘管理里查看直接显示为黑色区域，估计是某些分区读不出来，搜了下解决方法：先输入命令diskpart，之后： 即123456diskpartlist diskselect disk 2cleancreate partition primaryexit 2. U盘制作系统盘用u盘制作系统启动盘时，以前常用Win32DiskImager，有一次失败了，用Linux的dd命令也失败了，使用了下面的方法成功：123456789diskpartlist diskselect disk #cleancreate partition primaryselect partition 1activeformat fs=fat32 quick #这里我经常使用ntfs文件格式，也可以exit 之后将iso镜像解压至u盘即可]]></content>
      <categories>
        <category>techonology</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>udisk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音乐信号灯电子电路设计]]></title>
    <url>%2F2015%2F09%2F12%2FelectronicDesign01%2F</url>
    <content type="text"><![CDATA[注意事项： 想使multisim的四路示波器波形相对静止下查看，如果是正弦波可以在示波器上选中波形类型为正弦波，否则可以直接点击暂停仿真使停止 仿真过程极慢，现实1s在multisim中竟然走了3、4s，改multisim步长有时可以解决问题，但若是仿真电路本身的确复杂，则只能靠等待了，毕竟仿真是需要计算时间的 Mesurement Probe的确好用，但是有时运行一段时间后，会导致Transient time point calculation did not converge这个错误，出现这个问题的另一个原因可能是示波器未接地。 一、设计目的针对电子线路课程要求，对学生进行实用型电子线路设计、安装、调试等各环节综合性训练，培养学生运用课程中所学的理论与实践紧密结合，独立的解决实际问题的能力。电路设计工具MULTISIM的学习与应用，应用计算机的能力，用简洁的文字,清晰的图表来表达自己设计思想的能力。 二、设计内容和要求 1、音乐信号分为三个频段，分别控制红、绿、蓝三种颜色的彩灯；三段信号的频率为： 低频段：25Hz—200Hz 中频段：500Hz —1200Hz 高频段：2000Hz—3000Hz 2、当输入信号大于10mV时，彩灯的亮度分为6个等级；当输入信号小于10mV时彩灯全亮。 三、设计任务分析灯泡亮度通过双向可控硅电路控制，图3-1为控制波形图。如果输入交流220V正弦波电压过零点时在双向可控硅的控制极和阴极之间连续加入幅度大于3V，宽度大于1ms的同步触发脉冲，可控硅就可连续导通，忽略可控硅导通压降，正弦波电压将全部加到灯泡上，灯泡最亮。如果触发脉冲消失，可控硅就会在输入正弦波电压下一个过零点时自然截止，灯泡熄灭。可以设想，把同步触发脉冲每六个分为一组，利用音乐信号的大小控制每组脉冲出现的个数，就可以控制加在灯泡正弦波半波的个数，从而也就控制了灯泡的亮度。 图3-1 把音乐信号分成三个频率段可用带通滤波器去实现。组成带通滤波器电路的形式很多，其中最简单的并且上、下限截止频率分别可调的是由低、高通滤波电路串联而成的带通滤波器。这种电路的缺点是所用元件较多，优点是调整方便，很容易实现指标要求。通过带通滤波器选出所需要的频率段的音乐信号，经过精密整流器变为直流，其直流电平随音乐信号大小而上下浮动。此电平作为参考电压加在电压比较器的一个输入端，由同步触发脉冲作为计数信号的数模转换器，输出阶梯波作为比较电压加在电压比较器的另一个输入端，使电压比较器的输出电压高电平的时间与参考电压成正比，并控制与门打开时间，以决定放过同步脉冲的个数去触发可控硅，从而控制灯泡的亮度。 四、系统设计方案 图4-1 五、单元电路分析与设计1、整流电路通过变压器得到的±10V交流电压经过整流应该得到±12V的电压，再通过W7805稳压电路得到5V的电压，通过整流电路的输出电压给整个电路中用到的芯片供电。电路原理图如图5-1所示： 图5-1 2、同步脉冲发生器 图5-2 开始利用555定时器设计了一个多谐振荡器的电路如图5-2，生成300Hz的方波作为同步脉冲的发生器，实际搭建电路时，老师指导我们555作为数字电子器件精度达不到要求，要求用模拟电路搭成同步脉冲发生器，于是重新构建电路如图5-3所示： 图5-3 3、阶梯波产生电路 图5-4 图5-5 其中由于是清零时方式设置的计时循环，所以在输出位置加C_16这个电容，以除去产生的尖峰。 4、低通和带通滤波器由于最低频段的要求为25Hz至200Hz，为了方便，直接用低通电路设计，其他两路用带通电路。并且输入电压值较小，滤波后电压值也小，于是后面都需要加一个放大电路，通过滤波电路和放大电路最终将原始电压都放大了100倍。滤波和放大电路的设计图见图5-6。 图5-6 电路中电阻电容的参数计算的公式结合电路图讲解： 1) 低通电路参数计算图5-7 2) 带通电路参数计算图5-8 中频段中心频率为850Hz，频宽BW=700Hz，取适当增益(这里我们取2)，可计算得到适当参数，高频段中心频率2500Hz，频宽BW=1000Hz，取适当增益(这里我们取2)，可计算得到适当参数。 5、精密整流器和电压比较器滤波放大之后的电压还是交流电，为了和之后的阶梯波相比较，必须先整流成直流电压，然后再和阶梯波比较生成PWM波，设计电路如下： 图5-9 其中运放的反向端即是阶梯波的输出，整流后的电压通过与其比较生成PWM波，整流后的电压若在0-1V之间，则占空比为1/6，在1V-2V间，占空比为2/6，在2V-3V间，占空比为3/6，在3V-4V间，占空比为4/6，在4V-5V间，占空比为5/6，大于5V时，占空比为6/6，以上说明均以高电平所占周期比例作为占空比。 6、10mV音乐信号鉴别器电路如图5-10示： 图5-10 通过放大电路放大输入的电压值，再通过半波整流电路得到直流电压，此直流电压和输入交流电压的幅值成正比，将其作为比较器的反相输入，比较器的正相输入为二极管D16的压降值。通过仔细调节R32/R31的比值，可以达到当输入电压幅值小于10mV时U16输出高电平，大于10mV时输出低电平的效果。最后将三路电压比较器的输出分别与此输出相或，得到输出的结果即是我们想要的结果，低于10mV时全是高电平，即占空比100%，否则为其他5种不同的状态。由于要控制彩灯，而彩灯是要通过晶闸管触发的，通过触发脉冲数不同，可以得到不同亮度。 六、系统仿真电路系统整体仿真电路图6-1，其中为了方便脉冲触发就用以前的555作为脉冲的产生电路： 图6-1 七、仿真结果显示输出电压参数为150Hz、20mV仿真，输出的PWM波和最终的脉冲触发电路分别如图7-1和图7-2所示： 图7-1 图7-2 八、实际电路结果实际搭建的硬件电路，最终示波器测量阶梯波、同步脉冲波以及最终的触发波如下图所示： 图8-1 图8-2]]></content>
      <categories>
        <category>techonology</category>
        <category>ee</category>
      </categories>
      <tags>
        <tag>electronic</tag>
        <tag>multisim</tag>
        <tag>EDA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公共DNS]]></title>
    <url>%2F2015%2F09%2F08%2FpublicDNS%2F</url>
    <content type="text"><![CDATA[各大公司提供的公共DNSGoogle8.8.8.8 Alibaba223.5.5.5 223.6.6.6 Baidu180.76.76.76 Tecent(DNSPod)119.29.29.29 114DNS114.114.114.114 114.114.115.115]]></content>
      <categories>
        <category>techonology</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[simhash与重复信息识别]]></title>
    <url>%2F2015%2F09%2F02%2Fsimhash%2F</url>
    <content type="text"><![CDATA[Simhash, Minhash参考这些文章http://grunt1223.iteye.com/blog/964564http://blog.csdn.net/heiyeshuwu/article/details/44117473]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>simhash</tag>
        <tag>minhash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习五]]></title>
    <url>%2F2015%2F08%2F29%2FmachineLearning05%2F</url>
    <content type="text"><![CDATA[1. 支持向量机(Support Vector Machines)SVM有很多实现，最流行的一种实现是序列最小优化(Sequential Minimal Optimization)算法可以使用核函数(kernel)的方式将SVM扩展到更多数据集上SVM的优缺点: 优点：泛化错误率低，计算开销不大，结果易解释 缺点：对参数调节和核函数的选择敏感，原始分类器不加修改仅适用于处理二类问题 2. 基于最大间隔分隔数据可以用一条线将两类数据点分开，则这组数据线性可分，否则线性不可分线性可分数据集中的分隔界限称为分隔超平面(separating hyperplane)，也就是分类的决策边界，分布在超平面一侧的数据都属于某个类别，而另一侧的数据属于另一类别我们希望找到离分隔超平面最近的点，确保它们离分隔面的距离尽可能的远，这里，点到分隔面的距离称之为间隔(margin)支持向量(support vector)就是离分隔超平面最近的那些点 3. 寻找最大间隔分割超平面的形式可以写成\(w^Tx+b\)，要计算A点到分割超平面的距离，必须给出点到分隔面的法线长度，该值为\(|w^TA+b|/||w||\) 3.1 分类器求解的优化问题输入数据给分类器会输出一个类别标签，使用类似Heaviside的函数，u&lt;0时，f(u)输出-1，u&gt;0为+1，即类别标签是-1和+1当计算数据点到分隔面的距离并确定分隔面的放置位置时，间隔通过label \(w^Tx+b\)计算。现在的目标是找出分类器定义的w和b，为此需要找到具有最小间隔的数据点，而这些数据点就是前面提到的支持向量，一旦找到具有最小间隔的数据点，我们就需要对该间隔最大化，这可以写作：\(\arg \max\limits_{w,b} \{ \min\limits_{n} (label\cdot (w^Tx+b)) \cdot \frac{1}{||w||}\}\)直接求解上式太难，需要转换形式。在上述优化问题中，给定了一些约束条件求最优值，约束条件就是label \(w^Tx+b\)，因此该问题是一个带约束条件的优化问题，可以考虑拉格朗日乘子法。引入拉格朗日乘子，就可以基于约束条件来表示原问题，由于此处约束条件都是基于数据点的，可以将超平面写成数据点的形式：$$ \max\limits_a \left[ \sum_{i=1}^m a-\frac{1}{2}\sum_{i,j=1}^m label^{(i)}\cdot label^{(i)}\cdot \alpha_{i} \cdot \alpha_{j}\langle x^{(i)},x^{(j)}\rangle\right]$$其约束条件为：\(\alpha \geq 0\)和\(\sum_{i=1}^m \alpha_i \cdot label^{(i)}=0\)以上基于假设：数据必须100%线性可分，但实际并不是，这时引入”松弛变量(slack variable)”，来允许有些数据点可以处于分隔面的错误一侧，这样我们的优化目标就能保持不变，但是此时新约束规则为：\(C\geq \alpha \geq 0,\)和\(\sum_{i=1}^m \alpha_i \cdot label^{(i)}=0\)这里常数C用于控制”最大化间隔”和”保证大部分点的函数间隔小于1.0”这两个目标的权重，在优化算法的实现代码中将C作为一个参数，则可以通过调节这个参数得到不同的结果，一旦求出了所有的alpha，就可以用这些alpha里表示分隔超平面，SVM的主要工作就是求这些alpha 3.2 SVM应用的一般框架 收集数据：可以使用任何方法 准备数据：需要数值型数据 分析数据：有助于可视化分隔超平面 训练算法：SVM的大部分时间都源自训练，该过程主要实现两个参数的调优 测试算法：十分简单的计算过程就可以实现 使用算法：几乎所有的分类问题都可以使用SVM，值得一提的是，SVM本身是一个二类分类器，对多累问题应用SVM需要地代码做些修改 4. SMO高效优化算法我们对上述最后的式子进行优化，其中一个是最小化的目标函数，一个是在优化过程中必须遵循的约束条件。以前，人们还在使用二次规划求解工具(quadratic solver)来求解上述优化问题，这种工具是一种用于在线性约束下优化具有多个变量的二次目标函数的软件。而这些二次规划求解工具则需要强大的计算能力的支撑，另外在实现上也十分复杂。所有需要做的围绕优化的事情就是训练分类器，一旦得到alpha最优值，我们就得到了分隔超平面并能够将其用于数据分类 4.1 Platt的SMO算法SMO表示序列最小优化(Sequential Minimal Optimization)。Platt的SMO算法将大优化问题分解为多个小优化问题，这些小优化问题往往很容易求解，并且将它们进行顺序求解的结果与作为整体求解的结果是一致的，在结果完全相同的同时，SMO算法的求解问题短很多SMO算法的目标是求出一系列alpha和b，一旦求出了这些alpha，就很容易计算出权重向量w并得到分隔超平面SMO算法的工作原理是：每次循环中选择两个alpha进行优化处理，一旦找到一对合适的alpha，那么久增大其中一个同时减小另外一个，这里所谓的”合适”就是指两个alpha必须要符合一定的条件，条件之一就是这两个alpha必须在间隔边界之外，而第二则是这两个alpha还没有进行过区间化处理或者不在边界上 4.2 应用简化版SMO算法处理小规模数据集Platt SMO算法的完整实现需要大量代码，于是从简化到完整逐渐递增Platt SMO算法中的外循环确定要优化的最佳alpha对，而简化版却会跳过这一部分，首先在数据集上遍历每一个alpha，然后在剩下的alpha集合中随机选择另一个alpha，从而构建alpha对。这里有一点很重要，就是我们要同时改变两个alpha，之所以这样做是因为我们有一个约束条件：\(\sum \alpha_i \cdot label^{(i)}=0\)由于改变一个alpha可能导致该约束条件失效，因此我们总是同时改变两个alpha为此将构建一个辅助函数，用于在某个区间范围内随机选择一个整数。同时，我们也需要另一个辅助函数，用于在数值太大时对其进行调整，实现代码：辅助函数：123456789101112131415161718192021def loadDataSet(fileName): dataMat = []; labelMat = [] fr = open(fileName) for line in fr.readlines(): lineArr = line.strip().split('\t') dataMat.append([float(lineArr[0]), float(lineArr[1])]) labelMat.append(float(lineArr[2])) return dataMat,labelMatdef selectJrand(i,m): j=i #we want to select any J not equal to i while (j==i): j = int(random.uniform(0,m)) return jdef clipAlpha(aj,H,L): if aj &gt; H: aj = H if L &gt; aj: aj = L return aj 简化的SMO函数伪代码：12345678创建一个alpha向量并将其初始化为0向量当迭代次数小于最大迭代次数时(外循环) 对数据集中的每个数据向量(内循环): 如果该数据向量可以被优化: 随机选择另外一个数据向量 同时优化这两个向量 如果两个向量都不能被优化,退出内循环 如果所有向量都没被优化,增加迭代数目,继续下一次循环 简化版SMO算法：12345678910111213141516171819202122232425262728293031323334353637383940def smoSimple(dataMatIn, classLabels, C, toler, maxIter): dataMatrix = mat(dataMatIn); labelMat = mat(classLabels).transpose() b = 0; m,n = shape(dataMatrix) alphas = mat(zeros((m,1))) iter = 0 while (iter &lt; maxIter): alphaPairsChanged = 0 for i in range(m): fXi = float(multiply(alphas,labelMat).T*(dataMatrix*dataMatrix[i,:].T)) + b Ei = fXi - float(labelMat[i])#if checks if an example violates KKT conditions if ((labelMat[i]*Ei &lt; -toler) and (alphas[i] &lt; C)) or ((labelMat[i]*Ei &gt; toler) and (alphas[i] &gt; 0)): j = selectJrand(i,m) fXj = float(multiply(alphas,labelMat).T*(dataMatrix*dataMatrix[j,:].T)) + b Ej = fXj - float(labelMat[j]) alphaIold = alphas[i].copy(); alphaJold = alphas[j].copy(); if (labelMat[i] != labelMat[j]): L = max(0, alphas[j] - alphas[i]) H = min(C, C + alphas[j] - alphas[i]) else: L = max(0, alphas[j] + alphas[i] - C) H = min(C, alphas[j] + alphas[i]) if L==H: print "L==H"; continue eta = 2.0 * dataMatrix[i,:]*dataMatrix[j,:].T - dataMatrix[i,:]*dataMatrix[i,:].T - dataMatrix[j,:]*dataMatrix[j,:].T if eta &gt;= 0: print "eta&gt;=0"; continue alphas[j] -= labelMat[j]*(Ei - Ej)/eta alphas[j] = clipAlpha(alphas[j],H,L) if (abs(alphas[j] - alphaJold) &lt; 0.00001): print "j not moving enough"; continue alphas[i] += labelMat[j]*labelMat[i]*(alphaJold - alphas[j])#update i by the same amount as j #the update is in the oppostie direction b1 = b - Ei- labelMat[i]*(alphas[i]-alphaIold)*dataMatrix[i,:]*dataMatrix[i,:].T - labelMat[j]*(alphas[j]-alphaJold)*dataMatrix[i,:]*dataMatrix[j,:].T b2 = b - Ej- labelMat[i]*(alphas[i]-alphaIold)*dataMatrix[i,:]*dataMatrix[j,:].T - labelMat[j]*(alphas[j]-alphaJold)*dataMatrix[j,:]*dataMatrix[j,:].T if (0 &lt; alphas[i]) and (C &gt; alphas[i]): b = b1 elif (0 &lt; alphas[j]) and (C &gt; alphas[j]): b = b2 else: b = (b1 + b2)/2.0 alphaPairsChanged += 1 print "iter: %d i:%d, pairs changed %d" % (iter,i,alphaPairsChanged) if (alphaPairsChanged == 0): iter += 1 else: iter = 0 print "iteration number: %d" % iter return b,alphas 4.3 利用完整Platt SMO算法加速优化完整版Platt SMO的支持函数：123456789101112131415161718192021222324252627282930313233343536class optStruct: def __init__(self,dataMatIn, classLabels, C, toler): # Initialize the structure with the parameters self.X = dataMatIn self.labelMat = classLabels self.C = C self.tol = toler self.m = shape(dataMatIn)[0] self.alphas = mat(zeros((self.m,1))) self.b = 0 self.eCache = mat(zeros((self.m,2))) #first column is valid flagdef calcEk(oS, k): fXk = float(multiply(oS.alphas,oS.labelMat).T*(oS.X*oS.X[k,:].T)) + oS.b Ek = fXk - float(oS.labelMat[k]) return Ek def selectJ(i, oS, Ei): #this is the second choice -heurstic, and calcs Ej maxK = -1; maxDeltaE = 0; Ej = 0 oS.eCache[i] = [1,Ei] #set valid #choose the alpha that gives the maximum delta E validEcacheList = nonzero(oS.eCache[:,0].A)[0] if (len(validEcacheList)) &gt; 1: for k in validEcacheList: #loop through valid Ecache values and find the one that maximizes delta E if k == i: continue #don't calc for i, waste of time Ek = calcEk(oS, k) deltaE = abs(Ei - Ek) if (deltaE &gt; maxDeltaE): maxK = k; maxDeltaE = deltaE; Ej = Ek return maxK, Ej else: #in this case (first time around) we don't have any valid eCache values j = selectJrand(i, oS.m) Ej = calcEk(oS, j) return j, Ejdef updateEk(oS, k):#after any alpha has changed update the new value in the cache Ek = calcEk(oS, k) oS.eCache[k] = [1,Ek] 完整Platt SMO算法中的优化例程1234567891011121314151617181920212223242526272829303132333435def innerL(i, oS): Ei = calcEk(oS, i) if ((oS.labelMat[i]*Ei &lt; -oS.tol) and (oS.alphas[i] &lt; oS.C)) or\ ((oS.labelMat[i]*Ei &gt; oS.tol) and (oS.alphas[i] &gt; 0)): j,Ej = selectJ(i, oS, Ei) alphaIold = oS.alphas[i].copy(); alphaJold = oS.alphas[j].copy(); if (oS.labelMat[i] != oS.labelMat[j]): L = max(0, oS.alphas[j] - oS.alphas[i]) H = min(oS.C, oS.C + oS.alphas[j] - oS.alphas[i]) else: L = max(0, oS.alphas[j] + oS.alphas[i] - oS.C) H = min(oS.C, oS.alphas[j] + oS.alphas[i]) if L==H: print "L==H"; return 0 eta = 2.0 * oS.X[i,:]*oS.X[j,:].T - oS.X[i,:]*oS.X[i,:].T - \ oS.X[j,:]*oS.X[j,:].T if eta &gt;= 0: print "eta&gt;=0"; return 0 oS.alphas[j] -= oS.labelMat[j]*(Ei - Ej)/eta oS.alphas[j] = clipAlpha(oS.alphas[j],H,L) updateEk(oS, j) if (abs(oS.alphas[j] - alphaJold) &lt; 0.00001): print "j not moving enough"; return 0 oS.alphas[i] += oS.labelMat[j]*oS.labelMat[i]*\ (alphaJold - oS.alphas[j]) updateEk(oS, i) b1 = oS.b - Ei- oS.labelMat[i]*(oS.alphas[i]-alphaIold)*\ oS.X[i,:]*oS.X[i,:].T - oS.labelMat[j]*\ (oS.alphas[j]-alphaJold)*oS.X[i,:]*oS.X[j,:].T b2 = oS.b - Ej- oS.labelMat[i]*(oS.alphas[i]-alphaIold)*\ oS.X[i,:]*oS.X[j,:].T - oS.labelMat[j]*\ (oS.alphas[j]-alphaJold)*oS.X[j,:]*oS.X[j,:].T if (0 &lt; oS.alphas[i]) and (oS.C &gt; oS.alphas[i]): oS.b = b1 elif (0 &lt; oS.alphas[j]) and (oS.C &gt; oS.alphas[j]): oS.b = b2 else: oS.b = (b1 + b2)/2.0 return 1 else: return 0 完整版Platt SMO的外循环代码：123456789101112131415161718192021def smoP(dataMatIn, classLabels, C, toler, maxIter,kTup=('lin', 0)): #full Platt SMO oS = optStruct(mat(dataMatIn),mat(classLabels).transpose(),C,toler, kTup) iter = 0 entireSet = True; alphaPairsChanged = 0 while (iter &lt; maxIter) and ((alphaPairsChanged &gt; 0) or (entireSet)): alphaPairsChanged = 0 if entireSet: #go over all for i in range(oS.m): alphaPairsChanged += innerL(i,oS) print "fullSet, iter: %d i:%d, pairs changed %d" % (iter,i,alphaPairsChanged) iter += 1 else:#go over non-bound (railed) alphas nonBoundIs = nonzero((oS.alphas.A &gt; 0) * (oS.alphas.A &lt; C))[0] for i in nonBoundIs: alphaPairsChanged += innerL(i,oS) print "non-bound, iter: %d i:%d, pairs changed %d" % (iter,i,alphaPairsChanged) iter += 1 if entireSet: entireSet = False #toggle entire set loop elif (alphaPairsChanged == 0): entireSet = True print "iteration number: %d" % iter return oS.b,oS.alphas 5. 在复杂数据上应用核函数核函数(kernel)将数据转换成易于分类器理解的形式 5.1 利用核函数将数据映射到高维空间Figure 6-6中，数据点位于一个圆中，人类能够意识到这点，但对于分类器而言，他只能识别分类器的结果是大于0还是小于0，如果只在x、y轴构成的坐标系中插入直线进行分类的话，我们得不到理想结果。或许可以对圆中的数据进行某种形式的转换，从而得到新变量来表示数据。在此例中，我们将数据从一个特征空间转换到另一个特征空间，在新空间下我们很容易利用已有的工具对数据进行处理，数学家们喜欢将这个过程称为从一个特征空间到另一个特征空间的映射。通常情况下，这种映射会将低维特征空间映射到高维特征空间。这种从某个特征空间到另一个特征空间的映射是通过核函数来实现的，读者可以把核函数想象成一个包装器(wrapper)或接口(interface)，它能把数据从一个很难处理的形式转换成另一个较容易处理的形式。换种简单但不确切的方式来理解，可以把它想象成另一种距离计算的方法，距离计算的方法有很多种，核函数一样具有多种类型。经过空间转换后，我们可以在高维空间中解决线性问题，也就等价于在低维空间中解决非线性问题。SVM优化中的一个有点就是所有运算都可以写成内积(inner product)的形式，我们可以把内积运算转换为核函数，而不必简化处理。将内积替换为核函数的方式称为核技巧(kernel substation) 5.2 径向基核函数(radial basis function)核函数不仅应用于SVM，还有其他很多机器学习算法也需要用到，下面来介绍一个流行的核函数：径向基核函数径向基函数是一个采用向量作为自变量的函数，能够基于向量距离运算输出一个标量。这个距离可以是从&lt;0,0&gt;向量或其他向量开始计算的距离。径向基函数的高斯版本公式为：\(k(x,y)=\exp\left(\frac{-||x-y||^2}{2\sigma^2}\right)\)\(\sigma\)是用户定义的用于确定到达率(reach)或者说函数值跌落到0的速度参数上述高斯核函数将数据从特征空间映射到更高维空间，具体说是映射到一个无穷维空间，使用高斯核函数会得到一个理想的结果。对于Figure 6-6中例子，可以发现直接度量数据点到原点距离即可，然而碰到一个非此类的数据集，我们便会陷入困境。在该数据集中，使用高斯核函数可以得到很好的结果，当然，该函数也可以用于许多其他的数据集，并得到较低的错误率。添加函数kernelTrans()，对optStruct类进行修改：1234567891011121314151617181920212223242526def kernelTrans(X, A, kTup): #calc the kernel or transform data to a higher dimensional space m,n = shape(X) K = mat(zeros((m,1))) if kTup[0]=='lin': K = X * A.T #linear kernel elif kTup[0]=='rbf': for j in range(m): deltaRow = X[j,:] - A K[j] = deltaRow*deltaRow.T K = exp(K/(-1*kTup[1]**2)) #divide in NumPy is element-wise not matrix like Matlab else: raise NameError('Houston We Have a Problem -- \ That Kernel is not recognized') return Kclass optStruct: def __init__(self,dataMatIn, classLabels, C, toler, kTup): # Initialize the structure with the parameters self.X = dataMatIn self.labelMat = classLabels self.C = C self.tol = toler self.m = shape(dataMatIn)[0] self.alphas = mat(zeros((self.m,1))) self.b = 0 self.eCache = mat(zeros((self.m,2))) #first column is valid flag self.K = mat(zeros((self.m,self.m))) for i in range(self.m): self.K[:,i] = kernelTrans(self.X, self.X[i,:], kTup) 在线性核函数的情况下，内积计算在”所有数据集”和”数据集中的一行”这两个输入之间展开。在径向基核函数情况下，在for循环里对矩阵的每个元素计算高斯核函数的值，而在for循环结束后，我们将计算过程应用到整个向量中去。为了使用该函数，前述innerL()和calcEk()需要做些修改，修改之后：123456789101112131415161718192021222324252627282930313233def innerL(i, oS): Ei = calcEk(oS, i) if ((oS.labelMat[i]*Ei &lt; -oS.tol) and (oS.alphas[i] &lt; oS.C)) or ((oS.labelMat[i]*Ei &gt; oS.tol) and (oS.alphas[i] &gt; 0)): j,Ej = selectJ(i, oS, Ei) #this has been changed from selectJrand alphaIold = oS.alphas[i].copy(); alphaJold = oS.alphas[j].copy(); if (oS.labelMat[i] != oS.labelMat[j]): L = max(0, oS.alphas[j] - oS.alphas[i]) H = min(oS.C, oS.C + oS.alphas[j] - oS.alphas[i]) else: L = max(0, oS.alphas[j] + oS.alphas[i] - oS.C) H = min(oS.C, oS.alphas[j] + oS.alphas[i]) if L==H: print "L==H"; return 0 eta = 2.0 * oS.K[i,j] - oS.K[i,i] - oS.K[j,j] #changed for kernel if eta &gt;= 0: print "eta&gt;=0"; return 0 oS.alphas[j] -= oS.labelMat[j]*(Ei - Ej)/eta oS.alphas[j] = clipAlpha(oS.alphas[j],H,L) updateEk(oS, j) #added this for the Ecache if (abs(oS.alphas[j] - alphaJold) &lt; 0.00001): print "j not moving enough"; return 0 oS.alphas[i] += oS.labelMat[j]*oS.labelMat[i]*(alphaJold - oS.alphas[j])#update i by the same amount as j updateEk(oS, i) #added this for the Ecache #the update is in the oppostie direction b1 = oS.b - Ei- oS.labelMat[i]*(oS.alphas[i]-alphaIold)*oS.K[i,i] - oS.labelMat[j]*(oS.alphas[j]-alphaJold)*oS.K[i,j] b2 = oS.b - Ej- oS.labelMat[i]*(oS.alphas[i]-alphaIold)*oS.K[i,j]- oS.labelMat[j]*(oS.alphas[j]-alphaJold)*oS.K[j,j] if (0 &lt; oS.alphas[i]) and (oS.C &gt; oS.alphas[i]): oS.b = b1 elif (0 &lt; oS.alphas[j]) and (oS.C &gt; oS.alphas[j]): oS.b = b2 else: oS.b = (b1 + b2)/2.0 return 1 else: return 0def calcEk(oS, k): fXk = float(multiply(oS.alphas,oS.labelMat).T*oS.K[:,k] + oS.b) Ek = fXk - float(oS.labelMat[k]) return Ek 5.3 在测试中使用核函数接下来我们构造一个对Figure 6-6中数据点进行有效分类的分类器，该分类器使用了径向基核函数。前面提到的径向基函数有一个用户定义的输入\(\sigma\)，首先得确定它的大小，然后利用核函数构建分类器，整个函数如下：123456789101112131415161718192021222324def testRbf(k1=1.3): dataArr,labelArr = loadDataSet('testSetRBF.txt') b,alphas = smoP(dataArr, labelArr, 200, 0.0001, 10000, ('rbf', k1)) datMat=mat(dataArr); labelMat = mat(labelArr).transpose() svInd=nonzero(alphas.A&gt;0)[0] sVs=datMat[svInd] labelSV = labelMat[svInd]; print "there are %d Support Vectors" % shape(sVs)[0] m,n = shape(datMat) errorCount = 0 for i in range(m): kernelEval = kernelTrans(sVs,datMat[i,:],('rbf', k1)) predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b if sign(predict)!=sign(labelArr[i]): errorCount += 1 print "the training error rate is: %f" % (float(errorCount)/m) dataArr,labelArr = loadDataSet('testSetRBF2.txt') errorCount = 0 datMat=mat(dataArr); labelMat = mat(labelArr).transpose() m,n = shape(datMat) for i in range(m): kernelEval = kernelTrans(sVs,datMat[i,:],('rbf', k1)) predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b if sign(predict)!=sign(labelArr[i]): errorCount += 1 print "the test error rate is: %f" % (float(errorCount)/m) 上述函数的可选输入参数即\(\sigma\)可以尝试更换不同的k1参数以观察测试错误率、训练错误率、支持向量个数随k1的变化情况支持向量的数目存在一个最优值，SVM的优点在于它能对数据进行高校分类。如果支持向量太少，就可能会得到一个很差的决策边界，如果支持向量太多，就相当于每次都利用整个数据集进行分类，这种分类方法称为k近邻我们可以对SMO算法中的其他设置进行随意地修改或者建立新的核函数 6. 示例手写识别问题, 使用SMO算法, 构建一个系统去测试手写数字上的分类器：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def img2vector(filename): returnVect = zeros((1,1024)) fr = open(filename) for i in range(32): lineStr = fr.readline() for j in range(32): returnVect[0,32*i+j] = int(lineStr[j]) return returnVectdef loadImages(dirName): from os import listdir hwLabels = [] trainingFileList = listdir(dirName) #load the training set m = len(trainingFileList) trainingMat = zeros((m,1024)) for i in range(m): fileNameStr = trainingFileList[i] fileStr = fileNameStr.split('.')[0] #take off .txt classNumStr = int(fileStr.split('_')[0]) if classNumStr == 9: hwLabels.append(-1) else: hwLabels.append(1) trainingMat[i,:] = img2vector('%s/%s' % (dirName, fileNameStr)) return trainingMat, hwLabels def testDigits(kTup=('rbf', 10)): dataArr,labelArr = loadImages('trainingDigits') b,alphas = smoP(dataArr, labelArr, 200, 0.0001, 10000, kTup) datMat=mat(dataArr); labelMat = mat(labelArr).transpose() svInd=nonzero(alphas.A&gt;0)[0] sVs=datMat[svInd] labelSV = labelMat[svInd]; print "there are %d Support Vectors" % shape(sVs)[0] m,n = shape(datMat) errorCount = 0 for i in range(m): kernelEval = kernelTrans(sVs,datMat[i,:],kTup) predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b if sign(predict)!=sign(labelArr[i]): errorCount += 1 print "the training error rate is: %f" % (float(errorCount)/m) dataArr,labelArr = loadImages('testDigits') errorCount = 0 datMat=mat(dataArr); labelMat = mat(labelArr).transpose() m,n = shape(datMat) for i in range(m): kernelEval = kernelTrans(sVs,datMat[i,:],kTup) predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b if sign(predict)!=sign(labelArr[i]): errorCount += 1 print "the test error rate is: %f" % (float(errorCount)/m) 基于SVM构建多类分类器已有很多研究和对比了，感兴趣可以查看C.W.Huset等人发表的一篇论文”A Comparison of Methods for Multiclass Support Vector Machines” 《机器学习实战》一书中，作者使用不同的σ值，并尝试了线性核函数，得到的结果是：表中结果表明，径向基函数中的参数\(\sigma=10\)左右时，可以得到最小测试错误率，该参数值比前面例子中的取值1.3大得多，这些差距是由于数据不同造成的，手写识别的数据中有1024个特征，而这些特征的值可能高达1.0，而前面的例子中只有2个特征。如何取值呢?多次尝试可以得到比较好的结果，C的设置也会影响到分类的结果。当然存在另外的SVM形式，把C同时考虑进了优化过程中，例如v-SVM，这里可以参考Sergios Theodoridis和Konstantinos Koutroumbas撰写的Pattern Recognition。我们还会发现，最小的训练错误率并不对应于最小的支持向量数目，另一个值得注意的点是：线性核函数的效果并不是特别差，可以牺牲线性核函数的错误率来提高分类速度，]]></content>
      <categories>
        <category>techonology</category>
        <category>ai</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统一]]></title>
    <url>%2F2015%2F08%2F26%2FoperatingSystem01%2F</url>
    <content type="text"><![CDATA[1. 前言华中科技大学的讲义很不错主要备份了此讲义的内容[1]文中用到的一些概念： 原语：操作系统或计算机网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程。primitive or atomic action 是由若干个机器指令构成的完成某种特定功能的一段程序，具有不可分割性，即原语的执行必须是连续的，在执行过程中不允许被中断。 2. 操作系统简介2.1 发展过程无操作系统:人工操作-&gt;脱机I/O方式单道批处理系统-&gt;多道批处理系统-&gt;分时系统-&gt;实时系统-&gt;网络操作系统-&gt;分布式操作系统 2.2 基本特性 并发 共享: 互斥共享模式和同时访问模式 虚拟 异步 2.3 主要功能 处理机管理功能: 进程控制、进程同步、进程通信 存储器管理功能: 内存分配、内存保护、地址映射、内存扩充 设备管理功能: 缓冲管理、设备分配、设备处理 文件管理功能: 文件存储空间的管理、目录管理、文件的读/写管理和保护 用户接口: 命令接口、程序接口、图形接口 3. 进程3.1 进程的特征与状态为使程序能够并发执行，且为了对并发执行的程序加以描述和控制,因此引入了”进程”的概念: 结构特征 动态性 并发性 独立性 异步性 3.1.1 定义 1) 进程是程序的一次执行 2) 进程是一个程序及其数据在处理机上顺序执行所发生的活动 3) 进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位 3.1.2 三种基本状态 就绪状态 运行状态 等待(阻塞)状态 3.1.3 挂起状态3.1.4 进程控制块(PCB)进程是程序的一次执行过程，程序是完成该进程的操作的算法描述。当程序并发执行时，产生了动态特征，并由于并发程序之间的相互制约关系而形成了一个比较复杂的外界环境。为了描述一个进程和其他进程以及系统资源的关系，刻画了一个进程在各个不同时期所处的状态，人们采用了一个与进程相联系的数据块来描述，称为进程控制块(Process Control Block, PCB)或进程描述器(Process Descriptor)。进程控制块是一个数据结构，是标识进程存在的实体。当系统创建一个进程时，必须为它设置一个PCB，然后根据PCB的信息对进程实施控制和管理，进程任务完成时，系统撤销它的PCB，进程也随之消亡。对一般系统而言，PCB应具有以下信息： 进程标识符 进程的状态 当前队列指针next 进程优先级priority CPU现场保护区cpustatus 通信信息communication infomation 家族联系process family 占用资源清单own_resource 3.1.5 总结从结构上说，每个进程都由一个程序段(包括数据)和一个进程控制块PCB组成。程序和数据描述进程本身应该完成的功能，而PCB则描述进程的动态特征，进程与其他进程和系统资源的关系 3.2 进程控制3.2.1 进程创建在系统初启时，创建并产生一些必须的、承担系统资源分配和管理工作的系统进程，而用户进程是在用户程序提交给系统时创建的。当用户程序进入系统时，系统为该程序创建一个进程，这个进程还可以创建一些子进程，以完成一些并行的工作，创建者称为父进程，被创建者称为子进程，创建父进程的进程被称为祖父进程，这样就构成了一个进程家族。进程管理的基本功能之一就是提供创建进程的支持，这些新进程是一个与现有进程不同的实体。用户不能直接创建进程，只能通过操作系统提供的进程创建原语，以系统请求的方式向操作系统申请创建一个进程 3.2.2 进程撤销进程撤销的功能包括：撤销本进程、撤销一个指定标识符的进程或者撤销一组子进程，后面两个撤销命令只能用于父进程撤销子进程。撤销本进程的功能是将当前运行的进程(因为是自我撤销)的PCB结构归还到PCB结构池，所占用的资源归还给父进程，然后转进程调度程序。 3.2.3 进程阻塞当进程要等待某一事件完成时，它可以调用阻塞原语将自己挂起。进程一旦挂起，就只能由另一个进程唤醒，进程阻塞的原语形式为susp(chan)，参数chan是进程等待的原因。阻塞命令的功能是停止调用进程的执行，将CPU现场保留到该进程的PCB现场保护区，然后改变其状态为”等待”，并插入到等待chan的等待队列，最后使控制转向进程调度 3.2.4 进程唤醒进程由”运行”变为”阻塞”状态是由于进程必须等待某一事件的发生，所以处于阻塞状态的进程是不可能唤醒自己的。例如，某进程正在等待I/O操作完成或等待其他进程发消息给它，只有当该进程所期待的事件出现时，才由发现者进程用唤醒原语叫醒它。一般来说，发现者进程和被唤醒进程是合作的并发进程，唤醒原语的形式为wakeup(chan)唤醒原语的功能是当进程等待的事件发生时，唤醒等待该事件的进程 3.3 进程间的约束关系3.3.1 进程竞争与合作 竞争系统资源进程间的相互制约关系，有一种情况是由于竞争系统资源而引起的间接的相互制约关系。进程共享系统资源，他们对共享资源的使用是通过操作系统的资源管理程序来协调的。凡需使用共享资源的进程，先向系统提出申请，然后由资源管理程序根据资源状况，按一定的策略来实施分配。 进程协作当进程之间存在有共享数据时，将引起直接的相互制约关系。例如，并发进程共享了某些数据、变量、队列等，为了保证数据的完整性，需要正确地处理进程协作的问题。解决进程协作问题的方法是操作系统提供一种同步机构，各进程利用这些同步机构来使用共享数据，来实现正确的协作。进程在以下两种情况下需要协作： 信息共享由于多个用户可能对同样的信息感兴趣，所以操作系统必须提供支持，以允许这些资源类型的并发访问。由于对多个信息(数据)共享，这些进程是合作进程。 并行处理如果一个任务在逻辑上可以分为多个子任务，这些子任务可以并发执行以加快该任务的处理速度。由于这些子任务是为了完成一个整体任务而并发执行的，他们之间一定有直接的相互制约关系。这些进程称为合作进程协调进程间的直接相互制约关系就是要协调各进程前进的步伐，即实现进程的同步，而要实现进程正确的同步，则必须支持进程间的信息传递，这就是进程间的通信。进程同步可细分为：进程互斥、进程同步和进程的直接通信 3.3.2 进程互斥的概念进程同步是通过进程间的通信来实现的，他们之间需要交换信息以便达到协调的目的。进程同步广义上是指对于进程操作的时间顺序所加的某种限制。在这些同步规则中有一个比较特殊的规则是”多个操作绝不能再同一时刻执行”，这种同步规则成为互斥。所以同步是一个大的范畴，互斥是同步的一个特例，但二者又有区别。为理解进程互斥的概念，先讨论临界资源和临界区的概念。 临界资源通常把一次仅允许一个进程使用的资源称为临界资源。 临界区一组进程共享某一临界资源，这组进程中的每一个进程对应的程序中都包含了一个访问该临界资源的程序段。在每个进程中，访问该临界资源的那段程序能够从概念上分离出来，称为临界区或临界段。临界区是进程中队公共变量(或存储区)进行访问与修改的程序段，成为相对于该公共变量的临界区。关于临界区的概念需要注意以下几点： 临界区是针对某一临界资源而言的 相对于某临界资源的临界区个数就是共享该临界资源的进程个数 相对于同一公共变量的若干临界区，必须是互斥地进入，即一个进程执行完毕且出了临界区，另一个进程才能进入他的临界区。为禁止两个进程同时进入临界区所采用的方法必须遵循下列准则： 当有若干进程欲进入它的临界区时，应在有限时间内使进程进入临界区。换言之，他们不应相互阻塞而致使彼此都不能进入临界区。 每次至多有一个进程处于临界区 进程在临界区内仅逗留有限时间 互斥进程互斥可描述为：在操作系统中，当某一进程正在访问某一存储区域时，就不允许其他进程来读出或者修改该存储区的内容，否则会发生无法估计的错误。进程间的这种相互制约的关系称为互斥 3.3.3 进程同步的概念 什么是同步所谓同步，是指多个相互合作的进程，在一些关键点上可能需要相互等待或相互交换信息，这种互相制约的关系称为进程同步。 同步的例子系统中有两个合作的进程，他们共用一个单缓冲区。这两个进程一个是计算进程，负责对数据进行计算；另一个为打印进程，负责对计算结果进行打印。当计算进程没有计算完毕，计算结果没有送到缓冲区的时候，打印进程就不能打印。一旦计算进程把计算结果送入缓冲区，就应该给打印进程发送一个信号，打印进程收到信号后就可以从缓冲区中取出计算结果进行打印。 3.4 同步机构要实现进程间正确的协作，必须具备两个条件: 应用程序的编制者必须十分清楚并发进程之间的同步关系，知道何处需要等待，何处需要给对方发消息 操作系统必须提供实现进程协作的措施和方法，称为同步机构。用户程序利用操作系统提供的同步机构来实现正确的同步。 操作系统提供的同步机构有以下两种： 锁和上锁、开锁操作 信号灯(或称之为信号量)和P、V操作 锁和信号灯是一个物理实体，采用一个标志位代表某种资源的状态或并发程序当前的状态。而基于标志上的操作是为了询问资源或进程的当前状态，以便进行正确的控制。这两个同步机构都可以实现进程互斥，而信号灯比锁的功能更强一些，它还可以方便的实现进程同步。 3.4.1 锁和上锁、开锁操作在锁同步机构中，对应于每一个共享的临界资源(如数据块或设备)都要有一个单独的锁位。常用锁位值为”0”表示资源可用，为”1”表示资源已被占用进程使用共享资源之前必须完成以下操作，称为关锁操作： 检测锁位的值 如果原来是0，将其置为1 如果原来是1，再次返回到检测锁位值的步骤 当进程使用完资源后，它将锁位置为0，称为开锁操作系统提供一个在锁位w上的两个原语操作lock(w)和unlock(w)，其算法描述分别见下：12345678910算法 lock输入: 锁变量w输出: 无&#123; test; if(w==1): goto test //测试锁位的值 else: w=1 //上锁&#125; 123456算法 unlock输入: 锁变量w输出: 无&#123; w=0 //开锁&#125; 在测试锁位值和置锁位的值为1这两步间，锁位不得被其他进程所改变。在上述上锁原语中，goto语句使执行lock(w)原语的进程可能要循环测试而占用处理机时间(称为”忙等待”)。为此，可将上锁原语和开锁原语做进一步修改。修改后的上锁过程和开锁过程如下：1234567891011算法 lock1输入: 锁变量w输出: 无&#123; while(w==1): 保护现行进程的CPU现场 将现行进程的PCB插入w的等待队列 置该进程为&quot;等待&quot;状态 转进程调度 w=1 //上锁&#125; 12345678910算法 unlock1输入: 锁变量w输出: 无&#123; if(w等待队列不空): 移出等待队列首元素 将该进程的PCB插入就绪队列 置该进程为&quot;就绪&quot;状态 w=0 //开锁&#125; 3.4.2 信号灯和P、V操作 信号灯信号灯是一个确定的二元组(s,q)，s是一个具有非负初值的整形变量，q是一个初始状态为空的队列。整形变量s代表代表资源的实体或者并发进程的状态。操作系统利用信号灯的状态对并发进程和共享资源进行管理。一个信号灯的建立必须经过说明，即应该准确说明信号灯s的意义和初值(非负)。每个信号灯都有相应的一个队列，在建立信号灯时，队列为空。当信号灯的值大于或等于0时，表示绿灯，表示进程可以继续推进，若小于0，表示红灯，进程被阻。整形变量s的值可以改变，以反映资源或并发进程状态的改变。操作系统提供称为P、V操作原语来实施对信号灯的操作。需要提及的是，信号灯的值只能由P、V操作原语来改变，由用户程序给出信号灯的初值，其后信号灯在进程同步过程中的值不能由用户程序直接修改。 P、V操作 P操作对信号灯的P操作记为P(s)，P(s)是个不可分割的原语操作，即取信号灯值减1，若结果为负，则调用P(s)的进程被阻，并插入到该信号灯的等待队列中，否则可以继续执行P操作的主要动作如下： s值减1 若结果大于等于0，则进程继续执行 若相减结果小于0，该进程被封锁，并将它插入到该信号灯的等待队列中，然后转进程调度程序具体算法描述：1234567891011算法 P输入: 变量s输出: 无&#123; s-- if(s&lt;0): 保留调用进程CPU现场 将该进程的PCB插入s的等待队列 置该进程为&quot;等待&quot;状态 转进程调度&#125; V操作对信号灯的V操作记为V(s)，V(s)是个不可分割的原语操作，即取信号灯值加1，若结果大于0，进程继续执行，否则，唤醒在信号灯等待队列上的一个进程。V操作的主要动作如下： s值加1 若结果大于0，则进程继续执行 若相减小于或等于0，则从信号灯的等待队列中移出一个进程，解除它的等待状态，然后返回本进程继续执行具体算法描述：12345678910算法 V输入: 变量s输出: 无&#123; s++ if(s&lt;=0): 移出s等待队首元素 将该进程的PCB插入就绪队列 置该进程为&quot;就绪&quot;状态&#125; 3.5 进程互斥与同步的实现主要就是通过以上讲解的锁和信号灯方法。 3.5.1 上锁原语和开锁原语实现进程互斥两进程使用上锁原语和开锁原语实现临界资源的操作可描述为：12345678910111213141516171819202122程序 task1main() &#123; int w=0; //互斥锁 cobegin pp1(); pp2(); coend&#125;pp1() &#123; ... lock(w); cs1; unlock(w); ...&#125;pp2() &#123; ... lock(w); cs2; unlock(w); ...&#125; 3.5.2 信号灯实现进程互斥用信号灯及P、V操作解决并发进程临界区问题，方法是： 设互斥信号灯，一般记为mutex(mutual exclusion)，赋初值为，表示初始时刻临界资源未被占用 将进入临界区的操作置于P(mutux)和V(mutux)之间，即可实现进程互斥上述方法能正确实现进程互斥。任何欲进入临界区的进程，必先在互斥信号灯上执行P操作，在完成对临界资源区的访问后才执行V操作。由于互斥信号灯初值为1，当第一个进程执行P操作后mutux变为0，说明临界资源可分配给该进程，使之进入临界区。若此时又有第二个进程进入临界区，也应先执行P操作，结果使mutux变为负值，这就意味着临界资源已被占用，因此第二个进程被阻塞。直到第一个进程执行V操作，释放临界资源而恢复mutux值为0后，方可唤醒第二个进程，使之进入临界区，待他完成临界资源的访问时，又执行V操作，mutux恢复初值设两个并发进程pa和pb，具有相对于变量n的临界段csa和csb，用信号灯实现他们的互斥措施： 12345678910111213141516171819202122程序 task2main() &#123; int mutux=1; cobegin pa(); pb(); coend&#125;pa() &#123; ... p(mutux); csa; v(mutux); ...&#125;pb() &#123; ... p(mutux); csb; v(mutux); ...&#125; 对于两个并发进程，互斥信号灯值仅取1、0、-1三个值若mutux=1，表示没有进程进入临界区若mutux=0，表示有一个进程进入临界区若mutux=-1，表示有一个进程进入临界区，另一个进程等待进入 3.5.3 进程同步的实现用信号灯的P、V操作实现进程同步的关键是要分析清楚同步进程之间的相互关系，即什么时候某个进程需要等候，什么情况下需要给对方发一个消息，还需要分析清楚同步进程各自关心的状态，依据分析的结果就可以知道如何设置信号灯，如何安排P、V操作在病员就诊例子中，医生看病活动与化验室化验活动的同步关系分析： 看病进程开出化验单，并发送给化验进程，化验进程才能开始工作，否则化验进程等待 化验进程化验完毕必须得到化验结果，并发送给看病进程，看病进程才能根据化验结果确定医疗方案，否则看病进程必须等待 用信号灯的P、V操作来实现这两个进程的同步：123456789101112131415161718192021222324程序 task3main() &#123; int s1=0; //表示有无化验单 int s2=0; //表示有无化验结果 cobegin labora(); diagnosis(); coend&#125;labora() &#123; while(化验工作未完成) &#123; p(s1); //询问有无化验单,若无则等待 化验工作; //送出化验结果 v(s2); &#125;&#125;diagnosis() &#123; while(看病未完成) &#123; 看病; v(s1); //送出化验单 p(s2); //等化验结果 diagnosis; //诊断 &#125;&#125; 实际应用中同步问题很多，按特点不同一般分为两类，一类保证一组合作进程按逻辑需要所确定的执行次序，另一类是保证共享缓存区(或共享数据)的合作进程的同步。 合作进程的执行次序为了完成一个共同的任务，可能有多个进程并发执行。然而，这些并发进程根据逻辑上的需要，有的没有时间上的先后次序，有的则有先后次序。也就是说它们必须遵循一定的同步规则，才能得出最后正确得结果。为了描述方便，我们用一个图来表示进程集合的执行时间轨迹。图的连接描述了进程间开始和结束的次序约束。此图称为进程流程图。如用s表示系统中某一任务启动，f表示完成，则可用下图所示的进程流程图来表示这一组合作进程执行的先后次序。图片从左至右依次是 串行、并行、一般a)说明P1、P2、P3、P4这四个进程依次顺序执行，只有在前一个进程结束后，后一个进程才能开始执行，当P4完成时，这一组进程全部结束。而图b)则表示P1、P2、P3、P4这四个进程可以同时执行。图c)中描述的进程执行次序时混合式的，既有串行的、也有并行的。例：Pa、Pb、Pc为一组合作进程，其进程流程图如下:试用信号灯的p、v操作实现这三个进程的同步。进程流图说明任务启动后Pa先执行，当它结束后Pb、Pc可以开始执行。为了确保这一执行顺序，设两个同步信号灯Sb、Sc分别表示进程Pb和Pc能否开始执行，其初值均为0。这三个进程的同步描述如下： 123456789101112131415main() &#123; int Sb=0; //表示Pb进程能否开始执行 int Sc=0; //表示Pc进程能否开始执行 cobegin Pa(); Pb(); Pc(); coend&#125;Pa() Pb() Pc()&#123; &#123; &#123; ... p(Sb); p(Sc); v(Sb); ... ... v(Sc); ... ...&#125; &#125; &#125; 共享缓存区的合作进程的同步多进程的另一类同步问题是共享缓冲区的同步。我们以下例说明这类问题的同步规则及信号量解法。设计算进程cp和打印进程iop公用一个单缓冲buft，如下图所示:进程cp不断的计算数据并送入缓冲区buft中,iop进程负责从缓冲区buft中取出数据去打印。这两各进程可以并发执行，但由于它们公用一个缓冲区，因此,进程cp和进程iop必须遵循下面同步规则: 当cp进程把计算结果送入buft时, iop进程才能从buft中取出结果去打印,否则必须等待。 当iop进程把buft中的数据取出打印后,cp进程才能把下一个计算结果数据送入buft中,否则必须等待。算法描述：123456789101112131415161718main() &#123; Sa=0; //表示缓冲区中是否有可供打应的计算结果 Sb=0; //表示缓冲区中有无空位置存放新信息 cobegin cp( ); iop( ); coend&#125;iop() cp()&#123; &#123; while(打印机工作未完成) while(计算未完成) &#123; &#123; P(Sa); 得到一个计算结果; 从缓冲区中取一数据; P(Sb); V(Sb); 将数据送入缓冲区; 从打印机上输出; V(Sa); &#125; &#125;&#125; 3.5.4 生产者—消费者问题生产者-消费者问题是一种同步问题的抽象描述。系统中的进程当它使用某一资源时，可以认为它是消费，所以称该进程为消费者。系统中的进程将它所使用的资源释放时，可以看作它在生产。所以称该进程为生产者。因此，计算机系统中的每个进程都可以消费或生产某些资源。这些资源包括硬资源(CPU,外设,主存缓冲区等)和软资源(临界区,消息等)。我们可以通过一个有界缓冲区把一群生产者P1、P2、…、Pm和一群消费者C1、C2、….、Ck联系起来，如图所示：一组生产者P1,P2,….Pm只要buft不满，便可将产品放入其中；只要缓冲区buft未空，消费者便可从中取走产品。因此, 生产者和消费者是同步关系。这种关系禁止生产者向满缓冲区输入产品，也禁止消费者从空缓冲区中提取物品 。在生产者-消费者问题中，信号灯具有两种功能。首先，它是跟踪资源的生产和消费的计数器，其次它是协调资源的生产者和消费者之间的同步器。在生产者和消费者问题中，既有同步，又有互斥问题,所以既要设置公用信号量，也要设置私用信号量。所以，为了解决这一类生产者－消费者问题，应该设置两个同步信号灯，一个说明空缓冲区的数目，用empty表示，其初值为有界缓冲区的大小n，另一个说明满缓冲区(即信息)的数目，用full表示，其初值为0。由于有界缓冲区是一个临界资源，必须互斥使用，所以，另外还需要设置一个互斥信号灯mutex，其初值为1。其算法描述与演示如下: 3.5.5 管程机制 管程的引入尽管信号量机制是一种既方便又有效的同步机制，每个要访问临界资源的进程都必须自备P、V操作，这就使大量的同步操作分散在各个进程中，这不仅给系统管理带来麻烦，而且也会引同步操作的使用不当产生死锁。为了解决上述问题，便产生了进程同步工具—管程(MONITOR)。 管程的概念管程的定义为：一个管程定义了一个数据结构和能为并发进程所执行的、在该数据结构上的一组操作，这组操作能同步进程和改变管理中的数据。也就是说，当共享资源用共享数据结构表示时，资源管理程序可用对该数据结构进行操作的一组过程来表示，这样一组相关的数据结构和过程称为管程。管程的结构：管程相当于围墙，它把共享变量和对它进行操作的若干过程围起来，所有进程要访问临界资源时，都必须经过管程（相当于通过围墙的门）才能进入，而管程每次只准许一个进程进入管程，从而实现了进程。管程示意图：管程的语法： 1234567891011type monitor_name=monitor variable declarations procedure entry p1(...); begin...end; procedure entry p2(...); begin...end; ．．．．．． procedure entry pn(...); begin...end; begin initialization code 利用管程解决生产者-消费者问题利用管程解决生产者-消费者问题的管程 Producer-Consumer描述如下： 1234567891011121314151617181920212223Type producer-consumer=monitor var in,out,count:integer; buffer:array[0..n-1] of item; notfull.notempty:condition; pricedure entry put(item) begin if count&gt;=n then notfull.wait; buffer(in):=nextp; in:=(in+1) mod n; count :=count+1; if notempty.queue then notempty.signal; end procedure entry get(item) begin if count&lt;=0 then notempty.wait; nextc:=buffer(out); out:=(out+1) mod n; count:=count-1; if notfull.queue then notfull.signal; end begin in:=out:=0; count:=0; end 在利用管程解决生产者-消费者问题时，其中的生产者和消费者可描述为:1234567891011121314producer: begin repeat produce and item in nextp; produce-consumer.put(item); until false; endconsumer: begin repeat produce-consumer.get(item); consumer the item it nextc; until false; end 3.6 进程通信3.6.1 引言前面我们介绍了几种同步装置，如锁和信号量，并发进程通过这些装置达到协调同步的目的。但这些装置常常限制为一个或几个字的信息存贮，因而进程间传递的只能是单一的信号。这种通信方式是一种较低级的、间接的通信方式。然而，进程之间的信息交换包含着更复杂的结构，它们可能要传递大量的信息。为了提高效率，我们应采用直接的进程通信方式。 a)进程通信的概念所谓进程通信是指进程之间可直接以较高的效率传递较多数据的信息交换方式。这种方式中采用的是通信机构，如信息发送和接收、邮箱结构等，在进程通信时往往以消息形式传递信息。所谓消息是指进程之间相互传送的赖以发生交互作用的有结构的数据。 b)从进程的观点看 (i)OS是由各种进程组成的从进程观点来看，一幅OS运行时刻的“快照”会给我们呈现:系统进程、用户进程、计算进程、打印进程… (ii) 进程可产生通信,如已知的互斥,同步从进程观点来看，OS中的有关进程因共享资源而相互竞争，“互斥”;会为了完成某一共同任务，进程会相互合作，“同步”。 (iii) 对进程通信的分类从本质上看依进程间的通信内容有 : 控制信息的传送(即”低级通信”) 其目的是控制进程执行速度 大批量数据传送(即”高级通信”) 其目的是交换信息 3.6.2 进程通信的实现方式(1)锁(2)信号量(3)主从式通信系统(4)会话式通信系统(5)消息或信箱机制式通信系统(6)共享存储区方式通信系统进程通信(Interprocess Communication,IPC)是一个进程与另一个进程间共享消息的一种方式。消息(message)是发送进程形成的一个信息块，通过信息的语法表示形成所需传送的内容给接收进程。IPC机制是消息从一个进程的地址空间拷贝到另一个进程的地址空间的过程，而不使用共享存储器的方法。IPC通信机制适用于分布环境下处于不同节点上进程间的通信，应用范围比较广。由于现代操作系统都提供存储保护手段，一个用户程序执行时只能在自己的存储空间范围内访问，不能进入另一个用户的存储空间。所以上述的消息传递只能通过操作系统提供的支持才能实现，这就是IPC机制。即信息在一个进程的地址空间打包形成消息，然后从消息中拷贝信息到另一个进程的地址空间，这些工作是由操作系统提供的IPC机制来实现的，发送或接收消息需要操作系统的干预。 消息缓冲通信在消息通信中，接收方和发送方有明确的协议，双方都认可其中的消息格式。在大多数消息传递机制中都使用消息头用于标识与消息相关的信息，包括发送进程的标识符、接收进程的标识符以及消息中传送的字节数等。消息头能够被系统中所有进程理解。消息缓冲通信方式包括消息缓冲、发送原语和接收原语。每当发送进程欲发送消息时，便形成一个消息缓冲区(包括消息头和消息内容)，然后用发送原语把消息发送出去。接收进程在接收消息之前，在本进程的主存空间中设置一个接收区，然后用接收原语接收消息。两通信进程必须满足的条件： a.在发送进程把消息写入缓冲区和把缓冲区挂入消息队时，应禁止其它进程对该缓冲区消息队列的访问。同理对接收进程。 b.当缓冲区中已有消息存在时，接收进程不能接收到任何消息 在消息缓冲通信方式中，发送原语的形式为：send(m)这里的m是发送区开始地址。发送原语的功能是把欲发送之消息从发送区复制到消息缓冲区，并将它挂到接收消息队列的末尾。如果接收进程正因等待消息而处于等待状态，则被唤醒。发送原语的算法描述为：123456789101112131415161718算法 send输入: 发送区首址m 输出: 无 &#123; 从发送区id域得接收进程id号; 以此id号得接收进程pcb的消息队列头; 从发送区size域得缓冲区大小; 以此大小加上缓冲区头得area; 向存贮管理模块申请一个消息缓冲区area; 发送进程id送area的sptr域; //建立新的消息缓冲区 缓冲区大小送area的size域; 发送区的text送area的text域; 置area的勾链字为链尾标记; p(mutex); //封锁消息队列 将area入消息队列 v(mutex); //解琐消息队列 v(Si); //与接收进程同步&#125; 接收原语的形式为:receive(n,sid)这里n为接收开始地址，sid为发送进程的id号。接收原语的功能是将所要的消息缓冲区中的信息读到接收区。接收原语的实现为： 1234567891011121314算法 receive输入: 接受区首址n,发送进程id号输出: 无&#123; p(si); //有无消息可取 p(mutex); //封锁消息队列 在消息队列中找到发送者为sid的消息; 从消息队列中摘下此消息缓冲区area; v(mutex); //解琐消息队列 area的sptr送接收区的id域; area的size送接收区的size域; area的text送接收区的text域; 释放area给存贮管理模块;&#125; 信箱通信在信息通信中，除了定义信箱结构外，还包括消息发送和接收功能模块，提供发送原语和接收原语。使用信箱传递消息时，所使用的信箱可以位于用户空间中，是接收进程地址空间的一部分，也可以位于操作系统的空间中，具体由操作系统的设计者根据需求来决定。下图所示为使用用户空间中的信箱实现消息传递:下图所示为系统空间中的信箱实现消息传递:在操作系统空间中存放接收进程的信箱，并且消息的拷贝是在接收进程发出接收消息的系统调用时进行，这种方法中信箱的管理由操作系统负责，这就防止了对消息和信箱数据结构的随意破坏，因为任何一个进程都不能之间访问信箱。这种方法的缺点是要求操作系统为所有的进程分配主存信箱，由于系统空间有限，可能对通信进程数有限制。此外，通信进程间应满足的条件： a、发送进程发送消息时，邮箱中至少要有一个空格能存放该消息。 b、接收进程接收消息时，邮箱中至少要有一个消息存在。 3.6.3. 经典IPC问题哲学家进餐问题 ——对多个竞争进程互斥地访问有限资源这类问题的建模 A.问题描述1965年，Dijkstra提出一个他称为“哲学家进餐”的同步问题。问题如下：五个哲学家围坐在一张圆桌周围，每个哲学家面前都有一碟通心面，由于面很滑，所以要两把叉子才能夹住。相邻两个碟子之间有一把叉子，如下图：哲学家的活动如下：吃饭与思考。当一个哲学家觉得饿时，他就试图分两次去取他左边和右边的叉子，每次拿一把，但不分次序。如果成功地获得了两把叉子，他就开始吃饭，吃完以后放下叉子继续思考。现要解决地问题是：为每一位哲学家写一段程序来描述其行为，要求不死锁。 B.一种不正确的哲学家进餐问题解决方案123456789101112#define N 5 //哲学家数目void philospher(int i) //i:哲学家号从0到4&#123; while(TRUE) &#123; think(); //正在思考 take-fork(i); //取左叉 take-fork((i+1)%n); //取右叉 eat(); //吃面 put_fork(i); //放回左叉 put_fork((i+1)%n); //放回右叉 &#125;&#125; 当５位哲学家都同时拿起左叉，则他们都拿不到右叉，于是死锁发生。规则修改１：规定在拿到左叉后，查看右面的叉子是否可用，若不可用，则先放下左叉，等待一段时间再重复整个过程。上述解法仍无法回避某一个瞬时间，所有哲学家都同时启动这个算法，取左叉，看到右叉不可用，放下左叉；等待一会儿，又同时拿起左叉，如此这样重复下去于是死锁。规则修改２：哲学家在拿不到右叉时等待一段随机的时间，而不是等待相同的时间，发生上述死锁的概率就很小了。实际情况确实如此，但在一些要害部分，如武器系统，核反应系统，这仍不能达到要求。 C.正确的哲学家就餐问题的较好解决方案 1234567891011121314151617181920212223242526272829303132333435363738#define N 5 //哲学家数目#define LEFT(i+1)%N //i的左边#define RIGHT(i+1)%N //i的右边#define THINKING 0 //正在思考#define HUNGRY 1 //想取得叉#define EATING 2 //正吃面子typedef int semaphore //信号量是一个特殊的整型变量int state[N]; //记录每个人状态的数组semaphore mutex=1; //临界区互斥semaphore s[N]; //每个哲学家一个信号量Void philosopher(int i) //i:某位哲学家&#123; while(TRUE) &#123; think(); //思考 take_forks(i); //或者取得两叉，或者阻塞 eat(); //吃面 put_forks(i); //将两叉同时放回 &#125;&#125;Void take_fork(int i) &#123; down(&amp;mutex); //进入临界区 state[i]=HUNGRY; //记录状态 test(i); //试图取得两只叉子 up(&amp;mutex); //离开临界区 down(&amp;s[i]); //若得不到叉子就阻塞&#125;Void test(semaphore i) &#123; if (state[i]==HUNGRY &amp;&amp;state(LEFT)!=EATING &amp;&amp;state(RIGHT)!=EATING) state[i]=EATING; up(&amp;S[i]);&#125;Void put_forks(int i) &#123; down(&amp;mutex); //进入临界区 state[i]=THINKING; //进餐结束 test(LEFT); //看一下左邻居现在是否能进餐 test(RIGHT); //看一下右邻居现在是否能进餐 up(&amp;mutex); //离开临界区&#125; D.利用管程解决哲学家进餐问题用于解决哲学家进餐问题的管程描述如下： 12345678910111213141516171819202122232425262728Type dining-philosophers=monitor var state:array[0..4]of(think,hungry,eating); //可利用pickup过程进餐 var self:array[0..4] of condition; produre entry pickup(i:0..4);begin state[i]:=hungry; //测试是否具备进餐条件不具备进餐条件则执行self[i].wait,推迟进餐 if state(i)&lt;&gt;eating then self(i).wait; produre entry putdown(i:0..4); begin //当哲学家进餐完毕,便放下筷子,继续思考 state[i]=thinking; test(i+1 mod 5); test(i+1 mod 5); endbegin if state[k+4 mod 5]&lt;&gt;eating //条件为真表示具备进餐条件 and state[k]=hungry and state[k+1 mod 5]&lt;&gt;eating then begin state[k]:=eating; self[k].signal endendbegin for i=0 to 4 do state[i]:=thinking;end 3.7 线程概念及特点3.7.1 线程的概念线程(threads &amp; lightweight processes)是进程中的一个实体，是被独立调度和分派的基本单位，线程除拥有运行中必不可少的程序记数器，一组寄存器和栈外，基本上不拥有系统资源。为了提高系统内程序并发执行的程度，从而可进一步提高系统的吞吐量，在现代的操作系统中引入了比进程更小的能独立运行的基本单位—线程(threads)。多线程的概念首先是在多处理机系统的并行处理中提出来的。传统的多处理机由若干台处理机组成，每台处理机每次运行单个现场，也就是说，每台处理机有一个有限硬件资源的单一控制线索。这样的多处理机系统在进行远程访问时会出现等待现象，处理机在这段时间间隔内处于空闲。为了提高处理机的并行操作能力，提出了多线程的概念。在每台处理机上建立多个运行现场，这样每台处理机有多个控制线程。在多线程系统结构中，多线程控制为实现隐藏处理机长时间等待提供了一种有效的机制，线程可以用一个现场(context)表示，现场由程序计数器、寄存器组和所要求的现场状态字组成。线程是比进程更小的活动单位，它是进程中的一个执行路径。一个进程可以有多条执行路径即线程。这样在一个进程内部就可以有多个可以独立活动的单位，可以加快进程处理的速度，进一步提高系统的并行处理能力。线程也可以这样来描述： 线程是进程中的一条执行路径 它有自己私有的堆栈和处理机执行环境(尤其是处理器寄存器) 它共享父进程的主存 它是单个进程所创建的许多个同时存在的线程中的一个 进程与线程既有联系也有区别，可以进一步将进程的组成概括为以下几个方面： 一个可执行程序，它定义了初始代码和数据 一个私有地址空间(address space)，它是进程可以使用的一组虚拟主存地址 进程执行时所需的系统资源(如文件、信号灯、通信端口等)是由操作系统分配给进程的 若系统支持线程运行，那么每个进程至少有一个执行线程 当系统支持多线程处理时，线程是任务调度的单位而不是系统资源的分配单位，进程是系统资源的分配单位，也是任务调度的单位。线程实例： 例1、浏览器在取一副Web页面时会设立多个线程，以便可以同时请求传输多副图象,以组合成一副完整的Web页面。 例2、在Windows下，用户启动画图程序后，Windows系统将创建进程并启动执行该进程的主执行线程，当主执行线程终止时，进程也终止。 字处理程序中，可以一个线程显示图形，另一个线程用来读入用户的输入，还有一个线程进行拼写和语法检查。 3.7.2 线程的特点和状态 线程的特点在进程内创建多个线程，可以提高系统的并行处理能力。例如，一个文件服务器，某时刻正好封锁在等待磁盘操作上，如果这个服务器进程具有多个控制线程，那么当一个线程在等待磁盘操作时，另一个线程就可以运行，比如它可以接收一个新的文件服务请求，这样可以提高系统的性能。又比如: 前者各线程在不同的地址空间中操作，后者所有三个线程共享同一个地址空间，因此，线程的同步和通讯的实现容易。 线程的状态变迁如果一个系统支持线程的创建与线程的活动，那么处理机调度的最小单位是线程而不是进程。一个进程可以创建一个线程，那么它具有单一的控制路径，也可以创建多个那么就具有多个控制路径，这时线程是争夺CPU的单位。线程中也有一个从创建到消亡的生命过程，在这一过程中它具有运行、等待、就绪或终止几个状态。 创建。建立一个新线程 就绪。线程处于线程就绪队列中，等待被调度。 运行。一个线程正在占用CPU，执行它的程序 等待。一个正在执行的线程如果发生某些事件，如被挂起或需要执行费时的输入/输出操作时，将让出CPU，暂时中断自己的执行，进入等待状态，等待另一个线程唤醒它。 终止。一个线程已经退出，但该信息还没有被其他线程所收集(在UNIX术语中，父进程还没有做wait) 线程在活动过程中状态是不断变化的。 用户线程和内核线程用户线程是在内核的支持下，在用户层通过线程库实现的。线程库提供对线程创建、调度和管理等方面的支持。用户线程的创建和调度是在用户空间内进行的，不需要内核干预，因此，用户级线程通常能快速的创建和管理。用户线程存在的缺点是:如果内核是单线程的，那么任何一个用户级线程执行了一个线程等待的系统调用，就会引起整个进程的阻塞，即使还有其他线程可以在应用程序内运行。用户线程库的例子有: POSIX Pthread、Mach C-thread和Solaris 2 UI-thread。内核线程由操作系统直接支持，对内核线程的管理是由操作系统完成的，内核在其空间内执行进程创建、调度和管理。内核线程的创建和管理比在用户级创建和管理用户线程要慢，但正是由于内核管理线程，当一个线程执行等待的系统调用时，内核能调度应用程序内的另一个线程去运行。而且，在多处理器环境下，内核能在不同的处理器上调度线程，大多数现代操作系统都支持内核线程。 3.7.3 引入线程后带来的问题线程的引入，改变了编程模型。多线程共享的数据结构的操作，会带来意想不到的问题，如系统崩溃。 多线程对全局变量的使用，会带来不可预知的结果，可能引起混乱。多线程对堆栈管理带来了麻烦。但这些问题不是不可以克服，但应对OS作彻底设计，起码是对系统调用的语义重新定义，库函数也应重写。 3.8 操作系统的并发机制实例3.8.1 创建进程及应用实例UNIX/Linux系统的核心为系统调用fork完成以下操作： + 为新进程分配一个新的PCB结构 + 为子进程赋一个唯一的进程标识号(PID) + 做一个父进程上下文的逻辑副本。由于进程的正文区(代码段)可被几个进程所共享，所以核心只需要增加某个正文区的引用数即可，而不是真的将该区拷贝到一个新的物理内存区。这意味着父子进程将执行相同的代码。但数据段和堆栈段属于进程的私有数据，需要拷贝到新的内存区中。 + 增加与该进程相关联的文件表和索引节点表的引用数。这意味着父进程打开的文件子进程可以继续使用。 + 对父进程返回子进程的进程号，对子进程返回0 在从系统调用fork中返回时，两个进程除了返回值PID不同外，具有完全一样的用户级上下文。在子进程中，PID的值为0,父进程中PID为子进程的PID。在系统启动时由核心内部建的0#进程是唯一不通过系统调用fork而创建的进程。1234567891011121314151617181920#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main() &#123; pid_t child; int i = 2; if( (child=fork()) == -1 ) &#123; printf(&quot;fork error.\n&quot;); exit(EXIT_SUCCESS); &#125; if( child == 0 ) &#123; i = i+3; printf(&quot;i=%d\n&quot;,i); &#125; i += 5; printf(&quot;i=%d\n&quot;,i); return 0;&#125; 该程序多次运行时理论上可能输出以下4种情况: + fork error + i = 5 i = 10 i = 7 + i = 7 i = 5 i = 10 + i = 5 i = 7 i = 10 只有当前进程数达到系统规定上限或系统内存不足，才会出现第一种情况。第二种情况对应子进程先调度运行并执行完两条打印语句后才执行父进程的情况，而第三种则是先执行父进程的打印语句再调度执行子进程的情况，第四种结果对应着穿插的情况。之所以说是理论情况下，是因为: 1)进程创建一般都很成功，第一种很少出现 2)父子进程一般执行时间很短，中间一般不会出现进程调度，可以在程序中适当的地方加入系统调用函数sleep()，引起进程调度从而得到后面三种情况。例如可以在i+=5前加入sleep(1)。父进程为了启动一个新的程序的执行，在UNIX/Linux系统中需要用到exec()类函数，在Linux中有execl()、execlp()、execle()、execv()、execvp()、execve()。exec()函数族的作用是根据参数指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。一个进程一旦调用了exec()类函数，系统将该进程的代码替换为新的程序代码，废弃原有的数据段和堆栈段，并根据新程序分配新的数据段和堆栈段，唯一留下的就是进程的PCB结构和进程号，也就是说，，对系统来说还是同一个进程，只是已经是一个新程序了。12345678910111213#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; if( fork() == 0 ) &#123; printf(&quot;a&quot;); execlp(&quot;./file1&quot;,NULL,(char *)NULL); printf(&quot;b&quot;); &#125; printf(&quot;c&quot;); return 0;&#125; 其中file1对应的源码如下:123456#include &lt;stdio.h&gt;int main() &#123; printf(&quot;d&quot;); return 0;&#125; 程序运行结果可能是acd、cad、adc三种，可在某些位置添加sleep()验证，但是无论如何b不会print。Windows提供了CreateProcess()函数用于创建进程，如果需要运行一个新程序，只需要改变该API函数的cmdLine参数即可。 3.8.2 创建线程及应用实例Linux系统下多线程遵循POSIX线程接口，称为pthread。编写Linux下多线程的程序，需要头文件pthread.h，连接时需要使用库libpthread.a。Linux下pthread的实现是通过系统调用clone实现的，clone()是Linux特有的系统调用。12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;void thread() &#123; int i; for(i = 0; i &lt; 3; i++) &#123; printf(&quot;This is a pthread.\n&quot;); &#125;&#125;int main(void) &#123; pthread_t id; int i,ret; ret = pthread_create(&amp;id,NULL,(void *) thread,NULL); if(ret!=0) &#123; printf(&quot;Create pthread error!\n&quot;); exit(1); &#125; for(i=0;i&lt;3;i++) &#123; printf(&quot;This is the main process.\n&quot;); &#125; pthread_join(id,NULL); return 0;&#125; gcc test.c -o test -lpthread编译后运行即可看出结果。 3.8.3 等待进程、线程的终止及其应用在UNIX/Linux中，一个进程可以通过系统调用wait使它的执行与子进程的终止同步，wait调用格式: pid=wait(stat_addr)wait()函数使父进程暂停执行，直到它的一个子进程结束为止，该函数返回值是终止运行的子进程的pid。参数status所指向的变量存放子进程的退出码，即从子进程的main()函数返回的值或子进程exit函数的参数。如果status不是一个空指针，状态信息将被写入它所指向的变量。在Linux中，waitpid(pid_t pid, int* status, int options)也用来等待子进程结束，但它用于等待某个特定进程的结束。参数pid指明要等待的子进程的PID，参数status的含义与wait()函数一致。上图所示的进程流图可以由下列程序实现:123456789101112131415#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int main() &#123; pid_t pid; int status; pid = fork(); if( pid==0 ) &#123; //To execute P2; exit(); &#125; else &#123; //To execute P1; &#125; wait(&amp;status); //To execute P3;&#125; 类似的，pthread线程库也提供了pthread_join()函数来等待线程的终止。示例程序:123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;int A;void subp1() &#123; printf(&quot;A in thread is %\n&quot;, A); A = 10;&#125;int main() &#123; pthread_t p1; int pid; A = 0; pid = fork(); if( pid == 0 ) &#123; printf(&quot;A in son process is %d\n&quot;, A); A = 100; exit(0); &#125; wait(); pthread_create(&amp;p1,NULL,subp1,NULL); pthread_join(p1,NULL); printf(&quot;A in father process is %d\n&quot;, A); return 0;&#125; Windows提供了WaitForSingleObject()函数可以实现类似功能。 3.8.4 信号量与使用方法Linux信号量函数在通用的信号量数组上进行操作，而不是一个单一的二值信号量上进行操作。这些系统调用主要包括: semget、semop和semctl。使用时需#include&lt;sys/sem.h&gt; 信号量创建semget函数来创建一个新的信号量或是获得一个已存在的信号量键值。函数原型int semget(key_t _key,int _nsems,int _semflg)， 返回值:成功的返回信号量的标识码，如果函数调用失败返回-1 第一个参数_key,为整型值，是允许其他的进程访问信号量的一个整型的变量。所以的信号都是通过间接的方式获得的，运行的程序会提供一个信号的键值，系统为每一个键值赋予一个信号量，其他的处理函数只能通过对semget函数的返回值进行处理。 第二个参数_nsems,参数表示所需要信号量的数目，几乎总是取值为1。semget()创建的是一个信号量数组，数组元素个数即为_nsems 第三个参数_semflg是一个标记集合，与open()函数的标记十分类似，低9位是信号量的权限，其作用与文件权限类似。另外这些标记可以与IPC_CREATE进行或操作来创建新的信号量。 信号量控制Linux提供了semctl函数来直接控制信号量的信息。函数原型int semctl(int sem_id,int sem_num,int command,...) 返回值：成功返回0，失败返回-1 参数sem_id: 信号量标识码，还是通过semget来获得的，是semget函数的一个返回值 参数sem_num: 信号量数组元素的下标，即指定对第几个信号量进行控制。 参数command: 是要执行的动作，常用值有两个: SETVAL: 用于为信号量赋初值 IPC_RMID: 当信号量不再需要时用于删除一个信号量标识 如果有第四个参数则是union semun。对信号量赋值时，需要提供该参数，其值通过union中的val指定。 信号量操作LInux提供semop()来操作信号量。函数原型int semop(int sem_id, struct sembuf *sem_ops, size_t num_sem_ops) 返回值：函数调用成功返回0，失败返回-1 参数semid: 由semget()函数所返回的信号量标识符 参数sops: 一个指向信号量结构体数组的指针，信号量的结构体至少有3个成员。其结构如下： 12345struct sembuf &#123; unsigned short sem_num; short sem_op; short sem_flg;&#125; 此结构中，第一个成员sem_num是信号量数组下标；sem_op是信号量的变化量值，通常两个值，-1对应P操作，+1对应V操作；sem_flg是信号操作标志，有两种状态，一个是SEM_UNDO,另一个是SEM_NOWAIT，通常设为0 Windows提供了一组API函数实现信号量及其操作 3.8.5 共享内存及应用实例共享内存是进程间通信中最简单的方式之一。共享内存允许两个或更多进程访问同一块内存，就如同 malloc() 函数向不同进程返回了指向同一个物理内存区域的指针。当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。因为所有进程共享同一块内存，共享内存在各种进程间通信方式中具有最高的效率。访问共享内存区域和访问进程独有的内存区域一样快，并不需要通过系统调用或者其它需要切入内核的过程来完成。同时它也避免了对数据的各种不必要的复制。因为系统内核没有对访问共享内存进行同步，您必须提供自己的同步措施。例如，在数据被写入之前不允许进程从共享内存中读取信息、不允许两个进程同时向同一个共享内存地址写入数据等。解决这些问题的常用方法是通过使用信号量进行同步。在 Linux 系统中，每个进程的虚拟内存是被分为许多页面的。这些内存页面中包含了实际的数据。每个进程都会维护一个从内存地址到虚拟内存页面之间的映射关系。尽管每个进程都有自己的内存地址，不同的进程可以同时将同一个内存页面映射到自己的地址空间中，从而达到共享内存的目的。要使用一块共享内存，进程必须首先分配它。随后需要访问这个共享内存块的每一个进程都必须将这个共享内存绑定到自己的地址空间中。当完成通信之后，所有进程都将脱离共享内存，并且由一个进程释放该共享内存块。 共享内存的分配分配一个新的共享内存块会创建新的内存页面。因为所有进程都希望共享对同一块内存的访问，只应由一个进程创建一块新的共享内存。再次分配一块已经存在的内存块不会创建新的页面，而只是会返回一个标识该内存块的标识符。一个进程如需使用这个共享内存块，则首先需要将它绑定到自己的地址空间中。这样会创建一个从进程本身虚拟地址到共享页面的映射关系。当对共享内存的使用结束之后，这个映射关系将被删除。当再也没有进程需要使用这个共享内存块的时候，必须有一个(且只能是一个)进程负责释放这个被共享的内存页面。进程通过调用shmget(Shared Memory GET，获取共享内存)来分配一个共享内存块。该函数的第一个参数是一个用来标识共享内存块的键值。彼此无关的进程可以通过指定同一个键以获取对同一个共享内存块的访问。不幸的是，其它程序也可能挑选了同样的特定值作为自己分配共享内存的键值，从而产生冲突。用特殊常量IPC_PRIVATE作为键值可以保证系统建立一个全新的共享内存块。该函数的第二个参数指定了所申请的内存块的大小。因为这些内存块是以页面为单位进行分配的，实际分配的内存块大小将被扩大到页面大小的整数倍。第三个参数是一组标志，通过特定常量的按位或操作来shmget。这些特定常量包括： IPC_CREAT：这个标志表示应创建一个新的共享内存块。通过指定这个标志，我们可以创建一个具有指定键值的新共享内存块。 IPC_EXCL：这个标志只能与 IPC_CREAT 同时使用。当指定这个标志的时候，如果已有一个具有这个键值的共享内存块存在，则shmget会调用失败。也就是说，这个标志将使线程获得一个“独有”的共享内存块。如果没有指定这个标志而系统中存在一个具有相同键值的共享内存块，shmget会返回这个已经建立的共享内存块，而不是重新创建一个。 模式标志：这个值由9个位组成，分别表示属主、属组和其它用户对该内存块的访问权限。其中表示执行权限的位将被忽略。指明访问权限的一个简单办法是利用&lt;sys/stat.h&gt;中指定，并且在手册页第二节stat条目中说明了的常量指定。例如，S_IRUSR和S_IWUSR分别指定了该内存块属主的读写权限，而 S_IROTH和S_IWOTH则指定了其它用户的读写权限。 下面例子中shmget函数创建了一个新的共享内存块(当shm_key已被占用时则获取对一个已经存在共享内存块的访问)，且只有属主对该内存块具有读写权限，其它用户不可读写。 int segment_id = shmget (shm_key, getpagesize (), IPC_CREAT | S_IRUSR| S_IWUSR ); 如果调用成功，shmget将返回一个共享内存标识符。如果该共享内存块已经存在，系统会检查访问权限，同时会检查该内存块是否被标记为等待摧毁状态。 共享内存的绑定要让一个进程获取对一块共享内存的访问，这个进程必须先调用 shmat(SHared Memory Attach，绑定到共享内存)。将 shmget 返回的共享内存标识符 SHMID 传递给这个函数作为第一个参数。该函数的第二个参数是一个指针，指向您希望用于映射该共享内存块的进程内存地址；如果您指定NULL则Linux会自动选择一个合适的地址用于映射。第三个参数是一个标志位，包含了以下选项： SHM_RND表示第二个参数指定的地址应被向下靠拢到内存页面大小的整数倍。如果您不指定这个标志，您将不得不在调用shmat的时候手工将共享内存块的大小按页面大小对齐。 SHM_RDONLY表示这个内存块将仅允许读取操作而禁止写入。 如果这个函数调用成功则会返回绑定的共享内存块对应的地址。通过 fork函数创建的子进程同时继承这些共享内存块；如果需要，它们可以主动脱离这些共享内存块。当一个进程不再使用一个共享内存块的时候应通过调用 shmdt(Shared Memory Detach，脱离共享内存块)函数与该共享内存块脱离。将由 shmat 函数返回的地址传递给这个函数。如果当释放这个内存块的进程是最后一个使用该内存块的进程，则这个内存块将被删除。对exit或任何exec族函数的调用都会自动使进程脱离共享内存块。 共享内存的释放调用 shmctl(“Shared Memory Control”，控制共享内存)函数会返回一个共享内存块的相关信息。同时shmctl允许程序修改这些信息。该函数的第一个参数是一个共享内存块标识。要获取一个共享内存块的相关信息，则为该函数传递 IPC_STAT作为第二个参数，同时传递一个指向一个 struct shmid_ds 对象的指针作为第三个参数。要删除一个共享内存块，则应将 IPC_RMID 作为第二个参数，而将NULL作为第三个参数。当最后一个绑定该共享内存块的进程与其脱离时，该共享内存块将被删除在结束使用每个共享内存块的时候都使用shmctl进行释放，以防止超过系统所允许的共享内存块的总数限制。调用 exit 和 exec 会使进程脱离共享内存块，但不会删除这个内存块。要查看其它有关共享内存块的操作的描述，请参考shmctl函数的手册页。 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/stat.h&gt;int main() &#123; int segment_id; char* shared_memory; struct shmid_ds shmbuffer; int segment_size; const int shared_segment_size = 0x6400; //分配一个共享内存块 segment_id = shmget(IPC_PRIVATE, shared_segment_size, IPC_CREAT|IPC_EXCL|S_IRUSR|S_IWUSR ); //绑定到共享内存块 shared_memory = (char*)shmat(segment_id, 0, 0); printf(&quot;shared memory attached at address %p\n&quot;, shared_memory); //确定共享内存的大小 shmctl(segment_id, IPC_STAT, &amp;shmbuffer); segment_size = shmbuffer.shm_segsz; printf(&quot;segment size: %d\n&quot;, segment_size); sprintf(shared_memory, &quot;Hello, world.&quot;); //在共享内存中写入一个字符串 shmdt(shared_memory); //脱离该共享内存块 shared_memory = (char*)shmat(segment_id, (void*) 0x500000, 0); //重新绑定该内存块 printf(&quot;shared memory reattached at address %p\n&quot;, shared_memory); printf(&quot;%s\n&quot;, shared_memory); //输出共享内存中的字符串 shmdt(shared_memory); //脱离该共享内存块 shmctl(segment_id, IPC_RMID, 0); //释放这个共享内存块 return 0;&#125; Windows提供了FileMapping机制来实现共享内存的功能 3.9 进程调度3.9.1 调度/分派结构系统中处于就绪状态的进程是处理机的竞争是由进程调度程序来协调的，进程调度的功能可以分为调度和分派两部分。其中调度的含义是依照确定的策略将一批进程排序，排在首位的进程一定是满足调度原则的、可被选择的进程。而分派则是当调度时机到来时，从就绪队列中移出一个进程并给它提供处理机的使用权。相应的调度程序和分派程序的功能是：调度程序负责将一个进程插入到就绪队列并按一定原则保持队列结构；分派程序是将进程从就绪队列中移出并建立该进程执行的机器状态。调度/分派结构如下图所示： 3.9.2 进程调度的功能 各进程PCB中记录该进程的执行情况，根据各进程的状态特征和资源需求情况，动态调整各PCB队列 当CPU空闲时，按照一定的策略从就绪队列上选择一个进程，确定其占用CPU的时间，准备进入CPU上去执行 进行进程上下文切换，即实施CPU的分配与回收进程上下文: 一个进程的上下文(contex)是进程的状态、数据结构和有关变量的值、CPU寄存器值、PCB和相关的程序等内容的集合; 任何进程是在其上下文中执行的，所以当某进程退出CPU时，必须及时保留其上下文的值尔后能顺利恢复该进程的执行 装入被调度进程的上下文，使其拥有CPU的执行控制权。 3.9.3 调度方式 非剥夺方式: 当有优先级更高的进程转变为就绪状态时，仍然让正在执行的进程继续执行，直到该进程完成或发生某事件(如提出I/O请求)而进入完成或阻塞状态时，才把处理机分配给重要而紧迫的进程，使之执行 可剥夺方式: 当有优先级更高的进程转变为就绪状态时，便暂停正在执行的进程，立即把处理机分配给高优先级的进程，这种方式称为可剥夺调度方式。所实施的策略就是可抢占调度策略 3.9.4 进程优先度调度算法较简单的进程状态变迁图如下:在此例中，指出了两种就绪状态：低优先就绪和高优先就绪。一个进程如果在运行中超过了它的时间量就进入低优先就绪，而当它从阻塞状态变为就绪状态时则进入高优先就绪队列。由此我们可以看出，进入低优先就绪队列的进程一般是计算量比较大的，即称受CPU限制的进程；而有阻塞状态变为高优先就绪的进程一般是输入量比较大的进程，即称受I/O现在的进程。图所示的状态变迁图说明的进程调度算法是： - 1.从高优先就绪队列中选择一个进程来进行。 - 2.如果高优先就绪队列为空，则从低优先就绪队列中选择一个进程运行。 这种调度策略优先照顾了I/O量大的进程。一种较为复杂的状态变迁图如下图所示：这种调度算法可用于具有页面存贮管理的分时操作系统中。在变迁图中，阻塞进程分为三组：等待终端I/O受阻，等待盘或带I/O受阻和等待页面I/O受阻。就绪进程页分为三组：高优先就绪、中优先就绪和低优先就绪。其调度策略是从高优先就绪队列中选取进程去运行，若此队列为空，则从较低优先就绪队列中选择进程。只有在无较高优先级的进程时才运行低优先级的就绪进程。进程先进先出调度算法(FIFO) - a.基本思想：进行进程调度时，每次从就绪队列中选择一个最先进入该队列的进程，把处理机分配给它，使之投入运行。直到它运行完毕或因等待I/O而处于阻塞状，才放弃处理机。 - b.优点： + 实现简单 + 适合于长作业，CPU 繁忙的作业 - c.缺点： + 若一个短作业在长作业之后到达就绪队列,将等待较长时间才能投入运行 + I/O繁忙型的作业，在CPU处理时，需要频繁地请求I/O，而每次I/O的操作时间较短，它们放弃CPU之后，不易再次获得CPU而需等待较长时间。 3.9.5 循环轮转调度 a. 基本思想: CPU处理时间分成固定大小的时间片，如果一个进程在进程调度过程中获得CPU之后用完了系统规定的时间片，但仍未运行完毕，则它自行释放CPU，由执行状态就绪状态，排在就绪队列尾，等待下一次调度。同时,进程调度又去调度当前就绪队列中的第一个进程。 b. 时间片选择: 时间片的选择非常重要，关系到整个系统的性能。选择时间片的原则：适当地选择，不仅要齐头并进 ，还要利益均等。 c. 确定时间片的四个因素: 1、系统响应时间(与时间片q成正比,与就绪队列中进程数目成反比) 2、当前就绪队列中进程数目 3 、进程转换时间 4、CPU处理能力: CPU速度越高，q越大；CPU速度越低，q越小。 d. 简单轮转法该算法是以就绪队列中的所有进程均以相等的速度向前进栈为特征的。时间片长度选择根据系统对响应时间要求T响和就绪队列中的最大进程数Nmax确定，即q=T响/Nmax。如果就绪队列中有k个就绪进程，时间片的长度为q秒，则每个进程在每kq的时间内可获得q秒的CPU时间，亦即每个进程是以1/K的实际CPU速度运行在处理机上。 优点: 使用和设计都较简单。 缺点: 没有考虑到特殊的有紧急事件的进程的发生。 e. 可变时间片基本思想: 时间片不固定，而是动态地确定时间片q=T响/Nmax,即按照用户响应时间的要求，按就绪队列中实际的进程数目来动态的确定时间片。当就绪队列中进程多时，时间片小；若就绪队列中进程少时，设置时间片大。 优点: 避免了进程调来调去，降低了系统关于进程交换的开销。 缺点: 设计及实现较复杂，而且系统在判断过程中也有较大的开销(判断当前就绪队列中有多少个进程) f. 多队列轮转法基本思想: 给出两种就绪状态高优先就绪和低优先就绪一个进程若在运行过程中系统分配给它的时间片用完，但它还未完成任务,则进入低优先就绪队列，而且因请求I/O而阻塞的进程I/O完成之后，它进入高优先就绪队列它的调度算法是： 1)CPU空闲时，首先从高优先就绪队列中选择一个进程运行，赋予时间片为100ms 2)如果高优先就绪队列为空，则从低优先就绪队列中选择一个进程运行，赋予时间片500ms 优点: 这种策略优先照顾了I/O量大的进程，使它们处高优先就绪队列，可以较快地被调度；而计算量比较大的进程，如果一个时间片用完后，就进入低优先就绪队列等待较长时间，但若它一旦被调度，则可以在CPU上较长时间(系统赋予它的时间片较大)，这样减少了交换次数 缺点: 增加了队列，系统开销增大了。 3.9.6 优先级调度算法优先级调度算法又称优先权调度算法，该算法既可以用于作业调度，也可以用于进程调度，该算法中的优先级用于描述作业运行的紧迫程度。在作业调度中，优先级调度算法每次从后备作业队列中选择优先级最髙的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。根据新的更高优先级进程能否抢占正在执行的进程，可将该调度算法分为： + 非剥夺式优先级调度算法。当某一个进程正在处理机上运行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在运行的进程继续运行，直到由于其自身的原因而主动让出处理机时(任务完成或等待事件)，才把处理机分配给更为重要或紧迫的进程。 + 剥夺式优先级调度算法。当一个进程正在处理机上运行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在运行的进程，将处理机分配给更重要或紧迫的进程。 而根据进程创建后其优先级是否可以改变，可以将进程优先级分为以下两种： 静态优先级。优先级是在创建进程时确定的，且在进程的整个运行期间保持不变。确定静态优先级的主要依据有进程类型、进程对资源的要求、用户要求。 动态优先级。在进程运行过程中，根据进程情况的变化动态调整优先级。动态调整优先级的主要依据为进程占有CPU时间的长短、就绪进程等待CPU时间的长短。 3.9.7 多级反馈队列调度多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展，通过动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面的系统目标。例如，为提高系统吞吐量和缩短平均周转时间而照顾短进程；为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程；同时，也不必事先估计进程的执行时间多级反馈队列调度算法的实现思想如下： + 应设置多个就绪队列，并为各个队列赋予不同的优先级，第1级队列的优先级最高，第2级队列次之，其余队列的优先级逐次降低。 + 赋予各个队列中进程执行时间片的大小也各不相同，在优先级越高的队列中，每个进程的运行时间片就越小。例如，第2级队列的时间片要比第1级队列的时间片长一倍，……第i+1级队列的时间片要比第i级队列的时间片长一倍。 + 当一个新进程进入内存后，首先将它放入第1级队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS 原则等待调度执行；如果它在第2级队列中运行一个时间片后仍未完成，再以同样的方法放入第3级队列……如此下去，当一个长进程从第1级队列依次降到第 n 级队列后，在第n级队列中便釆用时间片轮转的方式运行。 + 仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；仅当第1 ~ (i-1)级队列均为空时，才会调度第i级队列中的进程运行。如果处理机正在执行第i级队列中的某进程时，又有新进程进入优先级较高的队列（第 1 ~ (i-1)中的任何一个队列），则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。 多级反馈队列的优势有： - 终端型作业用户：短作业优先。 - 短批处理作业用户：周转时间较短。 - 长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理。 3.9.8 线程调度为了提高并行处理能力，现代操作系统多采用多线程技术，一般对线程调度采用优先调度算法。线程就绪队列按优先级的高低排序。对于优先级相同的进程，则遵从队列”先进先出”的原则，当一个在就绪队列中排列的线程分配到了处理机进入运行状态之后，这个线程称为是被调度的。WIndows中线程总共分为32个优先级，具体看下图：每个线程都会被赋予一个从0到31的优先级号码。当系统要分配线程时间片的时候，它首先是找到所有线程中优先级别最高的一个线程进行运行，在运行期间，如果出现一个可被调度的更高优先级的线程，则会中断当前的运行，而执行更高优先级的线程，否则，一直执行到时间片用完，这时，系统会查看所有的可调度线程。 + 如果这些线程的优先级都比当前的线程优先级低，那么系统将继续执行当前的线程，其他的线程将不会得到CPU，如果经过3~5秒一直处于这样的状态，那么系统会动态的提升某些渴求调度线程的优先级，让他们占用CPU一定时间，然后再降回原来的优先级。 + 如果存在相同优先级的线程，则系统会将CPU分配给那个线程。 总的来说，优先级高的线程基本上会一直占有CPU，而不给低优先级线程以机会。同时不管当前线程的时间片是否用完，如果出现可调度的更高优先级的线程，那么就会打断当前的线程，去执行高优先级的线程。因此，高优先级的线程不应该一直占有CPU，应该注意时常将其挂起。 Footnotes1.http://202.114.32.200:8080/courseware/208310/20831011/ ↩]]></content>
      <categories>
        <category>science</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>operating system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Game Theory]]></title>
    <url>%2F2015%2F08%2F26%2FgameTheory%2F</url>
    <content type="text"><![CDATA[1. 一场博弈的四个基本要素 至少两个参与者。博弈论的参与者又被称为决策主体，也就是在博弈中制定决策的人 利益 策略。在博弈中，决策主体根据获得的信息和自己的判断，制定出一个行动方案，这个行动方案便是策略 信息。利益是博弈的目的，策略是获得利益的手段，而信息就是制定策略的依据 2. 博弈的分类2.1 合作博弈和非合作博弈根据博弈的参与者之间是否有一个具有约束力的协议，博弈可分为合作博弈和非合作博弈 合作博弈。合作博弈并不是指参与者之间有合作的意向，或是合作态度，而是参与者之间有具有约束力的协议、约定或者契约，参与者必须在这些协议的范围内进行博弈。合作博弈是研究合作中如何分配利益的问题，目的是使得协议框架内所有参与者都满意。 非合作博弈。非合作博弈指参与者在博弈的时候，无法达成一个对各方都有约束力的协议。非合作博弈的目的是如何为自己争取最大化的利益，并不考虑其他参与者的利益。 2.2 静态博弈与动态博弈按照参与者选择策略、作出决定的先后顺序，可分为静态博弈与动态博弈 静态博弈。如果参与者们同时选择策略，或者虽然有先后，但是后做出策略的参与者并不知道其他参与者的策略，那就是静态博弈，例如”剪刀石头布” 动态博弈。如果参与者的行动有先后顺序，并且后者是在了解前者策略的前提下制定自己的策略，这种情况就是动态博弈，如打扑克 2.3 完全信息博弈和不完全信息博弈基于对其他参与者的信息掌握程度，可分为完全信息博弈和不完全信息博弈 完全信息博弈是指博弈中对其他参与者特征、利益、可能选择的策略等信息都有一个准确的了解 不完全信息博弈是指博弈中对其他参与者特征、利益、可能选择的策略等信息没有一个准确的了解，或者有多个参与者的情况下，只有对个别参与者的信息了解 2.4 负和博弈、零和博弈与正和博弈按照博弈的结果来分，博弈分为负和博弈、零和博弈与正和博弈 负和博弈。负和博弈指博弈的参与者最后得到的收获都小于付出，都没有占到便宜，是一种两败俱伤的博弈 零和博弈。零和博弈是指参与者中一方获益，另一方损失，并且参与者之间获得的利益与损失之和为零，如赌博 正和博弈。正和博弈又被称为双赢博弈、合作博弈，是指参与者都能获益，或者一方的收益增加并不影响其他参与者的利益，这种博弈被认为是结局最好的一种博弈，也就是双赢 3. 纳什均衡Wiki简单来说就是，多人参加的博弈中，每个人根据他人的策略制定自己的最优策略，所有人的这些策略组合成一个策略组合，在这个策略组合里，没有人会主动改变自己的策略，那样会降低他的收益，只要没有人做出策略调整，任何一个理性的参与者都不会主动改变自己的策略，这个时候，所有参与者的策略并达到了一种平衡，这种平衡就是”纳什均衡”严谨的”纳什均衡”定义为：在博弈\(G=\{S_1,\cdots,\cdots,S_n: u_1,\cdots,\cdots,u_n\}\)中，如果由各个博弈方的各一个策略组成的某个策略组合\(s_1^{*},\ldots,\ldots,s_n^{*}\)中，任一博弈方的策论\(s_i^{*}\)都是对其余博弈方策略的组合\(s_1^{*},\ldots,s_{i-1}^{*},s_{i+1}^{*},\ldots,s_n^{*}\)的最佳对策，也即\(u_i(s_1^{*},\ldots,s_{i-1}^{*},s_i^{*},s_{i+1}^{*},\ldots,s_n^{*}) \gequ_i(s_1^{*},\ldots,s_{i-1}^{*},s_{ij}^{*},s_{i+1}^{*},\ldots,s_n^{*})\)对任意\(s_{ij}\in S_i\)都成立，则称\(s_1^{*},\ldots,\ldots,s_n^{*}\)为G的一个“纳什均衡” 4. 夏普里值方法夏普里值方法以每个局中人对联盟边际贡献大小来分配联盟的总收益，它的目标是构造一种综合考虑冲突各方要求的折中的效用分配方案，从而保证分配的公平性用夏普里值方法解决合作利益分配问题时，需要满足以下两个条件: 局中人之间地位平等 所有局中人得到的利益之和是联盟的总财富]]></content>
      <categories>
        <category>science</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>game theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习四]]></title>
    <url>%2F2015%2F08%2F25%2FmachineLearning04%2F</url>
    <content type="text"><![CDATA[1. Logistic回归利用Logistic回归进行分类的主要思想是: 根据现有数据对分类边界线建立回归公式,以此进行分类 2. 基于Logistic回归和Sigmoid函数的分类我们想要的函数是能接受所有的输入然后预测出类别。例如,在两个类的情况下,上述函数输出0或1,我们接触过的函数 Heaviside step function(单位阶跃函数)即是。然而此函数在跳跃点上从0瞬间跳跃到1，这个瞬间跳跃过程有时很难处理。Sigmoid函数有类似的性质但是更容易处理，其具体计算公式为：\(\sigma(z)=\frac{1}{1+e^{-z}}\)为了实现Logistic回归分类器，我们可以在每个特征上都乘以一个回归系数，然后把所有的结果值相加，将这个总和代入Sigmoid函数中，进而得到一个范围在0~1之间的数值。任何大于0.5的数据被分入1类，小于0.5即被归为0类。所以，Logistic回归也可以看成是一种概率估计确定了分类器的函数形式后，问题变为求最佳回归系数。 3. 基于最优化方法的最佳回归系数确定Sigmoid函数的输入记为z，由下公式得出:\(z=w_0x_0+w_1x_1+\cdots+w_nx_n=w^Tx\)其中向量x是分类器的输入数据，向量w就是我们要找到的最佳参数(系数)，从而使分类器尽可能精确。 3.1 最优化方法：梯度上升法梯度上升法基于的思想是:要找到某函数的最大值最好的方法是沿着该函数的梯度方向做探寻，如果梯度记为\(\nabla\)，则函数\(f(x,y)\)的梯度由下式表示：\(\nabla f(x,y)=\begin{bmatrix}\frac{\partial f(x,y)}{\partial x} \\\frac{\partial f(x,y)}{\partial y}\end{bmatrix}\)其中，函数f(x,y)必须在待计算的点上有定义并可微。具体函数示例图如下: 梯度上升算法到达每个点后都会重新估计移动的方向。从P0开始，计算完该点的梯度，函数就根据梯度移动到下一点P1，在P1点梯度再次被重新计算，并沿新的梯度方向移动到P2，如此循环迭代直到满足停止条件。迭代过程中，梯度算子总是保证我们能选取到最佳的移动方向。可以看到，梯度算子总是指向函数值增长最快的方向，这里所说的是移动方向，而未提到移动量的大小，该变量称为步长，记作\(\alpha\)，用向量表示的话，梯度上升算法的迭代公式如下：\(w:=w+\alpha \nabla_wf(w)\)该公式将一直被迭代执行，直到达到某个停止条件为止Addition: 梯度下降算法只需要将上式的+改为－。梯度上升算法用来求函数的最大值，梯度下降算法用来求函数的最小值 训练算法下图中有100个样本点，每个点包含两个数值型特征：X1和X2。在此数据集上，通过梯度上升算法找到最佳回归系数，也就是拟合出Logistic回归模型的最佳参数梯度上升伪代码：12345每个回归系数初始化为1重复R次： 计算整个数据集的梯度 使用alpha × gradient更新回归系数的向量 返回回归系数 3.2 分析数据: 画出决策边界上面已经解出了一组回归系数，它确定了不同类别数据间的分割线，以下函数画出分割线:12345678910111213141516171819202122def plotBestFit(wei): import matplotlib.pyplot as plt weights = wei.getA() dataMat,labelMat=loadDataSet() dataArr = array(dataMat) n = shape(dataArr)[0] xcord1 = []; ycord1 = [] xcord2 = []; ycord2 = [] for i in range(n): if int(labelMat[i])== 1: xcord1.append(dataArr[i,1]); ycord1.append(dataArr[i,2]) else: xcord2.append(dataArr[i,1]); ycord2.append(dataArr[i,2]) fig = plt.figure() ax = fig.add_subplot(111) ax.scatter(xcord1, ycord1, s=30, c='red', marker='s') ax.scatter(xcord2, ycord2, s=30, c='green') x = arange(-3.0, 3.0, 0.1) y = (-weights[0]-weights[1]*x)/weights[2] ax.plot(x, y) plt.xlabel('X1'); plt.ylabel('X2'); plt.show() 3.3 训练算法：随机梯度上升梯度上升算法在每次更新回归系数时都需要遍历整个数据集，该方法处理100个左右的数据集时尚可，若数据集过大则计算复杂度太高，改进方法之一是一次仅用一个样本点来更新回归系数，该方法称为随机梯度上升算法。由于可以在新样本到来时对分类器进行增量式更新，因而随机梯度上升算法是一个在线学习算法，与”在线学习”相对应，一次处理所有系数称为”批处理”伪代码：12345每个回归系数初始化为1对数据集中每个样本： 计算该样本的梯度 使用alpha × gradient更新回归系数值返回回归系数值 实际代码：123456789def stocGradAscent0(dataMatrix, classLabels): m,n = shape(dataMatrix) alpha = 0.01 weights = ones(n) for i in range(m): h = sigmoid(sum(dataMatrix[i]*weights)) error = classLabels[i] - h weights = weights + alpha * error * dataMatrix[i] return weights 运行一次并不能看出最终效果，修改代码使其在数据集上运行200(or other)次。而对于不同的系数，迭代达到稳定的次数不同，有的也许只要50次，而有的则会来回波动，为了避免来回波动，从而收敛到某个值，以及加快收敛速度，代码改进：123456789101112def stocGradAscent1(dataMatrix, classLabels, numIter=150): m,n = shape(dataMatrix) weights = ones(n) for j in range(numIter): dataIndex = range(m) for i in range(m): alpha = 4/(1.0+j+i)+0.01 randIndex = int(random.uniform(0,len(dataIndex))) h = sigmoid(sum(dataMatrix[randIndex]*weights)) error = classLabels[randIndex] - h weights = weights + alpha * error * dataMatrix[randIndex] del(dataIndex[randIndex]) return weights - 一方面，alpha在每次迭代时都会调整，这会缓解数据波动或高频波动，另外虽然alpha随着迭代次数不断减小，但不会减为0，这样做是为了保证多次迭代后新数据仍有一定影响。如果要处理的问题是动态变化的，可以适当加大上述常数项，以确保新值获得更大的回归系数。在降低alpha函数中，每次减少1/(j+i)，其中j是迭代次数，i是样本点的下标，这样j&amp;lt;&amp;lt;max(i)时，alpha就不是严格下降的，避免严格下降也常用于模拟退火等优化算法中 - 另一方面，通过随机选取样本来更新回归系数，这将减少周期性的波动 - 此外，改进算法增加了一个参数确定迭代次数 4. 示例：预测病马的死亡率数据来源于UCI机器学习数据库，数据包含368个样本和28个特征。该数据集部分指标主观难以测量，且数据集中有30%的值是缺失的 4.1 准备数据处理数据中的缺失值, 可选做法有： 使用可用特征的均值来填补缺失值 使用特殊值来填补缺失值，如-1 忽略有缺失的样本 使用相似样本的均值填补缺失值 使用另外的机器学习算法预测缺失值 这里我们将所有的缺失值用0替代，因为其恰好能用于Logistic回归，在回归系数更新公式中:weights = weights + alpha * error * dataMatrix[randIndex]如果dataMatrix的某特征对应0，则该特征将不做更新。另外由于sigmoid(0)=0.5，它对结果的预测不具有任何倾向性如果在测试数据集中发现一条数据的类别标签已经缺失，最简单的做法是将该数据丢弃 4.2 测试算法用Logistic回归进行分类, Logistic回归分类函数：1234567891011121314151617181920212223242526272829303132333435def classifyVector(inX, weights): prob = sigmoid(sum(inX*weights)) if prob &gt; 0.5: return 1.0 else: return 0.0def colicTest(): frTrain = open('horseColicTraining.txt') frTest = open('horseColicTest.txt') trainingSet = []; trainingLabels = [] for line in frTrain.readlines(): currLine = line.strip().split('\t') lineArr =[] for i in range(21): lineArr.append(float(currLine[i])) trainingSet.append(lineArr) trainingLabels.append(float(currLine[21])) trainWeights = stocGradAscent1(array(trainingSet), trainingLabels, 500) errorCount = 0; numTestVec = 0.0 for line in frTest.readlines(): numTestVec += 1.0 currLine = line.strip().split('\t') lineArr =[] for i in range(21): lineArr.append(float(currLine[i])) if int(classifyVector(array(lineArr), trainWeights))!= int(currLine[21]): errorCount += 1 errorRate = (float(errorCount)/numTestVec) print "the error rate of this test is: %f" % errorRate return errorRatedef multiTest(): numTests = 10; errorSum=0.0 for k in range(numTests): errorSum += colicTest() print "after %d iterations the average error rate is: %f" % (numTests, errorSum/float(numTests)) classifyVector()，它以回归系数和特征向量作为输入来计算对应的Sigmoid值colicTest()是用于打开测试集和训练集，并对数据进行格式化处理的函数multiTest()，其功能是调用colicTest()10次并求结果的平均值]]></content>
      <categories>
        <category>techonology</category>
        <category>ai</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
        <tag>logistic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习三]]></title>
    <url>%2F2015%2F08%2F19%2FmachineLearning03%2F</url>
    <content type="text"><![CDATA[1. 朴素贝叶斯朴素贝叶斯的两个假设： 特征之间相互独立，即一个单词出现的可能性与它和其他单词相邻没有关系 每个特征同等重要 2. 文本分类2.1 准备数据从文本中构建词向量, 将文本看成单词向量或词条向量(也就是说将句子转换为向量)1234567891011121314151617181920212223def loadDataSet(): postingList=[['my', 'dog', 'has', 'flea', 'problems', 'help', 'please'], ['maybe', 'not', 'take', 'him', 'to', 'dog', 'park', 'stupid'], ['my', 'dalmation', 'is', 'so', 'cute', 'I', 'love', 'him'], ['stop', 'posting', 'stupid', 'worthless', 'garbage'], ['mr', 'licks', 'ate', 'my', 'steak', 'how', 'to', 'stop', 'him'], ['quit', 'buying', 'worthless', 'dog', 'food', 'stupid']] classVec = [0,1,0,1,0,1] #1 is abusive, 0 not return postingList,classVec def createVocabList(dataSet): vocabSet = set([]) #create empty set for document in dataSet: vocabSet = vocabSet | set(document) #union of the two sets return list(vocabSet)def setOfWords2Vec(vocabList, inputSet): returnVec = [0]*len(vocabList) for word in inputSet: if word in vocabList: returnVec[vocabList.index(word)] = 1 else: print "the word: %s is not in my Vocabulary!" % word return returnVec loadDataSet()创建了一些实验样本createVocabList()会创建一个包含在所有文档中出现的不重复词的列表获取词汇表后，使用setOfWords2Vec()函数，该函数的输入参数为词汇表及某个文档，输出的是文档向量，向量的每一元素为1或0，分别表示在词汇表中的单词在输入文档中是否出现 2.2 训练算法从词向量计算概率12345678910111213141516def trainNB0(trainMatrix,trainCategory): numTrainDocs = len(trainMatrix) numWords = len(trainMatrix[0]) pAbusive = sum(trainCategory)/float(numTrainDocs) p0Num = ones(numWords); p1Num = ones(numWords) #change to ones() p0Denom = 2.0; p1Denom = 2.0 #change to 2.0 for i in range(numTrainDocs): if trainCategory[i] == 1: p1Num += trainMatrix[i] p1Denom += sum(trainMatrix[i]) else: p0Num += trainMatrix[i] p0Denom += sum(trainMatrix[i]) p1Vect = log(p1Num/p1Denom) #change to log() p0Vect = log(p0Num/p0Denom) #change to log() return p0Vect,p1Vect,pAbusive 上述训练算法原本应该为：12345p0Num = zeros(numWords); p1Num = zeros(numWords)p0Denom = 0; p1Denom = 0......p1Vect = p1Num/p1Denomp0Vect = p0Num/p0Denom 原来初始化为0，使用zeros()，然而若其中一个概率值为0，则最终也为0，故改用ones()，并且同时修改p0(1)Denom为2原来也没有对数，为了防止乘积数字太小下溢出为0，改用对数 代码函数中的输入参数为文档矩阵trainMatrix，以及由每篇文档类别标签所构成的向量trainCategory。首先计算文档属于侮辱性文档(class=1)的概率，即P(1)，因为这是一个二分类问题较为简单，多于两类的分类问题要对代码稍作修改；之后计算条件概率；最后对每个元素除以该类别中的总词数 2.3 测试算法根据现实情况修改分类器123456789101112131415161718192021def classifyNB(vec2Classify, p0Vec, p1Vec, pClass1): p1 = sum(vec2Classify * p1Vec) + log(pClass1) #element-wise mult p0 = sum(vec2Classify * p0Vec) + log(1.0 - pClass1) if p1 &gt; p0: return 1 else: return 0def testingNB(): listOPosts,listClasses = loadDataSet() myVocabList = createVocabList(listOPosts) trainMat=[] for postinDoc in listOPosts: trainMat.append(setOfWords2Vec(myVocabList, postinDoc)) p0V,p1V,pAb = trainNB0(array(trainMat),array(listClasses)) testEntry = ['love', 'my', 'dalmation'] thisDoc = array(setOfWords2Vec(myVocabList, testEntry)) print testEntry,'classified as: ',classifyNB(thisDoc,p0V,p1V,pAb) testEntry = ['stupid', 'garbage'] thisDoc = array(setOfWords2Vec(myVocabList, testEntry)) print testEntry,'classified as: ',classifyNB(thisDoc,p0V,p1V,pAb) 使用bayes.testingNB()测试算法。 2.4 准备数据文档词袋模型: 我们将每个词的出现与否作为一个特征，这可以被描述为词集模型(set-of-words model)，如果一个词在文档中出现不止一次，这可能意味着包含该词是否出现在文档中所不能表达的某种信息，这种方法被称为词袋模型(bag-of-words model)。在词袋中，每个单词可出现多次，而词集中每个词只能出现一次，为适应词袋模型，将setOfWords2Vec()函数稍作修改为bagOfWords2VecMN()123456def bagOfWords2VecMN(vocabList, inputSet): returnVec = [0]*len(vocabList) for word in inputSet: if word in vocabList: returnVec[vocabList.index(word)] += 1 return returnVec 3. 过滤垃圾邮件3.1 准备数据切分文本: 利用正则表达式切分文本12345emailText = open('email/ham/6.txt').read()import reregExpress = re.compile('\\w*')listOfTokens = regExpress.split(emailText)[tok.lower() for tok in listOfTokens if len(tok) &gt; 0] 3.2 测试算法使用朴素贝叶斯进行交叉验证1234567891011121314151617181920212223242526272829303132333435def textParse(bigString): #input is big string, #output is word list import re listOfTokens = re.split(r'\W*', bigString) return [tok.lower() for tok in listOfTokens if len(tok) &gt; 2] def spamTest(): docList=[]; classList = []; fullText =[] for i in range(1,26): wordList = textParse(open('email/spam/%d.txt' % i).read()) docList.append(wordList) fullText.extend(wordList) classList.append(1) wordList = textParse(open('email/ham/%d.txt' % i).read()) docList.append(wordList) fullText.extend(wordList) classList.append(0) vocabList = createVocabList(docList)#create vocabulary trainingSet = range(50); testSet=[] #create test set for i in range(10): randIndex = int(random.uniform(0,len(trainingSet))) testSet.append(trainingSet[randIndex]) del(trainingSet[randIndex]) trainMat=[]; trainClasses = [] for docIndex in trainingSet:#train the classifier (get probs) trainNB0 trainMat.append(bagOfWords2VecMN(vocabList, docList[docIndex])) trainClasses.append(classList[docIndex]) p0V,p1V,pSpam = trainNB0(array(trainMat),array(trainClasses)) errorCount = 0 for docIndex in testSet: #classify the remaining items wordVector = bagOfWords2VecMN(vocabList, docList[docIndex]) if classifyNB(array(wordVector),p0V,p1V,pSpam) != classList[docIndex]: errorCount += 1 print "classification error",docList[docIndex] print 'the error rate is: ',float(errorCount)/len(testSet) #return vocabList,fullText spamTest()对贝叶斯垃圾邮件分类器进行自动化处理，导入文件夹spam和ham下的文本文件，并将它们解析为词列表，接下来构建一个测试集和训练集，两个集合中的元素是被随机选出的。随机选取数据的一部分为训练集，而剩余部分作为测试集的过程称为留存交叉验证(hold-out cross validation)。重复多次求平均值可以更好的估计错误率 4. 示例使用朴素贝叶斯分类器从个人广告中获取区域倾向 4.1 收集数据导入RSS源, 安装feedparser库pip install feedparser, 使用方法如下:123import feedparserny = feedparser.parse('http://newyork.craigslist.org/stp/index.rss')print ny['entries'] RSS源分类器及高频词去除函数123456789101112131415161718192021222324252627282930313233343536373839404142def calcMostFreq(vocabList,fullText): import operator freqDict = &#123;&#125; for token in vocabList: freqDict[token]=fullText.count(token) sortedFreq = sorted(freqDict.iteritems(), key=operator.itemgetter(1), reverse=True) return sortedFreq[:30] def localWords(feed1,feed0): import feedparser docList=[]; classList = []; fullText =[] minLen = min(len(feed1['entries']),len(feed0['entries'])) for i in range(minLen): wordList = textParse(feed1['entries'][i]['summary']) docList.append(wordList) fullText.extend(wordList) classList.append(1) #NY is class 1 wordList = textParse(feed0['entries'][i]['summary']) docList.append(wordList) fullText.extend(wordList) classList.append(0) vocabList = createVocabList(docList)#create vocabulary top30Words = calcMostFreq(vocabList,fullText) #remove top 30 words for pairW in top30Words: if pairW[0] in vocabList: vocabList.remove(pairW[0]) trainingSet = range(2*minLen); testSet=[] #create test set for i in range(20): randIndex = int(random.uniform(0,len(trainingSet))) testSet.append(trainingSet[randIndex]) del(trainingSet[randIndex]) trainMat=[]; trainClasses = [] for docIndex in trainingSet:#train the classifier (get probs) trainNB0 trainMat.append(bagOfWords2VecMN(vocabList, docList[docIndex])) trainClasses.append(classList[docIndex]) p0V,p1V,pSpam = trainNB0(array(trainMat),array(trainClasses)) errorCount = 0 for docIndex in testSet: #classify the remaining items wordVector = bagOfWords2VecMN(vocabList, docList[docIndex]) if classifyNB(array(wordVector),p0V,p1V,pSpam) != classList[docIndex]: errorCount += 1 print 'the error rate is: ',float(errorCount)/len(testSet) return vocabList,p0V,p1V 移除高频词是由于词汇表中的一小部分单词却占据了所有文本用词的一大部分，产生这种现象的原因是语言中大部分都是冗余和结构辅助性内容。另一个常用方法是不仅移除高频词，同时从某个预定词表中移除结构上的辅助词，该词表称为停用词表(stop word list)，可以在网上找到(例如 http://www.ranks.nl/resources/stopwords.html)通过以下命令测试上述代码：1234ny = feedparser.parse('http://newyork.craigslist.org/stp/index.rss')sf = feedparser.parse('http://sfbay.craigslist.org/stp/index.rss')vocabList, pSF, pNY = bayes.localWords(ny,sf)vocabList, pSF, pNY = bayes.localWords(ny,sf) 为了得到错误率的精确估计，应该多次进行上述实验取平均值 4.2 分析数据显示地域相关的用词, 可以先对向量pSF和pNY进行排序, 然后按照顺序将词打印出来。123456789101112131415def getTopWords(ny,sf): import operator vocabList,p0V,p1V=localWords(ny,sf) topNY=[]; topSF=[] for i in range(len(p0V)): if p0V[i] &gt; -6.0 : topSF.append((vocabList[i],p0V[i])) if p1V[i] &gt; -6.0 : topNY.append((vocabList[i],p1V[i])) sortedSF = sorted(topSF, key=lambda pair: pair[1], reverse=True) print "SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**" for item in sortedSF: print item[0] sortedNY = sorted(topNY, key=lambda pair: pair[1], reverse=True) print "NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**" for item in sortedNY: print item[0] getTopWords()使用两个RSS源作为输入，然后训练并测试朴素贝叶斯分类器，返回使用的概率值。bayes.getTopWords(ny,sf)可查看运行结果]]></content>
      <categories>
        <category>techonology</category>
        <category>ai</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
        <tag>bayes decision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模式识别二]]></title>
    <url>%2F2015%2F08%2F17%2FpatternRecognition02%2F</url>
    <content type="text"><![CDATA[贝叶斯决策1. 基本规则贝叶斯决策理论就是用统计概率的方法研究随机模式的决策问题。用贝叶斯决策理论方法进行分类时要求满足以下两个条件： 1)各类别总体的概率分布是已知的 2)要决策的类别数是一定的 在统计模式识别中，模式分类问题实际上就是把特征空间分割成若干个区域，每一个区域对应一个模式类别。对于确定性模式，由于模式样本的观测值是确定的，所以样本都会被正确地区分到相应的类型区域中。然而对大多数情况而言，这是非常理想的概率分布，许多实际情况下，即使在类型A的条件下，模式样本x位于区域A的概率也小于1，而位于B的概率大于0，这种交错分布的样本使分类发生错误，这是模式随机性的一种体现。如何使分类错误率尽可能小是研究各种分类方法的中心议题。 2. 相关概念 1)先验概率：预先已知的或者可以估计的模式识别系统位于某种类型的概率 2)类条件概率密度函数：系统位于某种类型条件下模式样本X出现的概率密度分布函数。为了强调是同一事物内部，因此这种分布密度函数往往表示成条件概率的形式，即\(P(X|Y)\) 3)后验概率：系统在某个具体的模式样本X条件下位于某种类型的概率。一个具体事物属于某种类别的概率，比如一个学生用特征向量X表示，他/她是男性或女性的概率表示成\(P(Male|X)\)和\(P(Female|X)\)，这就是后验概率，而一个具体事物必然有所属，故有\(P(Male|X)+P(Female|X)=1\)的约束，这与类分布密度函数是不同的。后验概率与先验概率也不同，后验概率涉及一个具体事物，而先验概率是泛指一类事物，因此\(P(Male|X)\)和\(P(Male)\)是不同的概念。后验概率可以根据贝叶斯公式计算，它直接用作分类判别的依据。 4)贝叶斯公式：两个事物X与w联合出现的概率称为联合概率，可写成\(P(X,w)\)，而它们又可与条件概率联系起来，即\(P(X,w)=P(X|w)P(w)=P(w|X)P(X)\)，这就是贝叶斯公式。如果将上式中各个项与先验概率、类条件概率密度函数以及后验概率联合起来，可以找到利用先验概率和类条件概率密度函数来计算后验概率的方法 3. 几种常用的决策规则3.1 最小错误率的贝叶斯决策基于最小错误概率的贝叶斯决策理论就是按照后验概率的大小作判决的，其决策规则为：如果\(P(w_1|x)&gt;P(w_2|x)\)，则\(x\in w_1\)，否则\(x\in w_2\)而上式中：$$\begin{equation}\begin{cases}P(w_i|x)=\frac{P(x|w_i)}{P(x)}P(w_i) \\P(x)=\sum_{j=1}^2P(x|w_j)P(w_j)\end{cases}\nonumber\end{equation}$$因为分母P(x)在决策时不起作用，最小错误率的决策规则的其他表达形式： 1) 如果\(P(x|w_1)P(w_1)&gt;P(x|w_2)P(w_2)\)，则\(x\in w_1\)，否则\(x\in w_2\) 2) 对于1还可以用比值方式表示，得到相应决策规则为：如果\(l(x)=\frac{P(x|w_1)}{P(x|w_2)}&gt;\frac{P(w_2)}{P(w_1)}\)，则\(x\in w_1\)，否则\(x\in w_2\)我们称\(P(x|w_i)\)关于x的似然函数或似然，式中\(l(x)\)称为似然比，\(\frac{P(w_2)}{P(w_1)}\)为似然比的阈值。因此贝叶斯决策法则也可以表达为：如果似然比超过某个阈值\(\frac{P(w_2)}{P(w_1)}\)（它与x无关），则做决策\(x\in w_1\)，否则\(x\in w_2\) 3) 对于2中的\(l(x)\)取自然对数的负值，决策规则可写为：如果\(h(x)=-\ln[l(x)]=-\ln P(x|w_1)+\ln P(x|w_2)&lt;\ln\frac{P(w_1)}{P(w_2)}\)，则\(x\in w_1\)，否则就判定\(x\in w_2\) 以上为两个类别且模式只有一个特征的情况，考虑多个类别并且模式具有多个特征情况下的最小错误率贝叶斯决策规则：设\(\Omega=\{w_1,w_2,\ldots,w_c\}\)是c个类别状态的有限集合，特征向量X是d维随机向量，\(P(X|w_i)\)是模式向量X在\(w_i\)状态下的类条件概率密度，\(P(w_i)\)为\(w_i\)类的先验概率，则根据贝叶斯公式，后验概率\(P(w_i|X)=\frac{P(X|w_i)}{P(X)}P(w_i)\)，其中：\(P(X)=\sum_{j=1}^cP(X|w_j)P(w_j)\)。这时最小错误率的贝叶斯决策法为：如果存在\(P(w_i|X)&gt;P(w_j|X)\)对于一切\(i\neq j\)成立，则决策为\(w_i\)需要注意的是：当我们考虑一个特征时，只用一个标量x表示；而对于多个特征，则要用向量X代替标量x。另外需要指出的是，如果两种类别的决策概率几近相等，而不做出决定又不太重要时，可以选择拒绝决策。 3.2 最小风险的贝叶斯决策从不同性质的错误会引起不同程度的损失这一考虑出发，我们宁可扩大一些总的错误率，也要使总的损失减小，因此引进一个与损失有关联的、更为广泛的概念—风险。在作出决策时，要考虑所承担的风险，最小风险的贝叶斯决策规则正是为了体现这一点而产生的，把各种分类错误引起的损失考虑进去的贝叶斯决策法则。在最小错误概率的贝叶斯决策方法中，分类时的决策单纯取决于观测值X对各类的后验概率中之最大值，因而也就无法估计做出错误决策所带来的损失，为此不妨将做出判决的依据从单纯考虑后验概率最大值，改为对该观测值X条件下各状态后验概率求加权和的方式：\(R_i(X)=\sum_{j=1}^c\lambda_j^{(i)}P(w_j|X)\)，式中\(\lambda_j^{(i)}\)表示观测样本X实属类别j，而被判定为状态i时所造成的损失；\(R_i(X)\)则表示了观测值X被判为i类时损失的均值。因此加权和\(R_i(X)\)衡量了观测样本X被判为状态\(w_i\)所需承担的风险。下面我们给出一些确切的定义，然后讨论最小风险的贝叶斯决策规则。 1)自然状态与状态空间。自然状态是指待识别对象的类别，而状态空间是由所有自然状态所组成的空间，\(\Omega=\{w_1,w_2,\cdots,w_c\}\) 2)决策与决策空间。在决策论中，对分类问题所做的判决，称之为决策，由所有决策组成的空间称为决策空间。决策不仅包括根据观测值将样本划归哪一类别(状态)，还可以包括其他决策，如”拒绝”等，因此决策空间内决策总数可以不等于类别数c，表示成如下形式：\(A=\{\alpha_1,\alpha_2,\cdots,\alpha_a\}\) 3)损失函数\(\lambda(\alpha_i|w_j)\)，也记为\(\lambda(\alpha_i,w_j)\)，这就是我们前面引用的\(\lambda_j^{(i)}\)，它明确表示对自然状态\(w_j\)做出决策\(\alpha_i\)时所造成的损失 4)观测值X条件下的期望损失。\(R(\alpha_i|X)=\sum_{j=1}^c\lambda(\alpha_i|w_j)P(w_j|x),i=1,2,3,\ldots,\alpha\) 也称为条件风险 每一个决策都会带来损失，通常它是决策和自然状态的函数，可以用决策表来表示其关系对于实际问题，最小风险的贝叶斯决策可按下列步骤进行： 1)根据贝叶斯公式计算后验概率 2)根据后验概率和决策表，计算出各个决策的条件风险 3)找出使条件风险最小的决策，就是最小风险贝叶斯决策对于二类问题：$$\begin{equation}\begin{cases}R(\alpha_1|X)=\lambda_{11}P(w_1|X)+\lambda_{12}P(w_2|X) \\R(\alpha_2|X)=\lambda_{21}P(w_1|X)+\lambda_{22}P(w_2|X)\end{cases}\nonumber\end{equation}$$其中\(\lambda_{ij}=\lambda(\alpha_i,w_j)\)，若\(R(\alpha_1|X)&lt;R(\alpha_2|X)\)，则判定\(w_1\)为真正状态，否则为\(w_2\)也可以用先验概率和类条件概率密度之积替代后验概率,得到其他形式 3.3 限定错误率的两类判别决策在两类判别决策问题中，有两种错误分类的可能。实际中，有时要求限制其中一类错误率为某个常数，而另一类错误率尽可能小，这就是所谓Neyman-Pearson决策要解决的问题。 3.4 最大最小决策最小错误率和最小风险贝叶斯决策的决策都是与先验概率有关的，对给定的x，其P(wi)不变。如果P(wi)可变或者先验概率未知，再按照某个固定的P(wi)条件下的决策规则进行决策就往往得不到最小的错误率或风险。最大最小决策就是希望考虑在P(wi)变化的情况下，使最大可能的风险最小，即在最差条件下争取最好的结果 4. 分类器设计分类器设计实质上是在描述待识别对象的d维特征所组成的特征空间内，将其划分为c个决策域。决策域的边界面称为决策面，在数学上用解析形式表示成决策面方程，用于表达决策规则的某些函数称为判别函数。显然判别函数与决策面方程式密切相关的，并且都由相关决策规则确定的。判别函数：对于d维特征空间中的c个模式类别，各给出一个由d个特征组成的单值函数，称为判别函数。在c类的情况下，我们共有c个判别函数，分别对应c个模式类 5. 正态分布时的统计决策正太分布假设是对各种随机变量使用得最普遍的假设。 5.1 单变量正态分布概率密度函数\(p(x)=\frac{1}{\sqrt{2\pi}\sigma}\exp\left[-\frac{1}{2}(\frac{x-\mu}{\sigma})^2\right]\) 5.2 多元正太分布概率密度函数\(p(x)=\frac{1}{(2\pi)^{\frac{d}{2}}|\Sigma|^{\frac{1}{2}}}\exp\left[-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)\right]\)其中\(\Sigma\)是\(d\times d\)维协方差矩阵，是个半正定的对称矩阵：\(\Sigma=\begin{bmatrix}\sigma_{11}^2 &amp; \sigma_{12}^2 &amp; \cdots &amp; \sigma_{1d}^2 \\\sigma_{21}^2 &amp; \sigma_{22}^2 &amp; \cdots &amp; \sigma_{2d}^2 \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\sigma_{d1}^2 &amp; \sigma_{d2}^2 &amp; \cdots &amp; \sigma_{dd}^2\end{bmatrix}\)通常将上式简记为：\(p(x)\sim N(\mu,\sigma)\)，其中\(\mu=E[x]=(\mu_1,\mu_2,\ldots,\mu_d)^T\) 5.3 多元正太分布下最小错误率贝叶斯决策 第一种情况：\(\Sigma_i=\sigma^2I\) 第二种情况：\(\Sigma_i=\Sigma\) 第三种情况：\(\Sigma_i\)任意 6. 离散情况的贝叶斯决策7. 概率密度函数估计在前面我们都假设类条件概率密度函数是已知的，然后去设计贝叶斯分类器，但在很多情况下，类条件概率密度函数往往必须首先利用统计推断理论中的估计方法从可用的样本集数据中估计出来。从样本集推断总体概率分布主要包括以下两种方法： 7.1 参数估计如果已知概率密度函数的类型(如正态分布)，而表征概率密度函数的某些参数未知(如均值和方差)，则可以利用参数估计方法 最大似然估计 贝叶斯估计和贝叶斯学习 7.2 非参数估计如果不知道概率密度函数的形式，但能估计出一些参数(如均值和方差)，则采用非参数估计方法 Parzen窗法 Kn近邻估计法 8. 分类错误率的计算对于类条件概率密度及先验概率已知的问题，当我们用指定的决策规则来进行分类时，它的错误率应是固定的。但实际中，经常遇到类条件概率密度函数的形式或其参数，甚至是类型的先验概率等都预先未知的情况，再加上训练样本的数据也具有随机性，就使得训练和判决问题变得十分复杂。这种复杂性反映在错误率上，使错误率也具有随机性。因此可以认为，错误率反应了分类问题的固有复杂性，它是分类问题复杂性的一种量度。对错误率的计算或估计方法可分为以下三个方面： 按理论公式计算(特殊情况才可) 正态分布且协方差阵相等的情况下 各维为独立随机变量情况下 计算错误率上界 Chernoff界限 用Bhattacharyya系数确定的错误率上界 实验估计]]></content>
      <categories>
        <category>science</category>
        <category>ai</category>
      </categories>
      <tags>
        <tag>pattern recognition</tag>
        <tag>bayes decision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习二]]></title>
    <url>%2F2015%2F08%2F16%2FmachineLearning02%2F</url>
    <content type="text"><![CDATA[1. 决策树定义决策树是一个预测模型；他代表的是对象属性与对象值之间的一种映射关系。树中每个节点表示某个对象，而每个分叉路径则代表的某个可能的属性值，而每个叶结点则对应从根节点到该叶节点所经历的路径所表示的对象的值。决策树仅有单一输出，若欲有复数输出，可以建立独立的决策树以处理不同输出。从数据产生决策树的机器学习技术叫做决策树学习, 通俗说就是决策树。 2. 决策树优缺点决策树是一种简单但是广泛使用的分类器。通过训练数据构建决策树，可以高效的对未知的数据进行分类。 决策数有两大优点： 1、决策树模型可读性好，具有描述性，有助于人工分析 2、效率高，决策树只需要一次构建，反复使用，每一次预测的最大计算次数不超过决策树的深度。 决策树缺点：可能会产生过度匹配问题 3. 构造决策树3.1 构造决策树算法决策树算法有ID3算法、C4.5、CART等，以ID3为例: 对于当前数据集，计算不同属性(特征)的信息增益，并从中取出信息增益最大的属性(特征)R 用R作为划分root节点的方法，把R属性可能对应的不同值归为不同的子集 对每个子集，递归调用建树算法 若子集只含有单个属性，则分支为叶子节点，(即递归函数的停止条件)，判断其属性值并标上相应的符号，然后返回调用处 3.2 度量数据集无序程度构造决策树需要解决的第一个问题就是，当前数据集上哪个特征在划分数据分类时起决定性作用。如果按照A特征划分之后已经完全正确的将数据集分类了，那么A特征就足够好，也可以说划分后的数据集无序程度下降了，即划分数据集的最大原则是：将无序的数据变得更加有序。而度量数据集无序程度的方法有熵(entropy)和基尼不纯度(Gini impurity)等，此处使用熵。关于熵，熵定义为信息的期望值，而对于符号\(x_i\)的信息定义为\(l(x_i)=-\log_2p(x_i)\)，为了计算熵，我们需要计算所有类别所有可能值包含的信息期望值，通过以下公式得到: \(H=-\sum_{i=1}^np(x_i)\log_2p(x_i)\)熵越高，数据集的无序程度越大，即混合的数据越多 通过熵度量划分数据集的信息增益，判断按照哪个属性(特征)划分数据集为最好的划分方式 3.3 递归构建决策树递归结束的条件是：遍历完所有划分数据集的属性，或者每个分支下的所有实例都具有相同的分类。如果所有实例都具有相同的分类，则得到一个叶子节点或者终止块，任何到达叶子节点的数据必然属于叶子节点的分类 4. Matplotlib注解以上构造的决策树为文本描述方式，不够直观，虽然实际应用中大多就是如此，但本着学习的态度，且数据集也很小，使用matplotlib注解直观形象的作出一个决策树，不详述 5. 测试算法决策树构造完毕后，需要使用它来执行分类 6. 决策树的存储决策树的构造过程十分耗时，如果每次使用决策树都需要先构造，会浪费计算时间，可以将训练好的决策树存储起来，需要使用的时候读取出来 7. 过渡拟合这是ID3算法的不足之处，其概念和优化方法可以参见http://www.cnblogs.com/bourneli/archive/2013/03/15/2961568.html 8. 应用示例Machine Learning in Action 书中使用了隐形眼镜示例，数据来源为UCI数据库，并进行了相应的改造代码可见此处]]></content>
      <categories>
        <category>techonology</category>
        <category>ai</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
        <tag>decision tree</tag>
        <tag>ID3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模式识别一]]></title>
    <url>%2F2015%2F08%2F16%2FpatternRecognition01%2F</url>
    <content type="text"><![CDATA[1. 模式识别系统的构成其中： 分类器设计，为了把待识别模式分配到各自的模式类中去，必须设计出一套分类判别规则。基本做法是：用一定数量的样本（称为训练样本集）确定出一套分类判别规则，使得按照这套分类判别规则对待模式识别进行分类所造成的错误识别率最小或引起的损失最小。这就是分类器设计的过程。 分类决策，分类器按照已确定的分类判别规则对待识别模式进行分类判别，输出分类结果，这就是分类器的使用过程，也称为分类决策。 2. 识别方法一般来说，描述模式有两种方法：定量描述和结构性描述，定量描述就是用一组数据来描述模式，结构性描述就是用一组基元来描述模式。对应于两种描述方法有两种基本的模式识别方法： 统计模式识别：在统计模式识别中，被研究的模式用特征向量来描述，特征向量中的每一个元素代表模式中的一个特征或属性，特征向量构成的空间叫特征空间。如果我们用某种方法来分割特征空间，使得同一类模式大体上都在特征空间的同一区域，那么对于待分类的模式，就可以根据它的特征向量在特征空间中哪一个区域来判定它属于哪一类模式。研究统计模式识别方法的任务就是用不同的方法划分特征空间，从而达到识别的目的。 结构模式识别：此方法主要立足于分析模式的结构信息，由于模式是一些模式基元按一定的结构规则组合而成的，因此结构分析的内容就是分析模式如何由基元构成的规则。目前比较成功的是句法结构模式识别方法，它通过检查代表这个模式的句子是否符合事先给定的某一类文法规则，如果符合，那么这个模式就属于这个文法所代表的那个模式类。]]></content>
      <categories>
        <category>science</category>
        <category>ai</category>
      </categories>
      <tags>
        <tag>pattern recognition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习一]]></title>
    <url>%2F2015%2F08%2F11%2FmachineLearning01%2F</url>
    <content type="text"><![CDATA[1. 简介学习此书[1]时的一些记录 2. 如何选择合适的算法考虑使用机器学习算法的目的, 如果想要预测目标变量的值，则可以选择监督学习算法，否则可以选择无监督学习算法。确定选择监督学习算法后，进一步确定目标变量类型，如果目标变量是离散型，如是/否、1/2/3、A/B/C等，则可以选择分类算法；如果目标变量是连续型的数值，如0.0~100.00、-999~999或者+∞~-∞等，则需要选择回归算法, 如果不想预测目标变量的值，则可以选择无监督算法，进一步分析是否需要将数据划分为离散的组。如果这是唯一的要求，则使用聚类算法，如果还需要估计数据与每个分组的相似程度，则需要使用密度估计算法。 3. 开发机器学习程序的应用步骤 收集数据 准备数据 分析数据 训练算法 测试算法 使用算法 4. kNN算法4.1 k-近邻算法的原理存在一个样本数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据与所属分类的对应关系。输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据(最近邻)的分类标签。一般来说，我们只选取样本数据集中前k个最相似的数据，这就是k-近邻算法 4.2 kNN的应用在书[1]中提供了一个识别数字的实例，对其稍作修改，最终代码在此 Footnotes1.Machine Learning in Action ↩2.PRML ↩]]></content>
      <categories>
        <category>techonology</category>
        <category>ai</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
        <tag>kNN</tag>
        <tag>k-Nearest Neighbour</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux琐记二]]></title>
    <url>%2F2015%2F08%2F03%2Flinux02%2F</url>
    <content type="text"><![CDATA[1. dd命令win8.1下镜像直接点击setup.exe无效…系统要求都符合，只是我这是双系统且是BIOS引导，也不是UEFI想想要不制作个系统盘，Win32DiskImager制作后还是不行，转到Ubuntu使用dd if=en_windows_10_multiple_editions_x64_dvd_6846432.iso of=/dev/sdb bs=2Mbs=2M情况下最后平均写入速度为7M/s 虽然最终还是失败了、、、 2. 格式化u盘U盘写入到一半时被我中止了，结果就是U盘变成了只读状态，挂载后也无法操作…于是mkfs.vfat -I /dev/sdb或者mkfs -t vfat /dev/sdb -I 3. Shadowsocks12pip install shadowsockssslocal -c conf.json conf.json自己编写，格式如下：12345678&#123; "server":"my_server_ip", "server_port":*****, "local_port":1080, "password":"*****", "timeout":600, "method":"*****"&#125; 4. 关闭防火墙ipv412chkconfig iptables offservice iptables stop ipv612chkconfig ip6tables offservice ip6tables stop 5. 外网出口ip在终端下输入 curl ip.gs 即可获取当前自己的外网出口IPv4地址]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 琐记一]]></title>
    <url>%2F2015%2F08%2F03%2Fwindows01%2F</url>
    <content type="text"><![CDATA[1. Word中字体大小与磅值对应关系字号”八号”对应磅值5字号”七号”对应磅值5.5字号”小六”对应磅值6.5字号”六号”对应磅值7.5字号”小五”对应磅值9字号”五号”对应磅值10.5字号”小四”对应磅值12字号”四号”对应磅值14字号”小三”对应磅值15字号”三号”对应磅值16字号”小二”对应磅值18字号”二号”对应磅值22字号”小一”对应磅值24字号”一号”对应磅值26字号”小初”对应磅值36字号”初号”对应磅值42 2. 比较文件命令本想用windows自带的fc命令,却发现只可以比较两文件无法比较文件夹,于是加上自己用的cmder自带很多linux命令(其实应该是msysgit带的),于是考虑使用diff命令, 用-r选项即可diff -r &#39;E:\Amusement\music\&#39; &#39;F:\Recreation\Music\&#39; 3. markdown文件中加入html代码例如加上&lt;p align=&quot;center&quot;&gt;Test&lt;/p&gt;，则必须在后面加一空行，否则不会输出理想结果，原因暂时未知。 4. cmd设置为utf-8编码CHCP 65001切换回GBK可用chcp 936 5. cmder切为PowerShell模式下无法使用git等将git的bin目录加入系统path下，加入用户组的path貌似不可以，至少我的电脑上是这样若还不行可以尝试Set-ExecutionPolicy RemoteSigned 6. Windows 录音命令行输入soundrecorder /file outputfile.wav]]></content>
      <categories>
        <category>techonology</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>skills</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端相关]]></title>
    <url>%2F2015%2F07%2F25%2Fweb01%2F</url>
    <content type="text"><![CDATA[1. 响应式网页图标http://www.gbtags.com/gb/share/2774.htmhttp://fortawesome.github.io/Font-Awesome/ 2. html编码Ascii编码见这里Unicode编码太多, 可网上找工具转换例如”你好”可以Unicode编码为\u4f60\u597d]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>icon</tag>
        <tag>html encoding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shadowsocks 高级教程]]></title>
    <url>%2F2015%2F07%2F19%2Fshadowsocks%2F</url>
    <content type="text"><![CDATA[1. HTTP代理在网上看到建立shadowsocks之后会自动建立一个http的代理，使用8123端口，知道这一点就可以使用http代理而不仅只是socks5了 2. Shadowsocks服务端配置曾在DigitalOcean上自建了一个Shadowsocks服务端，虽然后来被封了，但幸而在电脑上记录下一下重点，Shadowsocks服务端的配置文件为:123456789101112131415161718#ipv4&#123; "server":"0.0.0.0", "server_port":443, #经尝试，443端口比其他端口要快一点 "local_port":1080, "password":"******", "timeout":600, "method":"aes-256-cfb"&#125;#ipv6&#123; "server":"::", "server_port":443, "local_port":1080, "password":"******", "timeout":600, "method":"aes-256-cfb"&#125; 3. Shadowsocks服务端的安装源码在此处先安装pip再安装SS：12apt-get install python-pippip install shadowsocks 如果默认Python版本不对则需要先安装Python，不赘述。 4. Shadowsocks服务端的启动与关闭12ssserver -c config -d startssserver -c config -d stop 其中config即前面配好的配置文件 5. 检查日志sudo less /var/log/shadowsocks.log]]></content>
      <categories>
        <category>techonology</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>proxy</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 琐记二]]></title>
    <url>%2F2015%2F07%2F16%2Fpython02%2F</url>
    <content type="text"><![CDATA[1. zip函数zip函数接受任意多个（包括0个和1个）序列作为参数，返回一个tuple列表123456x = [1, 2, 3]y = [4, 5, 6]z = [7, 8, 9]xyz = zip(x, y, z)print xyz[(1, 4, 7), (2, 5, 8), (3, 6, 9)] 2. 写入wav fileshttp://stackoverflow.com/questions/3637350/how-to-write-stereo-wav-files-in-python 3. 矩阵转置可以用1中的zip函数 zip(*x)一维数组的转置还可以123M=10k = np.array(range(M))k = np.matrix(k).T 4. 复数表示 虚数i用j表示，且虚数系数是1时要在j前加上1，如 1+1jmath.exp(1+2j)会报错，can’t convert complex to float应使用cmath.exp(1+2j) 或者 (math.e) ** (1+2j) 5. 复数取模自以为是math.abs 或者 cmath.abs结果发现就是abs 6. 读取二维数组的第几列123456s = [[1,2,3,4,5,6],[2,3,4,5,6,7],[3,4,5,6,7,8],[4,5,6,7,8,9]][t[0] for t in s] #这是第1列[t[1] for t in s] #这是第2列list(zip(*s)[0]) #这是第1列list(zip(*s)[1]) #这是第2列 以上两种方法均可以 7. functools.partial在map、reduce、filter里如果想传递多个参数给函数，可以查阅functools.partial的用法简单来说就是能使函数用更少的参数进行调用，示例如下:12345678910111213import functoolsdef add(a, b): return a + badd(4, 2)6plus3 = functools.partial(add, 3)plus5 = functools.partial(add, 5)plus3(4)7plus3(7)10plus5(10)15]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>programming language</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[傅里叶变换窗函数]]></title>
    <url>%2F2015%2F06%2F27%2FwindowFunction%2F</url>
    <content type="text"><![CDATA[原理用窗函数分析信号，相当于将一个待分析信号x1通过一个传输函数为窗函数傅里叶变换的滤波器得到输出信号或分析信号y1 http://www.cnblogs.com/gaozehua/p/3516556.htmlhttp://people.ece.cornell.edu/land/courses/ece4760/FinalProjects/s2010/gjm76_asr96/gjm76_asr96/]]></content>
      <categories>
        <category>science</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>fourier</tag>
        <tag>window function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神经网络识别手写体数字]]></title>
    <url>%2F2015%2F06%2F15%2FdigitRecognition%2F</url>
    <content type="text"><![CDATA[1. 前言智能控制课程的作业之一就是利用神经网络识别手写体数字, 花了两天时间用Matlab实现了 2. BP算法神经网络是智能控制领域很重要的一部分，BP网络算法则是神经网络控制中最重要的算法之一。http://blog.csdn.net/gongxq0124/article/details/7681000 3. 源代码The source code of this project is here.]]></content>
      <categories>
        <category>techonology</category>
        <category>ai</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>intelligent control</tag>
        <tag>neural control</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三字符构成字符串]]></title>
    <url>%2F2015%2F06%2F15%2FthreeCharacters%2F</url>
    <content type="text"><![CDATA[1. 描述仅由三个字符A、B、C构成字符串，且字符串任意相邻三个元素不能完全相同。如“ACCCAB”不合法，“ABBCBCA”合法。求满足条件的长度为n的字符串个数。假定不考虑整数溢出，要求时间和空间复杂度不高于O(N)。 2. Hints 1、考虑使用动态规划，将长度为N的字符串个数表示成长度为N-1的字符串个数的递归关系； 2、使用滚动数组降低空间复杂度； 3、矩阵乘幂降低时间复杂度。 3. Solution若当前已经有长度为n-1的合法字符串，则在末端增加一个字符，形成长度为n的字符串，n-1的字符串可分为“末端两字符相等”和“末端两字符不等”，分别记为\(dp[n-1][0]\)和\(dp[n-1][1]\)，长度为n的字符串都可以这样划分，于是:$$\begin{cases}dp[n][0] = dp[n-1][0]*2 + dp[n-1][1]*2 \\dp[n][1] = dp[n-1][0]\end{cases}$$其初始条件为\(dp[1][0] = 3, dp[1][1] = 0\); 状态转移方程为$$\begin{cases}dp[n][0] = dp[n-1][0]*2 + dp[n-1][1]*2 \\dp[n][1] = dp[n-1][0]\end{cases}$$其可以通过滚动数组简化：$$\begin{cases}dp[0] = dp[0]*2 + dp[1]*2 \\dp[1] = dp[0]\end{cases}$$由此可以将空间复杂度降为O(1) 4. 代码123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;int calculateCount(int);int main(int argc, char** argv) &#123; int n; cin &gt;&gt; n; int accumulation = calculateCount(n); cout &lt;&lt; accumulation &lt;&lt; endl; return 0;&#125;int calculateCount(int n) &#123; int accumulation = 0; int dp0 = 3, dp1 = 0; for(int i = 1; i &lt; n; i++) &#123; int temp = dp0; dp0 = 2*dp0 + 2*dp1; dp1 = temp; &#125; accumulation = dp0+dp1; return accumulation;&#125; 5. 优化此题还可以简化时间复杂度，方法就是题目中的提示3。由矩阵的状态方程：$$\begin{cases}dp[0] = 2*dp[0] + 2*dp[1] \\dp[1] = dp[0]\end{cases}$$得到矩阵形式：$$\begin{equation}(dp[0] dp[1])_{new} = (dp[0] dp[1])_{old} \cdot \bigl( \begin{matrix} 2 &amp; 1 \\ 2 &amp; 0 \end{matrix} \bigr)\nonumber\end{equation}$$从而得到：$$\begin{equation}\begin{split}(dp[0] dp[1])_{n} &amp;= (dp[0] dp[1])_{n-1} \cdot \bigl( \begin{matrix} 2 &amp; 1 \\ 2 &amp; 0 \end{matrix} \bigr) \\&amp;= (dp[0] dp[1])_{n-2} \cdot \bigl( \begin{matrix} 2 &amp; 1 \\ 2 &amp; 0 \end{matrix} \bigr) \bigl( \begin{matrix} 2 &amp; 1 \\ 2 &amp; 0 \end{matrix} \bigr) \\&amp;= \ldots \\&amp;= (dp[0] dp[1])_{1} \cdot \bigl( \begin{matrix} 2 &amp; 1 \\ 2 &amp; 0 \end{matrix} \bigr)^{n-1}\end{split}\nonumber\end{equation}$$ 新建一个矩阵求幂的类，并据此写出完整代码，以下只给出类实现:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#ifndef POWMATRIX_H#define POWMATRIX_Hclass PowMatrix &#123; public: PowMatrix(int dimension); //构造函数 virtual ~PowMatrix(); //析构函数 void setMatrix(int* matrix); //设置矩阵 int multiply(int row,int column); //两数组对应相乘 void pow(int count); //求幂函数 int* getResult() &#123; //得到结果 return result; &#125; private: int dimension; //矩阵维度 int* matrix; //需要求幂的初始矩阵 int* result; //求幂之后存放结果的矩阵&#125;;#endif // POWMATRIX_HPowMatrix::PowMatrix(int dimension) &#123; this-&gt;dimension = dimension; //初始化维度 matrix = new int[dimension*dimension]; //初始化分配matrix空间 result = new int[dimension*dimension]; //初始化分配存放结果的矩阵的内存空间&#125;PowMatrix::~PowMatrix() &#123; delete matrix; delete result;&#125;void PowMatrix::setMatrix(int* matrix) &#123; //设置需要自乘的矩阵值,用一维数组形式逐行存放 int len = dimension*dimension; for(int i = 0; i &lt; len; i++) &#123; (this-&gt;matrix)[i] = matrix[i]; &#125;&#125;int PowMatrix::multiply(int row, int column) &#123; //result矩阵第row行和matrix矩阵第column列相乘 int val = 0; for(int i = 0, j = 0; i &lt; dimension; i++,j++) &#123; val += ( result[row*dimension+i] ) * ( matrix[j*dimension+column] ); &#125; return val;&#125;void PowMatrix::pow(int count) &#123; //矩阵求幂函数 //以下为建立单位矩阵 for(int i = 0; i &lt; dimension*dimension; i++) &#123; if(i/dimension == i%dimension) &#123; //判断一维数组模拟矩阵的实际对角线位置 result[i] = 1; &#125; else &#123; result[i] = 0; &#125; &#125; //矩阵的count次幂 for(int k = 0; k &lt; count; k++) &#123; //第k次自乘 int* temp = new int[dimension*dimension]; //以下循环,逐次求出矩阵row行column列的值 for(int row = 0; row &lt; dimension; row++) &#123; for(int column = 0; column &lt; dimension; column++) &#123; temp[row*dimension+column] = multiply(row,column); &#125; &#125; //将temp矩阵赋值给result矩阵,即更新result矩阵 for(int j = 0; j &lt; dimension*dimension; j++) &#123; result[j] = temp[j]; &#125; &#125;&#125; 代码可在此处下载]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux琐记一]]></title>
    <url>%2F2015%2F06%2F06%2Flinux01%2F</url>
    <content type="text"><![CDATA[1. 音频设备aplay -l会列出所有设备alsamixer灰常实用/usr/bin/lspci | grep -i audio 2. xargs通常使用管道的范例：cat test.txt | grep -E &#39;*test*&#39;但若是前者可以作为后者的参数带入时，可以使用xargs：echo “*test*” | xargs find / -name上述若是不加xargs则无法使用xargs的实际功能是是以行为单位读取输入数据并执行参数变化，于是可以有更强大的用处，例如：find / -name &#39;*portaudio*&#39; | xargs ls -l 3. 截图截图可以将PrntScr辅以Shift和Alt键，得到不同效果 4. ssh远程下载上传文件12scp [-P port] username@host:/path/to/remote/source /path/to/local/destscp [-P port] /path/to/local/source username@host:/path/to/remote/dest 5. qhost6. wc统计词数 7. downloadaria2cktorrent 8. 校验md5sumsha1sumopenssl sha1 filename 9. 默认打开程序12/etc/gnome/defaults.list (这个文件保存了全局的打开方式)~/.local/share/applications/mimeapps.list (这个文件保存了个人的打开方式) 10. Steghide 工具一个给音频、图像等加密或嵌入文件的小程序，很实用12steghide embed -cf 被加密的文件 -ef 加密的内容文件steghide extract -sf 被加密的文件]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[九宫格(八数码)问题]]></title>
    <url>%2F2015%2F05%2F29%2Feightpuzzle%2F</url>
    <content type="text"><![CDATA[1. 前言智能控制基础的课后题，开始以为没什么，但是不写复杂的算法好久~动手写起来还是漏洞百出主要参考了这篇博客的内容英文描述此问题可参见此处 2. 实现2.1 定义一个图的节点类123456789101112131415161718192021222324252627class VertexOfGraph &#123; //定义图的节点类public: int vertex[3][3]; int h,g; int x,y; string hashValue;public: VertexOfGraph() &#123; //构造函数将成员变量初始化为0和空 x = 0; y = 0; h = 0; g = 0; hashValue = ""; &#125;; bool isValid() &#123; //判断当前状态是否有效,如果超出边界范围则无效 if(x &gt;= 0 &amp;&amp; x &lt; 3 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; 3) &#123; return true; &#125; return false; &#125; void newStatus(int oldX, int oldY) &#123; //将现在存储的空位位置x,y与oldX,oldY对应的位置交换数值,得到新状态 int temp = vertex[x][y]; vertex[x][y] = vertex[oldX][oldY]; vertex[oldX][oldY] = temp; &#125;&#125;; 为了方便将类的成员变量都定义为public类型，省去了set、get方法，类中的h、g并没有用到，初始化都置0了，作为以后扩展用，主要是用于启发式搜索中的估价函数，搜索得到比较常用的启发式搜索方法有A*搜索，目前的算法都没有用到~ 2.2 输入功能输入功能必须要有,就控制台输入了, 可以把代码移到C#上，用Winform做一个GUI界面~1int origin[3][3],target[3][3]; 定义3*3的数组表示九宫格的九个数字, origin分别为初始状态和目标状态, 循环读入即可. 至于为何不使用1*9的一维数组, 照顾要是考虑到后续搜索路径的问题, 3*3的路径比较容易设计, 其中一个数组下标变化1即可, 而对于1*9, 感觉有点复杂(后来发现其实并不是, 将下标分别+-3和+-1就得到了四个路径, 再判断新状态是否有效即可, 好像还比3*3简单点) 2.3 状态判重对于每个状态必须判重，也要判断是否与目标状态相同，如果是将9个元素逐个比较，太耗时，肯定是得用到hash，hash方法http://www.cnblogs.com/goodness/archive/2010/05/04/1727141.html中的境界二有提到，但是我没看懂~”逆序值”这个词写的不清楚，感觉应该是排列组合中的一个名词，但是搜出来的都不对，于是自己设计个不能称之为hash的hash函数, 因为这个方法的信息量没有压缩, 是可逆的对于每种状态只需要唯一对应一个值即可，于是想着把每种状态的数字串成字符串当作hash值，这肯定不是好方法，至少本来只需要9!=362880个int型元素就能存下所有状态，而现在对于每种状态都是一个9位长的字符串~不过有一个好处就是存储的信息相对而言多了, 对于最后输出所有路径有所帮助。12345678910111213string getHash(int v[3][3]) &#123; //将状态的数字排序转换为字符串,作为hash值 string hashString = ""; for(int i = 0; i &lt; 3; i++) &#123; for(int j = 0; j &lt; 3; j++) &#123; stringstream sstream; string str; sstream &lt;&lt; v[i][j]; //注意sstream输入是&lt;&lt;而不是iostream的&gt;&gt; sstream &gt;&gt; str; hashString += str; &#125; &#125; return hashString;&#125; 2.4 建立初始表结构根据给定初始状态建立初始的表结构，找到0的位置即为可移动的空格位置并记录，找到得到hash值并记录123456789101112131415VertexOfGraph createGraph(int vertex[3][3]) &#123; VertexOfGraph returnGraph; for(int i=0; i &lt; 3; i++) &#123; for(int j = 0; j &lt;3; j++) &#123; returnGraph.vertex[i][j] = vertex[i][j]; if(vertex[i][j] == 0) &#123; returnGraph.x = i; returnGraph.y = j; &#125; &#125; &#125; returnGraph.hashValue = getHash(vertex); return returnGraph;&#125; 2.5 bfs广度搜索搜索结果返回一个map表，将每一状态转换之后的状态作为key值，原状态作为value，一一对应保存起来，最后通过此表可得到实际路径1234567891011121314151617181920212223242526272829303132333435map&lt;string,string&gt; bfsSearch(VertexOfGraph graph,string targetHash,map&lt;string,bool&gt; visited) &#123; int direction[4][2] = &#123; &#123;-1,0&#125;, &#123;0,1&#125;, &#123;1,0&#125;, &#123;0,-1&#125; &#125;; queue&lt;VertexOfGraph&gt; que; que.push(graph); map&lt;string,string&gt; route; while(!que.empty()) &#123; VertexOfGraph movingVertex = que.front(); //cout &lt;&lt; movingVertex.hashValue &lt;&lt; endl; //测试遍历结果 VertexOfGraph savingVertex = movingVertex; que.pop(); for(int i = 0; i &lt; 4; i++) &#123; movingVertex = savingVertex; movingVertex.x = savingVertex.x + direction[i][0]; movingVertex.y = savingVertex.y + direction[i][1]; if(!movingVertex.isValid()) &#123; continue; &#125; else &#123; movingVertex.newStatus(savingVertex.x, savingVertex.y); movingVertex.hashValue = getHash(movingVertex.vertex); if(visited.find(movingVertex.hashValue)==visited.end()) &#123; visited[movingVertex.hashValue] = true; route[movingVertex.hashValue] = savingVertex.hashValue; que.push(movingVertex); &#125; if(movingVertex.hashValue == targetHash) &#123; return route; &#125; &#125; &#125; &#125; return route;&#125; bfs的想法是，从第一个状态开始遍历可能的所有状态，对于当前状态，找出其可以转换的状态，将他们全部放入队列的尾部，保存route，并判断他们是否是目标状态，若是，返回route退出，否则不停取出队列的头元素，执行相同操作 2.6 找回实际路径从route和目标hash值中找回实际路径，并输出1234567891011121314151617181920212223242526272829303132333435void display(map&lt;string,string&gt; searchRoute,string targetHash) &#123; stack&lt;string&gt; shortestRoute; shortestRoute.push(targetHash); string nextWay = targetHash; while( searchRoute.find(nextWay) != searchRoute.end() ) &#123; nextWay = searchRoute[nextWay]; shortestRoute.push(nextWay); &#125; cout &lt;&lt; endl; int counts = 0; while( !shortestRoute.empty() ) &#123; string displayString = shortestRoute.top(); shortestRoute.pop(); if( (counts == 0) &amp;&amp; (displayString == targetHash) ) &#123; //如果堆栈内只有一个字符串元素,且等于targetHash,那么说明遍历了所有的状态也无法达到目标状态 cout &lt;&lt; "Sorry, but you can not reach the target status, and you can try another status instead." &lt;&lt; endl; break; &#125; cout &lt;&lt; "Step " &lt;&lt; counts &lt;&lt; " :"; counts++; for(unsigned int i = 0; i &lt; displayString.length(); i++) &#123; if( i % 3 == 0 ) &#123; cout &lt;&lt; endl; &#125; cout &lt;&lt; displayString.substr(i,1) &lt;&lt; ' '; &#125; cout &lt;&lt; endl; &#125; if( counts &gt; 1 ) &#123; cout &lt;&lt; "Totally, you used " &lt;&lt; counts-1 &lt;&lt; " steps to the target status." &lt;&lt; endl; &#125;&#125; 源码源码可以在这里看到]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>eightpuzzle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装Ubuntu 15.04之后]]></title>
    <url>%2F2015%2F05%2F26%2Fubuntu01%2F</url>
    <content type="text"><![CDATA[前言重装了系统, 不小心点错了键盘, 用户名设置错了, 再折腾一下其他东西又是一晚上, 幸亏以前用过Ubuntu, 还有点印象，重装前Kali也算是和Ubuntu同源的，都来自Debian，所以没有走太多弯路。 1. SourceList1234567891011121314151617181920212223242526272829303132333435363738394041424344454647### Aliyun# deb http://mirrors.aliyun.com/ubuntu/ vivid main restricted universe multiverse# deb http://mirrors.aliyun.com/ubuntu/ vivid-security main restricted universe multiverse# deb http://mirrors.aliyun.com/ubuntu/ vivid-updates main restricted universe multiverse# deb http://mirrors.aliyun.com/ubuntu/ vivid-proposed main restricted universe multiverse# deb http://mirrors.aliyun.com/ubuntu/ vivid-backports main restricted universe multiverse# deb-src http://mirrors.aliyun.com/ubuntu/ vivid main restricted universe multiverse# deb-src http://mirrors.aliyun.com/ubuntu/ vivid-security main restricted universe multiverse# deb-src http://mirrors.aliyun.com/ubuntu/ vivid-updates main restricted universe multiverse# deb-src http://mirrors.aliyun.com/ubuntu/ vivid-proposed main restricted universe multiverse# deb-src http://mirrors.aliyun.com/ubuntu/ vivid-backports main restricted universe multiverse### Neteasedeb http://mirrors.163.com/ubuntu/ vivid main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ vivid-security main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ vivid-updates main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ vivid-proposed main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ vivid-backports main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ vivid main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ vivid-security main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ vivid-updates main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ vivid-proposed main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ vivid-backports main restricted universe multiverse### Bit# deb http://mirror.bit.edu.cn/ubuntu/ vivid main restricted universe multiverse# deb http://mirror.bit.edu.cn/ubuntu/ vivid-security main restricted universe multiverse# deb http://mirror.bit.edu.cn/ubuntu/ vivid-updates main restricted universe multiverse# deb http://mirror.bit.edu.cn/ubuntu/ vivid-proposed main restricted universe multiverse# deb http://mirror.bit.edu.cn/ubuntu/ vivid-backports main restricted universe multiverse# deb-src http://mirror.bit.edu.cn/ubuntu/ vivid main restricted universe multiverse# deb-src http://mirror.bit.edu.cn/ubuntu/ vivid-security main restricted universe multiverse# deb-src http://mirror.bit.edu.cn/ubuntu/ vivid-updates main restricted universe multiverse# deb-src http://mirror.bit.edu.cn/ubuntu/ vivid-proposed main restricted universe multiverse# deb-src http://mirror.bit.edu.cn/ubuntu/ vivid-backports main restricted universe multiverse### Bit ipv6# deb http://mirror.bit6.edu.cn/ubuntu/ vivid main restricted universe multiverse# deb http://mirror.bit6.edu.cn/ubuntu/ vivid-security main restricted universe multiverse# deb http://mirror.bit6.edu.cn/ubuntu/ vivid-updates main restricted universe multiverse# deb http://mirror.bit6.edu.cn/ubuntu/ vivid-proposed main restricted universe multiverse# deb http://mirror.bit6.edu.cn/ubuntu/ vivid-backports main restricted universe multiverse# deb-src http://mirror.bit6.edu.cn/ubuntu/ vivid main restricted universe multiverse# deb-src http://mirror.bit6.edu.cn/ubuntu/ vivid-security main restricted universe multiverse# deb-src http://mirror.bit6.edu.cn/ubuntu/ vivid-updates main restricted universe multiverse# deb-src http://mirror.bit6.edu.cn/ubuntu/ vivid-proposed main restricted universe multiverse# deb-src http://mirror.bit6.edu.cn/ubuntu/ vivid-backports main restricted universe multiverse 2. Flashcp libflashplayer.so /usr/lib/mozilla/plugins/ 3. Input Method先apt-get install fcitx-table-wbpy, 再在Language Support里改框架为fcitx，修改配置重启 4. Desktop修改一下桌面背景、透明度、终端配色等 5. hostname username 对于hostname 首先修改 /etc/hostname文件 sudo vim /etc/hostname 将其中的主机名改为你所要修改的主机名 再修改 /etc/hosts文件 sudo vim /etc/hosts 127.0.0.1 主机名 这里的主机名要和上面修改的一致 修改完成后需重启 对于username 先切换到tty终端下，如tty1为Ctrl+Alt+F1 chfn hypocisy usermod -l hypocrisy hypocisy usermod -d /home/hypocrisy/ -m /home/hypocisy/ groupmod -n hypocrisy hypocisy 实际信息可以看/etc/passwd和/etc/shadow 6. Default root修改lightdm配置对于早期的系统，打开root登陆，修改 /etc/lightdm/lightdm.conf.d/50-unity-greeter.conf添加：greeter-show-manual-login=trueallow-guest=true说明：greeter-show-manual-login=true #允许手工输入登陆系统的用户名和密码allow-guest=true #允许guest登录，可以根据自己的需要修改保存后重启，就可以通过输入用户名root登陆了而在15.04中，配置文件位置改变了，为/user/share/lightdm/lightdm.conf.d/加入greeter-show-manual-login=true之后重启会有错误，再修改/root/.profiletty -s &amp;&amp; mesg n 7. ProxyShadowsocks 8. root后的问题root登录后发现他把键有些不能补全，修改/root/.bashrc文件123#if [ -f /etc/bash_completion ] &amp;&amp; ! shopt -oq posix; then# . /etc/bash_completion#fi 将上述注释去了即可root后无声音：修改/root/.profile，最后加一句pulseaudio --start --log-target=syslog 或者运行alsamixer，修改auto-mute-mode 9. Githubhttps://help.github.com/articles/generating-ssh-keys/创建ssh key先，ls -al ~/.ssh查询该主机没有ssh key，于是创建：ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;Ensure ssh-agent is enabled:eval &quot;$(ssh-agent -s)&quot;Add your SSH key to the ssh-agent:ssh-add ~/.ssh/id_rsa open the ~/.ssh/id_rsa.pub file.Select the entire contents of the file and copy it to your clipboard. Do not add any newlines or whitespace.Add the copied key to GitHub: Test the connection:ssh -T git@github.com 10. FontYaHei.Consolas.1.12 11. Telegram挂代理下载包，解压缩直接运行即可。 12. Vim13. PDFevince ***.pdf 14. Codeblocks15. irc 命令行工具irssiweechat]]></content>
      <categories>
        <category>techonology</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[民生银行2015笔试]]></title>
    <url>%2F2015%2F05%2F15%2Finterview01%2F</url>
    <content type="text"><![CDATA[1. 前言看到群里说有民生银行的内推, 直接去笔试面试即可, 就想着还没有正式去找过工作实习, 权当锻炼自己 2. 笔试做完后告诉我们是去年的试题、、 2.1 选择题选择题还是很基础的一些题型，感觉就是计院的期末考题(非计算机专业的胡乱猜测)，有算法时间复杂度的，二叉树的各类遍历，Http状态码、数据库的操作语句，简单的加密解密方法、 2.2 编程题 第一题应该是最简单的，当然是对其他人而言，考的是数据库的操作，我只会最基本的SELECT语句，稍微复杂点就忘了，都是现用现查，而且我也的确没系统学习过数据库, 所以直接放弃。但是其知识点还是知道的，应该就是数据库的多表连接知识 第二题考的是算法，很常见的一道题，但是是留到最后做的。题目就是“最大访客数”，网上搜一下都是 第三题是求1~n内的所有素数，主要应该考虑时间复杂度吧，这里得说下笔试要求是要写出可以编译运行的代码，也就是说得写完整了，比如Java得有的public static void main(String[] args){}，C得有main()函数，手写代码简直痛苦，怕写错对象方法名，所以默默地用C写的 第四题以二维码为背景，但是我觉得考察点是位操作和字符串操作。悲剧的是做完出来和别人一聊发现原来不止一小题，我输出字符串后以为没有其他题了 后续还有两道附加题，考的是移动端开发，IOS和Android，毕竟移动端是大势所趋。Android的还知道点，Android Service如何保证运行不被杀死，详见此处 3. 面试本以为一上午能解决完的, 没想到等到下午再面试, 可惜下午又考试，坐地铁回还得2小时，只能遗憾地向管理人员说明情况提前离开]]></content>
      <categories>
        <category>life</category>
        <category>work</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记七]]></title>
    <url>%2F2015%2F05%2F08%2Freading07%2F</url>
    <content type="text"><![CDATA[1. PrefaceFrom Sand and Foam (excerpt) by Kahlil Gibran 2. ContentSeven times I have despised my soul:The first time when I saw her being meek that she might attain height.The second time when I saw her limping before the crippled.The third time when she was given to choose between the hard and the easy, and she chose the easy.The fourth time when she committed a wrong, and comforted herself that others also commit wrong.The fifth time when she forbore for weakness, and attributed her patience to strength.The sixth time when she despised the ugliness of a face, and knew not that it was one of her own masks.And the seventh time when she sang a song of praise, and deemed it a virtue纪伯伦 《沙与沫》 （节选）曾有七次我鄙视我的灵魂：第一次，当我看到她可以升迁却退让时第二次，当我看到她在瘸者面前跛足前行时第三次，当她处在难易之间而选择了易时第四次，当她犯了错，却安慰自己说别人也会犯错时第五次，当她因为懦弱而忍耐，却自认为坚忍时第六次，当她鄙视一张人面的丑陋，却不知道那正是自己面具的一张时第七次，当她唱着颂歌并自以为是一种美德时All(全文):I AM FOREVER walking upon these shores,Betwixt the sand and the foam,The high tide will erase my foot-prints,And the wind will blow away the foam.But the sea and the shore will remainForever.Once I filled my hand with mist.Then I opened it and lo, the mist was a worm.And I closed and opened my hand again, and behold there was a bird.And again I closed and opened my hand, and in its hollow stood a man with a sad face, turned upward.And again I closed my hand, and when I opened it there was naught but mist.But I heard a song of exceeding sweetness.It was but yesterday I thought myself a fragment quivering without rhythm in the sphere of life.Now I know that I am the sphere, and all life in rhythmic fragments moves within me.They say to me in their awakening, “You and the world you live in are but a grain of sand upon the infinite shore of an infinite sea.”And in my dream I say to them, “I am the infinite sea, and all worlds are but grains of sand upon my shore.”Only once have I been made mute. It was when a man asked me, “Who are you?”The first thought of God was an angel.The first word of God was a man.We were fluttering, wandering, longing creatures a thousand thousand years before the sea and the wind in the forest gave us words.Now how can we express the ancient of days in us with only the sounds of our yesterdays?The Sphinx spoke only once, and the Sphinx said, “A grain of sand is a desert, and a desert is a grain of sand; and now let us all be silent again.”I heard the Sphinx, but I did not understand.Long did I lie in the dust of Egypt, silent and unaware of the seasons.Then the sun gave me birth, and I rose and walked upon the banks of the Nile,Singing with the days and dreaming with the nights.And now the sun threads upon me with a thousand feet that I may lie again in the dust of Egypt.But behold a marvel and a riddle!The very sun that gathered me cannot scatter me.Still erect am I, and sure of foot do I walk upon the banks of the Nile.Remembrance is a form of meeting.Forgetfulness is a form of freedom.We measure time according to the movement of countless suns; and they measure time by little machines in their little pockets.Now tell me, how could we ever meet at the same place and the same time?Space is not space between the earth and the sun to one who looks down from the windows of the Milky Way.Humanity is a river of light running from the ex-eternity to eternity.Do not the spirits who dwell in the ether envy man his pain?On my way to the Holy City I met another pilgrim and I asked him, “Is this indeed the way to the Holy City?”And he said, “Follow me, and you will reach the Holy City in a day and a night.”And I followed him. And we walked many days and many nights, yet we did not reach the Holy City.And what was to my surprise he became angry with me because he had misled me.Make me, oh God, the prey of the lion, ere You make the rabbit my prey.One may not reach the dawn save by the path of the night.My house says to me, “Do not leave me, for here dwells your past.”And the road says to me, “Come and follow me, for I am your future.”And I say to both my house and the road, “I have no past, nor have I a future. If I stay here, there is a going in my staying; and if I go there is a staying in my going. Only love and death will change all things.”How can I lose faith in the justice of life, when the dreams of those who sleep upon feathers are not more beautiful than the dreams of those who sleep upon the earth? Strange, the desire for certain pleasures is a part of my pain.Seven times have I despised my soul:The first time when I saw her being meek that she might attain height.The second time when I saw her limping before the crippled.The third time when she was given to choose between the hard and the easy, and she chose the easy.The fourth time when she committed a wrong, and comforted herself that others also commit wrong.The fifth time when she forbore for weakness, and attributed her patience to strength.The sixth time when she despised the ugliness of a face, and knew not that it was one of her own masks.And the seventh time when she sang a song of praise, and deemed it a virtue.I AM IGNORANT of absolute truth. But I am humble before my ignorance and therein lies my honor and my reward.There is a space between man’s imagination and man’s attainment that may only be traversed by his longing.Paradise is there, behind that door, in the next room; but I have lost the key.Perhaps I have only mislaid it.You are blind and I am deaf and dumb, so let us touch hands and understand.The significance of man is not in what he attains, but rather in what he longs to attain.Some of us are like ink and some like paper.And if it were not for the blackness of some of us, some of us would be dumb;And if it were not for the whiteness of some of us, some of us would be blind.Give me an ear and I will give you a voice.Our mind is a sponge; our heart is a stream.Is it not strange that most of us choose sucking rather than running?When you long for blessings that you may not name, and when you grieve knowing not the cause, then indeed you are growing with all things that grow, and rising toward your greater self.When one is drunk with a vision, he deems his faint expression of it the very wine.You drink wine that you may be intoxicated; and I drink that it may sober me from that other wine.When my cup is empty I resign myself to its emptiness; but when it is half full I resent its half-fulness.The reality of the other person is not in what he reveals to you, but in what he cannot reveal to you.Therefore, if you would understand him, listen not to what he says but rather to what he does not say.Half of what I say is meaningless; but I say it so that the other half may reach you.A sense of humour is a sense of proportion.My loneliness was born when men praised my talkative faults and blamed my silent virtues.When Life does not find a singer to sing her heart she produces a philosopher to speak her mind.A truth is to be known always, to be uttered sometimes.The real in us is silent; the acquired is talkative.The voice of life in me cannot reach the ear of life in you; but let us talk that we may not feel lonely.When two women talk they say nothing; when one woman speaks she reveals all of life.Frogs may bellow louder than bulls, but they cannot drag the plough in the field not turn the wheel of the winepress, and of their skins you cannot make shoes.Only the dumb envy the talkative.If winter should say, “Spring is in my heart,” who would believe winter?Every seed is a longing.Should you really open your eyes and see, you would behold your image in all images.And should you open your ears and listen, you would hear your own voice in all voices.It takes two of us to discover truth: one to utter it and one to understand it.Though the wave of words is forever upon us, yet our depth is forever silent.Many a doctrine is like a window pane. We see truth through it but it divides us from truth.Now let us play hide and seek. Should you hide in my heart it would not be difficult to find you. But should you hide behind your own shell, then it would be useless for anyone to seek you. A woman may veil her face with a smile.How noble is the sad heart who would sing a joyous song with joyous hearts.He who would understand a woman, or dissect genius, or solve the mystery of silence is the very man who would wake from a beautiful dream to sit at a breakfast table.I would walk with all those who walk. I would not stand still to watch the procession passing by.You owe more than gold to him who serves you. Give him of your heart or serve him.Nay, we have not lived in vain. Have they not built towers of our bones?Let us not be particular and sectional. The poet’s mind and the scorpion’s tail rise in glory from the same earth.Every dragon gives birth to a St. George who slays it.Trees are poems that the earth writes upon the sky. We fell them down and turn them into paper that we may record our emptiness.Should you care to write (and only the saints know why you should) you must needs have knowledge and art and music – the knowledge of the music of words, the art of being artless, and the magic of loving your readers.They dip their pens in our hearts and think they are inspired.Should a tree write its autobiography it would not be unlike the history of a race.If I were to choose between the power of writing a poem and the ecstasy of a poem unwritten, I would choose the ecstasy. It is better poetry.But you and all my neighbors agree that I always choose badly.Poetry is not an opinion expressed. It is a song that rises from a bleeding wound or a smiling mouth.Words are timeless. You should utter them or write them with a knowledge of their timelessness.A POET IS a dethroned king sitting among the ashes of his palace trying to fashion an image out of the ashes.Poetry is a deal of joy and pain and wonder, with a dash of the dictionary.In vain shall a poet seek the mother of the songs of his heart.Once I said to a poet, “We shall not know your worth until you die.”And he answered saying, “Yes, death is always the revealer. And if indeed you would know my worth it is that I have more in my heart than upon my tongue, and more in my desire than in my hand.”If you sing of beauty though alone in the heart of the desert you will have an audience.Poetry is wisdom that enchants the heart.Wisdom is poetry that sings in the mind.If we could enchant man’s heart and at the same time sing in his mind,Then in truth he would live in the shadow of God.Inspiration will always sing; inspiration will never explain.We often sing lullabies to our children that we ourselves may sleep.All our words are but crumbs that fall down from the feast of the mind.Thinking is always the stumbling stone to poetry.A great singer is he who sings our silences.How can you sing if your mouth be filled with food?How shall your hand be raised in blessing if it is filled with gold?They say the nightingale pierces his bosom with a thorn when he sings his love song.So do we all. How else should we sing?Genius is but a robin’s song at the beginning of a slow spring.Even the most winged spirit cannot escape physical necessity.A madman is not less a musician than you or myself; only the instrument on which he plays is a little out of tune.The song that lies silent in the heart of a mother sings upon the lips of her child.No longing remains unfulfilled.I have never agreed with my other self wholly. The truth of the matter seems to lie between us.Your other self is always sorry for you. But your other self grows on sorrow; so all is well.There is no struggle of soul and body save in the minds of those whose souls are asleep and whose bodies are out of tune.When you reach the heart of life you shall find beauty in all things, even in the eyes that are blind to beauty.We live only to discover beauty. All else is a form of waiting.Sow a seed and the earth will yield you a flower. Dream your dream to the sky and it will bring you your beloved.The devil died the very day you were born.Now you do not have to go through hell to meet an angel.Many a woman borrows a man’s heart; very few could possess it.If you would possess you must not claim.When a man’s hand touches the hand of a woman they both touch the heart of eternity.Love is the veil between lover and lover.Every man loves two women; the one is the creation of his imagination, and the other is not yet born.Men who do not forgive women their little faults will never enjoy their great virtues.Love that does not renew itself every day becomes a habit and in turn a slavery.Lovers embrace that which is between them rather than each other.Love and doubt have never been on speaking terms.Love is a word of light, written by a hand of light, upon a page of light.Friendship is always a sweet responsibility, never an opportunity.If you do not understand your friend under all conditions you will never understand him.Your most radiant garment is of the other person’s weaving;You most savory meal is that which you eat at the other person’s table;Your most comfortable bed is in the other person’s house.Now tell me, how can you separate yourself from the other person?Your mind and my heart will never agree until your mind ceases to live in numbers and my heart in the mist.We shall never understand one another until we reduce the language to seven words.HOW SHALL MY heart be unsealed unless it be broken?Only great sorrow or great joy can reveal your truth.If you would be revealed you must either dance naked in the sun, or carry your cross.Should nature heed what we say of contentment no river would seek the sea, and no winter would turn to Spring. Should she heed all we say of thrift, how many of us would be breathing this air?You see but your shadow when you turn your back to the sun.You are free before the sun of the day, and free before the stars of the night;And you are free when there is no sun and no moon and no star.You are even free when you close your eyes upon all there is.But you are a slave to him whom you love because you love him,And a slave to him who loves you because he loves you.We are all beggars at the gate of the temple, and each one of us receives his share of the bounty of the King when he enters the temple, and when he goes out.But we are all jealous of one another, which is another way of belittling the King.You cannot consume beyond your appetite. The other half of the loaf belongs to the other person, and there should remain a little bread for the chance guest.If it were not for your guests all houses would be graves.Said a gracious wolf to a simple sheep, “Will you not honor our house with a visit?”And the sheep answered, “We would have been honored to visit your house if it were not in your stomach.”I stopped my guest on the threshold and said, “Nay, wipe not your feet as you enter, but as you go out.”Generosity is not in giving me that which I need more than you do, but it is in giving me that which you need more than I do.You are indeed charitable when you give, and while giving, turn your face away so that you may not see the shyness of the receiver.The difference between the richest man and the poorest is but a day of hunger and an hour of thirst.We often borrow from our tomorrows to pay our debts to our yesterdays.I too am visited by angels and devils, but I get rid of them.When it is an angel I pray an old prayer, and he is bored;When it is a devil I commit an old sin, and he passes me by.After all this is not a bad prison; but I do not like this wall between my cell and the next prisoner’s cell;Yet I assure you that I do not wish to reproach the warder not the Builder of the prison.Those who give you a serpent when you ask for a fish, may have nothing but serpents to give. It is then generosity on their part.Trickery succeeds sometimes, but it always commits suicide.You are truly a forgiver when you forgive murderers who never spill blood, thieves who never steal, and liars who utter no falsehood.He who can put his finger upon that which divides good from evil is he who can touch the very hem of the garment of God.If your heart is a volcano how shall you expect flowers to bloom in your hands?A strange form of self-indulgence! There are times when I would be wronged and cheated, that I may laugh at the expense of those who think I do not know I am being wronged and cheated.What shall I say of him who is the pursuer playing the part of the pursued?Let him who wipes his soiled hands with your garment take your garment. He may need it again; surely you would not.It is a pity that money-changers cannot be good gardeners.Please do not whitewash your inherent faults with your acquired virtues. I would have the faults; they are like mine own.How often have I attributed to myself crimes I have never committed, so that the other person may feel comfortable in my presence.Even the masks of life are masks of deeper mystery.You may judge others only according to your knowledge of yourself.Tell me now, who among us is guilty and who is unguilty?The truly just is he who feels half guilty of your misdeeds.Only an idiot and a genius break man-made laws; and they are the nearest to the heart of God.It is only when you are pursued that you become swift.I have no enemies, O God, but if I am to have an enemyLet his strength be equal to mine,That truth alone may be the victor.You will be quite friendly with your enemy when you both die.Perhaps a man may commit suicide in self-defense.Long ago there lived a Man who was crucified for being too loving and too lovable.And strange to relate I met him thrice yesterday.The first time He was asking a policeman not to take a prostitute to prison; the second time He was drinking wine with an outcast; and the third time He was having a fist-fight with a promoter inside a church.If all they say of good and evil were true, then my life is but one long crime.Pity is but half justice.THE ONLY ONE who has been unjust to me is the one to whose brother I have been unjust.When you see a man led to prison say in your heart, “Mayhap he is escaping from a narrower prison.”And when you see a man drunken say in your heart, “Mayhap he sought escape from something still more unbeautiful.”Oftentimes I have hated in self-defense; but if I were stronger I would not have used such a weapon.How stupid is he who would patch the hatred in his eyes with the smile of his lips.Only those beneath me can envy or hate me.I have never been envied nor hated; I am above no one.Only those above me can praise or belittle me.I have never been praised nor belittled; I am below no one.Your saying to me, “I do not understand you,” is praise beyond my worth, and an insult you do not deserve. How mean am I when life gives me gold and I give you silver, and yet I deem myself generous.When you reach the heart of life you will find yourself not higher than the felon, and not lower than the prophet.Strange that you should pity the slow-footed and not the slow-minded,And the blind-eyed rather than the blind-hearted.It is wiser for the lame not to break his crutches upon the head of his enemy.How blind is he who gives you out of his pocket that he may take out of your heart.Life is a procession. The slow of foot finds it too swift and he steps out;And the swift of foot finds it too slow and he too steps out.If there is such a thing as sin some of us commit it backward following our forefathers’ footsteps;And some of us commit it forward by overruling our children.The truly good is he who is one with all those who are deemed bad.We are all prisoners but some of us are in cells with windows and some without.Strange that we all defend our wrongs with more vigor than we do our rights.Should we all confess our sins to one another we would all laugh at one another for our lack of originality.Should we all reveal our virtues we would also laugh for the same cause.An individual is above man-made laws until he commits a crime against man-made conventions; After that he is neither above anyone nor lower than anyone.Government is an agreement between you and myself. You and myself are often wrong.Crime is either another name of need or an aspect of a disease.Is there a greater fault than being conscious of the other person’s faults?If the other person laughs at you, you can pity him; but if you laugh at him you may never forgive yourself.If the other person injures you, you may forget the injury; but if you injure him you will always remember.In truth the other person is your most sensitive self given another body.How heedless you are when you would have men fly with your wings and you cannot even give them a feather.Once a man sat at my board and ate my bread and drank my wine and went away laughing at me.Then he came again for bread and wine, and I spurned him;And the angels laughed at me.Hate is a dead thing. Who of you would be a tomb?It is the honor of the murdered that he is not the murderer.The tribune of humanity is in its silent heart, never its talkative mind.They deem me mad because I will not sell my days for gold;And I deem them mad because they think my days have a price.They spread before us their riches of gold and silver, of ivory and ebony, and we spread before them our hearts and our spirits.;And yet they deem themselves the hosts and us the guests.I would not be the least among men with dreams and the desire to fulfill them, rather than the greatest with no dreams and no desires.The most pitiful among men is he who turns his dreams into silver and gold.We are all climbing toward the summit of our hearts’ desire. Should the other climber steal your sack and your purse and wax fat on the one and heavy on the other, you should pity him;The climbing will be harder for his flesh, and the burden will make his way longer.And should you in your leanness see his flesh puffing upward, help him a step; it will add to your swiftness.You cannot judge any man beyond your knowledge of him, and how small is your knowledge.I would not listen to a conqueror preaching to the conquered.The truly free man is he who bears the load of the bond slave patiently.A thousand years ago my neighbor said to me, “I hate life, for it is naught but a thing of pain.”And yesterday I passed by a cemetery and saw life dancing upon his grave.Strife in nature is but disorder longing for order.Solitude is a silent storm that breaks down all our dead branches;Yet it sends our living roots deeper into the living heart of the living earth.Once I spoke of the sea to a brook, and the brook thought me but an imaginative exaggerator;And once I spoke of a brook to the sea, and the sea thought me but a depreciative defamer.How narrow is the vision that exalts the busyness of the ant above the singing of the grasshopper.The highest virtue here may be the least in another world.The deep and the high go to the depth or to the height in a straight line; only the spacious can move in circles.IF IT WERE not for our conception of weights and measures we would stand in awe of the firefly as we do before the sun.A scientist without imagination is a butcher with dull knives and out-worn scales.But what would you, since we are not all vegetarians?When you sing the hungry hears you with his stomach.Death is not nearer to the aged than to the new-born; neither is life.If indeed you must be candid, be candid beautifully; otherwise keep silent, for there is a man in our neighborhood who is dying.Mayhap a funeral among men is a wedding feast among the angels.A forgotten reality may die and leave in its will seven thousand actualities and facts to be spent in its funeral and the building of a tomb.In truth we talk only to ourselves, but sometimes we talk loud enough that others may hear us.The obvious is that which is never seen until someone expresses it simply.If the Milky Way were not within me how should I have seen it or known it?Unless I am a physician among physicians they would not believe that I am an astronomer.Perhaps the sea’s definition of a shell is the pearl.Perhaps time’s definition of coal is the diamond.Fame is the shadow of passion standing in the light.A root is a flower that disdains fame.There is neither religion nor science beyond beauty.Every great man I have known had something small in his make-up; and it was that small something which prevented inactivity or madness or suicide.The truly great man is he who would master no one, and who would be mastered by none.I would not believe that a man is mediocre simply because he kills the criminals and the prophets.Tolerance is love sick with the sickness of haughtiness.Worms will turn; but is it not strange that even elephants will yield?A disagreement may be the shortest cut between two minds.I am the flame and I am the dry bush, and one part of me consumes the other part.We are all seeking the summit of the holy moutain; but shall not our road be shorter if we consider the past a chart and not a guide?Wisdom ceases to be wisdom when it becomes too proud to weep, too grave to laugh, and too self-ful to seek other than itself.Had I filled myself with all that you know what room should I have for all that you do not know?I have learned silence from the talkative, toleration from the intolerant, and kindness from the unkind; yet strange, I am ungrateful to these teachers.A bigot is a stone-leaf orator.The silence of the envious is too noisy.When you reach the end of what you should know, you will be at the beginning of what you should sense.An exaggeration is a truth that has lost its temper.If you can see only what light reveals and hear only what sound announces,Then in truth you do not see nor do you hear.A fact is a truth unsexed.You cannot laugh and be unkind at the same time.The nearest to my heart are a king without a kingdom and a poor man who does not know how to beg.A shy failure is nobler than an immodest success.Dig anywhere in the earth and you will find a treasure, only you must dig with the faith of a peasant.Said a hunted fox followed by twenty horsemen and a pack of twenty hounds, “Of course they will kill me. But how poor and how stupid they must be. Surely it would not be worth while for twenty foxes riding on twenty asses and accompanied by twenty wolves to chase and kill one man.”It is the mind in us that yields to the laws made by us, but never the spirit in us.A traveler am I and a navigator, and every day I discover a new region within my soul.A woman protested saying, “Of course it was a righteous war. My son fell in it.”I said to Life, “I would hear Death speak.”And Life raised her voice a little higher and said, “You hear him now.”When you have solved all the mysteries of life you long for death, for it is but another mystery of life.Birth and death are the two noblest expressions of bravery.My friend, you and I shall remain strangers unto life,And unto one another, and each unto himself,Until the day when you shall speak and I shall listenDeeming your voice my own voice;And when I shall stand before youThinking myself standing before a mirror.They say to me, “Should you know yourself you would know all men.”And I say, “Only when I seek all men shall I know myself.”MAN IS TWO men; one is awake in darkness, the other is asleep in light.A hermit is one who renounces the world of fragments that he may enjoy the world wholly and without interruption.There lies a green field between the scholar and the poet; should the scholar cross it he becomes a wise man; should the poet cross it, he becomes a prophet.Yestereve I saw philosophers in the market-place carrying their heads in baskets, and crying aloud, “Wisdom! Wisdom for sale!”Poor philosophers! They must needs sell their heads to feed their hearts. Said a philosopher to a street sweeper, “I pity you. Yours is a hard and dirty task.”And the street sweeper said, “Thank you, sir. But tell me what is your task?”And the philosopher answered saying, “I study man’s mind, his deeds and his desires.”Then the street sweeper went on with his sweeping and said with a smile, “I pity you too.”He who listens to truth is not less than he who utters truth.No man can draw the line between necessities and luxuries. Only the angels can do that, and the angels are wise and wistful.Perhaps the angels are our better thought in space.He is the true prince who finds his throne in the heart of the dervish.Generosity is giving more than you can, and pride is taking less than you need.In truth you owe naught to any man. You owe all to all men.All those who have lived in the past live with us now. Surely none of us would be an ungracious host.He who longs the most lives the longest.They say to me, “A bird in the hand is worth ten in the bush.”But I say, “A bird and a feather in the bush is worth more than ten birds in the hand.”Your seeking after that feather is life with winged feet; nay, it is life itself.There are only two elements here, beauty and truth; beauty in the hearts of lovers, and truth in the arms of the tillers of the soil.Great beauty captures me, but a beauty still greater frees me even from itself.Beauty shines brighter in the heart of him who longs for it than in the eyes of him who sees it.I admire him who reveals his mind to me; I honor him who unveils his dreams. But why am I shy, and even a little ashamed before him who serves me?The gifted were once proud in serving princes.Now they claim honor in serving paupers.The angels know that too many practical men eat their bread with the sweat of the dreamer’s brow.Wit is often a mask. If you could tear it you would find either a genius irritated or cleverness juggling.The understanding attributes to me understanding and the dull, dullness. I think they are both right.Only those with secrets in their hearts could divine the secrets in our hearts.He who would share your pleasure but not your pain shall lose the key to one of the seven gates of Paradise.Yes, there is a Nirvanah; it is in leading your sheep to a green pasture, and in putting your child to sleep, and in writing the last line of your poem.We choose our joys and our sorrows long before we experience them.Sadness is but a wall between two gardens.When either your joy or your sorrow becomes great the world becomes small.Desire is half of life; idifference is half of death.The bitterest thing in our today’s sorrow is the memory of our yesterday’s joy.They say to me, “You must needs choose between the pleasures of this world and the peace of the next world.”And I say to them, “I have chosen both the delights of this world and the peace of the next. For I know in my heart that the Supreme Poet wrote but one poem, and it scans perfectly, and it also rhymes perfectly.”Faith is an oasis in the heart which will never be reached by the caravan of thinking.When you reach your height you shall desire but only for desire; and you shall hunger, for hunger; and you shall thirst for greater thirst.If you reveal your secrets to the wind you should not blame the wind for revealing them to the trees.The flowers of spring are winter’s dreams related at the breakfast table of the angels.Said a skunk to a tube-rose, “See how swiftly I run, while you cannot walk nor even creep.”Said the tube-rose to the skunk, “Oh, most noble swift runner, please run swiftly!”Turtles can tell more about roads than hares.Strange that creatures without backbones have the hardest shells.The most talkative is the least intelligent, and there is hardly a difference between an orator and an auctioneer.Be grateful that you do not have to live down the renown of a father nor the wealth of an uncle.But above all be grateful that no one will have to live down either your renown or your wealth.Only when a juggler misses catching his ball does he appeal to me.The envious praises me unknowingly.Long were you a dream in your mother’s sleep, and then she woke to give you birth.The germ of the race is in your mother’s longing.My father and mother desired a child and they begot me.And I wanted a mother and a father and I begot night and the sea.Some of our children are our justifications and some are but our regrets.When night comes and you too are dark, lie down and be dark with a will.And when morning comes and you are still dark stand up and say to the day with a will, “I am still dark.”It is stupid to play a role with the night and the day.They would both laugh at you.The mountain veiled in mist is not a hill; an oak tree in the rain is not a weeping willow.Behold here is a paradox; the deep and high are nearer to one another than the mid-level to either.When I stood a clear mirror before you, you gazed into me and saw your image.Then you said, “I love you.”But in truth you loved yourself in me.When you enjoy loving your neighbor it ceases to be a virtue.Love which is not always springing is always dying.You cannot have youth and the knowledge of it at the same time;For youth is too busy living to know, and knowledge is too busy seeking itself to live. You may sit at your window watching the passersby. And watching you may see a nun walking toward your right hand, and a prostitute toward your left hand.And you may say in your innocence, “How noble is the one and how ignoble is the other.”But should you close your eyes and listen awhile you would hear a voice whispering in the ether, “One seeks me in prayer, and the other in pain. And in the spirit of each there is a bower for my spirit.”Once every hundred years Jesus of Nazareth meets Jesus of the Christian in a garden among the hills of Lebanon. And they talk long; and each time Jesus of Nazareth goes away saying to Jesus of the Christian, “My friend, I fear we shall never, never agree.”May God feed the over-abundant!A great man has two hearts; one bleeds and the other forbears.Should one tell a lie which does not hurt you nor anyone else, why not say in your heart that the house of his facts is too small for his fancies, and he had to leave it for larger space?Behind every closed door is a mystery sealed with seven seals.Waiting is the hoofs of time.What if trouble should be a new window in the Eastern wall of your house?You may forget the one with whom you have laughed, but never the one with whom you have wept.There must be something strangely sacred in salt. It is in our tears and in the sea.Our God in His gracious thirst will drink us all, the dewdrop and the tear.You are but a fragment of your giant self, a mouth that seeks bread, and a blind hand that holds the cup for a thirsty mouth.If you would rise but a cubit above race and country and self you would indeed become godlike.If I were you I would not find fault with the sea at low tide.It is a good ship and our Captain is able; it is only your stomach that is in disorder.Should you sit upon a cloud you would not see the boundary line between one country and another, nor the boundary stone between a farm and a farm.It is a pity you cannot sit upon a cloud.Seven centuries ago seven white doves rose from a deep valley flying to the snow-white summit of the mountain. One of the seven men who watched the flight said, “I see a black spot on the wing of the seventh dove.”Today the people in that valley tell of seven black doves who flew to the summit of the snowy mountain.In the autumn I gathered all my sorrows and buried them in my garden.And when April returned and spring came to wed the earth, there grew in my garden beautiful flowers unlike all other flowers.And my neighbors came to behold them, and they all said to me, “When autumn comes again, at seeding time, will you not give us of the seeds of these flowers that we may have them in our gardens?”It is indeed misery if I stretch an empty hand to men and receive nothing; but it is hopelessness if I stretch a full hand and find none to receive.I long for eternity because there I shall meet my unwritten poems and my unpainted pictures.Art is a step from nature toward the Infinite.A work of art is a mist carved into an image.Even the hands that make crowns of thorns are better than idle hands.Our most sacred tears never seek our eyes.Every man is the descendant of every king and every slave that ever lived.If the great-grandfather of Jesus had known what was hidden within him, would he not have stood in awe of himself?Was the love of Judas’ mother of her son less than the love of Mary for Jesus?There are three miracles of our Brother Jesus not yet recorded in the Book: the first that He was a man like you and me, the second that He had a sense of humour, and the third that He knew He was a conqueror though conquered.Crucified One, you are crucified upon my heart; and the nails that pierce your hands pierce the walls of my heart.And tomorrow when a stranger passes by this Golgotha he will not know that two bled here.He will deem it the blood of one man.You may have heard of the Blessed Mountain.It is the highest mountain in our world.Should you reach the summit you would have only one desire, and that to descend and be with those who dwell in the deepest valley.That is why it is called the Blessed Mountain.Every thought I have imprisoned in expression I must free by my deeds.]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>poetry</tag>
        <tag>kahlil gibran</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 琐记一]]></title>
    <url>%2F2015%2F03%2F15%2Fpython01%2F</url>
    <content type="text"><![CDATA[1. BOOLPython 中bool类型把数0看作falsebool(0) 2. range最常用的函数range，可传递1、2或3个参数，只有1个则是下边界，两个就是上下边界，三个则加上了步长。 3. lambda类似于函数式程序语言Lisp，Python提供了lambda12f = lambda x,y: x+yprint f(1,2) 但是lambda功能有限，它只是一个表达式，不是一个语句，lambda会返回一个值，而不需要return，事实上使用了return就会出现语法错误lambda实际上就是def的简化形式，但是它可以在列表等数据容器中出现 4. mapmap函数处理的是函数，它对一个List对象的每一项都调用了一个传递的函数，并返回一个包含所有调用结果的列表1234567l = [1,2,3,4,5,6,7]def inc2times(x): return x+x;r = map(inc2times,l)print rprint map(lambda x: x+x, l) 5. 函数式编程python事实上完全支持函数式编程，函数即对象，这与JavaScript一致，函数可以作为对象来传递、调用，被作为列表的元素等 6. 嵌套函数的作用域嵌套的函数对自己的局部作用域，包含自己模块的全局作用域以及内置的名字作用域有访问权，它对包含自己的函数的作用域无访问权。无论多深的函数嵌套都只能看见三个作用域。12345678def outer(x): def inner(i): print i if(i): innenr(i-1) inner(x)outer(3) 上述代码就会语法出错。 7. name每一个模块都有一个内置属性name如果文件作为程序运行，在启动时，name设置为字符串main如果文件是被导入的，name设置为用户已知的模块名 8.site-packages和disk-packages的区别dist-packages is a Debian-specific convention that is also present in its derivatives, like Ubuntu. Modules are installed to dist-packages when they come from the Debian package manager into this location:/usr/lib/python2.7/dist-packagesSince easy_install and pip are installed from the package manager, they also use dist-packages, but they put packages here:/usr/local/lib/python2.7/dist-packagesFrom the Debian Python Wiki:dist-packages instead of site-packages. Third party Python software installed from Debian packages goes into dist-packages, not site-packages. This is to reduce conflict between the system Python, and any from-source Python build you might install manually.This means that if you manually install Python from source, it uses the site-packages directory. This allows you to keep the two installations separate, especially since Debian and Ubuntu rely on the system version of Python for many system utilities. 9. 中文注释在Linux中Python代码中加入中文注释提示编码错误，解决方案：文件头加入# coding:utf-8]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>programming language</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++琐记一]]></title>
    <url>%2F2015%2F03%2F12%2Fcpp01%2F</url>
    <content type="text"><![CDATA[1. 前言没有系统地学过C++, 偶尔会把C++当作高级的C语言用下, 用下它的STL库, 有些很基础的东西都不知道。某课程的作业要求只能用C/C++写, 一动手发现全是错误, 故在此记录。 2. string类string类经常使用, 平时还是用来连接下字符串比较多, 还有一些其他常用的方法：12substr(int, int)str.substr(start,length) //返回str字符串start位置开始的长度为length的字符串，需要依次输出字符串中的字符时，可以变为str.substr(i,1)，而不用str.at(i)，因为str.at(i)返回值类型为char * 3. int转为string直接用了toString(), 编译报错才想起来是C++不是Java啊……搜了下又不太想用itoa和sprintf, 就用了stringstream类12345#include &lt;sstream&gt;stringstream stream;string str;stream &lt;&lt; v[i][j]; //注意sstream输入是&lt;&lt;而不是iostream的&gt;&gt;stream &gt;&gt; str; 4. queue模板类顾名思义, queue就是队列, 这个类实现了队列的操作, 但是其pop()方法竟然不返回值, 只是删除队首元素, 要获取队首元素, 需要使用front()方法:123queue&lt;string&gt; que;string head = que.front();que.pop(); 5. map类提供了一一对应的关系, 实例化一个map类后, 添加了新元素, 想要查找其中的key, 利用了其find()方法:12345map&lt;string,int&gt; myMap;myMap["test"] = 1;if( myMap.find("test") == myMap.end() ) &#123; &#125; 更加常用的方法是count. 6. this的使用还是受Java影响, 如下:12345678910class A &#123;public: A(int a);private: int a;&#125;;A::A(int a) &#123; this.a = a; //错误 cout &lt;&lt; this.a &lt;&lt; endl;&#125; 区别在于C++中的this是指针, 而Java没有指针概念, 都是引用对象, 所以在C++中其实应该如此:12345678910class A &#123;public: A(int a);private: int a;&#125;;A::A(int a) &#123; (*this).a = a; //or this-&gt;a = a; cout &lt;&lt; (*this).a &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>programming language</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵的Jordan标准型求法以及对应的最小多项式]]></title>
    <url>%2F2015%2F03%2F10%2Fmatrix01%2F</url>
    <content type="text"><![CDATA[1. 矩阵的Jordan标准型求法2. 对应的最小多项式]]></content>
      <categories>
        <category>science</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>matrix</tag>
        <tag>jordan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈泛函、极值及最优化控制问题]]></title>
    <url>%2F2015%2F03%2F08%2Ffunctional%2F</url>
    <content type="text"><![CDATA[1. 前言花了几个小时复习自控，其中最后看的内容是关于泛函的，做个笔记，谈谈自己对它的理解。 2. 瞎想看到泛函的定义之后，我的第一反应是 这不就是将二维空间的函数上升了一个维度么。说起来，数学和物理领域很多概念都是在原有基础上进行维度的扩展得到的，不过进一步思考，泛函还可以上升到更高维度，简单的是二维空间内的函数对应一个具体数值，即上升到了三维空间，而如果是三维空间内的函数作为自变量(也就是宗量)，那么泛函就应该上升到四维空间了，如此推论，泛函其实可以定义在无限维空间。 从普通函数的维度扩展上来理解，泛函的很多性质，可以尝试着从原来我们所理解的函数基础上去学习，这样能够简化不少。 3. 定义维基百科上对泛函的说明: 传统上，泛函（functional）通常是指一种定义域为函数，而值域为实数的”函数”。换句话说，就是从函数组成的一个向量空间到实数的一个映射。也就是说它的输入为函数，而输出为实数。泛函的应用可以追溯到变分法，那里通常需要寻找一个函数用来最小化某个特定泛函。在物理学上，寻找某个能量泛函的最小系统状态是泛函的一个重要应用。在泛函分析中，泛函也用来指一个从任意向量空间到标量域的映射。泛函中的一类特例线性泛函引发了对对偶空间的研究。 4. 应用上述说到的寻找求取最小系统状态，便是我要学习泛函的原因之一，在控制系统中，给定状态和性能指标，要求计算出最小系统状态、最优控制或极小值等很常见。利用泛函这种工具，辅以欧拉方程、边界条件、横截条件可以比较方便地求出极值轨线，而对于有约束调节的状态，只是构造欧拉函数不同而已。而对于不受控的控制输入，求取最优控制时可以构造Hamilton函数，利用正则方程、边界条件和横截条件以及极值条件可以求解。最后，对于受控的控制输入，或者其控制变量不可微，那么久需要利用极小值原理，进行求解。 5. 无初始状态和末状态的极值轨线的求取6. 最优控制求取6.1 控制函数不受约束情况下6.2 控制函数受约束情况下]]></content>
      <categories>
        <category>science</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>functional</tag>
        <tag>optimal control</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript笔谈一]]></title>
    <url>%2F2015%2F02%2F25%2Fjavascript01%2F</url>
    <content type="text"><![CDATA[1. childNodes和children属性使用firstChild没有得到想要的结果, 用Chrome去调试发现firstChild竟然是文本元素, 然后又发现DOM节点有两属性childNodes和children, 于是学习记录下. 1.1. childNodes 属性标准的，它返回指定元素的子元素集合，包括HTML节点，所有属性，文本。可以通过nodeType来判断是哪种类型的节点，只有当nodeType==1时才是元素节点，2是属性节点，3是文本节点。有时候需要获取指定元素的第一个HTML子节点（非属性/文本节点），最容易想到的就是firstChild 属性。代码中第一个HTML节点前如果有换行，空格，那么firstChild返回的就不是你想要的了。看到这我就明白为什么我的firstChild不对了，因为我在html节点前加了好几个&amp;nbsp; 1.2 children 属性非标准的，它返回指定元素的子元素集合。经测试，它只返回HTML节点，甚至不返回文本节点。且在所有浏览器下表现惊人的一致。和childNodes 一样，在Firefox下不支持()取集合元素。需注意children在IE中包含注释节点。于是用children[0]代替firstChild，得到想要的结果、 2. Javascript迭代Object以为对象迭代只需要for(var item in object)即可取出object每个属性+值, 没想到这里的item只代表属性, 若需要得到值, 还需要object[item]但是若使用Angular JS的ng-repeat且只使用一个参数 则其自动得到的是值而不是属性若想得到key和value, 则(key,val) in data 3. Cookie for each tab若对浏览器打开某站点的每个tab页面都生成一个id并存储在cookie中, 可以使用SessionStorage例如sessionStorage.setItem(&#39;id&#39;,Date.now().toString());需要取出此id时, sessionStorage.getItem(&#39;id&#39;) 4. Canvas使用HTML5的Canvas画图, 发现长度不对, 设置style的width为1000px感觉只是scale了一下查阅文档发现Canvas作为特殊对象是存在width和height属性的, 应该设置该属性, 而不是style, 即&lt;canvas width=&quot;1000px&quot;&gt;&lt;/canvas&gt; 不使用 &lt;canvas style=&quot;width:1000px&quot;&gt;&lt;/canvas&gt;用jQuery的话则是$(&quot;#id&quot;).attr(&#39;width&#39;, 1000) 不是 $(&quot;#id&quot;).css(&#39;width&#39;,1000) 5. font-size一直以为font-size的30px表示显示的每个文字都是30px的宽和高, 最近发现font-size只决定高度, 宽度由字符集自己按照比例决定. 如果需要修改可以使用css的transform:scale(2.0,1.0)属性]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓概述]]></title>
    <url>%2F2014%2F11%2F02%2Fandroid04%2F</url>
    <content type="text"><![CDATA[前言 整理Github时, 找到了这篇以前不知是看哪本书时做的笔记。 1. 简析Android安装文件1.1 Android SDK目录结构 add-ons:包含了官方提供的API包，例如常用的Google Map API docs:包含了帮助文档和说明文档 platforms:包含了针对每个版本的SDK版本，提供了和其对应的API包以及一些示例文件，其中包含了各个版本的Android temp:包含了一些常用文件模板 tools:包含了一些通用的工具文件 usb_driver:包含了AMD64和X86下的驱动文件 SDK Setup.exe:Android的启动文件 1.2 android.jar及其内部结构在”platforms”目录下的每个Android版本中都有一个名为”android.jar”的压缩包 1.3 阅读SDK文档需要技巧 在解压缩文件”android.jar”之后，就可以了解其内部API的包结构和组织方式了。 使用浏览器打开”docs”目录下的文件index.html，这个网页就是SDK帮助文档的主页。 1.4 不简单的SDK工具SDK里面集成了很多其他有用的开发工具： Android模拟器 集成开发插件ADT 调试监视服务ddms.bat Android调试桥adb.exe Android虚拟设备 2. 实例教学Android安装目录中有一个名为”samples”的子目录, 在里面保存了SDK中的几个演示实例, 如android-7里面: 执行各个实例体验效果 3. 剖析Android系统架构3.1 Android体系结构的介绍Android是一个移动设备的开发平台，其软件层次结构包括操作系统(OS)、中间件(MiddleWare)和应用程序(Application)。根据软件框图，其软件层次自上而下分为以下四层： 操作系统层(OS) 各种库(Libraries)和Android运行环境(RunTime) 应用程序框架(Application Framework) 应用程序(Application) 上述各个层具体结构如下图示： 1) 操作系统层(OS)——最底层 Android对操作系统的使用包括核心和驱动程序两部分，Android的Linux核心为标准的Linux2.6内核，Android更多的是需要一些与移动设备相关的驱动程序，主要驱动程序如下： 显示驱动(Display Driver) Flash内存驱动(Flash Memory Driver) 照相机驱动(Camera Driver) 音频驱动(Audio Driver) Wifi驱动(Wifi Driver) 键盘驱动(KeyBoard Driver) 蓝牙驱动(Bluetooth Driver) Binder IPC驱动:Android的一个特殊驱动程序，具有单独的设备节点，提供进程间通信的功能 Power Management(能源管理) 2) 各种库(Libraries)和Android运行程序(RunTime)——中间层 Android的这一层分为两部分:一是各种库，另一个是Android运行环境。本层包含的库如下： C库 多媒体框架(MediaFramework) SGL SSL OpenGL ES 1.0 界面管理工具(Surface Management) SQLite WebKit FreeTypeAndroid的各种库一般是以系统中间件的形式提供的Android运行环境主要是指虚拟机技术——Dalvik 3) 应用程序(Application) 4) 应用程序框架(Application Framework) Android的应用程序框架为应用程序层的开发者提供APIs，它实际上是一个应用程序的框架。 一个基本的Android应用程序可以利用应用程序框架中的以下五个部分： Activity(活动) Broadcast Intent Receiver(广播意图接收者) Service(服务) Content Provider(内容提供者) Intent and Intent Filter(意图和意图过滤器) 3.2 Android应用工程文件组成 src目录——程序文件 AndroidMainfest.xml文件——设置文件 常量的定义文件 4. 简述五大组件4.1 用Activity来表现页面4.2 用Intent和IntentFilter实现切换4.3 Service 如何使用服务 Service生命周期 进程生命周期 4.4 用BroadcastIntentReceiver发送广播4.5 用ContentProvider存储数据 5. 进程和线程 6. 应用程序生命周期进程的类型多种多样,按重要程度分为以下几类: 前台进程(Foreground) 可见进程(Visible) 服务进程(Service) 后台进程(Background) 空进程(Empty)]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Configure OpenCV with VS2013]]></title>
    <url>%2F2014%2F10%2F28%2FconfigOpencv%2F</url>
    <content type="text"><![CDATA[1. InstallDownload OpenCV from:LastestHomepage Click the file you downloaded, choose a location to extract it. 2. Configuration2.1 EnvironmentConfigure your environment variables, for example, I add ;D:\Program Files\OpenCV\build\x86\vc12\bin to path: 2.2 ProjectThen open VS2013, and find project/properties: In VC++ Directories/Include Directories, add:123D:\Program Files\opencv\build\includeD:\Program Files\opencv\build\include\opencvD:\Program Files\opencv\build\include\opencv2 In VC++ Dorectories/Library Directories, add:D:\Program Files\opencv\build\x86\vc12\lib Then in Linker/Input/Additional Dependencies, add:12345678910111213141516171819opencv_ml249d.libopencv_calib3d249d.libopencv_contrib249d.libopencv_core249d.libopencv_features2d249d.libopencv_flann249d.libopencv_gpu249d.libopencv_highgui249d.libopencv_imgproc249d.libopencv_legacy249d.libopencv_objdetect249d.libopencv_ts249d.libopencv_video249d.libopencv_nonfree249d.libopencv_ocl249d.libopencv_photo249d.libopencv_stitching249d.libopencv_superres249d.libopencv_videostab249d.lib 3. CommentIf we use opencv-2.4.10, just change 249 to 2410, opencv-2.4.8 to 248. And there are equivalent .lib file without ‘d’, e.g.: opencv_videostab249.lib, it is used when we need to realease a project but not debug.And it is much easier in opencv-3.0, only a opencv_ts300d.lib or a opencv_ts300.lib will work.]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Usage of function generator in multisim]]></title>
    <url>%2F2014%2F10%2F26%2FfunctionGenerator%2F</url>
    <content type="text"><![CDATA[1. 问题进行多级放大电路和负反馈放大电路的模拟仿真时，用到了multisim里的function generator(函数发生器)，对其中的参数amplitude产生了困惑，这个amplitude(振幅)指的是峰值还是峰峰值。 2. 验证于是设计了一个及其简单的电路进行仿真: 其中函数发生器的amplitude设为10V，可是multimeter的结果却是14.142V，出乎意料于是查阅资料，发现function generator的三个引脚为正、负、接地，并不是负号出接地！这样改过之后，结果为7.071V 因为multimeter(万用表)测的为正弦交流信号的有效值，可以推测出function generator的amplitude为峰值。后来看见有网友解答说: 单位为Vp时是峰值，Vpp才是峰峰值 3. 电路图附上多级放大电路及负反馈电路的电路图：]]></content>
      <categories>
        <category>techonology</category>
        <category>ee</category>
      </categories>
      <tags>
        <tag>electronic</tag>
        <tag>multisim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ViewPager的使用]]></title>
    <url>%2F2014%2F09%2F01%2Fandroid03%2F</url>
    <content type="text"><![CDATA[1. 简介 ViewPager需要import android.support.v4这个jar包才可以使用ViewPager的效果就是能够轻松实现左右滑动屏幕, 不需要使用GestureDetector。在ViewPager的内部可以嵌入PagerTitleStrip或PagerTabStrip, 可以用来设置显示页面的title内容, 但是不要妄想把它当作Tab来用(虽然我的意图本来就是这样, 但是很悲剧), 因为它不是固定的首先获取ViewPager布局mViewPager, 或者自己用Java实现不用xml, 然后要想实现滑动翻页必须得设置它的Adapter, mViewPager.setAdapter(mAdapter)而mAdapter应该是一个继承FragmentPagerAdapter或者FragmentStatePagerAdapter的类的实例, 它应该实现滑动时所需要展示的页面, 而这些页面可以另外用一个继承Fragment的类实现, 然后将所需要的这些页面加入一个List中需要注意的地方有: 这其中用到的Fragment应使用android.support.v4.app.Fragment而不是android.app.Fragment, FragmentManager也是如此(因为其中用了getSupportFragmentManager方法, 它的返回值是v4包里的FragmentManager) 以上 2. 项目结构 3. 布局main.xml:12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="fill_parent" android:layout_height="fill_parent" android:orientation="vertical" &gt; &lt;android.support.v4.view.ViewPager android:id="@+id/pager" android:layout_width="wrap_content" android:layout_height="wrap_content"&gt; &lt;android.support.v4.view.PagerTabStrip android:id="@+id/pager_tab_strip" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="bottom" android:background="#636363" android:textColor="#fff" android:paddingTop="4dp" android:paddingBottom="4dp"/&gt; &lt;/android.support.v4.view.ViewPager&gt;&lt;/LinearLayout&gt; 4. 逻辑代码4.1 主Java程序:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.hecate.Apollo;/** * Created by hecate-xw on 2014/8/30. * It's a demo that display how to swipe pages via class ViewPager. */import android.support.v4.app.Fragment;import android.os.Bundle;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentPagerAdapter;import android.support.v4.app.FragmentActivity;import android.support.v4.view.ViewPager;import java.util.ArrayList;import java.util.List;public class MyActivity extends FragmentActivity &#123; /** 多个页面的list **/ List&lt;Fragment&gt; fragmentList = new ArrayList&lt;Fragment&gt;(); /** 多个页面的title list,用来显示PagerTabStrip的内容 **/ List&lt;String&gt; titleList = new ArrayList&lt;String&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); ViewPager mViewPager = (ViewPager) findViewById(R.id.pager); fragmentList.add(new MyFragment("page1")); fragmentList.add(new MyFragment("page2")); fragmentList.add(new MyFragment("page3")); titleList.add("Artist"); titleList.add("Song"); titleList.add("Favorite"); MyFragmentPagerAdapter myFragmentPagerAdapter = new MyFragmentPagerAdapter( getSupportFragmentManager(),fragmentList,titleList); mViewPager.setAdapter(myFragmentPagerAdapter); &#125; class MyFragmentPagerAdapter extends FragmentPagerAdapter &#123; private List&lt;Fragment&gt; fragmentList; private List&lt;String&gt; titleList; public MyFragmentPagerAdapter(FragmentManager supportFragmentManager, List&lt;Fragment&gt; fragmentList, List&lt;String&gt; titleList) &#123; super(supportFragmentManager); this.fragmentList = fragmentList; this.titleList = titleList; &#125; @Override public Fragment getItem(int i) &#123; return (fragmentList == null || fragmentList.size() == 0) ? null : fragmentList.get(i); &#125; @Override public int getCount() &#123; return ( fragmentList == null ) ? 0 : fragmentList.size(); &#125; @Override public CharSequence getPageTitle( int position ) &#123; return (titleList.size() &gt; position) ? titleList.get(position) : ""; &#125; &#125;&#125; 4.2 MyFragment.java:12345678910111213141516171819202122232425262728293031323334353637383940414243package com.hecate.Apollo;import android.support.v4.app.Fragment;import android.os.Bundle;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;/** * Created by hecate-xw on 2014/8/30. * Override some methods of class Fragment. */public class MyFragment extends Fragment &#123; private String page; public MyFragment(String page) &#123; super(); this.page = page; &#125; @Override public View onCreateView( LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // The last two arguments ensure LayoutParams are inflated // properly. if( "page1".equals(page) ) &#123; View view = inflater.inflate( R.layout.swipe_fragment_1, container, false); return view; &#125; else if( "page2".equals(page) ) &#123; View view = inflater.inflate( R.layout.swipe_fragment_2, container, false); return view; &#125; else if( "page3".equals(page) ) &#123; View view = inflater.inflate( R.layout.swipe_fragment_3, container, false); return view; &#125; else &#123; View view = inflater.inflate( R.layout.fragment, container, false); return view; &#125; &#125;&#125; 5. 测试运行添加相应的资源文件就可以运行了打开app开始显示的页面: 向左滑动一次或者点击PagerTabStrip的第二个Tab: 再向左滑动一次或者点击PagerTabStrip的第三个Tab: 附上每个page的xml布局文件，随便写的用来测试:swipe_fragment_1:1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent" android:weightSum="1"&gt; &lt;ImageView android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/imageView" android:src="@drawable/img1" android:layout_weight="0.66"/&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:textAppearance="?android:attr/textAppearanceLarge" android:text="This is page1" android:id="@+id/textView"/&gt;&lt;/LinearLayout&gt; swipe_fragment_2:123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent" android:weightSum="1"&gt; &lt;RatingBar android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/ratingBar"/&gt; &lt;ProgressBar style="?android:attr/progressBarStyleLarge" android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/progressBar"/&gt; &lt;SeekBar android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/seekBar" android:indeterminate="false"/&gt; &lt;Spinner android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/spinner"/&gt;&lt;/LinearLayout&gt; swipe_fragment_3:1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:weightSum="1" android:orientation="vertical"&gt; &lt;EditText android:layout_width="match_parent" android:layout_height="wrap_content" android:inputType="textEmailAddress" android:ems="10" android:id="@+id/editText"/&gt; &lt;RadioGroup android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;RadioButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="RadioButton1" android:id="@+id/radioButton" android:checked="false"/&gt; &lt;RadioButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="RadioButton2" android:id="@+id/radioButton2" android:layout_gravity="center_horizontal" android:checked="false"/&gt; &lt;RadioButton android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="RadioButton3" android:id="@+id/radioButton3" android:layout_gravity="right" android:checked="false"/&gt; &lt;/RadioGroup&gt; &lt;TextClock android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/textClock" android:layout_gravity="center_horizontal" android:layout_weight="0.07"/&gt;&lt;/LinearLayout&gt;]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>viewpager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Layout布局]]></title>
    <url>%2F2014%2F08%2F31%2Fandroid02%2F</url>
    <content type="text"><![CDATA[1. 用Java而非XML布局1.1 问题 在大部分应用程序中，我们都使用XML来实现页面布局，但实际上也可以不使用XML而使用Java来布局使用XML布局可以提高开发效率，用Java代码实现布局代码的安全性和执行效率更高Java处理效率比XML快，所以用Java代码实现布局比XML要优秀，但是对于一个复杂界面来说，用Java会很麻烦。所以并不建议全部用Java来布局但有些时候，我们的界面不是完全静态的，如果一个View中出现了大量的变化，那原来的XML就成了鸡肋。而且一旦想要将写好的一个Activity封装成JAR包，这时多余的XML就成了累赘 1.2 测试一个测试项目如下: MyActivity.java就是布局文件, 代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.hecate.Apollo;import android.app.Activity;import android.content.Context;import android.content.res.Resources;import android.graphics.*;import android.os.Bundle;import android.view.Gravity;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.TextView;/** * Created by hecate-xw on 2014/9/1. */public class MyActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; //TODO Auto-generated method stub super.onCreate(savedInstanceState); newView view = newView.buildView(MyActivity.this); setContentView(view); //原来指定的是R.layout.main,现在不用XML布局 Resources res = getResources(); //指定加载的图片 view.imageView.setImageDrawable(res.getDrawable(R.drawable.background)); &#125; //创建LinearLayout的布局 static class newView extends LinearLayout &#123; private ImageView imageView; public newView(Context c) &#123; super(c); //只创建一个ImageView imageView = new ImageView(c); TextView mTitle = new TextView(c); CharSequence title = "Love"; mTitle.setText(title); //添加文字 mTitle.setTextColor(Color.RED); //字体颜色 addView(mTitle, new LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT, Gravity.CENTER_HORIZONTAL)); addView(imageView, new LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT, Gravity.CENTER_HORIZONTAL)); /*对于LinearLayout本身的属性设置,可以直接利用继承后提供的方法,如 setBackgroundResource(imgId),setPadding(0,8,0,8) */ &#125; public static newView buildView(Context c) &#123; return new newView(c); &#125; &#125;&#125; 运行后效果图:]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android TabHost的使用]]></title>
    <url>%2F2014%2F08%2F27%2Fandroid01%2F</url>
    <content type="text"><![CDATA[1. 写在前面出于对新事物的好奇, 接触了一下Android, 主要是看书(《Anroid应用开发深入学习实录》 关立勋)、Google和看文档。使用的android-sdk的platform最低是android-14, 然后有android-17,android-20以及android-L(电脑配置暂时比较低,没法把每个版本都测试一遍）此时此刻Intellij IDEA社区版还没法渲染出android-20和android-L，所以我基本都是用的android-17虽然书的出版日期比较新, 但其中有些内容还是已经过时了 2. TabHost的使用详解2.1 项目结构先新建一个项目，使用以前构建项目的方法(虽然现在有了Gradle, 但是对于初学者来说学习成本稍高, 暂时搁置):MySetting.java在这里没用，忽略它…… 2.2 App布局布局main.xml:123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;TabHost android:layout_width="fill_parent" android:layout_height="fill_parent" xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/tabHost"&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="fill_parent" android:orientation="vertical"&gt; &lt;TabWidget android:id="@android:id/tabs" android:layout_width="fill_parent" android:layout_height="wrap_content"&gt; &lt;/TabWidget&gt; &lt;FrameLayout android:id="@android:id/tabcontent" android:layout_width="fill_parent" android:layout_height="fill_parent"&gt; &lt;TextView android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="@string/textview1" android:id="@+id/textView1" android:layout_gravity="left|top"/&gt; &lt;TextView android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="@string/textview2" android:id="@+id/textView2" android:layout_gravity="center_horizontal|top"/&gt; &lt;TextView android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="@string/textview3" android:id="@+id/textView3" android:layout_gravity="right|top"/&gt; &lt;/FrameLayout&gt; &lt;/LinearLayout&gt;&lt;/TabHost&gt; strings.xml不放了, 随便什么字符串无所谓 2.3 逻辑代码想要实现的就是添加三个Tab标签, 改变Tab标签的时候会弹出一个对话框, 按照书上及网上搜到的大部分代码, MyActivity.java应该是:123456789public class MyActivity extends Activity &#123; @Override public void onCreate( Bundle savedInstanceState ) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); mTabHost = getTabHost(); mTabHost.addTab... &#125;&#125; 这样的话有个问题: 查文档发现TabActivity在API Level 13中已经被弃用了。有:This class was deprecated in API level 13. New applications should use Fragments instead of this class; to continue to run on older devices, you can use the v4 support library which provides a version of theFragment API that is compatible down to DONUT.还有一句：A replacement for TabActivity can also be implemented by directly using TabHost.这其实意味着如果我们不考虑向下兼容的问题, 其实可以直接将上述代码写成:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.hecate.Apollo;import android.app.Activity;import android.app.AlertDialog;import android.app.Dialog;import android.content.DialogInterface;import android.content.Intent;import android.graphics.Color;import android.os.Bundle;import android.view.View;import android.widget.TabHost;public class MyActivity extends Activity &#123; /** * Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); TabHost mTabHost = (TabHost) findViewById(R.id.tabHost); mTabHost.setup(); mTabHost.addTab( mTabHost.newTabSpec("first").setIndicator("Tab 1",getResources().getDrawable(R.drawable.img1)).setContent(R.id.textView1) ); mTabHost.addTab( mTabHost.newTabSpec("second").setIndicator("Tab 2",getResources().getDrawable(R.drawable.img2)).setContent(R.id.textView2) ); mTabHost.addTab( mTabHost.newTabSpec("third").setIndicator("Tab 3",getResources().getDrawable(R.drawable.img3)).setContent(R.id.textView3) ); mTabHost.setBackgroundColor(Color.parseColor("blue")); mTabHost.setBackgroundResource(R.drawable.background); mTabHost.setCurrentTab(0); mTabHost.setOnTabChangedListener( new TabHost.OnTabChangeListener() &#123; @Override public void onTabChanged( String tabId ) &#123; Dialog dialog = new AlertDialog.Builder( MyActivity.this ) .setTitle("Change Tabs") .setMessage("You chosen "+tabId+" Tab") .setPositiveButton("OK", new DialogInterface.OnClickListener() &#123; public void onClick( DialogInterface dialogInterface, int whichButton ) &#123; dialogInterface.cancel(); &#125; &#125;).create(); dialog.show(); &#125; &#125;); &#125;&#125; 也就是直接继承Activity, 然后不使用getTabHost()方法而是findViewById(), 这时候又有一个注意点, 在TabHost文档的setup()方法中有:Call setup() before adding tabs if loading TabHost using findViewById().就是说如果你不是用getTabHost而是findViewById获取的TabHost，那在使用addTab()方法前要使用setup()方法。 2.4 运行测试按照以上完成之后, 再添加相应的资源文件就可以成功运行了(在API Level 13以上):原谅我的背景图片、、、点击TAB2后弹窗: 2.5 向下兼容说完了不向下兼容的方法, 那如果需要向下兼容呢? 正如一开始的文档所说, 使用Fragments和android.support.v4 library即可, 具体可以去查看详细的文档, 里面给了一个示例, 我把示例代码贴出来, 就不分析了:123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.v4.app.FragmentTabHost xmlns:android="http://schemas.android.com/apk/res/android" android:id="@android:id/tabhost" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TabWidget android:id="@android:id/tabs" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_weight="0"/&gt; &lt;FrameLayout android:id="@android:id/tabcontent" android:layout_width="0dp" android:layout_height="0dp" android:layout_weight="0"/&gt; &lt;FrameLayout android:id="@+id/realtabcontent" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1"/&gt; &lt;/LinearLayout&gt;&lt;/android.support.v4.app.FragmentTabHost&gt; Java代码:12345678910111213141516171819202122232425262728293031import com.example.android.supportv4.R;import android.os.Bundle;import android.support.v4.app.FragmentActivity;import android.support.v4.app.FragmentTabHost;/** * This demonstrates how you can implement switching between the tabs of a * TabHost through fragments, using FragmentTabHost. */public class FragmentTabs extends FragmentActivity &#123; private FragmentTabHost mTabHost; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.fragment_tabs); mTabHost = (FragmentTabHost)findViewById(android.R.id.tabhost); mTabHost.setup(this, getSupportFragmentManager(), R.id.realtabcontent); mTabHost.addTab(mTabHost.newTabSpec("simple").setIndicator("Simple"), FragmentStackSupport.CountingFragment.class, null); mTabHost.addTab(mTabHost.newTabSpec("contacts").setIndicator("Contacts"), LoaderCursorSupport.CursorLoaderListFragment.class, null); mTabHost.addTab(mTabHost.newTabSpec("custom").setIndicator("Custom"), LoaderCustomSupport.AppListFragment.class, null); mTabHost.addTab(mTabHost.newTabSpec("throttle").setIndicator("Throttle"), LoaderThrottleSupport.ThrottledLoaderListFragment.class, null); &#125;&#125;]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>tabhost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言琐记二]]></title>
    <url>%2F2014%2F07%2F02%2Fc02%2F</url>
    <content type="text"><![CDATA[一、枚举enum的使用12345678910111213#include &lt;stdio.h&gt;typedef enum _ErrorCode &#123; SystemError = -100, MemError, FileError&#125; ErrorCode;int main(int argc, char** argv) &#123; ErrorCode errorCode; printf("%d\n",errorCode.MemError); return 0;&#125; 以上输出结果为-99, 即枚举类型中的值只要不指定, 必然是逐个递增的, 而第一个值不指定则为0, 上述代码指定为-100则为-100, 以后的以此为基准逐一递增。 二、#if 1 和#if 012345#if constant ...程序段1...#else ...程序段2...#endif 这里表示, 如果constant为真(非0, 随便什么数字, 只要不是0), 就编译程序段1, 否则编译程序段2。如果有#if需要顶格写。]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>programming language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言琐记一]]></title>
    <url>%2F2014%2F06%2F04%2Fc01%2F</url>
    <content type="text"><![CDATA[1. 问题在codewarrior写的程序本来是可以编译的, 但只是调整了一些代码的位置, 将一些变量移到块作用域里, 却发现无法编译了, 以为是编译器配置突然出了问题, 解决了很久问题仍然存在 2. 解决最终发现是C语言的问题, C89的标准不允许随便声明变量, 变量声明不能放在任何可执行语句之后, 只允许在函数和块的开始处。这么不合理的规定在C99和C++里自然已经解除了。但是我所使用的codewarrior所用的C Compiler版本还是只支持到C89]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>codewarrior</tag>
        <tag>c</tag>
        <tag>programming language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记六]]></title>
    <url>%2F2013%2F12%2F17%2Freading06%2F</url>
    <content type="text"><![CDATA[1. PrefaceFrom The Wise King by Kahlil Gibran 2. Content 从前，一位威严而聪明的国王统治着远方的维兰尼城。他的威严使人敬畏，他的智慧令他倍受爱戴。 市中心有一口水井，井水清洌透澈，全城居民都从这口水井中汲水饮用，即使国王与大臣也不例外，因为这是城中唯一的一口井。 一天夜里，当大地万物都沉沉睡去，一个女巫进入城中，在井中点下七滴魔液，然后说：从现在起，凡喝了这井水的人就会发疯。 第二天清晨，除了国王和侍卫，所有居民都喝了这井里的水，正如女巫预言的那样，全都变成了疯人。 这一天，狭窄的街道上，市场中，人们都在窃窃私语，除此以外甚么事情也不做：“国王疯了，我们的国王与侍卫都失去了理智！我们不能让一个疯国王统治国家，我们必须废黜他。” 这天晚上，国王命人从井里汲来满满的一金杯水。水一送到，国王便大喝了一口，然后把剩下的水赏与侍卫。 于是遥远的维兰尼城热烈欢庆，因为他们的国王及其侍卫又恢复了理智。]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>poetry</tag>
        <tag>kahlil gibran</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记五]]></title>
    <url>%2F2013%2F09%2F16%2Freading05%2F</url>
    <content type="text"><![CDATA[1. PrefaceFrom A song of ice and fire Content fear filled his gut like a meal he could not digest. Ser Waymar was panting from the effort now, his breath steaming in the moonlight.]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>novel</tag>
        <tag>motto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记四]]></title>
    <url>%2F2013%2F07%2F16%2Freading04%2F</url>
    <content type="text"><![CDATA[1. PrefaceFrom Waiting for godot by Samuel Beckett.[1] 2. Content It’s so we won’t think.We have that excuse.It’s so we won’t hear.We have our reasons.All the dead voices.They make a noise like wings.Like leaves.Like sand.Like leaves.They all speak at once.Each one to itself.Rather they whisper.They rustle.They murmur.They rustle.What do they say?They talk about their lives.To have lived is not enough for them.They have to talk about it.To be dead is not enough for them.It is not sufficient.They make a noise like feathers .Like leaves.Likes ashes.Like leaves. Footnotes1.Waiting for Godot ↩]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>novel</tag>
        <tag>drama</tag>
        <tag>motto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记三]]></title>
    <url>%2F2013%2F06%2F20%2Freading03%2F</url>
    <content type="text"><![CDATA[1. PrefaceFrom The storied life of A.J.Fikry by Gabrielle Zevin. [1] 2. Content You shouldn’t look a gift horse in the mouth. The tough rose mouth says no one can hurt me, but the soft blue eyes say Yes you can and you probably will. And he had made that big dandelion of a girl cry. A.J. had found the reverent tone of the eulogies to be insufferable. She runs her fingers through her short hair. Ismay has chosen a collage because she had liked the pictures in the brochure, had married a man because he looked splendid in a tuxedo, and had started teaching because she’d seen a movie about a inspirational teacher. she was young and beautiful, which makes her death a tragedy. she was poor and black, which means people say they saw it coming. “it’s about a detective. but it moves kind of slow, and most things go unsolved, but then i thought, that’s how life is, that’s how the job really is.”“there’s a sequel.”A.J informs him. villains get punished, good guys triumph. You think child is enough, but child grows old. You think work is enough, but work is not warm body. Sales reps come to town with their summer offerings, and A.J. goes out of his way to be hospitable to them. A.J. mimes the universal gesture for toking up. No one travels without purpose. Those who are lost wish to be lost. It is the secret fear that we are unlovable that isolates us, but it is only because we are isolated that we think we are unlovable. Someday, you do not know when, you will be driving down a road. And someday, you do not know when, he, or indeed she, will be there. You will be loved because for the first time in your life, you will truly not be alone. You will have chosen to not be alone. For instance, two out of the three finalists were women, which might have tipped the scales toward the male. Footnotes1.The Storied Life of A. J. Fikry ↩]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>novel</tag>
        <tag>motto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记二]]></title>
    <url>%2F2013%2F04%2F29%2Freading02%2F</url>
    <content type="text"><![CDATA[1. PrefaceFrom Of Human Bondage(Part) writen by W. Somerset Maugham 2. Content It is an illusion that youth is happy, an illusion of those who have lost it; but the young know they are wretched for they are full of the truthless ideal which have been instilled into them, and each time they come in contact with the real, they are bruised and wounded. It looks as if they were victims of a conspiracy; for the books they read, ideal by the necessity of selection, and the conversation of their elders, who look back upon the past through a rosy haze of forgetfulness, prepare them for an unreal life. They must discover for themselves that all they have read and all they have been told are lies, lies, lies; and each discovery is another nail driven into the body on the cross of life.]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>novel</tag>
        <tag>motto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记一]]></title>
    <url>%2F2013%2F03%2F06%2Freading01%2F</url>
    <content type="text"><![CDATA[1. 前言摘自梁漱溟的《朝话:人生的省悟》[1] 2. 内容 在这个时代的青年，能够把自己安排对了的很少。 在这个时代，有一个大的欺骗他，或耽误他，容易让他误会，或让他不留心的一件事，就是把欲望当志气。 也许他很卖力气，却很不自然，很苦，且难以长进，因为背后存个贪的心，虽有时也会起一个大的反动，也许勉强干。但当自己勉强自己时，读书做事均难入，无法全副精神放在事情上。甚且会自己搪塞自己。 越聪明的人，越容易有欲望，越不知应在哪个地方搁下那个心。心实在应该搁在当下的。可是聪明的人，老是搁不在当下，老往远处跑，烦躁而不宁。所以没有志气的固不用说，就是自以为有志气的，往往不是志气而是欲望。仿佛他期望自己能有成就，要成功怎么个样子，这样不很好吗？无奈在这里常藏着不合适的地方，自己不知道。自己越不宽松，越不能耐，病就越大。所以前人讲学，志气欲望之辩很严，必须不是从自己躯壳动念，而念头真切，才是真志气。张横渠先生颇反对欲望，谓民胞物与之心，时刻不能离的。自西洋风气进来，反对欲望的话没人讲，不似从前的严格，殊不知正在这些地方，是自己骗自己害自己。 3. 琐言初次看到这段话的时候觉得梁老好像是在针对Kino一样，说的太准确让Kino害怕去相信。对于Kino来说，欲望就是金钱，一切都向钱看，学什么做什么都习惯用金钱去衡量，哪怕是考虑未来，也是在考虑未来能挣到多少钱。后来发现，并不是只有Kino，周围很多人都是这样，这应该是存在些共性原因的。 一是客观的家庭环境影响。把金钱放在第一位的人，很大一部分应该是小时候家庭环境不好的，所谓穷山恶水出刁民，Kino的生活环境与此有相似之处，所以也还算有所感触。一个人小时候若是生活艰苦了，自然会更羡慕那些经济宽松的人，希望自己也能得到同样的东西。有这种想法的孩子所做的行为却大相径庭，那些父母口中懂事的孩子，会明白父母的难处，对自己的行为束手束脚，也会容易陷入自卑，不怎么愿意交朋友；那些缺少监护人教育的，和彼此情况相似的孩子抱成一团的，因此而聚众欺负更加弱小的孩子，以此获得满足感；那些更加弱小的孩子，父母也不在身边，没有强有力的关爱，因而陷入违法犯罪行为的也有不少；那些和家境较好的孩子们玩在一起的，接触到更多不属于他的家庭环境他的年龄应该接触到的东西，往往会吵着闹着让父母买一些父母难以承受之物，若是得手，再将这些东西拿到家境困难的孩子中炫耀，懂事的孩子们会感觉到一丝心酸，却不会张口要买，聚众混混们会要求更加弱小的孩子买给他们，弱小的孩子们不敢向父母张口，只好去行偷窃之事。这样说并不是想要贬低任何一方，这里所有的人都是一个悲剧，你说穷山恶水出刁民，Kino无法反驳，能在这种环境中出人头地的能有几个呢，这些人可以被骂，但是不可以被嘲笑，你永远不知道一个人苦苦维持的自尊心会在什么时候破碎，情绪会在什么时候崩溃。无论怎样，一个人小时候若是缺乏什么，他长大就越想追求什么，所以家庭环境的影响是无法排除的。 二是媒体的宣传导向和社会的价值观取向所带来的影响。学校、企业、政府机关中总是有领导阶级的人喜欢拿今人与古人做比较，对今人的一切向钱看的思维批判一番，有时候媒体也喜欢这样批判。但Kino觉得这是没有道理的，今人对金钱的疯狂崇拜，很大一部分也是媒体的宣传所带来的，总是把财富值是多少当作成功的标志，然后反过来再说普通人追求财富没有情怀，这简直就是无理取闹。在这样的社会背景下，孩子在很小的时候就被灌输了财富的多少决定成功的观念，父母也是以子女财富多为骄傲，父母一辈间的交流就是孩子的工资、车、房，这样的社会很难让人坚守本心。所以说媒体的宣传和因此导致的社会价值取向的影响很大。 三是政策变化带来的社会阶级变化。Kino在读近代史时，会发现那个时代的风云人物有不少却是出身寒门，这种时代差异性实在太过巨大，民国时期社会处于动荡变革之中，每个人的生活都可能发生巨变，人们可能更多的是求生存，而少了一些其他的追求，到了抗战和新中国刚成立时，共产党做的是打土豪劣绅，进行土地改革，这个时候敛财者刚被打下去，大家的生活都很差不多，整个社会也是农民居多，又是吃大锅饭，个体缺少了追求财富的权力，自然与现在的社会不同。到了改革开放之后，个人拥有财富不再被当作资本主义毒瘤了，贫富分化渐渐明显了，社会阶级的流动十分迅速，很多人看到了机会，通过把握改革开放的红利迅速实现阶级上升，加之上述提到的媒体宣传，对这些成功者的崇拜，释放了被压抑许久的国人的追求个人财富的心性，然而成功者毕竟是少数。这时候成长起来的人就是Kino的父母一辈了，再通过他们向下释放信号，使孩子们从小就认识到了阶级性，在长大之后，看到光怪陆离的社会，没有人脉关系没有父母财富积累的人只能追求财富以实现阶级上升，而这条上升之路又没有完全封死，使人们还有一点希望，从而在追求财富中度过了自己的青春。 最后是人性的固有影响。人的本性总是想要活得轻松的，而财富自由就是实现轻松生活的最明确的答案，人们追求金钱也不奇怪了，当然这一点和人们想要寻求阶级上升其实是相似的。 即使说了这么多汲汲于追求金钱的原因，但还是有很多人有自己的想法与追求，除却父母已经有积累的，社会环境相同，社会舆论相同，家庭经济环境相同的人，依然有很多不把金钱放在第一顺位，这些人可以说是极为幸运的，他们遇到了好的父母、好的老师、好的同学，Kino也算是半个幸运儿吧。 说了这些，虽说把财富当欲望这种事有种种原因，也难以避免，但再看梁老的这段话，说的却仍是正中要害，把欲望当志气，想要致富想要改变阶级的欲望，无时无刻不在脑海中环绕，这样的想法在一定程度上会摧残一个人的意志，具体到学术/技术上，会使人盲目追求各种热点，而无法在一个方向沉下来，心不静则神不宁，梁老说越是聪明的人越是有欲望也没错，不过是Kino这种小聪明而无大才的，真有智商超群的无论做多少件事也能成功。这种把欲望当志气的想法也会带来思维的局限性，看待社会中的很多事容易陷入死胡同。说彻底改变自己的想法太过决绝，也难以实现，只能希望以后自己在学习生活中，除却陷入对未来的恐慌，更多一丝人情味。 Footnotes1.朝话:人生的省悟 ↩]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>motto</tag>
        <tag>梁漱溟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 1003]]></title>
    <url>%2F2013%2F02%2F23%2Fhdu1003%2F</url>
    <content type="text"><![CDATA[Problem DescriptionGiven a sequence a[1],a[2],a[3]……a[n], your job is to calculate the max sum of a sub-sequence. For example, given (6,-1,5,4,-7), the max sum in this sequence is 6 + (-1) + 5 + 4 = 14. InputThe first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line starts with a number N(1&lt;=N&lt;=100000), then N integers followed(all the integers are between -1000 and 1000). OutputFor each test case, you should output two lines. The first line is “Case #:”, # means the number of the test case. The second line contains three integers, the Max Sum in the sequence, the start position of the sub-sequence, the end position of the sub-sequence. If there are more than one result, output the first one. Output a blank line between two cases. Sample Input25 6 -1 5 4 -77 0 6 -1 1 -6 7 -5 Sample OutputCase 1:14 1 4 Case 2:7 1 6 Solution最初看到这题时的想法就是做循环,心里很明白这样做会超时,但还是去试了下,果然超时了,之后就暂时放下了这个问题。后来在《编程珠玑》里看到了对这个问题的详细讲解,豁然开朗,于是又重新做了一遍,感觉顺手多了。 《编程珠玑》看里给出了几种算法的比较,第一种自然是最简单的时间复杂度为O(n^3)的算法,然后可以改进为O(n^2)的算法,之后作者提到可以用分治法的思想,通过递归解决,时间复杂度为O(n*logn),而且这种方法在很长一段时间里被认为是最优的,直到某天遇到了一数学大神,据说该大神几分钟就想出了一个时间复杂度为O(n)的算法、、、 杭电的这题更复杂一点的地方在于它还要求出最大子序列的开始和结束位置,结束位置很简单,直接是Max的最后一个数,第一个当初想是从最后一个数向前做加法,直到和为Max,但是这样还要在判断这之前的数是否为0,很复杂,后来发现讨论区里有代码,研究了下,很巧妙,下面程序附的测试用例也是讨论区看到的、、、 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#define MAX_LEN 100000int main( int argc, char *argv[] ) &#123; int T,count = 0; scanf("%d",&amp;T); while(T--) &#123; ++count; int i,length; int a[MAX_LEN+1]; scanf("%d",&amp;length); for( i=0; i &lt; length; i++ ) &#123; scanf("%d",&amp;a[i]); &#125; int left = 0,right = 0,tmpLeft = 0; int max = a[0],maxWithLastNumber = 0; //需要注意数列全为负,故不能将max初始化为0 for( i = 0; i &lt; length; i++ ) &#123; maxWithLastNumber += a[i]; //数列全为负且第一个可能不是最大的负数,所以不能先比较maxWithLastNumber if( max &lt; maxWithLastNumber ) &#123; max = maxWithLastNumber; left = tmpLeft; right = i; &#125; if( maxWithLastNumber &lt; 0 ) &#123; maxWithLastNumber = 0; tmpLeft = i+1; &#125; &#125; printf("Case %d:\n%d %d %d\n",count,max,left+1,right+1); if( T ) &#123; printf("\n"); &#125; &#125; return 0;&#125;//附测试数据/* 4 0 0 2 0 -&gt; 2 1 3 6 2 7 -9 5 4 3 -&gt; 12 1 6 4 0 0 -1 0 -&gt; 0 1 1 7 -1 -2 -3 -2 -5 -1 -2 -&gt; -1 1 1 6 -1 -2 -3 1 2 3 -&gt; 6 4 6 5 -3 -2 -1 -2 -3 -&gt; -1 3 3*/]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器配置]]></title>
    <url>%2F2013%2F01%2F21%2FserverConfig%2F</url>
    <content type="text"><![CDATA[1. ssh1.1 安装open ssh123apt install openssh-server/etc/init.d/ssh restartvim /etc/ssh/sshd_config # 根据需要修改 1.2 生成密钥ssh-keygen生成公钥、私钥, 公钥放在服务器改名为authorizedkeys, 私钥放在客户端 1.3 修改密钥权限12chmod 700 ~/.sshchmod 600 ~/.ssh/authorized_keys 2. nginx &amp; let’s encrypt2.1 Refhttps://www.nginx.com/resources/wiki/https://github.com/certbot/certbot 2.2 安装nginx123add-apt-repository -y ppa:nginx/stableapt updateapt install nginx 2.3 查看nginx安装的模块12nginx -Vls /usr/lib/nginx/modules # 可选方式 2.4 配置/etc/nginx/nginx.conf查看bitbucket仓库 2.5 配置nginx server删除/etc/nginx/sites-available/default /etc/nginx/sites-enabled/default添加/etc/nginx/sites-available/yourdomain, 查看bitbucket仓库 2.6 建立软链接ln -s /etc/nginx/sites-available/yourdomain /etc/nginx/sites-enabled/yourdomain 2.7 启动nginxservice nginx start或nginx -s start 2.8 签发证书123456apt install software-properties-commonadd-apt-repository ppa:certbot/certbotapt updateapt install python-certbot-nginxcertbot --nginx certonly # if error, nextcertbot --authenticator standalone --installer nginx -d example.com --pre-hook "service nginx stop" --post-hook "ser vice nginx start" 2.9 配置证书到站点在/etc/nginx/sites-available/yourdomain里1234listen 443 ssl;listen [::]:443 ssl;ssl_certificate /etc/letsencrypt/live/yourdomain/fullchain.pem;ssl_certificate_key /etc/letsencrypt/live/yourdomain/privkey.pem; 2.10 自动更新证书crontab和certbot renew. 由于Cloudflare有HTTP Proxy, 域名对应IP非原始IP, 故无法自动更新, 需要先取消代理, 再更新 2.11 撤销删除证书12certbot revoke --cert-path /etc/letsencrypt/live/CERTNAME/cert.pemcertbot delete --cert-name example.com 3. 配置mail3.1 设置DNS记录3.2 安装Postfix12apt updateapt install postfix 安装时选择Internet Site, 之后System mail name填写yourdomain 3.3 查看Postfix配置postconf可以查看所有配置, 如postconf mail_version查看版本, postconf mail_spool_directory查看邮件保存位置 3.4 修改AWS Security GroupsEdit inbound rules添加SMTP TCP 25端口 3.5 测试echo &quot;Test mail&quot; | sendmail youraccount@example.com 3.6 用Nginx代理邮件https://www.nginx.com/resources/admin-guide/mail-proxy/https://www.nginx.com/resources/wiki/start/topics/examples/imapauthenticatewithapachephpscript/ 4. jupyterOfficial 4.1 Installpip3 install jupyter 4.2 Change config12jupyter notebook --generate-config # This will generate a file ~/.jupyter/jupyter_notebook_config.pyvim ~/.jupyter/jupyter_notebook_config.py generate passwd:123ipythonfrom notebook.auth import passwdpasswd() Create dir: mkdir JupyterChange ip, port, password and so on:1234c.NotebookApp.ip = '127.0.0.1'c.NotebookApp.port = '10010'c.NotebookApp.password = 'yourpasswd'c.NotebookApp.notebook_dir = '/home/username/Jupyter' # If use relative path, just Jupyter 4.3 Runjupyter notebook 4.4 Nginx 反向代理上述运行之后的jupyter只能在本地浏览器打开, 因为ip配置的是127.0.0.1而不是0.0.0.0, 端口号10010也没有在aws安全组策略中开启有意这样做的原因是想利用Nginx反代指向jupyter, 这样可以使用80端口.其中需要注意的一点是在配置文件里添加:123c.NotebookApp.allow_origin = 'http://yourdomain'c.NotebookApp.allow_remote_access = Truec.NotebookApp.trust_xheaders = True 之后 jupyter notebook &amp;&gt; /dev/null &amp; 后台运行jupyterNginx反向代理配置可以从Bitbucket仓库获得, 注意代理中添加的 WebSocket support 相关配置 4.5 Install kernelsPlease Refer to https://github.com/jupyter/jupyter/wiki/Jupyter-kernelsfor example:12pip3 install octave_kernelpython -m octave_kernel.install 5. VPN5.1 Install1234wget https://git.io/vpnsetup -O vpnsetup.sh &amp;&amp; sudo \VPN_IPSEC_PSK='your_ipsec_pre_shared_key' \VPN_USER='your_vpn_username' \VPN_PASSWORD='your_vpn_password' sh vpnsetup.sh Can also edit pre shared key, username, password in vpnsetup.shThen edit inbound rule, add 500,4500 port. 5.2 ClientsUbuntu: https://github.com/nm-l2tp/network-manager-l2tp12345678910111213git clone https://github.com/nm-l2tp/network-manager-l2tp.gitcd network-manager-l2tpapt install autoconf autogen intltoolapt install libglib2.0-devapt install ppp-dev./autogen.sh./configure \ --disable-static --prefix=/usr \ --sysconfdir=/etc --libdir=/usr/lib/x86_64-linux-gnu \ --libexecdir=/usr/lib/NetworkManager \ --localstatedir=/var \ --with-pppd-plugin-dir=/usr/lib/pppd/2.4.7make 5.3 Uninstallhttps://github.com/hwdsl2/setup-ipsec-vpn/blob/master/docs/uninstall.md 6. 配置Docker6.1 Docker HubCreate a repo in docker hub 6.2 Source fileCreate a repo in bitbucket 6.3 WebhookAdd webhook to docker hub repo. 6.4 Pull &amp; Run12docker pull username/repodocker run -p 80:80 -p 443:443 -dit username/repo 6.5 Other command12345docker psdocker ps -adocker images -adocker attach $IDdocker stop $ID 7. MOTD7.1 Install fortune and cowsay123apt install fortuneapt install fortunesapt install cowsay 7.2 Change motdvim /etc/update-motd.d/999-fortuneAdd:12#!bin/sh/usr/games/fortune | /usr/games/cowsay Then: chmod 755 /etc/update-motd.d/999-fortuneTo test: run-parts /etc/update-motd.d 8. Shadowsocks8.1 Install12apt install python-pippip install shadowsocks 8.2 Runsudo ssserver -c shadowsocks.conf -d start]]></content>
      <categories>
        <category>techonology</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发工具配置]]></title>
    <url>%2F2013%2F01%2F12%2FdevelopConfig%2F</url>
    <content type="text"><![CDATA[1. Tex1.1 Texlivehttps://www.tug.org/texlive/ 1.2 CTANhttps://www.ctan.org 2. Sublime2.1 Installhttps://www.sublimetext.com/3Backup: https://drive.google.com/open?id=0B7ciOrhoI8vkOEZqOXNBWnNrbzg 2.2 Package Controlhttps://packagecontrol.io/installation1import urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 2.3 SublimeCodeIntelhttps://github.com/SublimeCodeIntel/SublimeCodeIntel 2.4 ConvertToUTF8https://github.com/seanliang/ConvertToUTF8 2.5 Latexinghttp://www.latexing.comChange setting:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253&#123; "username": "", "license": "", "log": false, "quick_build": [ &#123; "name": "Primary Quick Build: pdflatex", "primary": true, "cmds": ["pdflatex"] //"cmds": ["xelatex"] // Change by hypocrisy on 2017.07.15 &#125;, &#123; "name": "Quick Build 1: pdflatex + bibtex + pdflatex (2x)", "cmds": ["pdflatex", "bibtex", "pdflatex", "pdflatex"] &#125;, &#123; "name": "Quick Build 2: pdflatex + biber + pdflatex (2x)", "cmds": ["pdflatex", "biber", "pdflatex", "pdflatex"] &#125;, &#123; // Add by Hypocrisy on 2017.07.15 "name": "Quick Build 3: xelatex", "cmds": ["xelatex"] &#125;, &#123; // Add by Hypocrisy on 2017.07.15 "name": "Quick Build 4: xelatex + bibtex + xelatex (2x)", "cmds": ["xelatex", "bibtex", "xelatex", "xelatex"] &#125; ], "fallback_encoding": "utf_8", // Changed by Hypocrisy on 2017.07.15 "path": ["D:\\Program Files\\Sublime Text 3","D:\\Programs\\texlive\\tlpkg\\tlperl\\bin","D:\\Programs\\texlive\\bin\\win32","C:\\Program Files\\Microsoft\\R Client\\R_SERVER\\bin"], "show_log_panel_on": ["errors", "warnings", "badboxes", "infos"], "keep_focus": true, "keep_focus_delay": 0.2, "executables": &#123; // Required "perl": ["perl"], "latexmk": ["latexmk"], // Optional "pdflatex": ["pdflatex"], "xelatex": ["xelatex"], "lualatex": ["lualatex"], "biber": ["biber"], "bibtex": ["bibtex"], "sublime": ["subl", "sublime_text", "sublime_text.exe"], "kpsewhich": ["kpsewhich"], "mthelp": ["mthelp"], "texcount": ["texcount"], "texdoc": ["texdoc"], "rscript": ["Rscript", "Rscript.exe"] &#125;, "forward_sync": true, "reverse_sync": true, "pdf_viewer_osx": &#123; "skim": [ "/Applications/Skim.app" ], "preview": [ "/Applications/Preview.app" ] &#125;, "pdf_viewer_windows": &#123; "foxit_reader": [ "D:\\Program Files (x86)\\Foxit Software\\Foxit PhantomPDF\\FoxitPhantomPDF.exe" // Changed by Hypocrisy on 2017.07.15 ], "sumatra_pdf": [ "D:\\Program Files\\SumatraPDF\\SumatraPDF.exe" // Changed by Hypocrisy on 2017.07.15 ] &#125;, "pdf_viewer_linux": &#123; "evince": [ "/usr/bin/evince" ], "okular": [ "/usr/bin/okular" ] &#125;, "pdf_viewer_order" : [ // OSX "skim", "preview", // Windows "sumatra_pdf", "adobe_reader", "foxit_reader", "pdf_xchange_viewer", // Linux "evince", "okular" ], "phrases": false, "phrases_mode": 0, "phrases_min_count": 2, "phrases_min_length": 3, "phrases_max_length": 5, "phrases_bounding_words": [], "partial_build": false, "open_pdf_on_load": true, "typeset_on_save": false, "type_scrolling": false, "output_directory": true, // Change by Hypocrisy on 2017/07/15 "output_directory_mode": 0, "default_tex_extension": ".tex", "default_bib_extension": ".bib", "check_source": ["local_bibliography", "remote_bibliography"], "tex_pattern": ["*.tex", "*.ltx", "*.tikz"], "graphics_pattern": ["*.jpeg", "*.jpg", "*.png", "*.eps", "*.pdf"], "currfile_graphicspath": false, "auto_trigger_fill": true, "cite_panel_format": ["#&#123;key&#125;: &#123;title&#125;", "&#123;type&#125; (&#123;origin&#125;) by &#123;author&#125;"], "label_format": "&#123;type&#125;:&#123;prefix&#125;:&#123;name&#125;", "label_type": &#123; "table": "tbl", "figure": "fig", "part": "prt", "chapter": "cha", "section": "sec", "subsection": "ssec", "subsubsection": "sssec", "paragraph": "par", "subparagraph": "spar" &#125;, "foldable_environments": ["table", "figure", "equation"], "static_cwl": ["tex.cwl", "latex-209.cwl", "latex-dev.cwl", "latex-document.cwl", "latex-l2tabu.cwl", "latex-mathsymbols.cwl"], "dynamic_cwl": true, "build_arguments": [], "symbols_in_category": true, "cache": &#123; "pkg": 168, "doc": 168, "tex": 24, "bib": 24, "bibsonomy": 48, "citeulike": 48, "global_bib": 48, "mendeley": 48, "zotero": 48 &#125;, "remote_bibliography_in_category": false, "bibname": "Remote.bib", "update_remote_bibliography": true, "cite_key_blacklist": ["the", "a", "an", "der", "die", "das"], "bibsonomy": false, "bibsonomy_username": "", "bibsonomy_apikey": "", "bibsonomy_internal_cite_key": false, "bibsonomy_cite_key_pattern": "&#123;Author&#125;&#123;Year&#125;&#123;Title&#125;", "citeulike": false, "citeulike_username": "", "citeulike_internal_cite_key": false, "citeulike_cite_key_pattern": "&#123;Author&#125;&#123;Year&#125;&#123;Title&#125;", "global_bib_file": false, "global_bib_file_path": "", "mendeley": false, "mendeley_oauth_token": "", "mendeley_oauth_token_secret": "", "mendeley_internal_cite_key": false, "mendeley_cite_key_pattern": "&#123;Author&#125;&#123;Year&#125;&#123;Title&#125;", "zotero": false, "zotero_user_id": "", "zotero_user_key": "", "zotero_cite_key_pattern": "&#123;Author&#125;&#123;Year&#125;&#123;Title&#125;", "online_lookup": [ &#123; "title": "Dict.cc", "url": "http://www.dict.cc/?s=&#123;query&#125;" &#125;, &#123; "title": "Dict.leo.org", "url": "http://dict.leo.org/ende/#/search=&#123;query&#125;" &#125;, &#123; "title": "Dictionary.com", "url": "http://dictionary.reference.com/browse/&#123;query&#125;" &#125;, &#123; "title": "Linguee.com EN-DE", "url": "http://www.linguee.com/english-german/search?query=&#123;query&#125;" &#125;, &#123; "title": "Linguee.de DE-EN", "url": "http://www.linguee.de/deutsch-englisch/search?query=&#123;query&#125;" &#125;, &#123; "title": "Pons.eu", "url": "http://en.pons.eu/dict/search/results/?q=&#123;query&#125;&amp;l=deen" &#125;, &#123; "title": "Thesaurus.com", "url": "http://thesaurus.com/browse/&#123;query&#125;" &#125; ], "knitr": false, "tikz": false, "tikz_create_pdf": false&#125; 2.6 LaTeX-cwlhttps://github.com/LaTeXing/LaTeX-cwl 2.7 PandocPandoc: http://pandoc.org/installing.htmlSublime-Pandoc: https://github.com/tbfisher/sublimetext-Pandoc123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&#123; "default": &#123; "pandoc-path": "D:/Programs/Pandoc/pandoc.exe", // Add by Hypocrisy on 2017/07/14 // transformations "transformations": &#123; "Markdown (Pandoc)": &#123; "new-buffer": 1, "scope": &#123; "text.html": "html" &#125;, "syntax_file": "Packages/Markdown/Markdown.tmLanguage", "pandoc-arguments": [ "--to=markdown", "--wrap=none", "--atx-headers" ] &#125;, "HTML 5": &#123; "new-buffer": 1, "scope": &#123; "text.html.markdown": "markdown" &#125;, "syntax_file": "Packages/HTML/HTML.tmLanguage", "pandoc-arguments": [ "--to=html5", "--no-highlight" ] &#125;, "PDF": &#123; "scope": &#123; "text.html": "html", "text.html.markdown": "markdown", //"text.tex.latex": "latex", // Add by Hypocrisy on 2017/07/14 &#125;, "pandoc-arguments": [ "-t", "pdf", //"--latex-engine=D:/Programs/texlive/bin/win32/xelatex.exe" // use --latex-engine=engine where engine is // pdflatex|lualatex|xelatex. This may need to be specified with a full path // if -o or --output missing, will write to a temporary file // "--output=~/Downloads/output.pdf" ] &#125;, "Microsoft Word": &#123; "scope": &#123; "text.html": "html", "text.html.markdown": "markdown", "text.tex.latex": "latex", // Add by Hypocrisy on 2017/07/14 &#125;, "pandoc-arguments": [ "-t", "docx", //"--latex-engine=D:/Programs/texlive/bin/win32/xelatex.exe", // Add by Hypocrisy on 2017/07/14 "--output=./Output/output.docx" // Add by Hypocrisy on 2017/07/14 ] &#125;, "PDF TOC (Narrow margins)": &#123; "scope": &#123; "text.html": "html", "text.html.markdown": "markdown", &#125;, "pandoc-arguments": [ "-V", "geometry:margin=1.25in", "-s", "--toc", "--number-sections", "--parse-raw", "-t", "pdf", ], &#125;, "PDF TOC": &#123; "scope": &#123; "text.html": "html", "text.html.markdown": "markdown", &#125;, "pandoc-arguments": [ "-s", "--toc", "--number-sections", "--parse-raw", "-t", "pdf", ], &#125;, "HTML TOC": &#123; "new-buffer": 1, "scope": &#123; "text.html.markdown": "markdown" &#125;, "syntax_file": "Packages/HTML/HTML.tmLanguage", "pandoc-arguments": [ "--to=html5", "--no-highlight", "-s", "--toc" ] &#125;, "Beamer Slides (PDF)": &#123; "scope": &#123; "text.html": "html", "text.html.markdown": "markdown", &#125;, // Use the "out-ext" parameter to define a custom output file extension. Commonly used for pdf. "out-ext": "pdf", "pandoc-arguments": [ "-t", "beamer", "--latex-engine=D:/Programs/texlive/bin/win32/pdflatex.exe" ] &#125;, "Beamer Slides (LaTeX)": &#123; "scope": &#123; "text.html": "html", "text.html.markdown": "markdown", &#125;, "pandoc-arguments": [ "-t", "beamer", ] &#125;, "s5 Slides": &#123; "scope": &#123; "text.html": "html", "text.html.markdown": "markdown", &#125;, "pandoc-arguments": [ "-t", "slidy", "-s", "--self-contained", ] &#125;, &#125;, // these should not need to be customized // output formats that are written to file, using -o parameter. These we do // not output to a sublime text buffer. "pandoc-format-file": ["docx", "epub", "pdf", "odt", "beamer"] &#125;&#125; 3. Vim3.1 InstallRecommend vim 8.1234567apt install python3-devgit clone https://github.com/vim/vim.gitcd vim# configure with python support./configure --enable-python3interp=yes \ --with-python3-config-dir=/usr/lib/python3.5/&lt;config-dir&gt; # &lt;config-dir&gt; varies in different system, I used &apos;config-3.5m-x86_64-linux-gnu&apos;.make install 3.2 Install plugins1234567891011121314151617181920212223242526mkdir -p ~/.vim/pack/yuzhen-plugins/start/cd ~/.vim/pack/yuzhen-plugins/startgit clone https://github.com/scrooloose/nerdtree.gitgit clone https://github.com/fholgado/minibufexpl.vim.gitgit clone https://github.com/mattn/emmet-vim.gitapt install exuberant-ctagsgit clone https://github.com/majutsushi/tagbar.gitgit clone https://github.com/SirVer/ultisnips.git # Need python supportgit clone https://github.com/honza/vim-snippets.git## YouCompleteMegit clone https://github.com/Valloric/YouCompleteMe.gitgit submodule update --init --recursive# Method 1(Recommend)python3 install.py# End of Method 1# Method 2mkdir ~/.ycm_buildcd ~/.ycm_buildapt install cmakecmake -G &quot;Unix Makefiles&quot; . ~/.vim/pack/yuzhen-plugins/start/YouCompleteMe/third_party/ycmd/cppcmake --build . --target ycm_core --config Release# End of Method 2# Add Javascript Supportcd ~/.vim/pack/yuzhen-plugins/start/YouCompleteMe/third_party/ycmd/third_party/tern_runtimeyarn install --production # or &apos;yarn global add install --production&apos;# End of Javascript Support 3.3 ConfigurationGit仓库获得/etc/vim/vimrc;/etc/vim/vimrc.local;/etc/vim/vimrc.tiny内容 3.4 Some problemsIf you have added set encoding=utf-8, but there is still ycm error, you can excute:12export LC_ALL=en_US.utf-8 export LANG=&quot;$LC_ALL&quot; If vim cannot find vimrc, you can excute:12export VIMINIT=&apos;source $MYVIMRC&apos;export MYVIMRC=&apos;/etc/vim/vimrc&apos; 4. Gitgit config --global core.editor &quot;vim&quot; 5. Valgrind]]></content>
      <categories>
        <category>techonology</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>development</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[书单]]></title>
    <url>%2F2012%2F11%2F22%2Fbooks%2F</url>
    <content type="text"><![CDATA[涉猎书目列表(不加筛选,供以后参考)《扫起落叶好过冬》 林达《白玉雕龙》 古龙《欢乐英雄》 古龙《萧十一郎》 古龙《多情剑客无情剑》 古龙《楚留香传奇》 古龙《大旗英雄传》 古龙《游侠录》 古龙《月异星邪》 古龙《笑傲江湖》 金庸《天龙八部》 金庸《神雕侠侣》 金庸《流星之绊》 东野圭吾(著),徐建雄(译) 南海出版社《搜索方法论——优化与决策支持技术入门教程》 Edmund K.Burke,Graham Kendall(著),许莹,郭斯羽,李仁发(译) 清华大学出版社《分布式实时系统》 张凤登 科学出版社《Java RESTful Web Service实战》 韩陆 机械工业出版社《运筹学》 寇玮华 西安交通大学出版社《堂吉诃德》 Miguel de Cervantes Saavedra(著),刘京胜(译) 中央编译出版社《荷马史诗·伊利亚特》 Homer(著),罗念生,王焕生(译)《编程之魂》 Federico Biancuzzi,Shane Warden(著) 闫怀志(译) 电子工业出版社《编译原理》 蒋宗礼,姜守旭 高等教育出版社《孤独漫步者的遐想》 Jean-Jacques Rousseau(著),钱培鑫(译) 译林出版社《普林斯顿数学指南(共三卷)》 Timothy Gowers(著),齐民友(译) 科学出版社《数学经验(学习版)》 Philip J.Davis,Reuben Hersh,Elena Anne Marchisotto(著),王前(译) 大连理工大学出版社《数学方法论稿(修订版)》 张奠宙,过伯祥,方均斌,龙开奋 上海教育出版社《超越普里瓦洛夫》 刘培杰数学工作室(编) 哈尔滨工业大学出版社《黎曼博士的零点》 Karl Sabbagh(著),汪晓勤(译) 上海教育出版社《精通AngularJS》 Pawel Kozlowski,Peter Bacon Darwin(著),李路(译) 华中科技大学出版社《Rails高级编程》 Brad Ediger(著),FreeWbeel UI Team(译) 机械工业出版社《Ruby基础教程(第4版)》 高桥征义(著),何文斯(译) 人民邮电出版社《最优化方法应用基础》 卢险峰 同济大学出版社《数学之美(第二版)》 吴军 人民邮电出版社《用AngularJS开发下一代Web应用》 Brad Green,Shyam Seshadri(著),大漠穷秋(译) 电子工业出版社《Effective C++(第三版)》 Scott Meyers(著),侯捷(译) 电子工业出版社《Pattern Recognition and Machine Learning》 Bishop Springer《Introduction to Algorithms(3rd edition)》 Thomas H.Cormen The MIT Press《雷达系统设计MATLAB仿真》 Bassem R. Mahafza,Atef Z. Elsherbeni(著),朱国富,黄晓涛(译) 电子工业出版社《拓扑学》 江辉有 机械工业出版社《深入浅出MFC(第二版)》 侯俊杰 华中科技大学出版社《徒然草·方丈记》 吉田兼好,鸭长明(著),王新禧(译)《枕草子》 清少纳言(著),周作人(译) 上海人民出版社《徒然草》 吉田兼好(著),田伟华(译) 湖南人民出版社《舒婷精选集》 舒婷 北京燕山出版社《数学先锋:数学前沿(1950-现在)》 Michael·J.Bradley(著),蒲实(译) 上海科学技术文献出版社《数学先锋:数学的奠基(1800-1900年)》 Michael·J.Bradley(著),杨延涛(译) 上海科学技术文献出版社《泛函分析–理论和应用》 Haim Brezis(著),叶东,周风(译) 清华大学出版社《英美诗歌名篇研读》 刘文荣 上海教育出版社《泛函分析》 Peter D.Lax(著),侯成军,王利广(译) 人民邮电出版社《计算机操作系统实验与实践(基于Windows与Linux)》 秦明,李波 清华大学出版社《浮生六记》 沈复(著),马一夫(译评) 吉林文史出版社《博弈论:日常生活中的博弈策略》 刘庆财 中国华侨出版社《操作系统实验教程(Linux版)》 潘景昌,刘杰 清华大学出版社《计算机操作系统(第二版)》 庞丽萍,阳富民 人民邮电出版社《模式识别》 钟珞,潘昊,封筠,何平 武汉大学出版社《短码之美》 Ozy(著),李秀银,赛丽娜(译) 人民邮电出版社《数学思想10讲》 张广祥 科学出版社《康托的无穷的数学和哲学》 周·道本(著),郑毓信,刘晓力(编译) 大连理工大学出版社《隐写分析原理与应用》 葛秀慧,田浩 清华大学出版社《Linux内核技术手册》 Greg Kroab-Hartman《啊哈，灵机一动》 Martin Gardner《Kali 渗透测试技术实战》 James Board, Andrew Bindner《Linux Shell脚本编程入门》 金泰龙《构建嵌入式Linux系统》 Karim Yagbmour《500个世界著名数学征解问题》 冯贝叶《e的密码》 陈仁政《大自然的常数》 约翰•巴罗《内核漏洞的利用与防范》 Enrico Perla，Massimiliano Oldani《音乐爱好者》 2015年3月号《无线电》 2014年11月《只差一个谎言》 东野圭吾《纪伯伦经典诗集》 卡里.纪伯伦《C++语言的设计与演化》 Bjarne Stroustrup《MySQL实用教程(第二版)》 郑阿奇《JavaScript启示录》 Cody Lindley《复杂性思考》 Allen B. Downey《东京岛》 桐野夏生《编程珠玑(续)》 Jon Bentley《Python编程实战》 Mark Summerfield《元明清散曲选》 王起《纯数学教程:纪念版:centenary edition》 G. H. Hardy《量子力学概论:翻译版》 David J. Griffiths《理论力学》 邵兴《高等数学》 刘光旭, 张效成, 赖学坚《工程制图》 朱廷祥, 龚斌, 苏明《顾城的诗》 顾城《二十世纪中国经典散文诗》 王光明, 孙玉石《陪安东尼度过漫长岁月》 安东尼《四级标准阅读100篇》 许淑清《革命根据地史话》 马洪武, 王明生《线性代数题型综合解析与方法指导》 梁晓毅, 白云霄《中国共产党史稿:1921-1949》 沙健孙《陈赓大将》 尹家民《英语专业四八级词汇认知速记一本通》 王天翼《全新大学英语1-6级词汇多彩联想》 黎小说《大学物理学》 黄亦斌《后来……》 纪尧姆·米索《高等数学:物理类.修订版》 文丽, 吴良《门》 夏目漱石《我是猫》 夏目漱石《爱与生的苦恼》 叔本华《英语专业4级考试复习思路及全真模拟》 王厚平《查泰莱夫人的情人》 劳伦斯《C/C++程序设计》 郝兴伟《叔本华文集.作为意志和表象的世界卷》 叔本华(Schopenhauer,A.)《Photoshop CS 5平面广告设计经典108例》 麓山文化编著《网页设计与制作》 孙振业《计算机网络安全》 邓亚平《动漫秀场.31,超级漫画男性角色素描技法》 黎贯宇《单片机C语言和汇编语言实用开发技术》 陈洪财《那些洒满阳光的日子》 达子《1978-2008哈尔滨工业大学理论力学本科期末考试题汇编》 程燕平, 王春香《大学物理典型题解题思路与技巧》 王小力, 张孝林, 徐忠锋《七个谎言》 詹姆士·莱思登《C和指针.第2版》 Kenneth A. Reek《年轻人最爱读的55则英文散文》 高山, 姜宗彦《C语言通用范例开发金典》 柳盛, 王国全, 沈永林《大学物理学习题分析与解答》 李存志, 郑建邦, 徐忠锋《标准C语言基础教程》 Gary J. Bronson《电路分析:基础理论与实用技术.第2版》 张永瑞, 周永金, 张双琦《Programming in ANSI C》 Balagurusamy, E.《数据结构与STL》 徐雅静,肖波 北京邮电大学出版社《数据结构:C语言描述》 王爱民，李杰《世上另一个我》 萨拉·帕坎南《C++应用程序设计》 Richard Johnsonbaugh, Martin Kalin《Access数据库技术及应用》 陈继锋, 苏云凤《Visual Basic 2010入门经典》 Thearon Willis, Bryan Newsome《Access 2007中文版从入门到精通:普及版》 颜金传, 陈德全, 黄平山《Visual C++.NET程序设计例学与实践》 魏亮, 王艳玲《C++面向对象程序设计》 谭浩强《考点、考题、精练一本全:会计》 注册会计师全国统一考试研究专家组编《C++大学教程》 P. J. Deitel, H. M. Deitel《Visual C++ 2005入门经典》 Ivor Horton《51单片机C语言应用开发技术大全.第2版》 刘坤, 赵红波, 张宪栋《Dreamweaver CS 5中文版标准教程》 牛红惠, 王超英, 孙膺《网页设计与网站建设完全实用手册》 孙东梅《完美应用Ubuntu.第2版》 何晓龙, 李明《网页设计与网站建设完全实用手册》 孙东梅《离散数学及其应用》 Kenneth H. Rosen《Linux操作系统.第2版》 邵国金《新世纪日本语教程自学指南》 李遇玫《新日本语》 斎藤里美, 李思纯《ACM国际大学生程序设计竞赛:题目与解读》 俞勇《电路分析基础》 刘景夏《复变函数与积分变换》 刘西民, 卢玉峰, 李崇君《MATLAB 2009从入门到精通》 崔智全《复变函数与积分变换》 刘明华, 周晖杰《Android应用开发入门》 Wallace Jackson《新编综合日语》 陈俊英《嵌入式Linux操作系统原理与应用》 文全刚《基于PROTEUS的电路及单片机设计与仿真》 张涵《PHP编程基础与实例教程》 孔祥盛《PHP与MySQL程序设计》 W. Jason Gilmore《MySQL高效编程》 王志刚, 江友华《Android进阶实践》 蔺华, 时允田《Java 7程序设计》 Budi Kurniawan《JavaScript基础教程》 Tom Negrino, Dori Smith《4周攻克雅思词汇周计划》 詹圣麒《JavaScript设计与开发新思维:develop &amp; design》 Larry Ullman《深入理解Java Web开发技术:探索基于主流框架的最佳组合》 谭贞军《单片机原理、应用与PROTEUS仿真.第2版》 张靖武, 周灵彬, 方曙光《Photoshop CS 5完全学习手册》 前沿文化编著《轻松玩转jQuery》 蓝健《HTML5开发手册》 Chuck Hudson, Tom Leadbetter《新参者》 东野圭吾《加密与解密实战攻略》 郭栋, 孙锋, 唐植明《十日谈》 Giovanni Boccaccio(著),方平,王科一(译) 上海译文出版社《Android应用开发深入学习实录》 关立勋《JavaScript基础教程》 Tom Negrino, Dori Smith《模拟电子技术》 陈永强, 魏金成, 吴昌东《精通MATLAB GUI设计》 陈垚光《MATLAB小波分析.第2版》 张德丰《论美国的民主》 托克维尔《古典音乐初烧必读》 许丽雯《自动控制原理》 卢京潮《失踪者》 折原一《自动控制元件》 葛伟亮《黑客反汇编揭秘》 Kris Kaspersky《Web安全测试》 Paco Hope, Ben Waltber《追忆似水年华.第一卷,在斯万家这边》 M. 普鲁斯特《SolidWorks 2012中文版入门与提高》 张云杰, 李玉庆《自动控制原理》 张爱民《电机学学习指导》 孙旭东, 王善铭《易学Python》 Anthony Briggs《深入HTML 5应用开发》 Anthony T. Holdener, Mario Andres Pagella《Python灰帽子:黑客与逆向工程师的Python编程之道:python programming for hackers and reverse engineers》 Justin Seitz《IDA Pro权威指南:the unofficial guide to the world’s most popular disassembler》 Chris Eagle《ARM嵌入式系统基础教程》 周立功《数据结构:Java语言描述》 刘小晶, 杜选《数据结构实例解析与实验指导:Java语言描述》 刘小晶《程序员面试攻略.第2版》 John Mongan, Noah Suojanen, Eric Giguere《数据结构:C++版》 吴小平, 马桂媛]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>favorite</tag>
        <tag>books</tag>
      </tags>
  </entry>
</search>
