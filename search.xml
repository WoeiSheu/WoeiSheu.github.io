<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>安卓概述</title>
    <url>/2014/11/02/android04/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>整理Github时, 找到了这篇以前不知是看哪本书时做的笔记。</p>
</blockquote>
<h3 id="1-简析Android安装文件"><a href="#1-简析Android安装文件" class="headerlink" title="1. 简析Android安装文件"></a>1. 简析Android安装文件</h3><h4 id="1-1-Android-SDK目录结构"><a href="#1-1-Android-SDK目录结构" class="headerlink" title="1.1 Android SDK目录结构"></a>1.1 Android SDK目录结构</h4><ul>
<li>add-ons:包含了官方提供的API包，例如常用的Google Map API</li>
<li>docs:包含了帮助文档和说明文档</li>
<li>platforms:包含了针对每个版本的SDK版本，提供了和其对应的API包以及一些示例文件，其中包含了各个版本的Android</li>
<li>temp:包含了一些常用文件模板</li>
<li>tools:包含了一些通用的工具文件</li>
<li>usb_driver:包含了AMD64和X86下的驱动文件</li>
<li>SDK Setup.exe:Android的启动文件</li>
</ul>
<a id="more"></a>
<h4 id="1-2-android-jar及其内部结构"><a href="#1-2-android-jar及其内部结构" class="headerlink" title="1.2 android.jar及其内部结构"></a>1.2 android.jar及其内部结构</h4><p>在”platforms”目录下的每个Android版本中都有一个名为”android.jar”的压缩包<br><img src="/images/android05_1.png" alt="01"></p>
<h4 id="1-3-阅读SDK文档需要技巧"><a href="#1-3-阅读SDK文档需要技巧" class="headerlink" title="1.3 阅读SDK文档需要技巧"></a>1.3 阅读SDK文档需要技巧</h4><ul>
<li>在解压缩文件”android.jar”之后，就可以了解其内部API的包结构和组织方式了。</li>
<li>使用浏览器打开”docs”目录下的文件index.html，这个网页就是SDK帮助文档的主页。</li>
</ul>
<h4 id="1-4-不简单的SDK工具"><a href="#1-4-不简单的SDK工具" class="headerlink" title="1.4 不简单的SDK工具"></a>1.4 不简单的SDK工具</h4><p>SDK里面集成了很多其他有用的开发工具：</p>
<ul>
<li>Android模拟器</li>
<li>集成开发插件ADT</li>
<li>调试监视服务ddms.bat</li>
<li>Android调试桥adb.exe</li>
<li>Android虚拟设备</li>
</ul>
<hr>
<h3 id="2-实例教学"><a href="#2-实例教学" class="headerlink" title="2. 实例教学"></a>2. 实例教学</h3><p>Android安装目录中有一个名为”samples”的子目录, 在里面保存了SDK中的几个演示实例, 如android-7里面:<br><img src="/images/android05_2.png" alt="02"></p>
<p>执行各个实例体验效果</p>
<hr>
<h3 id="3-剖析Android系统架构"><a href="#3-剖析Android系统架构" class="headerlink" title="3. 剖析Android系统架构"></a>3. 剖析Android系统架构</h3><h4 id="3-1-Android体系结构的介绍"><a href="#3-1-Android体系结构的介绍" class="headerlink" title="3.1 Android体系结构的介绍"></a>3.1 Android体系结构的介绍</h4><p>Android是一个移动设备的开发平台，其软件层次结构包括操作系统(OS)、中间件(MiddleWare)和应用程序(Application)。根据软件框图，其软件层次自上而下分为以下四层：</p>
<ul>
<li>操作系统层(OS)</li>
<li>各种库(Libraries)和Android运行环境(RunTime)</li>
<li>应用程序框架(Application Framework)</li>
<li>应用程序(Application)</li>
</ul>
<p>上述各个层具体结构如下图示：<br><img src="/images/android05_3.png" alt="03"></p>
<ul>
<li>1) 操作系统层(OS)——最底层<br>  Android对操作系统的使用包括核心和驱动程序两部分，Android的Linux核心为标准的Linux2.6内核，Android更多的是需要一些与移动设备相关的驱动程序，主要驱动程序如下：<ul>
<li>显示驱动(Display Driver)</li>
<li>Flash内存驱动(Flash Memory Driver)</li>
<li>照相机驱动(Camera Driver)</li>
<li>音频驱动(Audio Driver)</li>
<li>Wifi驱动(Wifi Driver)</li>
<li>键盘驱动(KeyBoard Driver)</li>
<li>蓝牙驱动(Bluetooth Driver)</li>
<li>Binder IPC驱动:Android的一个特殊驱动程序，具有单独的设备节点，提供进程间通信的功能</li>
<li>Power Management(能源管理)</li>
</ul>
</li>
<li>2) 各种库(Libraries)和Android运行程序(RunTime)——中间层<br>  Android的这一层分为两部分:一是各种库，另一个是Android运行环境。本层包含的库如下：<ul>
<li>C库</li>
<li>多媒体框架(MediaFramework)</li>
<li>SGL</li>
<li>SSL</li>
<li>OpenGL ES 1.0</li>
<li>界面管理工具(Surface Management)</li>
<li>SQLite</li>
<li>WebKit</li>
<li>FreeType<br>Android的各种库一般是以系统中间件的形式提供的<br>Android运行环境主要是指虚拟机技术——Dalvik</li>
</ul>
</li>
<li>3) 应用程序(Application)</li>
<li>4) 应用程序框架(Application Framework)<br>  Android的应用程序框架为应用程序层的开发者提供APIs，它实际上是一个应用程序的框架。<br>  一个基本的Android应用程序可以利用应用程序框架中的以下五个部分：<ul>
<li>Activity(活动)</li>
<li>Broadcast Intent Receiver(广播意图接收者)</li>
<li>Service(服务)</li>
<li>Content Provider(内容提供者)</li>
<li>Intent and Intent Filter(意图和意图过滤器)</li>
</ul>
</li>
</ul>
<h4 id="3-2-Android应用工程文件组成"><a href="#3-2-Android应用工程文件组成" class="headerlink" title="3.2 Android应用工程文件组成"></a>3.2 Android应用工程文件组成</h4><ul>
<li>src目录——程序文件</li>
<li>AndroidMainfest.xml文件——设置文件</li>
<li>常量的定义文件</li>
</ul>
<hr>
<h3 id="4-简述五大组件"><a href="#4-简述五大组件" class="headerlink" title="4. 简述五大组件"></a>4. 简述五大组件</h3><h4 id="4-1-用Activity来表现页面"><a href="#4-1-用Activity来表现页面" class="headerlink" title="4.1 用Activity来表现页面"></a>4.1 用Activity来表现页面</h4><h4 id="4-2-用Intent和IntentFilter实现切换"><a href="#4-2-用Intent和IntentFilter实现切换" class="headerlink" title="4.2 用Intent和IntentFilter实现切换"></a>4.2 用Intent和IntentFilter实现切换</h4><h4 id="4-3-Service"><a href="#4-3-Service" class="headerlink" title="4.3 Service"></a>4.3 Service</h4><ul>
<li>如何使用服务</li>
<li>Service生命周期</li>
<li>进程生命周期</li>
</ul>
<h4 id="4-4-用BroadcastIntentReceiver发送广播"><a href="#4-4-用BroadcastIntentReceiver发送广播" class="headerlink" title="4.4 用BroadcastIntentReceiver发送广播"></a>4.4 用BroadcastIntentReceiver发送广播</h4><h4 id="4-5-用ContentProvider存储数据"><a href="#4-5-用ContentProvider存储数据" class="headerlink" title="4.5 用ContentProvider存储数据"></a>4.5 用ContentProvider存储数据</h4><hr>
<h3 id="5-进程和线程"><a href="#5-进程和线程" class="headerlink" title="5. 进程和线程"></a>5. 进程和线程</h3><hr>
<h3 id="6-应用程序生命周期"><a href="#6-应用程序生命周期" class="headerlink" title="6. 应用程序生命周期"></a>6. 应用程序生命周期</h3><p>进程的类型多种多样,按重要程度分为以下几类:</p>
<ol>
<li>前台进程(Foreground)</li>
<li>可见进程(Visible)</li>
<li>服务进程(Service)</li>
<li>后台进程(Background)</li>
<li>空进程(Empty)</li>
</ol>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Layout布局</title>
    <url>/2014/08/31/android02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1-用Java而非XML布局"><a href="#1-用Java而非XML布局" class="headerlink" title="1. 用Java而非XML布局"></a>1. 用Java而非XML布局</h2><h3 id="1-1-问题"><a href="#1-1-问题" class="headerlink" title="1.1 问题"></a>1.1 问题</h3><blockquote>
<p>在大部分应用程序中，我们都使用XML来实现页面布局，但实际上也可以不使用XML而使用Java来布局<br>使用XML布局可以提高开发效率，用Java代码实现布局代码的安全性和执行效率更高<br>Java处理效率比XML快，所以用Java代码实现布局比XML要优秀，但是对于一个复杂界面来说，用Java会很麻烦。所以并不建议全部用Java来布局<br>但有些时候，我们的界面不是完全静态的，如果一个View中出现了大量的变化，那原来的XML就成了鸡肋。而且一旦想要将写好的一个Activity封装成JAR包，这时多余的XML就成了累赘</p>
</blockquote>
<a id="more"></a>
<h3 id="1-2-测试"><a href="#1-2-测试" class="headerlink" title="1.2 测试"></a>1.2 测试</h3><p>一个测试项目如下:<br><img src="/images/android_layout_1.png" alt="project structure"></p>
<p>MyActivity.java就是布局文件, 代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hecate.Apollo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.res.Resources;</span><br><span class="line"><span class="keyword">import</span> android.graphics.*;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.Gravity;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageView;</span><br><span class="line"><span class="keyword">import</span> android.widget.LinearLayout;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hecate-xw on 2014/9/1.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        newView view = newView.buildView(MyActivity.<span class="keyword">this</span>);</span><br><span class="line">        setContentView(view);   <span class="comment">//原来指定的是R.layout.main,现在不用XML布局</span></span><br><span class="line"></span><br><span class="line">        Resources res = getResources();</span><br><span class="line">        <span class="comment">//指定加载的图片</span></span><br><span class="line">        view.imageView.setImageDrawable(res.getDrawable(R.drawable.background));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建LinearLayout的布局</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">newView</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> ImageView imageView;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">newView</span><span class="params">(Context c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(c);</span><br><span class="line">            <span class="comment">//只创建一个ImageView</span></span><br><span class="line">            imageView = <span class="keyword">new</span> ImageView(c);</span><br><span class="line">            TextView mTitle = <span class="keyword">new</span> TextView(c);</span><br><span class="line">            CharSequence title = <span class="string">"Love"</span>;</span><br><span class="line">            mTitle.setText(title);     <span class="comment">//添加文字</span></span><br><span class="line">            mTitle.setTextColor(Color.RED);   <span class="comment">//字体颜色</span></span><br><span class="line">            addView(mTitle, <span class="keyword">new</span> LayoutParams(</span><br><span class="line">                    ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">                    ViewGroup.LayoutParams.WRAP_CONTENT,</span><br><span class="line">                    Gravity.CENTER_HORIZONTAL));</span><br><span class="line">            addView(imageView, <span class="keyword">new</span> LayoutParams(</span><br><span class="line">                    ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">                    ViewGroup.LayoutParams.WRAP_CONTENT,</span><br><span class="line">                    Gravity.CENTER_HORIZONTAL));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*对于LinearLayout本身的属性设置,可以直接利用继承后提供的方法,如</span></span><br><span class="line"><span class="comment">            setBackgroundResource(imgId),setPadding(0,8,0,8)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> newView <span class="title">buildView</span><span class="params">(Context c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> newView(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行后效果图:<br><img src="/images/android_layout_2.png" alt="java_layout"></p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio 与 Gradle</title>
    <url>/2015/10/23/android05/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h3><blockquote>
<p>以前是用IntelliJ IDEA直接玩安卓程序的, 但是自从Google根据IDEA开发了新的ide后, 很多开发者都转向Android Studio了, 网络上的有些源代码无法直接在IDEA上编译, 于是下了个Android Studio折腾, 用过IntelliJ IDEA后安装、配置环境都很简单, 不太相同的地方是Google采用Gradle作为Android app开发的包管理器之后, 其自家推出的Android Studio自然得默认下载它, 于是在新建工程的最后一步, 提醒你可能需要配置一下代理才能使用成功的下载安装Gradle, 使用SS代理, 成功下载安装</p>
</blockquote>
<a id="more"></a>
<h3 id="2-项目结构"><a href="#2-项目结构" class="headerlink" title="2. 项目结构"></a>2. 项目结构</h3><p>新建空白项目的结构:<br><img src="/images/android04_1.png" alt="first"></p>
<h3 id="3-Gradle简介"><a href="#3-Gradle简介" class="headerlink" title="3. Gradle简介"></a>3. Gradle简介</h3><blockquote>
<p>Gradle是一种依赖管理工具, 基于Groovy语言, 面向Java应用为主, 它抛弃了基于XML的各种繁琐配置, 取而代之的是一种基于Groovy的内部领域特定(DSL)语言。其优点有很多:</p>
<blockquote>
<p>像Ant一样，通用灵活的构建工具<br>可以切换的，基于约定的构建框架<br>强大的多工程构建支持<br>基于Apache Ivy的强大的依赖管理<br>支持maven, Ivy仓库<br>支持传递性依赖管理，而不需要远程仓库或者是pom.xml和ivy.xml配置文件。<br>对Ant的任务做了很好的集成<br>基于Groovy，build脚本使用Groovy编写<br>有广泛的领域模型支持构建</p>
</blockquote>
<p>缺点么, 我觉得就是又增加了入门者的学习成本</p>
</blockquote>
<h3 id="4-Gradle配置"><a href="#4-Gradle配置" class="headerlink" title="4. Gradle配置"></a>4. Gradle配置</h3><p>新建空白工程的里根目录和app目录下各有一个build.gradle文件，文件内容分别是:</p>
<h4 id="4-1-build-gradle"><a href="#4-1-build-gradle" class="headerlink" title="4.1 build.gradle"></a>4.1 build.gradle</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Top-level build file where you can add configuration options common to all sub-projects&#x2F;modules.</span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &#39;com.android.tools.build:gradle:1.3.0&#39;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; NOTE: Do not place your application dependencies here; they belong</span><br><span class="line">        &#x2F;&#x2F; in the individual module build.gradle files</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task clean(type: Delete) &#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-app-build-gradle"><a href="#4-2-app-build-gradle" class="headerlink" title="4.2 app/build.gradle"></a>4.2 app/build.gradle</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply plugin: &#39;com.android.application&#39;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 23</span><br><span class="line">    buildToolsVersion &quot;22.0.1&quot;</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId &quot;info.hypocrisy.test&quot;</span><br><span class="line">        minSdkVersion 15</span><br><span class="line">        targetSdkVersion 23</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])</span><br><span class="line">    testCompile &#39;junit:junit:4.12&#39;</span><br><span class="line">    compile &#39;com.android.support:appcompat-v7:23.1.0&#39;</span><br><span class="line">    compile &#39;com.android.support:design:23.1.0&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-直观认识"><a href="#4-3-直观认识" class="headerlink" title="4.3 直观认识"></a>4.3 直观认识</h4><p>在./build.gradle中的task clean中加入<code>println &#39;test gradle.&#39;</code>, 那么每次运行gradle时都会在Gradle Console里显示出test gradle, 当然, 显示的东西太多, 这一条不是很好找, 命令行下新建一个test.gradle文件:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task test &#123;</span><br><span class="line">    println &#39;test gradle.&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>之后<code>gradle -b test.gradle -q test</code>即可在terminal中看到<code>test gradle.</code></p>
<h4 id="4-4-解释说明"><a href="#4-4-解释说明" class="headerlink" title="4.4 解释说明"></a>4.4 解释说明</h4><p>从上述build.gradle文件可以很轻松的看出在android中使用gradle基本上就是各种配置选项, 对于不同目录下都可以建立build.gradle文件, 其作用域自然也就是当前目录, 比如./目录下的作用域就是整个project, 而./app目录下的作用范围就是app目录下的这些源文件。这样理解的话, 无论gradle怎么变, 都可以很轻松的快速掌握它, 与以前的android结构相比, 现在的gradle近似相当于其AndroidManifest.xml文件, 虽然现在此XML仍然存在。而gradle的功能更为强大, 至于其更多配置选项可以以后慢慢接触。</p>
<h4 id="4-5-setting-gradle"><a href="#4-5-setting-gradle" class="headerlink" title="4.5 setting.gradle"></a>4.5 setting.gradle</h4><p>在根目录下，还有一个setting.gradle文件。这个文件是全局的项目配置文件, 里面主要声明一些需要加入gradle的module(比如上述我们的app目录, 这个类似于java的结构com.xxx.xxx, 最终存放代码的部分都可以作为一个module, 而每个dot分隔开来的部分在android studio的结构里看就是一个目录), 这个Test程序的setting.gradle内容为: <code>include &#39;:app&#39;</code>, 如果我们加入了一个新的module叫做gaea, 那么setting.gradle内容就变为: <code>include &#39;:app&#39;, &#39;:gaea&#39;</code>, 如果我们再加入了一个extra/hecate的module, 类似于extra.hecate, 那么setting.gradle内容就变为：<code>include &#39;:app&#39;, &#39;:test&#39;, &#39;:extra:hecate&#39;</code></p>
<h3 id="5-gradlew"><a href="#5-gradlew" class="headerlink" title="5. gradlew"></a>5. gradlew</h3><p>了解了gradle的基本知识，以及android studio里一个project的配置信息，就很容易想到，如果我们从网上down了一份源码，别人虽然也是用gradle配置的，但是如果gradle版本不一样，那么由于其配置的一些语法不同，可能就无法正常编译打包了。我们注意到项目结构的根目录下有gradlew的文件，gradlew代表 gradle wrapper，相当于本地封装了gradle，在<code>/gradle/wrapper/gralde-wrapper.properties</code>文件中声明了它指向的目录和版本。在Android Studio下的terminal下运行 <code>gradlew -v</code>，若是第一次运行则显示Downloading如图：<br><img src="/images/android04_2.png" alt="second"><br>下载的目录为<code>C:\Users\[Username]\.gradle\wrapper\dists\gradle-2.4-all\3i2gobhdl0fm2tosnn15g540i0\</code><br>因为下载过程有点慢，也可以去<a href="https://services.gradle.org/distributions" target="_blank" rel="noopener">https://services.gradle.org/distributions</a>下载其他版本然后放到<code>C:\Users\[Username]\.gradle\wrapper\dists</code>相应目录下解压即可。</p>
<p>下载成功后即可用grdlew wrapper的命令代替全局的gradle命令，再次运行<code>gradlew -v</code>，结果如下：<br><img src="/images/android04_3.png" alt="third"></p>
<p>再次执行<code>gradlew build</code>可以编译并打包成apk文件，如果依赖不全会自动下载gradle的一些依赖，一般下载到<code>C:\Users\[Username]\.gradle\caches\modules-2\files-2.1\</code>目录下。下载成功会出现：<br><img src="/images/android04_4.png" alt="fourth"><br><img src="/images/android04_5.png" alt="fifth"><br>Terminal上可以看出编译成功与否。编译成功后可以在<code>Test\app\build\outputs\apk\</code>文件夹下找到apk文件，如下图：<br><img src="/images/android04_6.png" alt="fifth"></p>
<p>最后可以运行<code>gradlew clean</code>，其作用是清除/app目录下的build文件夹，依赖不全也会下载gradle的一些依赖。<br>以上在下载过程中可以看到<a href="https://jcenter.bintray.com/" target="_blank" rel="noopener">https://jcenter.bintray.com/</a>这个网址一直在出现，其实所有通过gradle导入的jar包都是从此网站的仓库上Downlad的。如果你需要的jar包在这个网站上没有，那就无法通过gradle的方式来导入。至于怎么确定是从这个网站Download，其实在根目录下的build.gradle中指定了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>gradlew的其他用法和参数搭配可以通过<code>gradlew -h</code>查看。</p>
<h3 id="6-其他建议"><a href="#6-其他建议" class="headerlink" title="6. 其他建议"></a>6. 其他建议</h3><p>除了以上命令行的做法, 还可以在将工程导入Android Studio后, 查看每个Module下的 build.gradle 下的buildToolsVersion, 然后通过 SDK Manager 查看本地你安装的 SDK Build-tools, 如果相应版本没有安装先下载安装; 之后, 更新build.gradle和gralde-wrapper.properties相应的部分, 然后使用Android Studio的Make build或Run app即可<br>也可以不使用Android Studio调用安卓模拟器, 手动打开Android Emulator, 之后将app-debug.apk拷到android-sdk\platform-tools目录下, cmd下cd到该目录执行<code>adb install app-debug.apk</code>即可将打包后的apk安装到正在运行的Emulator上了。顺便说下创建新的模拟器时勾选Use Host GPU效果应该会好点。</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>android studio</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Bootstrap小记一</title>
    <url>/2015/10/19/bootstrap01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>把车队主页给换了, 其实就是直接把discuz下的index.php给删了换成自己的, 然而自以为做的差不多了, 没想到好多以前的设计都错了, 其中就有一些关于bootstrap的使用上的错误</p>
<h3 id="2-Collapse-功能"><a href="#2-Collapse-功能" class="headerlink" title="2. Collapse 功能"></a>2. Collapse 功能</h3><p>导航栏的collapse, 以前测试用的网站写的简陋, 没注意导航栏的手机端兼容, 实际上导航栏的使用如下:<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;navbar-header&quot;&gt;</span><br><span class="line">    &lt;a class&#x3D;&quot;navbar-brand&quot; href&#x3D;&quot;#&quot;&gt;Test&lt;&#x2F;a&gt;</span><br><span class="line">    &lt;button type&#x3D;&quot;button&quot; class&#x3D;&quot;btn btn-navbar&quot; data-toggle&#x3D;&quot;collapse&quot; data-target&#x3D;&quot;.navbar-collapse&quot;&gt;</span><br><span class="line">      &lt;span class&#x3D;&quot;icon-bar&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;span class&#x3D;&quot;icon-bar&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;span class&#x3D;&quot;icon-bar&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;navbar&quot; class&#x3D;&quot;navbar-collapse collapse&quot;&gt;</span><br><span class="line">    &lt;ul class&#x3D;&quot;nav navbar-nav&quot;&gt;</span><br><span class="line">      &lt;li class&#x3D;&quot;active&quot;&gt;&lt;a href&#x3D;&quot;#&quot;&gt;Home&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li id&#x3D;&quot;ftp&quot;&gt;&lt;a href&#x3D;&quot;ftp:&#x2F;&#x2F;10.1.166.197&quot; target&#x3D;&quot;_blank&quot;&gt;FTP&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li id&#x3D;&quot;Wiki&quot;&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;10.1.166.197:8080&#x2F;xwiki&#x2F;bin&#x2F;view&#x2F;&quot; target&#x3D;&quot;_blank&quot;&gt;Wiki&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li id&#x3D;&quot;forum&quot;&gt;&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;10.1.166.197&#x2F;forum.php&quot; target&#x3D;&quot;_blank&quot;&gt;Forum&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">      &lt;li id&#x3D;&quot;contact&quot;&gt;&lt;a href&#x3D;&quot;#contact&quot;&gt;Contact&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><br>以前定义了class为navbar-collapse collapse的标签, 但是未定义拥有属性<code>data-toggle=&quot;collapse&quot; data-target=&quot;.navbar-collapse&quot;</code>的标签, 故用手机登陆时并没有好的效果, 现在则可以。看网上源码, 似乎这样写就可以了, 但是以上实现导致其<code>button</code>标签在电脑端浏览也显示, 不够美观, 于是在css里添加<code>@media</code>使button仅在小屏幕才显示出来, 并且设置<code>right:6px</code>使其显示在右侧, 当然还得指定<code>position</code>属性。</p>
<h3 id="3-BootStrap-不兼容-IE11"><a href="#3-BootStrap-不兼容-IE11" class="headerlink" title="3. BootStrap 不兼容 IE11"></a>3. BootStrap 不兼容 IE11</h3><p>因为不想兼容IE6/7/8，所以直接使用jQuery2.x版本，没想到的是搭配BootStrap使用连IE11都不兼容，网页全面崩溃，IE下F12:</p>
<ul>
<li>Object doesn’t support property or method ‘addEventListener’</li>
<li>Bootstrap’s JavaScript requires jQuery</li>
<li>The value of the property ‘$’ is null or undefined, not a Function object</li>
</ul>
<p>而我的jQuery引用必然是在Bootstrap之前的, Chrome和Edge上都可以理想的呈现, 只能是IE11的问题了。Google了一些方法尝试了下, 都不是很满意, 直到看到下面这句<code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot; &gt;</code>, 也很有趣, 既然Edge兼容的话，那就将页面设置为Edge兼容模式就好了。当然这也有可能有其他问题, 比如非Win10的系统, 因为Win10以前的系统并没有自带Edge, 手边暂时也没有其他电脑测试, 所以也不明白是否支持这个兼容模式。</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title>Schedule</title>
    <url>/2017/08/29/breakup/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><table>
<thead>
<tr>
<th style="text-align:center">Time</th>
<th style="text-align:center">Weekdays</th>
<th style="text-align:center">Weekend</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">06:00~06:50</td>
<td style="text-align:center">Get up</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">06:50~07:30</td>
<td style="text-align:center">Run &amp; breakfast</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">07:30~08:00</td>
<td style="text-align:center">Make coffee</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">08:00~08:30</td>
<td style="text-align:center">JLPT</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">08:30~11:30</td>
<td style="text-align:center">Read paper &amp; other things</td>
<td style="text-align:center">For fun</td>
</tr>
<tr>
<td style="text-align:center">11:30~13:50</td>
<td style="text-align:center">Lunch &amp; nap</td>
<td style="text-align:center">For fun</td>
</tr>
<tr>
<td style="text-align:center">13:00~17:15</td>
<td style="text-align:center">Read paper &amp; other things</td>
<td style="text-align:center">For fun</td>
</tr>
<tr>
<td style="text-align:center">17:15~18:00</td>
<td style="text-align:center">Run &amp; dinner</td>
<td style="text-align:center">For fun</td>
</tr>
<tr>
<td style="text-align:center">18:00~19:00</td>
<td style="text-align:center">Shower &amp; rest</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">19:00~22:00</td>
<td style="text-align:center">Coding(PLUTUS, Leetcode)</td>
<td style="text-align:center">Chat with sb.</td>
</tr>
<tr>
<td style="text-align:center">22:00~23:40</td>
<td style="text-align:center">JLPT &amp; patent agent</td>
<td style="text-align:center">Movie &amp; animation</td>
</tr>
</tbody>
</table>
<p>JLPT N2: 12/03/2017<br>Patent agent: 03/01/2018 ~ 11/04/2018<br>JLPT N1: 12/03/2018</p>
]]></content>
      <categories>
        <category>life</category>
        <category>love</category>
      </categories>
      <tags>
        <tag>breakup</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言琐记二</title>
    <url>/2014/07/02/c02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="一、枚举enum的使用"><a href="#一、枚举enum的使用" class="headerlink" title="一、枚举enum的使用"></a>一、枚举enum的使用</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _ErrorCode &#123;</span><br><span class="line">    SystemError = <span class="number">-100</span>,</span><br><span class="line">    MemError,</span><br><span class="line">    FileError</span><br><span class="line">&#125; ErrorCode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    ErrorCode errorCode;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,errorCode.MemError);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上输出结果为-99, 即枚举类型中的值只要不指定, 必然是逐个递增的, 而第一个值不指定则为0, 上述代码指定为-100则为-100, 以后的以此为基准逐一递增。<br><a id="more"></a></p>
<h3 id="二、-if-1-和-if-0"><a href="#二、-if-1-和-if-0" class="headerlink" title="二、#if 1 和#if 0"></a>二、#if 1 和#if 0</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if constant</span><br><span class="line">    ...程序段1...</span><br><span class="line">#else</span><br><span class="line">    ...程序段2...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>这里表示, 如果constant为真(非0, 随便什么数字, 只要不是0), 就编译程序段1, 否则编译程序段2。如果有#if需要顶格写。</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>programming language</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言琐记一</title>
    <url>/2014/06/04/c01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h3><p>在codewarrior写的程序本来是可以编译的, 但只是调整了一些代码的位置, 将一些变量移到块作用域里, 却发现无法编译了, 以为是编译器配置突然出了问题, 解决了很久问题仍然存在</p>
<h3 id="2-解决"><a href="#2-解决" class="headerlink" title="2. 解决"></a>2. 解决</h3><p>最终发现是C语言的问题, C89的标准不允许随便声明变量, 变量声明不能放在任何可执行语句之后, 只允许在函数和块的开始处。<br>这么不合理的规定在C99和C++里自然已经解除了。但是我所使用的codewarrior所用的C Compiler版本还是只支持到C89</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>programming language</tag>
        <tag>codewarrior</tag>
      </tags>
  </entry>
  <entry>
    <title>C++琐记一</title>
    <url>/2015/03/12/cpp01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>没有系统地学过C++, 偶尔会把C++当作高级的C语言用下, 用下它的STL库, 有些很基础的东西都不知道。某课程的作业要求只能用C/C++写, 一动手发现全是错误, 故在此记录。</p>
<h3 id="2-string类"><a href="#2-string类" class="headerlink" title="2. string类"></a>2. string类</h3><p>string类经常使用, 平时还是用来连接下字符串比较多, 还有一些其他常用的方法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">substr(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br><span class="line">str.substr(start,length) <span class="comment">//返回str字符串start位置开始的长度为length的字符串，需要依次输出字符串中的字符时，可以变为str.substr(i,1)，而不用str.at(i)，因为str.at(i)返回值类型为char *</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="3-int转为string"><a href="#3-int转为string" class="headerlink" title="3. int转为string"></a>3. int转为string</h3><p>直接用了toString(), 编译报错才想起来是C++不是Java啊……搜了下又不太想用itoa和sprintf, 就用了stringstream类<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="built_in">stringstream</span> stream;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">stream &lt;&lt; v[i][j];                          <span class="comment">//注意sstream输入是&lt;&lt;而不是iostream的&gt;&gt;</span></span><br><span class="line">stream &gt;&gt; str;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-queue模板类"><a href="#4-queue模板类" class="headerlink" title="4. queue模板类"></a>4. queue模板类</h3><p>顾名思义, queue就是队列, 这个类实现了队列的操作, 但是其pop()方法竟然不返回值, 只是删除队首元素, 要获取队首元素, 需要使用front()方法:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; que;</span><br><span class="line"><span class="built_in">string</span> head = que.front();</span><br><span class="line">que.pop();</span><br></pre></td></tr></table></figure></p>
<h3 id="5-map类"><a href="#5-map类" class="headerlink" title="5. map类"></a>5. map类</h3><p>提供了一一对应的关系, 实例化一个map类后, 添加了新元素, 想要查找其中的key, 利用了其find()方法:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; myMap;</span><br><span class="line">myMap[<span class="string">"test"</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>( myMap.find(<span class="string">"test"</span>) == myMap.end() ) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>更加常用的方法是count.</p>
<h3 id="6-this的使用"><a href="#6-this的使用" class="headerlink" title="6. this的使用"></a>6. this的使用</h3><p>还是受Java影响, 如下:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line">A::A(<span class="keyword">int</span> a) &#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;     <span class="comment">//错误</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>区别在于C++中的this是指针, 而Java没有指针概念, 都是引用对象, 所以在C++中其实应该如此:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line">A::A(<span class="keyword">int</span> a) &#123;</span><br><span class="line">    (*<span class="keyword">this</span>).a = a;      <span class="comment">//or this-&gt;a = a;</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (*<span class="keyword">this</span>).a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>programming language</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++琐记二</title>
    <url>/2015/10/27/cpp02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-vector"><a href="#1-vector" class="headerlink" title="1. vector"></a>1. vector</h3><h4 id="1-1-erase"><a href="#1-1-erase" class="headerlink" title="1.1 erase"></a>1.1 erase</h4><p>以前用vector时只是使用<code>push_back()</code>,<code>pop_back()</code>,<code>begin()</code>,<code>end()</code>,<code>front()</code>,<code>back()</code>等，没用过<code>erase()</code>, 今天搭配iterator用了一下, 才发现很神奇。比如删除一个vector上指定值为val的元素:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = nums.begin(); it != nums.end(); ) &#123;</span><br><span class="line">    <span class="keyword">if</span>( nums[i] == val ) &#123;</span><br><span class="line">        nums.erase(it++);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面这段代码是错误的，而且只要改一处就可以正确。修改后为:<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = nums.begin(); it != nums.end(); ) &#123;</span><br><span class="line">    <span class="keyword">if</span>( nums[i] == val ) &#123;</span><br><span class="line">        nums.erase(it);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>区别就是erase之后it没有自增，也就是将nums某个元素erase之后，并不需要将iterator自增，nums会自动调整整个结构，将后一个元素放到当前指针指的位置。</p>
<h4 id="1-2-iterator"><a href="#1-2-iterator" class="headerlink" title="1.2 iterator"></a>1.2 iterator</h4><p>iterator某种程度上可以当作指针来使用，上述程序还可以这样:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>( it != nums.end() ) &#123;</span><br><span class="line">    <span class="keyword">if</span>( *it == val ) &#123;</span><br><span class="line">        nums.erase(it);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="1-3-初始化"><a href="#1-3-初始化" class="headerlink" title="1.3 初始化"></a>1.3 初始化</h4><p>我通常不初始化vector, 但如果需要初始化分配一定空间, 可以使用<code>vector&lt;int&gt; num(100); vector&lt;int&gt; num(100,0)</code>，前者是包含100个值默认初始化值的元素，后者是包含100个0。<br>此外，C++11新增了一个array类，是固定长度的数组，使用起来可能更方便和安全，有兴趣可以再仔细看下。</p>
<h3 id="2-GCC编译器的问题"><a href="#2-GCC编译器的问题" class="headerlink" title="2. GCC编译器的问题"></a>2. GCC编译器的问题</h3><p>在CodeBlocks里输入<code>vector&lt;vector&lt;int&gt;&gt; s</code>竟然会编译出错，<strong>‘&gt;&gt;’ should be ‘&gt; &gt;’ within a nested template argument list</strong>，改成 <code>vector&lt; vector&lt;int&gt; &gt; s</code>才好, 而在VS里并没有问题, CodeBlocks自带的MinGW中的GCC编译器在某些方面还是比不上VS的编译器的</p>
<h3 id="3-Console输入"><a href="#3-Console输入" class="headerlink" title="3. Console输入"></a>3. Console输入</h3><p>C++中输入字符串我一般常用<code>string str; cin &gt;&gt; str;</code>，然而今天要输入一个字符串，中间带有空格，发现上述写法不对，会自动滤除所有空格，搜了下，使用<code>getline(cin,str);</code>即可。</p>
<h3 id="4-Struct与Class"><a href="#4-Struct与Class" class="headerlink" title="4. Struct与Class"></a>4. Struct与Class</h3><p>struct与class在C++者两者基本相同, 区别仅在以下几点:</p>
<ul>
<li>struct的成员默认权限是public，而class的成员默认权限是private</li>
<li>struct的默认继承方式为public，而class的默认继承为private</li>
<li>只有class可用模板template定义参数，而struct不可以</li>
</ul>
<h3 id="5-关于sizeof"><a href="#5-关于sizeof" class="headerlink" title="5. 关于sizeof"></a>5. 关于sizeof</h3><p>首先声明: <strong>sizeof不是函数,是操作符</strong></p>
<ul>
<li>sizeof是C/C++中的一个操作符(operator)，其作用就是返回一个对象或者类型所占的内存字节数</li>
<li>sizeof的计算发生在编译时刻，所以它可以被当作常量表达式使用</li>
<li>指针记录了另一个对象的地址，既然是来存放地址的，那么必然等于计算机内部地址总线的宽度，所以在32位计算机中，一个指针变量的返回值是4字节，在64位系统中指针变量的sizeof结果为8，当然与编译器的版本有关，如果在64位系统上运行32位编译器自然还是4。注意<code>sizeof(NULL) = 4</code></li>
<li>数组的sizeof值等于数组所占用的内存字节数</li>
<li>每个类的实例，在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类隐含的加一个字节，这样空类在实例化后在内存得到了独一无二的地址，因此空类默认会占用1个字节。如：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span> &#123;</span>&#125;;</span><br><span class="line"><span class="keyword">sizeof</span>(a);      <span class="comment">//为1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>programming language</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Configure OpenCV with VS2013</title>
    <url>/2014/10/28/configOpencv/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-Install"><a href="#1-Install" class="headerlink" title="1. Install"></a>1. Install</h3><p>Download OpenCV from:<br><a href="http://sourceforge.net/projects/opencvlibrary/files" target="_blank" rel="noopener">Lastest</a><br><a href="http://opencv.org" target="_blank" rel="noopener">Homepage</a></p>
<p>Click the file you downloaded, choose a location to extract it.<br><a id="more"></a></p>
<h3 id="2-Configuration"><a href="#2-Configuration" class="headerlink" title="2. Configuration"></a>2. Configuration</h3><h4 id="2-1-Environment"><a href="#2-1-Environment" class="headerlink" title="2.1 Environment"></a>2.1 Environment</h4><p>Configure your environment variables, for example, I add <code>;D:\Program Files\OpenCV\build\x86\vc12\bin</code> to path:<br><img src="/images/opencv_config_1.png" alt="environment path"></p>
<h4 id="2-2-Project"><a href="#2-2-Project" class="headerlink" title="2.2 Project"></a>2.2 Project</h4><p>Then open VS2013, and find project/properties:<br><img src="/images/opencv_config_2.png" alt="vs properties 1"></p>
<p>In VC++ Directories/Include Directories, add:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\Program Files\opencv\build\include</span><br><span class="line">D:\Program Files\opencv\build\include\opencv</span><br><span class="line">D:\Program Files\opencv\build\include\opencv2</span><br></pre></td></tr></table></figure><br>In VC++ Dorectories/Library Directories, add:<br><code>D:\Program Files\opencv\build\x86\vc12\lib</code></p>
<p><img src="/images/opencv_config_3.png" alt="vs properties 2"></p>
<p>Then in Linker/Input/Additional Dependencies, add:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">opencv_ml249d.lib</span><br><span class="line">opencv_calib3d249d.lib</span><br><span class="line">opencv_contrib249d.lib</span><br><span class="line">opencv_core249d.lib</span><br><span class="line">opencv_features2d249d.lib</span><br><span class="line">opencv_flann249d.lib</span><br><span class="line">opencv_gpu249d.lib</span><br><span class="line">opencv_highgui249d.lib</span><br><span class="line">opencv_imgproc249d.lib</span><br><span class="line">opencv_legacy249d.lib</span><br><span class="line">opencv_objdetect249d.lib</span><br><span class="line">opencv_ts249d.lib</span><br><span class="line">opencv_video249d.lib</span><br><span class="line">opencv_nonfree249d.lib</span><br><span class="line">opencv_ocl249d.lib</span><br><span class="line">opencv_photo249d.lib</span><br><span class="line">opencv_stitching249d.lib</span><br><span class="line">opencv_superres249d.lib</span><br><span class="line">opencv_videostab249d.lib</span><br></pre></td></tr></table></figure></p>
<h3 id="3-Comment"><a href="#3-Comment" class="headerlink" title="3. Comment"></a>3. Comment</h3><p>If we use opencv-2.4.10, just change 249 to 2410, opencv-2.4.8 to 248. And there are equivalent <em>.lib</em> file without ‘d’, e.g.: <em>opencv_videostab249.lib</em>, it is used when we need to realease a project but not debug.<br>And it is much easier in opencv-3.0, only a <em>opencv_ts300d.lib</em> or a <em>opencv_ts300.lib</em> will work.</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>日常软件配置</title>
    <url>/2015/10/15/dailyConfig/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-Foobar-2000"><a href="#1-Foobar-2000" class="headerlink" title="1. Foobar 2000"></a>1. Foobar 2000</h3><h4 id="1-1-插件"><a href="#1-1-插件" class="headerlink" title="1.1 插件:"></a>1.1 插件:</h4><blockquote>
<p>foo_ui_columns        //this component is used for better ui.<br>foo_input_monkey   //this component is used for playing music whose postfix is “ape”<br>foo_uie_lyrics3        //this component is used for displaying lyrics</p>
</blockquote>
<p>拖曳窗口最后调整过后是这样:<br><img src="/images/foobar2000_1.png" alt="first"><br>columns_ui的插件一个没用，就觉得已经不错了，而且现在的插件大多也支持default_ui，故觉得并不需要多改动。</p>
<h4 id="1-2-编码器"><a href="#1-2-编码器" class="headerlink" title="1.2 编码器"></a>1.2 编码器</h4><p>lame3.99.2.3和flac-1.3.1-win以及oggenc2<br><a id="more"></a></p>
<h4 id="1-3-搭配使用"><a href="#1-3-搭配使用" class="headerlink" title="1.3 搭配使用"></a>1.3 搭配使用</h4><p>为了自动创建cue下过软件CueTools，非常好用。以及该软件还有为了验证一个文件是不是真无损的功能。</p>
<h3 id="2-uTorrent"><a href="#2-uTorrent" class="headerlink" title="2. uTorrent"></a>2. uTorrent</h3><h4 id="1-1-限制带宽"><a href="#1-1-限制带宽" class="headerlink" title="1.1 限制带宽"></a>1.1 限制带宽</h4><p>options-&gt;preferences-&gt;Bittorrent-&gt;Limit local peer bandwidth<br>options-&gt;preferences-&gt;bandwidth</p>
<h4 id="1-2-限制ip范围"><a href="#1-2-限制ip范围" class="headerlink" title="1.2 限制ip范围"></a>1.2 限制ip范围</h4>]]></content>
      <categories>
        <category>life</category>
        <category>tools</category>
      </categories>
      <tags>
        <tag>foobar2000</tag>
      </tags>
  </entry>
  <entry>
    <title>C++琐记三</title>
    <url>/2015/10/30/cpp03/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-C-堆与栈的区别"><a href="#1-C-堆与栈的区别" class="headerlink" title="1. C++堆与栈的区别"></a>1. C++堆与栈的区别</h3><p>和大神一起从良乡回来, 地铁上突然想起了这个问题就问了下, 大神解释之后茅塞顿开、、、回来又查了查网上的东西, 再看发现理解起来轻松了许多</p>
<p>具体可以参考<a href="http://blog.csdn.net/nieyibin/article/details/7468323" target="_blank" rel="noopener">这篇文章</a>, 还有<a href="https://stackoverflow.com/questions/408670/stack-static-and-heap-in-c" target="_blank" rel="noopener">这个问题</a><br><a id="more"></a></p>
<h3 id="2-NULL"><a href="#2-NULL" class="headerlink" title="2. NULL"></a>2. NULL</h3><p>在C++中0是NULL</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>programming language</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Dancing Links</title>
    <url>/2015/11/20/dancingLinks/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>参考<a href="https://zh.wikipedia.org/wiki/%E8%88%9E%E8%B9%88%E9%93%BE" target="_blank" rel="noopener">维基百科</a></p>
<h3 id="2-分析实现"><a href="#2-分析实现" class="headerlink" title="2. 分析实现"></a>2. 分析实现</h3><p>参考<a href="http://www.cnblogs.com/grenet/p/3145800.html" target="_blank" rel="noopener"><strong>这里</strong></a>, 写的很详细</p>
]]></content>
      <categories>
        <category>techonology</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>dancing links</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络识别手写体数字</title>
    <url>/2015/06/15/digitRecognition/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>智能控制课程的作业之一就是利用神经网络识别手写体数字, 花了两天时间用Matlab实现了</p>
<h3 id="2-BP算法"><a href="#2-BP算法" class="headerlink" title="2. BP算法"></a>2. BP算法</h3><p>神经网络是智能控制领域很重要的一部分，BP网络算法则是神经网络控制中最重要的算法之一。<br><a href="http://blog.csdn.net/gongxq0124/article/details/7681000" target="_blank" rel="noopener">http://blog.csdn.net/gongxq0124/article/details/7681000</a></p>
<a id="more"></a>
<h3 id="3-源代码"><a href="#3-源代码" class="headerlink" title="3. 源代码"></a>3. 源代码</h3><p>The source code of this project is <a href="https://github.com/zhen-yu/Miscellaneous/tree/master/RecognizeNumber" target="_blank" rel="noopener">here</a>.</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>ai</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>intelligent control</tag>
        <tag>neural control</tag>
      </tags>
  </entry>
  <entry>
    <title>折腾车队服务器</title>
    <url>/2015/10/17/discuz/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>飞思卡尔车队有一台服务器一直闲置, 开学没那么多事就帮忙给服务器添加一些功能, 这个过程中有些以前在自己电脑上没有的问题都冒出来了、</p>
<h3 id="2-Apache"><a href="#2-Apache" class="headerlink" title="2. Apache"></a>2. Apache</h3><h4 id="2-1-缺少msvcr110-dll"><a href="#2-1-缺少msvcr110-dll" class="headerlink" title="2.1 缺少msvcr110.dll"></a>2.1 缺少msvcr110.dll</h4><p>首先是<code>httpd -k install</code>时直接提示缺少msvcr110.dll, 安装了<code>vcredist_x64.exe</code>还是不行, 想着直接装.net库, 然而并不可以。最后想起来当时下的apache是32位的, 安装了<code>vcredist_x86.exe</code>之后apache安装成功。<br><a id="more"></a></p>
<h4 id="2-2-Servername错误"><a href="#2-2-Servername错误" class="headerlink" title="2.2 Servername错误"></a>2.2 Servername错误</h4><p>之后出现了ServerName错误，直接将<code>#ServerName: localhost:80</code>注释去了，改为自己需要的。</p>
<h3 id="3-Discuz"><a href="#3-Discuz" class="headerlink" title="3. Discuz"></a>3. Discuz</h3><h4 id="3-1-无法连接数据库"><a href="#3-1-无法连接数据库" class="headerlink" title="3.1 无法连接数据库"></a>3.1 无法连接数据库</h4><p>安装discuz时，显示无法连接数据库，不支持<code>mysqli_connect</code>，建议<code>advice_mysqli_connect</code>，但是php的配置文件里绝对是修改过的，搜了搜发现是<code>extension_dir</code>使用相对路径有时会出错，改为绝对路径后成功</p>
<h4 id="3-2-网站间隔性无法访问"><a href="#3-2-网站间隔性无法访问" class="headerlink" title="3.2 网站间隔性无法访问"></a>3.2 网站间隔性无法访问</h4><p>安装之后即可查看了，但是网站会经常无法访问一段时间，查看日志错误信息为: <strong>AH00341 指定的网络名不再可用</strong>，找到的解决方法有:</p>
<ol>
<li>在httpd.conf里添加：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadsPerChild 1000</span><br><span class="line">MaxRequestsPerChild 10000</span><br><span class="line">Win32DisableAcceptEx</span><br></pre></td></tr></table></figure></li>
<li>在httpd.conf里添加：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AcceptFilter http none</span><br><span class="line">AcceptFilter https none</span><br><span class="line">EnableSendfile Off </span><br><span class="line">EnableMMAP off</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>使用第二种方法解决问题，但是只添加了前两句即可。</p>
<h4 id="3-3-Child-Starting-64-worker-threads"><a href="#3-3-Child-Starting-64-worker-threads" class="headerlink" title="3.3 Child: Starting 64 worker threads"></a>3.3 Child: Starting 64 worker threads</h4><p>errors.log里还有AH00354: Child: Starting 64 worker threads的提醒，这个应该是和分配给Apache的线程数有关，倒是可以用上述方法解决:<br>在httpd.conf找到：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;IfModule mpm_winnt.c&gt;</span><br><span class="line">  ThreadsPerChild 64</span><br><span class="line">  MaxRequestsPerChild 1000</span><br><span class="line">  Win32DisableAcceptEx</span><br><span class="line">&lt;&#x2F;IfModule&gt;</span><br></pre></td></tr></table></figure><br>将ThreadsPerChild的数目改大点，当然这和硬件关联很大。</p>
<h4 id="3-4-无法上传附件"><a href="#3-4-无法上传附件" class="headerlink" title="3.4 无法上传附件"></a>3.4 无法上传附件</h4><p>discuz的头像和附件都无法上传，开始以为只是头像无法上传，提示错误是cannot write data/tmp，感觉是权限问题，就把整个目录权限提升了一番，但是还是不行，最后将<code>#upload_tmp_dir =</code>注释去了，加入discuz的<code>ucenter_server/data/tmp</code>目录，解决问题。</p>
<h3 id="4-Filezilla"><a href="#4-Filezilla" class="headerlink" title="4. Filezilla"></a>4. Filezilla</h3><p>还用filezilla搭了个ftp服务器，配置好后无法通过其他地址访问，查阅资料将filezilla添加到防火墙允许通过</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>discuz</tag>
        <tag>filezilla</tag>
      </tags>
  </entry>
  <entry>
    <title>个人投资与理财</title>
    <url>/2017/10/08/economics01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这个国庆假期没有出游，总不能一直看小说、动画度日啊（虽然最终还是变成了这样、、、）<br>花了半天时间在图书馆，挑了一些个人理财与投资类的书籍<br>主要阅读了”个人理财”<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[个人理财（第3版）-劳伦斯·J·吉特曼](https://item.jd.com/11963877.html)
">[1]</span></a></sup>、”工资是靠不住的”<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[工资是靠不住的-卫志民](https://book.douban.com/subject/6880196/)
">[2]</span></a></sup>、”简单的投资学”<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[简单的投资学-藤泽数希](https://book.douban.com/subject/10454205/)
">[3]</span></a></sup>这三本书，第二本书的名字听起来尤其像是劣质书籍，但是在书架前站着随手翻的十几页写得倒是和Kino近期炒股得出的经验挺相符，就也借阅了。整体来看，第一本属于教科书类别，内容齐全，可以让人对自己一生的理财有个大局观，后两本就是个人投资的一些技巧性内容，如果更具体的想要系统地学习证券投资的知识，Kino手头还有本吴晓求的证券投资学，只看了前两章，私以为还可以<br>本来是想国庆期间有空就把这些内容整理整理，现在看来又是挖了一个新坑不知道什么时候才能填上了、、</p>
<a id="more"></a>
<h3 id="1-理财规划的基础"><a href="#1-理财规划的基础" class="headerlink" title="1. 理财规划的基础"></a>1. 理财规划的基础</h3><h3 id="2-基础资产理财"><a href="#2-基础资产理财" class="headerlink" title="2. 基础资产理财"></a>2. 基础资产理财</h3><h3 id="3-信贷管理"><a href="#3-信贷管理" class="headerlink" title="3. 信贷管理"></a>3. 信贷管理</h3><h3 id="4-保险管理"><a href="#4-保险管理" class="headerlink" title="4. 保险管理"></a>4. 保险管理</h3><h3 id="5-投资管理"><a href="#5-投资管理" class="headerlink" title="5. 投资管理"></a>5. 投资管理</h3><h3 id="6-退休与遗产规划"><a href="#6-退休与遗产规划" class="headerlink" title="6. 退休与遗产规划"></a>6. 退休与遗产规划</h3><h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h3><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)"><a href="https://item.jd.com/11963877.html" target="_blank" rel="noopener">个人理财（第3版）-劳伦斯·J·吉特曼</a><a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)"><a href="https://book.douban.com/subject/6880196/" target="_blank" rel="noopener">工资是靠不住的-卫志民</a><a href="#fnref:2" rev="footnote"> ↩</a></span></div><div id="fn:3" style="display:flex"><span style="width:20px">3.</span><span style="width:calc(100% - 20px)"><a href="https://book.douban.com/subject/10454205/" target="_blank" rel="noopener">简单的投资学-藤泽数希</a><a href="#fnref:3" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>humanities</category>
        <category>economics</category>
      </categories>
      <tags>
        <tag>finance</tag>
      </tags>
  </entry>
  <entry>
    <title>金融交易过程</title>
    <url>/2017/10/08/economics02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>接着挖坑吧、、想着哪个假期或者什么时候闲下来再填上，现在连Kino自己都开始怀疑了、<br>上一篇说的是个人理财与投资，主要是大局观的建立和一些大概的原则，具体到交易过程上，需要做的就是技术性的分析与工程上的实现了，其实目前有的投资不过是货币基金和股票配置，也都是买着玩，主要是通过这个过程使自己被动地关注市场的变化，了解一些交易规则，总结一些经验、其实最终目标是想做一个可以稳定盈利的投资工具（目前只考虑股票了）<br><a id="more"></a><br>关于理论方面的内容，主要参阅了”投资心理学”<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[投资心理学（双语版）（原书第5版）-约翰R·诺夫辛格](https://book.douban.com/subject/25788111/)
">[1]</span></a></sup>，这主要是源自Kino个人的偏执，Kino以为股票投资最核心的问题是心理问题，在一些投资人的口中就是所谓的投资情绪分析<br>股票某种意义上就是赌博，然而与赌博的不同的是股票投资中你能得到的数据足够多，而普通意义上的赌博大多是”信息非常不完全信息博弈”（Kino编的词），而股票投资中的对于博弈多方的交易数据大多都是可以查到的，只是专业机构可以通过分析或者内幕消息提前获知某些消息，这就是优势。也有看法是信息是投资中最核心的问题，这么说也没错，但是Kino认为信息也是用来驱动情绪的，影响投资人的心理，以此影响多还是空，小的信息用来影响个人投资者的情绪，大的信息会影响机构投资者的情绪，然而不止是实体行业的信息可以影响情绪，只用资金也可以做到影响情绪，这就反应在主力资金在K线上的拉升与打压，这一点上更接近赌博一点，像是赌博中的诈胡。所以说所谓的大牛市，其实就是所有主力资金的情绪都是积极状态，达到了一致性，个人投资者不用管啦，反正会随大流，而熊市来临也是因为所有投资者的情绪都变为消极了，因为羊毛薅完了啊，才不是什么分析文章里忽悠的国际形势又变差了、国家政策又要变了，如果信息属实那的确是有影响，当然也是影响了情绪，但是很多时候都是假信息，所以说信息也不能全信。</p>
<p>理论与应用结合方面参阅了”金融投资系统交易原理与应用”<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[金融投资系统交易原理与应用-吴军](https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00ITK6ILS)
">[2]</span></a></sup>这本书，其实主要还是看原理部分了。因为Kino一直都是靠直觉在写代码啊。</p>
<h3 id="1-分析流派"><a href="#1-分析流派" class="headerlink" title="1. 分析流派"></a>1. 分析流派</h3><h3 id="2-投资心理"><a href="#2-投资心理" class="headerlink" title="2. 投资心理"></a>2. 投资心理</h3><h3 id="3-工程实现"><a href="#3-工程实现" class="headerlink" title="3. 工程实现"></a>3. 工程实现</h3><p>这方面其实自己一直在维护一个工程，到现在连个可以用的Demo都没有做出来、、、<br>计划是做一个网页应用，前端用的框架是最近流行的Vue、考虑到处理的数据量和库的丰富性，后端肯定用Python啊，在Django和Flask之间纠结了一会还是用了Flask，前者太重Kino觉得没必要，网页应用Kino还是习惯做前后端完全分离的，后端只返回JSON数据就好，以及处理大数据。数据库用的PostgreSQL，大多数数据是从网易财经爬的，国庆期间主要就忙活这个了，初步算了下，只考虑A股的话，历史数据大概也得有5000*3000=1500万条，数据库写的不好、校园网爆炸、电脑间歇性崩溃，导致Kino已经放弃了这个假期把数据爬完的想法，寒假回去用台式机跑数据好了</p>
<h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h3><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)"><a href="https://book.douban.com/subject/25788111/" target="_blank" rel="noopener">投资心理学（双语版）（原书第5版）-约翰R·诺夫辛格</a><a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)"><a href="https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00ITK6ILS" target="_blank" rel="noopener">金融投资系统交易原理与应用-吴军</a><a href="#fnref:2" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>humanities</category>
        <category>economics</category>
      </categories>
      <tags>
        <tag>finance</tag>
      </tags>
  </entry>
  <entry>
    <title>九宫格(八数码)问题</title>
    <url>/2015/05/29/eightpuzzle/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>智能控制基础的课后题，开始以为没什么，但是不写复杂的算法好久~动手写起来还是漏洞百出<br>主要参考了<a href="http://blog.csdn.net/acm_cxlove/article/details/7745323" target="_blank" rel="noopener">这篇博客</a>的内容<br>英文描述此问题可参见<a href="http://www.aiai.ed.ac.uk/~gwickler/-inf.html" target="_blank" rel="noopener">此处</a></p>
<a id="more"></a>
<h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h3><h4 id="2-1-定义一个图的节点类"><a href="#2-1-定义一个图的节点类" class="headerlink" title="2.1 定义一个图的节点类"></a>2.1 定义一个图的节点类</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VertexOfGraph</span> &#123;</span>       <span class="comment">//定义图的节点类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> vertex[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> h,g;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="built_in">string</span> hashValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    VertexOfGraph() &#123;       <span class="comment">//构造函数将成员变量初始化为0和空</span></span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        h = <span class="number">0</span>;</span><br><span class="line">        g = <span class="number">0</span>;</span><br><span class="line">        hashValue = <span class="string">""</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">()</span> </span>&#123;        <span class="comment">//判断当前状态是否有效,如果超出边界范围则无效</span></span><br><span class="line">        <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; <span class="number">3</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">newStatus</span><span class="params">(<span class="keyword">int</span> oldX, <span class="keyword">int</span> oldY)</span> </span>&#123;    <span class="comment">//将现在存储的空位位置x,y与oldX,oldY对应的位置交换数值,得到新状态</span></span><br><span class="line">        <span class="keyword">int</span> temp = vertex[x][y];</span><br><span class="line">        vertex[x][y] = vertex[oldX][oldY];</span><br><span class="line">        vertex[oldX][oldY] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了方便将类的成员变量都定义为public类型，省去了set、get方法，类中的h、g并没有用到，初始化都置0了，作为以后扩展用，主要是用于启发式搜索中的估价函数，搜索得到比较常用的启发式搜索方法有A*搜索，目前的算法都没有用到~</p>
<h4 id="2-2-输入功能"><a href="#2-2-输入功能" class="headerlink" title="2.2 输入功能"></a>2.2 输入功能</h4><p>输入功能必须要有,就控制台输入了, 可以把代码移到C#上，用Winform做一个GUI界面~<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> origin[<span class="number">3</span>][<span class="number">3</span>],target[<span class="number">3</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure><br>定义3*3的数组表示九宫格的九个数字, origin分别为初始状态和目标状态, 循环读入即可. 至于为何不使用1*9的一维数组, 照顾要是考虑到后续搜索路径的问题, 3*3的路径比较容易设计, 其中一个数组下标变化1即可, 而对于1*9, 感觉有点复杂(后来发现其实并不是, 将下标分别+-3和+-1就得到了四个路径, 再判断新状态是否有效即可, 好像还比3*3简单点)</p>
<h4 id="2-3-状态判重"><a href="#2-3-状态判重" class="headerlink" title="2.3 状态判重"></a>2.3 状态判重</h4><p>对于每个状态必须判重，也要判断是否与目标状态相同，如果是将9个元素逐个比较，太耗时，肯定是得用到hash，hash方法<a href="http://www.cnblogs.com/goodness/archive/2010/05/04/1727141.html" target="_blank" rel="noopener">http://www.cnblogs.com/goodness/archive/2010/05/04/1727141.html</a>中的境界二有提到，但是我没看懂~”逆序值”这个词写的不清楚，感觉应该是排列组合中的一个名词，但是搜出来的都不对，于是自己设计个不能称之为hash的hash函数, 因为这个方法的信息量没有压缩, 是可逆的<br>对于每种状态只需要唯一对应一个值即可，于是想着把每种状态的数字串成字符串当作hash值，这肯定不是好方法，至少本来只需要9!=362880个int型元素就能存下所有状态，而现在对于每种状态都是一个9位长的字符串~不过有一个好处就是存储的信息相对而言多了, 对于最后输出所有路径有所帮助。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getHash</span><span class="params">(<span class="keyword">int</span> v[<span class="number">3</span>][<span class="number">3</span>])</span> </span>&#123;                           <span class="comment">//将状态的数字排序转换为字符串,作为hash值</span></span><br><span class="line">    <span class="built_in">string</span> hashString = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">stringstream</span> sstream;</span><br><span class="line">            <span class="built_in">string</span> str;</span><br><span class="line">            sstream &lt;&lt; v[i][j];                          <span class="comment">//注意sstream输入是&lt;&lt;而不是iostream的&gt;&gt;</span></span><br><span class="line">            sstream &gt;&gt; str;</span><br><span class="line">            hashString += str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-4-建立初始表结构"><a href="#2-4-建立初始表结构" class="headerlink" title="2.4 建立初始表结构"></a>2.4 建立初始表结构</h4><p>根据给定初始状态建立初始的表结构，找到0的位置即为可移动的空格位置并记录，找到得到hash值并记录<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VertexOfGraph <span class="title">createGraph</span><span class="params">(<span class="keyword">int</span> vertex[<span class="number">3</span>][<span class="number">3</span>])</span> </span>&#123;</span><br><span class="line">    VertexOfGraph returnGraph;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;<span class="number">3</span>; j++) &#123;</span><br><span class="line">            returnGraph.vertex[i][j] = vertex[i][j];</span><br><span class="line">            <span class="keyword">if</span>(vertex[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                returnGraph.x = i;</span><br><span class="line">                returnGraph.y = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    returnGraph.hashValue = getHash(vertex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> returnGraph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-5-bfs广度搜索"><a href="#2-5-bfs广度搜索" class="headerlink" title="2.5 bfs广度搜索"></a>2.5 bfs广度搜索</h4><p>搜索结果返回一个map表，将每一状态转换之后的状态作为key值，原状态作为value，一一对应保存起来，最后通过此表可得到实际路径<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string,string&gt; bfsSearch(VertexOfGraph graph,string targetHash,map&lt;string,bool&gt; visited) &#123;</span><br><span class="line">    <span class="keyword">int</span> direction[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line">    <span class="built_in">queue</span>&lt;VertexOfGraph&gt; que;</span><br><span class="line">    que.push(graph);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; route;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) &#123;</span><br><span class="line">        VertexOfGraph movingVertex = que.front();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; movingVertex.hashValue &lt;&lt; endl;       //测试遍历结果</span></span><br><span class="line">        VertexOfGraph savingVertex = movingVertex;</span><br><span class="line">        que.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            movingVertex = savingVertex;</span><br><span class="line">            movingVertex.x = savingVertex.x + direction[i][<span class="number">0</span>];</span><br><span class="line">            movingVertex.y = savingVertex.y + direction[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(!movingVertex.isValid()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                movingVertex.newStatus(savingVertex.x, savingVertex.y);</span><br><span class="line">                movingVertex.hashValue = getHash(movingVertex.vertex);</span><br><span class="line">                <span class="keyword">if</span>(visited.find(movingVertex.hashValue)==visited.end()) &#123;</span><br><span class="line">                    visited[movingVertex.hashValue] = <span class="literal">true</span>;</span><br><span class="line">                    route[movingVertex.hashValue] = savingVertex.hashValue;</span><br><span class="line"></span><br><span class="line">                    que.push(movingVertex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(movingVertex.hashValue == targetHash) &#123;</span><br><span class="line">                    <span class="keyword">return</span> route;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> route;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>bfs的想法是，从第一个状态开始遍历可能的所有状态，对于当前状态，找出其可以转换的状态，将他们全部放入队列的尾部，保存route，并判断他们是否是目标状态，若是，返回route退出，否则不停取出队列的头元素，执行相同操作</p>
<h4 id="2-6-找回实际路径"><a href="#2-6-找回实际路径" class="headerlink" title="2.6 找回实际路径"></a>2.6 找回实际路径</h4><p>从route和目标hash值中找回实际路径，并输出<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; searchRoute,<span class="built_in">string</span> targetHash)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; shortestRoute;</span><br><span class="line">    shortestRoute.push(targetHash);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> nextWay = targetHash;</span><br><span class="line">    <span class="keyword">while</span>( searchRoute.find(nextWay) != searchRoute.end() ) &#123;</span><br><span class="line">        nextWay = searchRoute[nextWay];</span><br><span class="line">        shortestRoute.push(nextWay);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> counts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( !shortestRoute.empty() ) &#123;</span><br><span class="line">        <span class="built_in">string</span> displayString = shortestRoute.top();</span><br><span class="line">        shortestRoute.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( (counts == <span class="number">0</span>) &amp;&amp; (displayString == targetHash) ) &#123;       <span class="comment">//如果堆栈内只有一个字符串元素,且等于targetHash,那么说明遍历了所有的状态也无法达到目标状态</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sorry, but you can not reach the target status, and you can try another status instead."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Step "</span> &lt;&lt; counts &lt;&lt; <span class="string">" :"</span>;</span><br><span class="line">        counts++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; displayString.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>( i % <span class="number">3</span> == <span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; displayString.substr(i,<span class="number">1</span>) &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( counts &gt; <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Totally, you used "</span> &lt;&lt; counts<span class="number">-1</span> &lt;&lt; <span class="string">" steps to the target status."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>源码可以在<a href="https://github.com/zhen-yu/Miscellaneous/tree/master/SquaredUp/CPP" target="_blank" rel="noopener">这里</a>看到</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>eightpuzzle</tag>
      </tags>
  </entry>
  <entry>
    <title>Usage of function generator in multisim</title>
    <url>/2014/10/26/functionGenerator/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h3><p>进行多级放大电路和负反馈放大电路的模拟仿真时，用到了multisim里的function generator(函数发生器)，对其中的参数amplitude产生了困惑，这个amplitude(振幅)指的是峰值还是峰峰值。<br><a id="more"></a></p>
<h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h3><p>于是设计了一个及其简单的电路进行仿真:<br><img src="/images/analogelec_functionGenerator_1.png" alt="simple circuit 1"></p>
<p>其中函数发生器的amplitude设为10V，可是multimeter的结果却是14.142V，出乎意料<br>于是查阅资料，发现function generator的三个引脚为正、负、接地，并不是负号出接地！这样改过之后，结果为7.071V<br><img src="/images/analogelec_functionGenerator_2.png" alt="simple circuit 2"></p>
<p>因为multimeter(万用表)测的为正弦交流信号的有效值，可以推测出function generator的amplitude为峰值。后来看见有网友解答说: 单位为Vp时是峰值，Vpp才是峰峰值</p>
<h3 id="3-电路图"><a href="#3-电路图" class="headerlink" title="3. 电路图"></a>3. 电路图</h3><p>附上多级放大电路及负反馈电路的电路图：<br><img src="/images/analogelec_functionGenerator_3.png" alt="Simple circuit 3"></p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>ee</category>
      </categories>
      <tags>
        <tag>electronic</tag>
        <tag>multisim</tag>
      </tags>
  </entry>
  <entry>
    <title>音乐信号灯电子电路设计</title>
    <url>/2015/09/12/electronicDesign01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul>
<li>想使multisim的四路示波器波形相对静止下查看，如果是正弦波可以在示波器上选中波形类型为正弦波，否则可以直接点击暂停仿真使停止</li>
<li>仿真过程极慢，现实1s在multisim中竟然走了3、4s，改multisim步长有时可以解决问题，但若是仿真电路本身的确复杂，则只能靠等待了，毕竟仿真是需要计算时间的</li>
<li>Mesurement Probe的确好用，但是有时运行一段时间后，会导致Transient time point calculation did not converge这个错误，出现这个问题的另一个原因可能是示波器未接地。</li>
</ul>
<a id="more"></a>
<h3 id="一、设计目的"><a href="#一、设计目的" class="headerlink" title="一、设计目的"></a>一、设计目的</h3><p>针对电子线路课程要求，对学生进行实用型电子线路设计、安装、调试等各环节综合性训练，培养学生运用课程中所学的理论与实践紧密结合，独立的解决实际问题的能力。电路设计工具MULTISIM的学习与应用，应用计算机的能力，用简洁的文字,清晰的图表来表达自己设计思想的能力。</p>
<h3 id="二、设计内容和要求"><a href="#二、设计内容和要求" class="headerlink" title="二、设计内容和要求"></a>二、设计内容和要求</h3><ul>
<li>1、音乐信号分为三个频段，分别控制红、绿、蓝三种颜色的彩灯；三段信号的频率为：<ul>
<li>低频段：25Hz—200Hz</li>
<li>中频段：500Hz —1200Hz</li>
<li>高频段：2000Hz—3000Hz</li>
</ul>
</li>
<li>2、当输入信号大于10mV时，彩灯的亮度分为6个等级；当输入信号小于10mV时彩灯全亮。</li>
</ul>
<h3 id="三、设计任务分析"><a href="#三、设计任务分析" class="headerlink" title="三、设计任务分析"></a>三、设计任务分析</h3><p>灯泡亮度通过双向可控硅电路控制，图3-1为控制波形图。如果输入交流220V正弦波电压过零点时在双向可控硅的控制极和阴极之间连续加入幅度大于3V，宽度大于1ms的同步触发脉冲，可控硅就可连续导通，忽略可控硅导通压降，正弦波电压将全部加到灯泡上，灯泡最亮。如果触发脉冲消失，可控硅就会在输入正弦波电压下一个过零点时自然截止，灯泡熄灭。可以设想，把同步触发脉冲每六个分为一组，利用音乐信号的大小控制每组脉冲出现的个数，就可以控制加在灯泡正弦波半波的个数，从而也就控制了灯泡的亮度。<br><img src="/images/electronicDesign_1.png" alt="3-1"></p>
<p align="center">图3-1</p>

<p>把音乐信号分成三个频率段可用带通滤波器去实现。组成带通滤波器电路的形式很多，其中最简单的并且上、下限截止频率分别可调的是由低、高通滤波电路串联而成的带通滤波器。这种电路的缺点是所用元件较多，优点是调整方便，很容易实现指标要求。<br>通过带通滤波器选出所需要的频率段的音乐信号，经过精密整流器变为直流，其直流电平随音乐信号大小而上下浮动。此电平作为参考电压加在电压比较器的一个输入端，由同步触发脉冲作为计数信号的数模转换器，输出阶梯波作为比较电压加在电压比较器的另一个输入端，使电压比较器的输出电压高电平的时间与参考电压成正比，并控制与门打开时间，以决定放过同步脉冲的个数去触发可控硅，从而控制灯泡的亮度。</p>
<h3 id="四、系统设计方案"><a href="#四、系统设计方案" class="headerlink" title="四、系统设计方案"></a>四、系统设计方案</h3><p><img src="/images/electronicDesign_2.png" alt="4-1"></p>
<p align="center">图4-1</p>


<h3 id="五、单元电路分析与设计"><a href="#五、单元电路分析与设计" class="headerlink" title="五、单元电路分析与设计"></a>五、单元电路分析与设计</h3><h4 id="1、整流电路"><a href="#1、整流电路" class="headerlink" title="1、整流电路"></a>1、整流电路</h4><p>通过变压器得到的±10V交流电压经过整流应该得到±12V的电压，再通过W7805稳压电路得到5V的电压，通过整流电路的输出电压给整个电路中用到的芯片供电。电路原理图如图5-1所示：<br><img src="/images/electronicDesign_3.png" alt="5-1"></p>
<p align="center">图5-1</p>

<h4 id="2、同步脉冲发生器"><a href="#2、同步脉冲发生器" class="headerlink" title="2、同步脉冲发生器"></a>2、同步脉冲发生器</h4><p><img src="/images/electronicDesign_4.png" alt="5-2"></p>
<p align="center">图5-2</p>

<p>开始利用555定时器设计了一个多谐振荡器的电路如图5-2，生成300Hz的方波作为同步脉冲的发生器，实际搭建电路时，老师指导我们555作为数字电子器件精度达不到要求，要求用模拟电路搭成同步脉冲发生器，于是重新构建电路如图5-3所示：<br><img src="/images/electronicDesign_5.png" alt="5-3"></p>
<p align="center">图5-3</p>

<h4 id="3、阶梯波产生电路"><a href="#3、阶梯波产生电路" class="headerlink" title="3、阶梯波产生电路"></a>3、阶梯波产生电路</h4><p><img src="/images/electronicDesign_6.png" alt="equation"><br><img src="/images/electronicDesign_7.png" alt="5-4"></p>
<p align="center">图5-4</p>

<p><img src="/images/electronicDesign_8.png" alt="5-5"></p>
<p align="center">图5-5</p>

<p>其中由于是清零时方式设置的计时循环，所以在输出位置加C_16这个电容，以除去产生的尖峰。</p>
<h4 id="4、低通和带通滤波器"><a href="#4、低通和带通滤波器" class="headerlink" title="4、低通和带通滤波器"></a>4、低通和带通滤波器</h4><p>由于最低频段的要求为25Hz至200Hz，为了方便，直接用低通电路设计，其他两路用带通电路。并且输入电压值较小，滤波后电压值也小，于是后面都需要加一个放大电路，通过滤波电路和放大电路最终将原始电压都放大了100倍。滤波和放大电路的设计图见图5-6。<br><img src="/images/electronicDesign_9.png" alt="5-6"></p>
<p align="center">图5-6</p>

<p>电路中电阻电容的参数计算的公式结合电路图讲解：</p>
<ul>
<li>1) 低通电路参数计算<br><img src="/images/electronicDesign_10.png" alt="5-7"><p align="center">图5-7</p>

</li>
</ul>
<p><img src="/images/electronicDesign_11.png" alt="equation"></p>
<ul>
<li>2) 带通电路参数计算<br><img src="/images/electronicDesign_12.png" alt="5-8"><p align="center">图5-8</p>

</li>
</ul>
<p><img src="/images/electronicDesign_13.png" alt="equation"><br>中频段中心频率为850Hz，频宽BW=700Hz，取适当增益(这里我们取2)，可计算得到适当参数，高频段中心频率2500Hz，频宽BW=1000Hz，取适当增益(这里我们取2)，可计算得到适当参数。</p>
<h4 id="5、精密整流器和电压比较器"><a href="#5、精密整流器和电压比较器" class="headerlink" title="5、精密整流器和电压比较器"></a>5、精密整流器和电压比较器</h4><p>滤波放大之后的电压还是交流电，为了和之后的阶梯波相比较，必须先整流成直流电压，然后再和阶梯波比较生成PWM波，设计电路如下：<br><img src="/images/electronicDesign_14.png" alt="5-9"></p>
<p align="center">图5-9</p>

<p>其中运放的反向端即是阶梯波的输出，整流后的电压通过与其比较生成PWM波，整流后的电压若在0-1V之间，则占空比为1/6，在1V-2V间，占空比为2/6，在2V-3V间，占空比为3/6，在3V-4V间，占空比为4/6，在4V-5V间，占空比为5/6，大于5V时，占空比为6/6，以上说明均以高电平所占周期比例作为占空比。</p>
<h4 id="6、10mV音乐信号鉴别器"><a href="#6、10mV音乐信号鉴别器" class="headerlink" title="6、10mV音乐信号鉴别器"></a>6、10mV音乐信号鉴别器</h4><p>电路如图5-10示：<br><img src="/images/electronicDesign_15.png" alt="5-10"></p>
<p align="center">图5-10</p>

<p>通过放大电路放大输入的电压值，再通过半波整流电路得到直流电压，此直流电压和输入交流电压的幅值成正比，将其作为比较器的反相输入，比较器的正相输入为二极管D16的压降值。通过仔细调节R32/R31的比值，可以达到当输入电压幅值小于10mV时U16输出高电平，大于10mV时输出低电平的效果。最后将三路电压比较器的输出分别与此输出相或，得到输出的结果即是我们想要的结果，低于10mV时全是高电平，即占空比100%，否则为其他5种不同的状态。由于要控制彩灯，而彩灯是要通过晶闸管触发的，通过触发脉冲数不同，可以得到不同亮度。</p>
<h3 id="六、系统仿真电路"><a href="#六、系统仿真电路" class="headerlink" title="六、系统仿真电路"></a>六、系统仿真电路</h3><p>系统整体仿真电路图6-1，其中为了方便脉冲触发就用以前的555作为脉冲的产生电路：<br><img src="/images/electronicDesign_16.png" alt="6-1"></p>
<p align="center">图6-1</p>


<h3 id="七、仿真结果显示"><a href="#七、仿真结果显示" class="headerlink" title="七、仿真结果显示"></a>七、仿真结果显示</h3><p>输出电压参数为150Hz、20mV仿真，输出的PWM波和最终的脉冲触发电路分别如图7-1和图7-2所示：<br><img src="/images/electronicDesign_17.png" alt="7-1"></p>
<p align="center">图7-1</p>

<p><img src="/images/electronicDesign_18.png" alt="7-2"></p>
<p align="center">图7-2</p>


<h3 id="八、实际电路结果"><a href="#八、实际电路结果" class="headerlink" title="八、实际电路结果"></a>八、实际电路结果</h3><p>实际搭建的硬件电路，最终示波器测量阶梯波、同步脉冲波以及最终的触发波如下图所示：<br><img src="/images/electronicDesign_19.png" alt="8-1"></p>
<p align="center">图8-1</p>

<p><img src="/images/electronicDesign_20.png" alt="8-2"></p>
<p align="center">图8-2</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>ee</category>
      </categories>
      <tags>
        <tag>electronic</tag>
        <tag>multisim</tag>
        <tag>EDA</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈泛函、极值及最优化控制问题</title>
    <url>/2015/03/08/functional/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>花了几个小时复习自控，其中最后看的内容是关于泛函的，做个笔记，谈谈自己对它的理解。</p>
<h3 id="2-瞎想"><a href="#2-瞎想" class="headerlink" title="2. 瞎想"></a>2. 瞎想</h3><p>看到泛函的定义之后，我的第一反应是 这不就是将二维空间的函数上升了一个维度么。说起来，数学和物理领域很多概念都是在原有基础上进行维度的扩展得到的，不过进一步思考，泛函还可以上升到更高维度，简单的是二维空间内的函数对应一个具体数值，即上升到了三维空间，而如果是三维空间内的函数作为自变量(也就是宗量)，那么泛函就应该上升到四维空间了，如此推论，泛函其实可以定义在无限维空间。</p>
<p>从普通函数的维度扩展上来理解，泛函的很多性质，可以尝试着从原来我们所理解的函数基础上去学习，这样能够简化不少。<br><a id="more"></a></p>
<h3 id="3-定义"><a href="#3-定义" class="headerlink" title="3. 定义"></a>3. 定义</h3><p>维基百科上对泛函的说明: 传统上，泛函（functional）通常是指一种定义域为函数，而值域为实数的”函数”。换句话说，就是从函数组成的一个向量空间到实数的一个映射。也就是说它的输入为函数，而输出为实数。泛函的应用可以追溯到变分法，那里通常需要寻找一个函数用来最小化某个特定泛函。在物理学上，寻找某个能量泛函的最小系统状态是泛函的一个重要应用。在泛函分析中，泛函也用来指一个从任意向量空间到标量域的映射。泛函中的一类特例线性泛函引发了对对偶空间的研究。</p>
<h3 id="4-应用"><a href="#4-应用" class="headerlink" title="4. 应用"></a>4. 应用</h3><p>上述说到的寻找求取最小系统状态，便是我要学习泛函的原因之一，在控制系统中，给定状态和性能指标，要求计算出最小系统状态、最优控制或极小值等很常见。利用泛函这种工具，辅以欧拉方程、边界条件、横截条件可以比较方便地求出极值轨线，而对于有约束调节的状态，只是构造欧拉函数不同而已。而对于不受控的控制输入，求取最优控制时可以构造Hamilton函数，利用正则方程、边界条件和横截条件以及极值条件可以求解。最后，对于受控的控制输入，或者其控制变量不可微，那么久需要利用极小值原理，进行求解。</p>
<h3 id="5-无初始状态和末状态的极值轨线的求取"><a href="#5-无初始状态和末状态的极值轨线的求取" class="headerlink" title="5. 无初始状态和末状态的极值轨线的求取"></a>5. 无初始状态和末状态的极值轨线的求取</h3><h3 id="6-最优控制求取"><a href="#6-最优控制求取" class="headerlink" title="6. 最优控制求取"></a>6. 最优控制求取</h3><h4 id="6-1-控制函数不受约束情况下"><a href="#6-1-控制函数不受约束情况下" class="headerlink" title="6.1 控制函数不受约束情况下"></a>6.1 控制函数不受约束情况下</h4><h4 id="6-2-控制函数受约束情况下"><a href="#6-2-控制函数受约束情况下" class="headerlink" title="6.2 控制函数受约束情况下"></a>6.2 控制函数受约束情况下</h4>]]></content>
      <categories>
        <category>science</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>functional</tag>
        <tag>optimal control</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1003</title>
    <url>/2013/02/23/hdu1003/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Given a sequence a[1],a[2],a[3]……a[n], your job is to calculate the max sum of a sub-sequence. For example, given (6,-1,5,4,-7), the max sum in this sequence is 6 + (-1) + 5 + 4 = 14.</p>
<a id="more"></a>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line starts with a number N(1&lt;=N&lt;=100000), then N integers followed(all the integers are between -1000 and 1000).</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, you should output two lines. The first line is “Case #:”, # means the number of the test case. The second line contains three integers, the Max Sum in the sequence, the start position of the sub-sequence, the end position of the sub-sequence. If there are more than one result, output the first one. Output a blank line between two cases.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>2<br>5 6 -1 5 4 -7<br>7 0 6 -1 1 -6 7 -5</p>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>Case 1:<br>14 1 4</p>
<p>Case 2:<br>7 1 6</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>最初看到这题时的想法就是做循环,心里很明白这样做会超时,但还是去试了下,果然超时了,之后就暂时放下了这个问题。后来在《编程珠玑》里看到了对这个问题的详细讲解,豁然开朗,于是又重新做了一遍,感觉顺手多了。</p>
<p>《编程珠玑》看里给出了几种算法的比较,第一种自然是最简单的时间复杂度为O(n^3)的算法,然后可以改进为O(n^2)的算法,之后作者提到可以用分治法的思想,通过递归解决,时间复杂度为O(n*logn),而且这种方法在很长一段时间里被认为是最优的,直到某天遇到了一数学大神,据说该大神几分钟就想出了一个时间复杂度为O(n)的算法、、、</p>
<p>杭电的这题更复杂一点的地方在于它还要求出最大子序列的开始和结束位置,结束位置很简单,直接是Max的最后一个数,第一个当初想是从最后一个数向前做加法,直到和为Max,但是这样还要在判断这之前的数是否为0,很复杂,后来发现讨论区里有代码,研究了下,很巧妙,下面程序附的测试用例也是讨论区看到的、、、</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LEN 100000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">int</span> i,length;</span><br><span class="line">        <span class="keyword">int</span> a[MAX_LEN+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; length; i++ ) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>,tmpLeft = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = a[<span class="number">0</span>],maxWithLastNumber = <span class="number">0</span>;   <span class="comment">//需要注意数列全为负,故不能将max初始化为0</span></span><br><span class="line">        <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; length; i++ ) &#123;</span><br><span class="line">            maxWithLastNumber += a[i];          <span class="comment">//数列全为负且第一个可能不是最大的负数,所以不能先比较maxWithLastNumber</span></span><br><span class="line">            <span class="keyword">if</span>( max &lt; maxWithLastNumber ) &#123;</span><br><span class="line">                max = maxWithLastNumber;</span><br><span class="line">                left = tmpLeft;</span><br><span class="line">                right = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( maxWithLastNumber &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                maxWithLastNumber = <span class="number">0</span>;</span><br><span class="line">                tmpLeft = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n%d %d %d\n"</span>,count,max,left+<span class="number">1</span>,right+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>( T ) &#123;  <span class="built_in">printf</span>(<span class="string">"\n"</span>);  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//附测试数据</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    4 0 0 2 0 -&gt; 2 1 3</span></span><br><span class="line"><span class="comment">    6 2 7 -9 5 4 3 -&gt; 12 1 6</span></span><br><span class="line"><span class="comment">    4 0 0 -1 0 -&gt; 0 1 1</span></span><br><span class="line"><span class="comment">    7 -1 -2 -3 -2 -5 -1 -2 -&gt; -1 1 1</span></span><br><span class="line"><span class="comment">    6 -1 -2 -3 1 2 3 -&gt; 6 4 6</span></span><br><span class="line"><span class="comment">    5 -3 -2 -1 -2 -3 -&gt; -1 3 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title>一起来学Haskell啦</title>
    <url>/2017/11/12/haskell01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>函数式语言Haskell听闻已久, 但是没看过, 最近两周看<em>learn you a haskell for great good!</em><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[learn you a haskell for great good!](http://learnyouahaskell.com/)
">[1]</span></a></sup>, 有种相见恨晚的感觉, 现在如果让我一个编程入门者学习的话, 我可能会推荐C++和Haskell吧… Haskell里的思想看完, 再看Python, JS ES2015/16/17引入的一些新特性, 一眼就能理解了.</p>
<p><em>learn you a haskell for great good!</em>这本书看完一遍, 再重新看一遍目录, 从中找到自己印象不深的章节, 稍作记录于此.</p>
<a id="more"></a>
<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>工具个人推荐用Stack, 官方文档查询步骤就好, 值得注意的是由于G*F*W的存在, <code>stack setup</code>时竟然没法下载GHC, 这里推荐:<br>中科大镜像:<br><a href="http://mirrors.ustc.edu.cn/help/hackage.html" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/help/hackage.html</a><br><a href="http://mirrors.ustc.edu.cn/help/stackage.html" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/help/stackage.html</a><br>清华Tuna镜像:<br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/hackage/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/hackage/</a><br><a href="https://mirror.tuna.tsinghua.edu.cn/help/stackage/" target="_blank" rel="noopener">https://mirror.tuna.tsinghua.edu.cn/help/stackage/</a></p>
<h3 id="2-自定义Type和Typeclass"><a href="#2-自定义Type和Typeclass" class="headerlink" title="2. 自定义Type和Typeclass"></a>2. 自定义Type和Typeclass</h3><h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h3><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)"><a href="http://learnyouahaskell.com/" target="_blank" rel="noopener">learn you a haskell for great good!</a><a href="#fnref:1" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>programming language</tag>
        <tag>haskell</tag>
      </tags>
  </entry>
  <entry>
    <title>Game Theory</title>
    <url>/2015/08/26/gameTheory/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-一场博弈的四个基本要素"><a href="#1-一场博弈的四个基本要素" class="headerlink" title="1. 一场博弈的四个基本要素"></a>1. 一场博弈的四个基本要素</h3><ul>
<li>至少两个参与者。博弈论的参与者又被称为决策主体，也就是在博弈中制定决策的人</li>
<li>利益</li>
<li>策略。在博弈中，决策主体根据获得的信息和自己的判断，制定出一个行动方案，这个行动方案便是策略</li>
<li>信息。利益是博弈的目的，策略是获得利益的手段，而信息就是制定策略的依据</li>
</ul>
<a id="more"></a>
<h3 id="2-博弈的分类"><a href="#2-博弈的分类" class="headerlink" title="2. 博弈的分类"></a>2. 博弈的分类</h3><h4 id="2-1-合作博弈和非合作博弈"><a href="#2-1-合作博弈和非合作博弈" class="headerlink" title="2.1 合作博弈和非合作博弈"></a>2.1 合作博弈和非合作博弈</h4><p>根据博弈的参与者之间是否有一个具有约束力的协议，博弈可分为合作博弈和非合作博弈</p>
<ul>
<li>合作博弈。合作博弈并不是指参与者之间有合作的意向，或是合作态度，而是参与者之间有具有约束力的协议、约定或者契约，参与者必须在这些协议的范围内进行博弈。合作博弈是研究合作中如何分配利益的问题，目的是使得协议框架内所有参与者都满意。</li>
<li>非合作博弈。非合作博弈指参与者在博弈的时候，无法达成一个对各方都有约束力的协议。非合作博弈的目的是如何为自己争取最大化的利益，并不考虑其他参与者的利益。</li>
</ul>
<h4 id="2-2-静态博弈与动态博弈"><a href="#2-2-静态博弈与动态博弈" class="headerlink" title="2.2 静态博弈与动态博弈"></a>2.2 静态博弈与动态博弈</h4><p>按照参与者选择策略、作出决定的先后顺序，可分为静态博弈与动态博弈</p>
<ul>
<li>静态博弈。如果参与者们同时选择策略，或者虽然有先后，但是后做出策略的参与者并不知道其他参与者的策略，那就是静态博弈，例如”剪刀石头布”</li>
<li>动态博弈。如果参与者的行动有先后顺序，并且后者是在了解前者策略的前提下制定自己的策略，这种情况就是动态博弈，如打扑克</li>
</ul>
<h4 id="2-3-完全信息博弈和不完全信息博弈"><a href="#2-3-完全信息博弈和不完全信息博弈" class="headerlink" title="2.3 完全信息博弈和不完全信息博弈"></a>2.3 完全信息博弈和不完全信息博弈</h4><p>基于对其他参与者的信息掌握程度，可分为完全信息博弈和不完全信息博弈</p>
<ul>
<li>完全信息博弈是指博弈中对其他参与者特征、利益、可能选择的策略等信息都有一个准确的了解</li>
<li>不完全信息博弈是指博弈中对其他参与者特征、利益、可能选择的策略等信息没有一个准确的了解，或者有多个参与者的情况下，只有对个别参与者的信息了解</li>
</ul>
<h4 id="2-4-负和博弈、零和博弈与正和博弈"><a href="#2-4-负和博弈、零和博弈与正和博弈" class="headerlink" title="2.4 负和博弈、零和博弈与正和博弈"></a>2.4 负和博弈、零和博弈与正和博弈</h4><p>按照博弈的结果来分，博弈分为负和博弈、零和博弈与正和博弈</p>
<ul>
<li>负和博弈。负和博弈指博弈的参与者最后得到的收获都小于付出，都没有占到便宜，是一种两败俱伤的博弈</li>
<li>零和博弈。零和博弈是指参与者中一方获益，另一方损失，并且参与者之间获得的利益与损失之和为零，如赌博</li>
<li>正和博弈。正和博弈又被称为双赢博弈、合作博弈，是指参与者都能获益，或者一方的收益增加并不影响其他参与者的利益，这种博弈被认为是结局最好的一种博弈，也就是双赢</li>
</ul>
<h3 id="3-纳什均衡"><a href="#3-纳什均衡" class="headerlink" title="3. 纳什均衡"></a>3. 纳什均衡</h3><p><a href="https://en.wikipedia.org/wiki/Nash_equilibrium#Definitions" target="_blank" rel="noopener">Wiki</a><br>简单来说就是，多人参加的博弈中，每个人根据他人的策略制定自己的最优策略，所有人的这些策略组合成一个策略组合，在这个策略组合里，没有人会主动改变自己的策略，那样会降低他的收益，只要没有人做出策略调整，任何一个理性的参与者都不会主动改变自己的策略，这个时候，所有参与者的策略并达到了一种平衡，这种平衡就是”纳什均衡”<br>严谨的”纳什均衡”定义为：<br>在博弈\(G=\{S_1,\cdots,\cdots,S_n: u_1,\cdots,\cdots,u_n\}\)中，如果由各个博弈方的各一个策略组成的某个策略组合\(s_1^{*},\ldots,\ldots,s_n^{*}\)中，任一博弈方的策论\(s_i^{*}\)都是对其余博弈方策略的组合\(s_1^{*},\ldots,s_{i-1}^{*},s_{i+1}^{*},\ldots,s_n^{*}\)的最佳对策，也即\(<br>u_i(s_1^{*},\ldots,s_{i-1}^{*},s_i^{*},s_{i+1}^{*},\ldots,s_n^{*}) \geq<br>u_i(s_1^{*},\ldots,s_{i-1}^{*},s_{ij}^{*},s_{i+1}^{*},\ldots,s_n^{*})<br>\)对任意\(s_{ij}\in S_i\)都成立，则称\(s_1^{*},\ldots,\ldots,s_n^{*}\)为G的一个“纳什均衡”</p>
<h3 id="4-夏普里值方法"><a href="#4-夏普里值方法" class="headerlink" title="4. 夏普里值方法"></a>4. 夏普里值方法</h3><p>夏普里值方法以每个局中人对联盟边际贡献大小来分配联盟的总收益，它的目标是构造一种综合考虑冲突各方要求的折中的效用分配方案，从而保证分配的公平性<br>用夏普里值方法解决合作利益分配问题时，需要满足以下两个条件:</p>
<ul>
<li>局中人之间地位平等</li>
<li>所有局中人得到的利益之和是联盟的总财富</li>
</ul>
]]></content>
      <categories>
        <category>science</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>game theory</tag>
      </tags>
  </entry>
  <entry>
    <title>HLA 入门一</title>
    <url>/2016/04/09/hla01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-What-is-hla"><a href="#1-What-is-hla" class="headerlink" title="1. What is hla?"></a>1. What is hla?</h3><p>HLA 即 High Level A rchitecture</p>
<a id="more"></a>
<h3 id="2-Why-do-we-use-it"><a href="#2-Why-do-we-use-it" class="headerlink" title="2. Why do we use it?"></a>2. Why do we use it?</h3><h3 id="3-About-pitch"><a href="#3-About-pitch" class="headerlink" title="3. About pitch"></a>3. About pitch</h3>]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>distributed simulation</tag>
        <tag>hla</tag>
        <tag>pitch rti</tag>
      </tags>
  </entry>
  <entry>
    <title>HLA 入门三</title>
    <url>/2016/05/28/hla03/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h3><p>在创建新的联邦时, 将Thesis.xml换成了Test.xml去create, 但CRC端实际显示的还是Thesis.xml, 以为是前端问题或是后端创建时传参问题, 检查没有发现错误</p>
<a id="more"></a>
<h3 id="2-解决"><a href="#2-解决" class="headerlink" title="2. 解决"></a>2. 解决</h3><p>在CRC服务器上关闭了Pitch RTI, 重新打开, 新创建的联邦显示的FOM就是Test.xml了。。。</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>distributed simulation</tag>
        <tag>hla</tag>
        <tag>pitch rti</tag>
      </tags>
  </entry>
  <entry>
    <title>Graph DFS</title>
    <url>/2015/11/19/graph/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="dfs添加顶点到集合"><a href="#dfs添加顶点到集合" class="headerlink" title="dfs添加顶点到集合"></a>dfs添加顶点到集合</h3><p>在调用dfs的过程中，有四种添加顶点到集合的顺序：</p>
<ul>
<li>Pre-Order，在递归调用dfs之前将当前顶点添加到queue中</li>
<li>Reverse Pre-Order，在递归调用dfs之前将当前顶点添加到stack中</li>
<li>Post-Order，在递归调用dfs之后将当前顶点添加到queue中</li>
<li>Reverse Post-Order，在递归调用dfs之后将当前顶点添加到stack中</li>
</ul>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title>HLA 入门二</title>
    <url>/2016/04/11/hla02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-RTI中time-management相关问题"><a href="#1-RTI中time-management相关问题" class="headerlink" title="1. RTI中time management相关问题"></a>1. RTI中time management相关问题</h3><h4 id="1-1-在创建Federate之后如何修改其时间控制策略"><a href="#1-1-在创建Federate之后如何修改其时间控制策略" class="headerlink" title="1.1 在创建Federate之后如何修改其时间控制策略"></a>1.1 在创建Federate之后如何修改其时间控制策略</h4><p>想要在创建Federate后改变其时间控制策略, 且同时修改其前瞻量, 这时会出现相关问题, 当然, 我们先假设三个Federate, A、B、C初始都是Regulating状态, 且A前瞻量2, 步长2, 当前时间为20, B前瞻量4, 步长4, 当前时间60, C前瞻量5, 步长5, 当前时间100<a id="more"></a></p>
<ul>
<li>先修改C为 Regulating and Constrained, 这时若先<code>rtiAmbassador.enableTimeRegulation(lookahead);</code>会<code>throw</code>一个<code>TimeRegulationAlreadyEnabled</code>的异常, 若我们捕获它并在<code>catch</code>中<code>rtiAmbassador.disableTimeRegulation(); rtiAmbassador.enableTimeRegulation(lookahead);</code>, 看似并没有什么问题。于是接下来执行<code>rtiAmbassador.enableTimeConstrained();</code>, 此时查看Pitch pRti的界面发现A的Constrained也没有启用, 看上去不知解决, 其实这时Constrained处于pending状态, 没有什么影响, 后续再说</li>
<li>再修改B为 Regulating and Constrained, 同上操作, 执行到<code>rtiAmbassador.disableTimeRegulation();</code>这句时, 观察Pitch pRti的时间管理界面发现其GALT增大为B的当前时间加其前瞻量, 即100+5, 之后抛出的异常也都相同, 不赘述</li>
<li>最后修改A为 Regulating and Constrained, 开始同上, 之后执行<code>rtiAmbassador.enableTimeRegulation(lookahead);</code>, 发现A的当前时间突然跳到了64, 这不是希望的结果, Orz… 这时我们如果我们观察B, 会发现其启用了constrained, 所以说<code>ConstrainedPending</code>状态不需要关心, 只是因为有其他Regulating状态的Federate限制了而已, 当其推进超过自己的当前时间即可, 回到A, 继续执行<code>rtiAmbassador.enableTimeConstrained();</code></li>
<li>这样虽然最后可以将所有Federate都改为 Regulating and Constrained 状态, 但是过程不是我们想要的结果</li>
<li>所以我们修改lookahead时不能先disable再enable, 那怎么解决这个问题? 很简单、、、查一下发现rtiAmbassador有<code>modifyLookahead(lookahead);</code>这个方法, 用它代替就好啦</li>
</ul>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>distributed simulation</tag>
        <tag>hla</tag>
        <tag>pitch rti</tag>
        <tag>time management</tag>
      </tags>
  </entry>
  <entry>
    <title>数学趣话一</title>
    <url>/2016/03/25/interestingMath01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>读过不少数学趣闻, 未成体系, 记录下来仅供娱乐</p>
<h3 id="2-秒差距-Parsec-pc"><a href="#2-秒差距-Parsec-pc" class="headerlink" title="2. 秒差距(Parsec,pc)"></a>2. 秒差距(Parsec,pc)</h3><p>和光年一样, 是一种长度单位, 不过更大, 1pc=3.26ly, 天文学这些单位也是奇怪。<a href="https://en.wikipedia.org/wiki/Parsec" target="_blank" rel="noopener">Wiki</a></p>
<a id="more"></a>
<h3 id="3-不老蠕虫爬长绳"><a href="#3-不老蠕虫爬长绳" class="headerlink" title="3. 不老蠕虫爬长绳"></a>3. 不老蠕虫爬长绳</h3><p>假设一条蠕虫，以1cm/s的速度在一根长1m的橡皮绳上从一端爬向另一端。每当蠕虫爬完1cm，橡皮绳就瞬间伸长1m。<br>如果橡皮绳可以无限伸长，蠕虫也“长生不老”，试问：蠕虫能爬到绳子的另一端吗？<br>乍一想，这蠕虫似乎永远也爬不到绳子的另一端，因为橡皮绳增长的速度远大于蠕虫爬行的速度。不过我们还是先别下结论，算算再说。<br>首先，橡皮绳每秒钟伸长1m，这种伸长是均匀的，而绳子伸长时，虫子爬过的那段也随之伸长。这样：<br>第一秒末，绳子长1m，蠕虫爬1cm即绳长的1/100<br>第一秒末，绳子长2m，蠕虫在这一秒又爬1cm即绳长的1/200，当然此时第一秒蠕虫爬的长度也随之变长，而且它所占绳子的比例1/100不变<br>……<br>类似，蠕虫在第n秒爬了绳子长度的1/(100n)<br>于是，前n秒内蠕虫总共爬了绳子长的<br>$$\frac{1}{100}+\frac{1}{200}+\cdots+\frac{1}{100n}=\frac{1}{100}(1+\frac{1}{2}+\cdots+\frac{1}{n})$$<br>显然，如果蠕虫爬的长度\(l_n \geq 1\)，那就说明蠕虫已经爬到了绳子的另一端。由于调和级数是发散的，所以其大于100是有可能的。<br>一位学者经过计算，得到n在\(2^{143}\sim 2^{144}\)秒之间的结果，当然这是个天文数字，但蠕虫是“长生不老”的<br>另一位学者将调和级数变成：<br>$$<br>\begin{equation}<br>\begin{split}<br>1+\frac{1}{2}+\frac{1}{3}+\cdots+\frac{1}{2^k} &amp;= (1+\frac{1}{2})+(\frac{1}{3}+\frac{1}{4})+(\frac{1}{5}+\frac{1}{6}+\frac{1}{7}+\frac{1}{8})+\cdots+(\frac{1}{2^{k-1}+1}+\frac{1}{2^{k-1}+2}+\cdots+\frac{1}{2^k}) \\<br>&amp;&gt; (1+\frac{1}{2}) + (\frac{1}{4}+\frac{1}{4}) + (\frac{1}{8}+\frac{1}{8}+\frac{1}{8}+\frac{1}{8}) + \cdots + \left(\frac{1}{2^k}+\frac{1}{2^k}+\cdots+\frac{1}{2^k}\right) \\<br>&amp;= 1+\left(\frac{1}{2}+\frac{1}{2}+\cdots+\frac{1}{2}\right)<br>\end{split}<br>\nonumber<br>\end{equation}<br>$$</p>
<h3 id="4-超越数-Transcendental-number"><a href="#4-超越数-Transcendental-number" class="headerlink" title="4. 超越数(Transcendental number)"></a>4. 超越数(Transcendental number)</h3><p><a href="https://en.wikipedia.org/wiki/Transcendental_number" target="_blank" rel="noopener">Wiki</a><br>In mathematics, a transcendental number is a real or complex number that is not algebraic—that is, it is not a root of a non-zero polynomial equation with rational coefficients.</p>
<h3 id="5-正态数-Normal-number"><a href="#5-正态数-Normal-number" class="headerlink" title="5. 正态数(Normal number)"></a>5. 正态数(Normal number)</h3><p><a href="https://en.wikipedia.org/wiki/Normal_number" target="_blank" rel="noopener">Wiki</a></p>
<h3 id="6-交错级数的悖论"><a href="#6-交错级数的悖论" class="headerlink" title="6. 交错级数的悖论"></a>6. 交错级数的悖论</h3><p>研究交错级数\(\sum_{i=1}^{\infty}(-1)^{i+1}a_i\)中的<br>$$\begin{equation}<br>1-1/2+1/3-1/4+1/5-1/6+1/7-1/8+\cdots=? \tag{6.1}<br>\end{equation}$$<br>正确答案不难找到：结果是\(\ln 2\)<br>把\(1-1/2+1/3-1/4+1/5-1/6+1/7-1/8+\cdots=\ln 2\)两边乘以1/2，就得到<br>$$\begin{equation}<br>1/2-1/4+1/6-1/8+1/10-1/12+1/14-1/16+\cdots=(\ln 2)/2 \tag{6.2}<br>\end{equation}$$<br>把6.1和6.2两边分别相加就得到<br>$$\begin{equation}<br>1/1+1/3-1/2+1/5+1/7-1/4+1/9+1/11-1/6+\cdots=3(\ln 2)/2 \tag{6.3}<br>\end{equation}$$<br>可以看到6.3和6.1左边完全一样，只是排列顺序不同，然而6.3的值却是6.1的3/2倍，这样我们会得出3/2=1的结论<br>显然这是一个悖论，对此，美籍德国数学家柯朗在他的微积分学论文中写到：“很容易想象出，这种明显的悖论发现对18世纪的数学家带来什么样的影响，他们习惯于运算无穷级数而不考虑它们的收敛。”<br>出现这种悖论现象的原因是：级数\(1-1/2+1/3-1/4+\cdots\)之所以收敛，只是因为它的项有交替变化的正负号，因此可以部分地相互“补偿”。但是如果我们取这些项的绝对值的时候，将会得到发散的调和级数。<br>这是两类收敛收敛级数之间的一个主要区别：收敛过程与各项的正负号无关的级数——绝对收敛级数，以及收敛仅仅是因为各项的正负号交替变化的级数——条件收敛级数。<br>正是前一类级数代表了收敛的较强类型，因为在这里之所以发生收敛，是因为它的自身可足够快地逼近零。<br>微积分学已经证明，如果级数\(\sum_{i=1}^{\infty}(-1)^{i+1}a_i\)满足条件\(a_n&gt;a_{n+1}\)和\(\lim\limits_{n\rightarrow \infty}a_n=0\)，那么这个级数收敛。这就是著名的莱布尼茨判别法。<br>只有在绝对收敛级数中，各项的任意重排才不会影响它的和。这就是著名的狄利克雷定理。</p>
<h3 id="7-素数定理"><a href="#7-素数定理" class="headerlink" title="7. 素数定理"></a>7. 素数定理</h3><p>Primzahlen unter a(=∞)  a/ln(a)<br>当a趋近于无穷大时, 小于a的素数个数越来越接近于a除以ln(a)的值</p>
<h3 id="8-1-1-2"><a href="#8-1-1-2" class="headerlink" title="8. 1+1=2"></a>8. 1+1=2</h3><p>罗素和怀特海德(Bertrand Russell and Alfred North Whitehead), 在数学原理(Principia_Mathematica)一书中, 证明了为何1+1=2<br><img src="/images/interestingMath01_05.gif" alt="05"></p>
<h3 id="9-欧拉zeta-ζ-函数"><a href="#9-欧拉zeta-ζ-函数" class="headerlink" title="9. 欧拉zeta(ζ)函数"></a>9. 欧拉zeta(ζ)函数</h3><p>本质是整数级数到素数级数的一种等价方法<br>\(\zeta\)函数可以表示成将所有整数加起来恰好等于包含所有素数的项相乘所得的另一个函数<br>\(\zeta(s)=\sum \frac{1}{n^2}=\prod \frac{p^s}{p^s-1}\)<br>假设s=2，则<br>$$<br>\begin{equation}<br>\begin{split}<br>\zeta(s)&amp;=\frac{1}{1^2}+\frac{1}{2^2}+\frac{1}{3^2}+\cdots \\<br>&amp;=\frac{2^2}{2^2-1}\times\frac{3^2}{3^2-1}\times\frac{5^2}{5^2-1}\times\frac{7^2}{7^2-1}\times\cdots<br>\end{split}<br>\nonumber<br>\end{equation}<br>$$</p>
<h3 id="10-整数N的拆分方式种数"><a href="#10-整数N的拆分方式种数" class="headerlink" title="10. 整数N的拆分方式种数"></a>10. 整数N的拆分方式种数</h3><p>1 = 1                     p(1) = 1<br>2 = 2 = 1+1               p(2) = 2<br>3 = 3 = 1+2 = 1+1+1       p(3) = 3<br>对于整数n, p(n) = ?, 哈代(Godfrey Harold)和拉马努金(Srinivasa Ramanujan)在某论文中得出了其公式:<br>$$\frac{1}{2\sqrt{2}}\sum_{q=1}^{\nu} \sqrt{q}A_q(n)\varphi_q(n)$$<br>其中\(A_q(n)=\sum\omega_{p,q}\exp(-2np\pi i/q)\)，和是对p来求的，p与q互素且小于q，\(\omega_{p,q}\)是1的某个24q次方根，\(\nu\)具有\(\sqrt{n}\)的阶数<br>$$\varphi_q(n)=\frac{d}{dn}\left(\exp\left(C\sqrt{n-\frac{1}{24}}/q\right)\right),C=\pi \sqrt{\frac{2}{3}}$$</p>
<p>关于1的n次方根其实是有n个不同的值的, 这个需要考虑到复数</p>
<h3 id="11-黎曼zeta-ζ-函数"><a href="#11-黎曼zeta-ζ-函数" class="headerlink" title="11. 黎曼zeta(ζ)函数"></a>11. 黎曼zeta(ζ)函数</h3><p>用复数代替欧拉\(\zeta\)函数中的指数s, 即可得到黎曼\(\zeta\)函数:<br>$$\zeta(s)=\sum\frac{1}{n^s}=1+\frac{1}{2^{(a+ib)}}+\frac{1}{3^{(a+ib)}}+\frac{1}{4^{(a+ib)}}+\cdots$$</p>
<p>对于某些s, 该函数值为0, 如s = 1/2 + 14.135i, 1/2 + 21.022i</p>
<h3 id="12-100-不是全部"><a href="#12-100-不是全部" class="headerlink" title="12. 100%不是全部"></a>12. 100%不是全部</h3><p>正如0%不是没有, 有理数占实数比重可以说是 0%, 但是你不能够说没有有理数。<br>所以即时1985年证明了费马大定理对于100%的指数都成立, 但是不能说对于所有的指数</p>
<h3 id="13-复数的对数没有确定的值"><a href="#13-复数的对数没有确定的值" class="headerlink" title="13. 复数的对数没有确定的值"></a>13. 复数的对数没有确定的值</h3><p>思考一下欧拉公式, 很容易得出结论</p>
]]></content>
      <categories>
        <category>science</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>数学趣话二</title>
    <url>/2016/04/16/interestingMath02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-数学符号"><a href="#1-数学符号" class="headerlink" title="1. 数学符号"></a>1. 数学符号</h3><p>Wiki上有所有数学符号的一个<a href="https://en.wikipedia.org/wiki/List_of_mathematical_symbols" target="_blank" rel="noopener">list</a>, 点击每个数学符号link可以查看其具体内容, 然而Kino只是想看一下其Unicode值</p>
<a id="more"></a>
<h3 id="2-分形理论"><a href="#2-分形理论" class="headerlink" title="2. 分形理论"></a>2. 分形理论</h3><p>Benoit Mandelbrot 创立了 分形理论(fractal theory), 基础是分形几何(fractal geometry)</p>
]]></content>
      <categories>
        <category>science</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>民生银行2015笔试</title>
    <url>/2015/05/15/interview01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>看到群里说有民生银行的内推, 直接去笔试面试即可, 就想着还没有正式去找过工作实习, 权当锻炼自己</p>
<a id="more"></a>
<h3 id="2-笔试"><a href="#2-笔试" class="headerlink" title="2. 笔试"></a>2. 笔试</h3><p>做完后告诉我们是去年的试题、、</p>
<h4 id="2-1-选择题"><a href="#2-1-选择题" class="headerlink" title="2.1 选择题"></a>2.1 选择题</h4><p>选择题还是很基础的一些题型，感觉就是计院的期末考题(非计算机专业的胡乱猜测)，有算法时间复杂度的，二叉树的各类遍历，Http状态码、数据库的操作语句，简单的加密解密方法、</p>
<h4 id="2-2-编程题"><a href="#2-2-编程题" class="headerlink" title="2.2 编程题"></a>2.2 编程题</h4><ul>
<li>第一题应该是最简单的，当然是对其他人而言，考的是数据库的操作，我只会最基本的SELECT语句，稍微复杂点就忘了，都是现用现查，而且我也的确没系统学习过数据库, 所以直接放弃。但是其知识点还是知道的，应该就是数据库的多表连接知识</li>
<li>第二题考的是算法，很常见的一道题，但是是留到最后做的。题目就是“最大访客数”，网上搜一下都是</li>
<li>第三题是求1~n内的所有素数，主要应该考虑时间复杂度吧，这里得说下笔试要求是要写出可以编译运行的代码，也就是说得写完整了，比如Java得有的public static void main(String[] args){}，C得有main()函数，手写代码简直痛苦，怕写错对象方法名，所以默默地用C写的</li>
<li>第四题以二维码为背景，但是我觉得考察点是位操作和字符串操作。悲剧的是做完出来和别人一聊发现原来不止一小题，我输出字符串后以为没有其他题了</li>
<li>后续还有两道附加题，考的是移动端开发，IOS和Android，毕竟移动端是大势所趋。Android的还知道点，Android Service如何保证运行不被杀死，详见<a href="http://blog.csdn.net/mad1989/article/details/" target="_blank" rel="noopener">此处</a></li>
</ul>
<h3 id="3-面试"><a href="#3-面试" class="headerlink" title="3. 面试"></a>3. 面试</h3><p>本以为一上午能解决完的, 没想到等到下午再面试, 可惜下午又考试，坐地铁回还得2小时，只能遗憾地向管理人员说明情况提前离开</p>
]]></content>
      <categories>
        <category>life</category>
        <category>work</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>日语学习番外篇一</title>
    <url>/2017/09/19/japanese02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在学习<a href="http://res.wokanxing.info/jpgramma/comparison.html" target="_blank" rel="noopener">日语比较</a>相关内容时，看到了“花より団子”这句谚语，直译过来就是“与其花，不如团子”，这种生涩绕口的翻译，却瞬间让Kino想起了一个朋友的签名：“比起花，还是青春”，她曾告诉过Kino这是她在某部韩剧里看到的，但是韩剧名我却已经忘了，也不想再去追问。<br>不过还是无意识地点开了一个又一个搜索结果，漫无目的，不知道自己在想什么，却无意间发现了“花より男子”这部漫画，漫画名应该就是套用的“花より団子”，而这部漫画又先后被日本和韩国改编成电视剧“花样男子”，也许，她所说的“比起花，还是青春”正是来自“花样男子”这部剧吧。<br>这样想着，好像就回忆起来当初被告知的那部剧就是“花样男子”一样，不过这些记忆已经变得不真切了，连Kino自己都不敢相信，没必要记住的事就随风散了也挺好<br>说到随风散去，又想起某个盆友说过很喜欢”Gone with the wind”、、、（Kino内心戏太足了、、）</p>
<p>好吧，其实就是因此突然生出一个想法，以此文记录一些日本谚语、作家作品里的名句、喜欢的歌词、动画里的戳中自己的句子，如此种种，并对其语法结构进行分析，也许还会有感而发写些不成熟的想法，也都算作学习的一环吧。</p>
<a id="more"></a>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ol>
<li><p>花より団子</p>
<blockquote>
<p>这里的语法主要体现在助词より上，其用于比较，意义是“比，较之，甚于”<br>AよりB（のほうがC）：比起A，B更C。其中C是动词形容词等<br>由于日语语序的灵活性，也可以写成：（Bのほうが）AよりC</p>
</blockquote>
</li>
<li><p>生まれて,すみません</p>
<blockquote>
<p>[生まれて]是[生まれる]的过去形式，因为诞生是过去的动作<br>[すみません]很常见，就是”抱歉了”<br>太宰治这句著名的话通常翻译成”生而为人, 我很抱歉”, 直译起来其实就是”出生到这个世界, 抱歉了”</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>humanities</category>
        <category>languages</category>
      </categories>
      <tags>
        <tag>japanese</tag>
      </tags>
  </entry>
  <entry>
    <title>日语学习五</title>
    <url>/2018/06/03/japanese06/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇叙述了日语中的体，这篇文章Kino将讲解日语中的态。<br>语态指在动词做述语的句子中，述语动词和主语的关系，即主语所表示的人物、事物是述语动词所表示的动作、作用的执行者还是承受者，是促进动作进行的人还是具备能力进行动作的人。<br>通常认为日语有五种语态, 不过这五种本身是建立在无任何变形的基本语态的基础上, 这种基本语态当然也得算作语态的一种, 可以被称为: 能动态/主动态.</p>
<a id="more"></a>
<h2 id="1-主动态"><a href="#1-主动态" class="headerlink" title="1. 主动态"></a>1. 主动态</h2><p>从施动者的角度叙述其动作、作用时，使用主动语态。述语动词就是基本形式即可。</p>
<h2 id="2-被动态"><a href="#2-被动态" class="headerlink" title="2. 被动态"></a>2. 被动态</h2><p>被动态表示主语是动作的承受者。从动作承受者的角度，叙述其受到、遭受的动作、作用时，使用被动语态。<br>被动态由述语动词后续助动词「(ら)れる」构成，不同类型的动词构成方式不同，具体为:</p>
<ul>
<li>五段动词的未然形+れる</li>
<li>一段动词的未然形+られる</li>
<li>する的被动态: せられる，约音形: される</li>
<li>くる的被动态: こられる</li>
</ul>
<p>示例:</p>
<ul>
<li>Eg. 学生は先生に褒められた</li>
<li>Eg. 雨に降られて、風邪を引いた</li>
</ul>
<h2 id="3-使役态"><a href="#3-使役态" class="headerlink" title="3. 使役态"></a>3. 使役态</h2><p>当叙述某个人引起了某个事态或强制、支使、允许他人进行了某个动作时，使用使役态。<br>使役态由述语动词后续助动词「(さ)せる」构成，不同类型的动词构成方式也不同，具体为:</p>
<ul>
<li>五段动词的未然形+せる</li>
<li>一段动词的未然形+させる</li>
<li>する的使役态: せさせる，约音形: させる</li>
<li>くる的使役态: こさせる</li>
</ul>
<p>示例:</p>
<ul>
<li>Eg. わたしは娘を自由に遊ばせました</li>
<li>Eg. 先生は学生に自由に意見を言わせました</li>
</ul>
<h2 id="4-被役态"><a href="#4-被役态" class="headerlink" title="4. 被役态"></a>4. 被役态</h2><p>又叫使役被动态。当叙述某个人受到别人的强迫，不得已、被迫做某事时，使用使役被动态。<br>被役态由述语动词后续助动词「(さ)せられる」构成，不同类型的动词构成方式也不同，具体为:</p>
<ul>
<li>五段动词的未然形+せられる</li>
<li>一段动词的未然形+させられる</li>
<li>する的被役态: させられる</li>
<li>くる的被役态: こさせられる</li>
</ul>
<p>示例:</p>
<ul>
<li>Eg. 私は母に宿題をさせられます</li>
</ul>
<h2 id="5-可能态"><a href="#5-可能态" class="headerlink" title="5. 可能态"></a>5. 可能态</h2><p>当叙述某人具有某种能力、技能或某事具有发生的条件、可能性时，使用可能态。可能态的构成方式比较多，主要有以下五种。</p>
<h3 id="5-1-使用可能助动词"><a href="#5-1-使用可能助动词" class="headerlink" title="5.1 使用可能助动词"></a>5.1 使用可能助动词</h3><p>在述语动词后面接续可能助动词「(ら)れる」，不同类型的动词接续方式也不同，具体为:</p>
<ul>
<li>五段动词的未然形+れる</li>
<li>一段动词的未然形+られる</li>
<li>くる的可能态: こられる<h3 id="5-2-使用可能动词"><a href="#5-2-使用可能动词" class="headerlink" title="5.2 使用可能动词"></a>5.2 使用可能动词</h3>把五段动词变成对应行的下一段动词，例如把「歩く」变成「歩ける」，把「読む」变成「読める」等。五段动词在实际的使用中多使用其对应的可能动词，而不是后续可能助动词。<h3 id="5-3-使用「できる」"><a href="#5-3-使用「できる」" class="headerlink" title="5.3 使用「できる」"></a>5.3 使用「できる」</h3>包括以下三种情况:</li>
<li>「する」变为「できる」，「~する」变为「~できる」</li>
<li>名词+ができる</li>
<li>动词原形+ことができる<h3 id="5-4-使用带有可能意义的自动词"><a href="#5-4-使用带有可能意义的自动词" class="headerlink" title="5.4 使用带有可能意义的自动词"></a>5.4 使用带有可能意义的自动词</h3>「分かる」「見える」「聞こえる」等动词本身带有可能的意义，不需要形式变化。<h3 id="5-5-使用接尾动词「うる」"><a href="#5-5-使用接尾动词「うる」" class="headerlink" title="5.5 使用接尾动词「うる」"></a>5.5 使用接尾动词「うる」</h3>在动词的连用形后面接续接尾词「うる」，如「考えうる」「ありうる」等。</li>
</ul>
<h2 id="6-自发态"><a href="#6-自发态" class="headerlink" title="6. 自发态"></a>6. 自发态</h2><p>当叙述动作自然发生或感情不可抑制时，使用自发态。<br>自发态的构成方式有三种。</p>
<h3 id="6-1-使用自发助动词"><a href="#6-1-使用自发助动词" class="headerlink" title="6.1 使用自发助动词"></a>6.1 使用自发助动词</h3><p>在表示感情、思想活动的述语动词后面接续自发助动词「(ら)れる」，不同类型的动词接续方式也不同，具体有:</p>
<ul>
<li>五段动词的未然形+れる</li>
<li>一段动词的未然形+られる</li>
<li>する的被动态: せられる，约音形: される<h3 id="6-2-使用可能动词"><a href="#6-2-使用可能动词" class="headerlink" title="6.2 使用可能动词"></a>6.2 使用可能动词</h3>「泣ける」「笑える」「思える」等<h3 id="6-3-使用带有可能意义的自动词"><a href="#6-3-使用带有可能意义的自动词" class="headerlink" title="6.3 使用带有可能意义的自动词"></a>6.3 使用带有可能意义的自动词</h3>「見える」「聞こえる」等</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文的例句选自日语五种语态、わかって使える日本語等文献.<br>这篇文章主要介绍了日语的语态，可以看出这六种语态在语法上并不完全是平行的，如果从平行关系来考虑，Kino认为可以这样划分:</p>
<ul>
<li>主动、被动、自发态三种在一个层级</li>
<li>使役态单独一个层级</li>
<li>可能态单独一个层级</li>
</ul>
<p>只从语法的构成可能性上来说，这三种是可以自由组合的，比如被动使役态、被动可能态、自发使役态、自发可能态，只不过由于日语的语言习惯以及现实世界的因果关系等限制，最终实际能够组合的就是被动使役态.<br>下一篇文章将介绍日语的语气。</p>
<h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><p> yueaegis9. “日语五种语态” 百度文库, 13 Jan 2011, <a href="https://wenku.baidu.com/view/ff190636ee06eff9aef807e5.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/ff190636ee06eff9aef807e5.html</a>.<br> 名古屋YWCA教材作成グループ. わかって使える日本語―中級レベル[M]. スリーエーネットワーク, 2004. </p>
]]></content>
      <categories>
        <category>humanities</category>
        <category>languages</category>
      </categories>
      <tags>
        <tag>japanese</tag>
      </tags>
  </entry>
  <entry>
    <title>日语学习四</title>
    <url>/2018/06/02/japanese05/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="/2018/06/01/japanese04/">上一篇文章</a>介绍了极性和时轴，这一章主要介绍体的相关语法，体的概念在<a href="/2017/09/16/japanese01/#2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">第一篇文章</a>里已经介绍过，此处再介绍一遍: 体表示某个动作或变化在<strong>说话人所设的时间轴</strong>上处于开始、持续和完成状态中的某一阶段，是从时间角度上对动作和变化的描写或把握。<strong>需要注意的是在日语中体仅仅反映在动词上</strong><br>PS: 日语语法在”体”这方面的变化并不是那么明显, 虽然语法概念上可以分很细, 但实际需要进行特殊的变形转换的并不多, 更多的是靠上下文的时间轴来界定”体”的状态.</p>
<a id="more"></a>
<h2 id="1-完整体（完成相）"><a href="#1-完整体（完成相）" class="headerlink" title="1. 完整体（完成相）"></a>1. 完整体（完成相）</h2><p>完整体用以整体来描述某个动作或变化，把动词表示的运动从开始到结束的整个过程完整地表达出来，一般不涉及该动作或变化的中间过程。根据涉及的动作是出于“完了”这一界限达成前还是达成后，完整体被分为未成体和完成体两种。</p>
<h3 id="1-1-未成体"><a href="#1-1-未成体" class="headerlink" title="1.1 未成体"></a>1.1 未成体</h3><p>表示动作即将完成或者将来完成。动词不用做变化。</p>
<ul>
<li>Eg. いま、新聞を読む</li>
<li>Eg. 明日、新聞を読む<h3 id="1-2-完成体"><a href="#1-2-完成体" class="headerlink" title="1.2 完成体"></a>1.2 完成体</h3>表示动作的完成，但是并不是一定过去时，整个行为可能发生在未来或是一个经常性的动作，只要在说话人设定的时间轴上是完成的动作即可。动词的变化规则和过去时相同。</li>
<li>Eg. 今朝、新聞を読んだ</li>
<li>Eg. 今朝、新聞を読んだ後に散歩に出かける</li>
</ul>
<h2 id="2-过程体（継続相）"><a href="#2-过程体（継続相）" class="headerlink" title="2. 过程体（継続相）"></a>2. 过程体（継続相）</h2><p>过程体用以描述动作或变化的各个环节，是把这种运动持续过程中的某一个局部表达出来。<br>参考Wasabi网站上的这篇文章, 即一个动作的开始、现在和结束的阶段.</p>
<h3 id="2-1-备放体（準備相）"><a href="#2-1-备放体（準備相）" class="headerlink" title="2.1 备放体（準備相）"></a>2.1 备放体（準備相）</h3><p>表示该动作是为下一步做准备的。表现形式有: <strong>一型词根+「ておく」</strong>。其中的动词必须是意志动词。</p>
<ul>
<li>Eg. 明日お客さんが来ますから、お菓子をかっておいてください<h3 id="2-2-即将体"><a href="#2-2-即将体" class="headerlink" title="2.2 即将体"></a>2.2 即将体</h3>表示动作、行为、作用等就要发生。表现形式有: 「ようとしている」「ところだ」「しそうだ」「ばかりになっている」「かかる」「かける」<h3 id="2-3-起始体"><a href="#2-3-起始体" class="headerlink" title="2.3 起始体"></a>2.3 起始体</h3>表示动作、行为、作用的开始。表现形式多为复合动词，如「始める」「出す」「かける」等，和「てくる」<h3 id="2-4-持续体"><a href="#2-4-持续体" class="headerlink" title="2.4 持续体"></a>2.4 持续体</h3>表示动作、行为正在进行或者反复进行，要求动词是一种持续性动词。表现形式很多，有: 「ている」「てくる」「ていく」「ているところだ」「つづく」「つづける」「つづある」「一方だ」「ている最中だ」「中」，相当于汉语的“正在…”、“持续…”、“持续…”</li>
<li>Eg. 日本語を勉強している</li>
<li>Eg. 森さんが一人で歩いている<h3 id="2-5-完结体"><a href="#2-5-完结体" class="headerlink" title="2.5 完结体"></a>2.5 完结体</h3>表示动作、行为的完成、结束。表现形式多为复合动词，如「終わる」「あがる」「あげる」「尽くす」「切る」「通す」「ぬく」等，和「てしまう」<h3 id="2-6-存续体"><a href="#2-6-存续体" class="headerlink" title="2.6 存续体"></a>2.6 存续体</h3>表示动作或作用完成后的状态的存续。表现形式有: 「ている」「てある」「(ら)れている」「たところだ」「たばかりだ」等，相当于汉语的“…了”、“…着”</li>
</ul>
<h2 id="3-特殊体"><a href="#3-特殊体" class="headerlink" title="3. 特殊体"></a>3. 特殊体</h2><h3 id="3-1-完成体的进行意义"><a href="#3-1-完成体的进行意义" class="headerlink" title="3.1 完成体的进行意义"></a>3.1 完成体的进行意义</h3><p>有些动词虽然是“完成体”的形态，但并不表示“完成体”的基本意义，而是表达行进过程中的状态。<br>「いく」「くる」以及类似它们的「むかい」「おく」之类的移动动词，以「していく」「している」的形式出现的动词，以及被「どんどん」「ぐんぐん」等行进性的副词修饰限定的变化动词等属于此类。</p>
<h3 id="3-2-完成体与持续体相同意义的情况"><a href="#3-2-完成体与持续体相同意义的情况" class="headerlink" title="3.2 完成体与持续体相同意义的情况"></a>3.2 完成体与持续体相同意义的情况</h3><p>表状态时“完成体”和“持续体”两者表达同样事物，“体”未实现其分化。主要有以下两类:</p>
<ul>
<li>表说话人以感官感觉到的状态性现象</li>
<li>表存在</li>
</ul>
<h3 id="3-3-整体性无法识别的情况"><a href="#3-3-整体性无法识别的情况" class="headerlink" title="3.3 整体性无法识别的情况"></a>3.3 整体性无法识别的情况</h3><p>在表示说话人内心活动时，是否是整体性处置的状态看不出来。主要有以下两类:</p>
<ul>
<li>表说话人的考虑和想法</li>
<li>表说话人的感觉</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>撰写本文前主要看了以下书籍和文章: 日语语法专题教程<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.
">[1]</span></a></sup>, Japanese Aspect: the Beginning, Middle, &amp; End of Actions, “浅析日语复句中的“时”和“体”, “日语动词的“体”特征分类”, Are Japanese ‘Tenses’ Aspects in Disguise?, 【中级日语】日语的时态和体，ル形、タ形和ている形的区别<br>Kino觉得，体的概念在日语中的确存在，但是并不是那么有规律，记住「ている」这种较为常见的用法即可，剩下的主要是能够理解句子的状态。<br>本篇文章主要叙述了体的概念，下一篇将讲解日语中的态。</p>
<h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><p> Admin, Wasabi. “Japanese Aspect: the Beginning, Middle, &amp; End of Actions.” 20 Aug. 2016, <a href="https://www.wasabi-jpn.com/japanese-grammar/japanese-aspect-the-beginning-middle-end-of-actions/" target="_blank" rel="noopener">https://www.wasabi-jpn.com/japanese-grammar/japanese-aspect-the-beginning-middle-end-of-actions/</a>.<br> 辛宇峰. “浅析日语复句中的“时”和“体”.” 长沙铁道学院学报:社会科学版 4(2014):54-55.<br> 孙敦夫. “日语动词的“体”特征分类” 外语教学 2(2008):39-42.<br> SweeperSweeper 2, et al. “Are Japanese ‘Tenses’ Aspects in Disguise?” Japanese Language Stack Exchange, 29 Jan. 2017, <a href="https://japanese.stackexchange.com/questions/42988/are-japanese-tenses-aspects-in-disguise" target="_blank" rel="noopener">https://japanese.stackexchange.com/questions/42988/are-japanese-tenses-aspects-in-disguise</a>.<br> 日本狸猫田中裕之. “【中级日语】日语的时态和体，ル形、タ形和ている形的区别.” 知乎专栏, 4 June 2019, <a href="https://zhuanlan.zhihu.com/p/67847551" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/67847551</a>.<div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)">马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.<a href="#fnref:1" rev="footnote"> ↩</a></span></div></div></div></p>
]]></content>
      <categories>
        <category>humanities</category>
        <category>languages</category>
      </categories>
      <tags>
        <tag>japanese</tag>
      </tags>
  </entry>
  <entry>
    <title>日语学习九</title>
    <url>/2020/05/02/japanese10/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>距离上一次写日语学习系列已经快两年了，这两年间日语水平并没有什么长进，甚至还在倒退，但却总有一个心结，想要将这个系列完成。<br>好了，话不多说，其实之前的文章内容已经基本涵盖了日语基础语法的各个方面，而这篇文章打算说说日语中一个句子的分析和改造顺序，也算是对前面内容的一个总结。<br>日语的变形，主要体现在用言(动词/形容词/形容动词)、助动词上，这其中又属动词最为复杂。</p>
<a id="more"></a>
<h2 id="1-分析顺序"><a href="#1-分析顺序" class="headerlink" title="1. 分析顺序"></a>1. 分析顺序</h2><h3 id="1-1-说明"><a href="#1-1-说明" class="headerlink" title="1.1 说明"></a>1.1 说明</h3><p>给出一句日语，我们如何分析它用了哪些语法结构呢？</p>
<ol>
<li>如果这个句子是由多个句子复合而成的句子，首先将句子拆分，按照2至6的步骤分析单个从句，分析完从句后，将从句看作整个句子的一个成分，用符号代替，再按照2至6的步骤分析主句。需要注意的是，语气和敬意通常都是在主句中表达的，所以从句也不太可能需要分析2和3，还有一点是，如果从句本身是经过活用变形的(如假定型的活用)，先将这种变形去除.</li>
<li>在讲解语气的文章中提到了语气的种种分类，但实际中，语气大多还是通过特定词语、附加助词和语调的变化来表达的，因此即使一个句子用到了特定的语气，也不会在句子形式上有大的变化，最常见的也只是添加了句尾助词，可以先将助词去掉，简化句子，再做分析.</li>
<li>之后我们需要区分的是这句话是否是敬语形式，敬语的形式很容易看出来，因此如果用了敬语，那么先将这个句子还原为普通形式.</li>
<li>在还原为普通形式后，可以继续分析该句是否用到了特殊的”体”，如「ている」这种表示持续体的特殊形式，如果有的话，将特殊的”体”去掉，再次简化句子.</li>
<li>已经去掉了”体”的变形，之后就是分析简化的句子中，是否还用到了特殊的语态，如果用到了语态，就将其变化形式还原.</li>
<li>经过以上还原后，剩下的句子就只剩下时和极性的变形了，而时和极性我们通常都是放在一起记忆的，所以也可以一次性将其还原为基本型. 如果硬要分一个顺序，应该是先还原时，再还原极性.</li>
</ol>
<h3 id="1-2-示例"><a href="#1-2-示例" class="headerlink" title="1.2 示例"></a>1.2 示例</h3><p>写了这么多，给出几个句子我们分析一下。</p>
<ol>
<li><p>人は褒められれば嬉しいものなのです<br>这个句子首先是一个复合句，那么先分析从句: 「人は褒められれば」<br>由于用了假定型，将其还原为 「人は褒められる」<br>可以看出现在这种形式，是用了被动态的，将其还原为「人は褒める」<br>这样从句就分析完毕了，接着分析主句「嬉しいものなのです」<br>可以看出主句只用了敬语的一种比较特殊的形式「な+のです」，直接简化为「嬉しいものだ」</p>
</li>
<li><p>勉強をさせられている生徒に教えることは、ザルに水を注ぎ続けるようなもの！<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="“消えた記事？　「勉強する」「させられる」.” 勉強が楽しくなる塾, 5 June 2015, https://shou3.ti-da.net/e7625869.html.">[1]</span></a></sup><br>这个句子也是一个复句，可以当作包孕句处理吧。<br>首先分析前半句，「勉強をさせられている生徒に教えることは」，<br>去掉从句的连接词，句子可以简化为「勉強をさせられている生徒に教える」.<br>而这个从句中还有一个定语从句「勉強をさせられている」，这个句子用了「ている」的”体”表示一种持续的状态，简化后变为「勉強をさせられる」<br>而「勉強をさせられる」又是典型的被役态，还原成最基本的形式就是「勉強をする」<br>这样就可以理解前半句的意思了: “教一直被逼着学习的学生这种事”.<br>再分析后半句，「ザルに水を注ぎ続けるようなもの」，后半句没有用到特殊的变形，只是用了「ようなもの」这种惯用语，表示”像xx一样”</p>
</li>
</ol>
<h2 id="2-改造顺序"><a href="#2-改造顺序" class="headerlink" title="2. 改造顺序"></a>2. 改造顺序</h2><h3 id="2-1-说明"><a href="#2-1-说明" class="headerlink" title="2.1 说明"></a>2.1 说明</h3><p>给定一个句子，如何去分析已经了解了。那在实际语境下，假设我们从最基础的形式出发，需要以什么样的顺序来对这个句子进行变形，从而达到我们想要表达的意思呢？ 其实就是把分析的过程倒过来就行.</p>
<ol>
<li>先明确句子的极性和时</li>
<li>再思考这句话的主体、情态，是否需要用到特殊的语态</li>
<li>考虑语境下是否有特殊的时间状态，即是否要用到体的变形</li>
<li>是否需要用敬体，如果需要用敬体的时和体替换原有的时和体</li>
<li>如果需要特殊语气，就通过助词和语调调整</li>
<li>单句无法表达时，通过组合句子来表达</li>
</ol>
<h3 id="2-2-示例"><a href="#2-2-示例" class="headerlink" title="2.2 示例"></a>2.2 示例</h3><p>平时在看剧时，多分析看到的复杂句是怎么构成的，如果是自己来表达同样的意思，会怎么表达，这样就好啦，具体的示例就不给了，意义也不大~</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分析的目的，和语文、英语的拆解句子结构一样，就是熟悉语法。<br>改造的目的，和语文、英语中的造句一样，就是正确熟练地表达。<br>等到不拘于此，不再需要思考如何去理解、如何去说，直接就能阅读和表达时，也就是真正掌握日语语法的时候.<br>本篇文章主要总结了日语中句子的分析和改造顺序，下一篇将介绍日语中的一些实用表达。</p>
<h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)">“消えた記事？　「勉強する」「させられる」.” 勉強が楽しくなる塾, 5 June 2015, <a href="https://shou3.ti-da.net/e7625869.html" target="_blank" rel="noopener">https://shou3.ti-da.net/e7625869.html</a>.<a href="#fnref:1" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>humanities</category>
        <category>languages</category>
      </categories>
      <tags>
        <tag>japanese</tag>
      </tags>
  </entry>
  <entry>
    <title>日语学习十一</title>
    <url>/2020/05/04/japanese12/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇介绍了一些实用表达，这一篇聊几句语篇。<br>语篇是在读这本语法教程<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.
">[1]</span></a></sup>中了解到的，想想也的确有道理，学习了音素、书写，记忆了单词，学会了语法，知道如何去表达一句话，总还有比一句话更广一点的语法概念的.<br>语篇的概念在该书<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="关春园, 徐宏亮. 多元化视角下的日语研究. 新华出版社, 2015.
">[2]</span></a></sup>中也有描述:</p>
<blockquote>
<p>普通语言学认为，语言的结构单位自上而下分为五级，即: 词素、词、词组、句子以及大于句子的语言单位。语篇是大于句子的语言单位。在特定语境中，一个句子也可以视为语篇.</p>
</blockquote>
<p>专业的日语研究者想要看学术性的语篇研究，这篇”现代日语语篇研究”<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="杜静波. 现代日语语篇研究. Diss.">[3]</span></a></sup>的论文应该值得一看.</p>
<p>只不过，姑且认为语篇就是文章的一部分的话，那么分析文章、写文章的难点，其实不在于语言本身，无论是中文、英语还是日语，想要写出好文章，逻辑、思想才是最难的~</p>
<a id="more"></a>
<h2 id="1-语篇连贯"><a href="#1-语篇连贯" class="headerlink" title="1. 语篇连贯"></a>1. 语篇连贯</h2><p>语篇连贯即:</p>
<ul>
<li>语篇内部各部分在意义上是相互联系的</li>
<li>语篇的衔接形成的语义网络形成一个语义整体</li>
<li>语篇必须适合情景语境, 在语境中有适当的功能</li>
</ul>
<p>日语研究<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="关春园, 徐宏亮. 多元化视角下的日语研究. 新华出版社, 2015.
">[2]</span></a></sup>中总结出的语篇连贯概念的四个基本特点有:</p>
<ul>
<li>整体性</li>
<li>分级性</li>
<li>连接性</li>
<li>功能性</li>
</ul>
<h2 id="2-语篇内部衔接的手段"><a href="#2-语篇内部衔接的手段" class="headerlink" title="2. 语篇内部衔接的手段"></a>2. 语篇内部衔接的手段</h2><p>一般来说有: 指示与词汇衔接、预设、替代与省略、会话含义、话语分析等…<br>学术性的东西，就不搬运太多了~</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章提及了下语篇，至此，日语学习系列的主框架也就完结了。剩下的，就是练习、练习、再练习了，直到不用再思考语法这件事.</p>
<h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)">马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.<a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)">关春园, 徐宏亮. 多元化视角下的日语研究. 新华出版社, 2015.<a href="#fnref:2" rev="footnote"> ↩</a></span></div><div id="fn:3" style="display:flex"><span style="width:20px">3.</span><span style="width:calc(100% - 20px)">杜静波. 现代日语语篇研究. Diss.<a href="#fnref:3" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>humanities</category>
        <category>languages</category>
      </categories>
      <tags>
        <tag>japanese</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux琐记四</title>
    <url>/2016/04/10/linux04/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-Ubuntu-ssh-登录提示信息"><a href="#1-Ubuntu-ssh-登录提示信息" class="headerlink" title="1. Ubuntu ssh 登录提示信息"></a>1. Ubuntu ssh 登录提示信息</h3><p>修改<code>/etc/issue</code>和<code>/etc/motd</code><br>前者的内容显示在login提示符之前, 后者显示在用户成功登录系统后, 一般都是希望修改后者</p>
<h3 id="2-curl-post-json数据"><a href="#2-curl-post-json数据" class="headerlink" title="2. curl post json数据"></a>2. curl post json数据</h3><p><code>curl -H &quot;Content-Type: application/json&quot; -X POST -d &#39;{&quot;id&quot;:&quot;1&quot;,&quot;password&quot;:&quot;miao&quot;}&#39; http://api</code><br>在post的data中使用变量:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">currentTime=`date +%s`</span><br><span class="line">curl -i -H <span class="string">"Accept:application/json"</span> -H <span class="string">"Content-Type:application/json"</span> -X POST \</span><br><span class="line">--data <span class="string">'&#123;"time":"'</span><span class="string">"<span class="variable">$currentTime</span>"</span><span class="string">'","message":"hypocrisy"&#125;'</span> <span class="string">"https://yourhost:port/api"</span></span><br></pre></td></tr></table></figure><br>循环post:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">i=10</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -gt 0 ]</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    curl -d <span class="string">'&#123;"data":"message"&#125;'</span> http://host:port/api</span><br><span class="line">    i=$(( <span class="variable">$i</span>-1 ))</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">    <span class="comment">#let i=i-1</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><br><a id="more"></a></p>
<h3 id="3-Linux权限"><a href="#3-Linux权限" class="headerlink" title="3. Linux权限"></a>3. Linux权限</h3><p>-rwxr-xr-x 中rwx不是最高权限, 还有sudo权限 -rwsr-xr-x, 方法是:<br><code>chmod u+s /usr/bin/someprogram</code></p>
<h3 id="4-sh和bash差距很大吗"><a href="#4-sh和bash差距很大吗" class="headerlink" title="4. sh和bash差距很大吗"></a>4. sh和bash差距很大吗</h3><p>在crontab中加入<code>* * * * * sh /home/hypocrisy/myshell.sh</code>, 一直无法运行, 执行到<code>i=60</code>显示60 not found, 我也没有加空格, 改为<code>* * * * * bash /home/hypocrisy/myshell.sh</code>, 竟然好了、、默认就是bash为何sh和bash结果还不同?</p>
<h3 id="5-设置系统时间"><a href="#5-设置系统时间" class="headerlink" title="5. 设置系统时间"></a>5. 设置系统时间</h3><p>树莓派没有硬件时钟, 局域网环境无法联网导致Linux系统时间也不对<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">date -s 04/10/16`</span><br><span class="line">date -s 10:10:10</span><br><span class="line">date -s 0410161010.10  <span class="comment"># MMDDhhmmYYYY.ss</span></span><br></pre></td></tr></table></figure><br>更改时区:<br><code>tzselect</code>得到命令, 将其添加到.profile或.bashrc中</p>
<h3 id="6-Python-post-data"><a href="#6-Python-post-data" class="headerlink" title="6. Python post data"></a>6. Python post data</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line">import urllib2</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">'id'</span>: 1, <span class="string">'message'</span>: <span class="string">'hypocrisy'</span>&#125;</span><br><span class="line"></span><br><span class="line">req = urllib2.Request(<span class="string">'http://example.com/api/posts/create'</span>)</span><br><span class="line">req.add_header(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>)</span><br><span class="line"></span><br><span class="line">response = urllib2.urlopen(req, json.dumps(data))</span><br></pre></td></tr></table></figure>
<h3 id="7-shell获取本机ip地址并保存在变量中"><a href="#7-shell获取本机ip地址并保存在变量中" class="headerlink" title="7. shell获取本机ip地址并保存在变量中"></a>7. shell获取本机ip地址并保存在变量中</h3><p><code>ip -o -4 addr list eth0 | awk &#39;{print $4}&#39; | cut -d/ -f1</code><br><code>ifconfig eth0 | grep -E &quot;inet\b&quot; | awk &#39;{print $2}&#39; | cut -d: -f2</code></p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript笔谈一</title>
    <url>/2015/02/25/javascript01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-childNodes和children属性"><a href="#1-childNodes和children属性" class="headerlink" title="1. childNodes和children属性"></a>1. childNodes和children属性</h3><p>使用firstChild没有得到想要的结果, 用Chrome去调试发现firstChild竟然是文本元素, 然后又发现DOM节点有两属性childNodes和children, 于是学习记录下.</p>
<h4 id="1-1-childNodes-属性"><a href="#1-1-childNodes-属性" class="headerlink" title="1.1. childNodes 属性"></a>1.1. childNodes 属性</h4><p>标准的，它返回指定元素的子元素集合，包括HTML节点，所有属性，文本。可以通过nodeType来判断是哪种类型的节点，只有当nodeType==1时才是元素节点，2是属性节点，3是文本节点。有时候需要获取指定元素的第一个HTML子节点（非属性/文本节点），最容易想到的就是firstChild 属性。代码中第一个HTML节点前如果有换行，空格，那么firstChild返回的就不是你想要的了。<br>看到这我就明白为什么我的firstChild不对了，因为我在html节点前加了好几个<code>&amp;nbsp</code>;<br><a id="more"></a></p>
<h4 id="1-2-children-属性"><a href="#1-2-children-属性" class="headerlink" title="1.2 children 属性"></a>1.2 children 属性</h4><p>非标准的，它返回指定元素的子元素集合。经测试，它只返回HTML节点，甚至不返回文本节点。且在所有浏览器下表现惊人的一致。和childNodes 一样，在Firefox下不支持()取集合元素。需注意children在IE中包含注释节点。<br>于是用children[0]代替firstChild，得到想要的结果、</p>
<h3 id="2-Javascript迭代Object"><a href="#2-Javascript迭代Object" class="headerlink" title="2. Javascript迭代Object"></a>2. Javascript迭代Object</h3><p>以为对象迭代只需要<code>for(var item in object)</code>即可取出object每个属性+值, 没想到这里的item只代表属性, 若需要得到值, 还需要<code>object[item]</code><br>但是若使用Angular JS的ng-repeat且只使用一个参数 则其自动得到的是值而不是属性<br>若想得到key和value, 则<code>(key,val) in data</code></p>
<h3 id="3-Cookie-for-each-tab"><a href="#3-Cookie-for-each-tab" class="headerlink" title="3. Cookie for each tab"></a>3. Cookie for each tab</h3><p>若对浏览器打开某站点的每个tab页面都生成一个id并存储在cookie中, 可以使用SessionStorage<br>例如<code>sessionStorage.setItem(&#39;id&#39;,Date.now().toString());</code><br>需要取出此id时, <code>sessionStorage.getItem(&#39;id&#39;)</code></p>
<h3 id="4-Canvas"><a href="#4-Canvas" class="headerlink" title="4. Canvas"></a>4. Canvas</h3><p>使用HTML5的Canvas画图, 发现长度不对, 设置style的width为1000px感觉只是scale了一下<br>查阅文档发现Canvas作为特殊对象是存在width和height属性的, 应该设置该属性, 而不是style, 即<br><code>&lt;canvas width=&quot;1000px&quot;&gt;&lt;/canvas&gt;</code> 不使用 <code>&lt;canvas style=&quot;width:1000px&quot;&gt;&lt;/canvas&gt;</code><br>用jQuery的话则是<code>$(&quot;#id&quot;).attr(&#39;width&#39;, 1000)</code> 不是 <code>$(&quot;#id&quot;).css(&#39;width&#39;,1000)</code></p>
<h3 id="5-font-size"><a href="#5-font-size" class="headerlink" title="5. font-size"></a>5. font-size</h3><p>一直以为font-size的30px表示显示的每个文字都是30px的宽和高, 最近发现font-size只决定高度, 宽度由字符集自己按照比例决定. 如果需要修改可以使用css的<code>transform:scale(2.0,1.0)</code>属性</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux琐记一</title>
    <url>/2015/06/06/linux01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-音频设备"><a href="#1-音频设备" class="headerlink" title="1. 音频设备"></a>1. 音频设备</h3><p>aplay -l会列出所有设备<br>alsamixer灰常实用<br><code>/usr/bin/lspci | grep -i audio</code></p>
<h3 id="2-xargs"><a href="#2-xargs" class="headerlink" title="2. xargs"></a>2. xargs</h3><p>通常使用管道的范例：<code>cat test.txt | grep -E &#39;*test*&#39;</code><br>但若是前者可以作为后者的参数带入时，可以使用xargs：<br><code>echo “*test*” | xargs find / -name</code><br>上述若是不加xargs则无法使用<br>xargs的实际功能是是以行为单位读取输入数据并执行参数变化，于是可以有更强大的用处，例如：<br><code>find / -name &#39;*portaudio*&#39; | xargs ls -l</code><br><a id="more"></a></p>
<h3 id="3-截图"><a href="#3-截图" class="headerlink" title="3. 截图"></a>3. 截图</h3><p>截图可以将PrntScr辅以Shift和Alt键，得到不同效果</p>
<h3 id="4-ssh远程下载上传文件"><a href="#4-ssh远程下载上传文件" class="headerlink" title="4. ssh远程下载上传文件"></a>4. ssh远程下载上传文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp [-P port] username@host:/path/to/remote/<span class="built_in">source</span> /path/to/<span class="built_in">local</span>/dest</span><br><span class="line">scp [-P port] /path/to/<span class="built_in">local</span>/<span class="built_in">source</span> username@host:/path/to/remote/dest</span><br></pre></td></tr></table></figure>
<h3 id="5-qhost"><a href="#5-qhost" class="headerlink" title="5. qhost"></a>5. qhost</h3><h3 id="6-wc"><a href="#6-wc" class="headerlink" title="6. wc"></a>6. wc</h3><p>统计词数</p>
<h3 id="7-download"><a href="#7-download" class="headerlink" title="7. download"></a>7. download</h3><p>aria2c<br>ktorrent</p>
<h3 id="8-校验"><a href="#8-校验" class="headerlink" title="8. 校验"></a>8. 校验</h3><p>md5sum<br>sha1sum<br>openssl sha1 filename</p>
<h3 id="9-默认打开程序"><a href="#9-默认打开程序" class="headerlink" title="9. 默认打开程序"></a>9. 默认打开程序</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/gnome/defaults.list    (这个文件保存了全局的打开方式)</span><br><span class="line">~/.<span class="built_in">local</span>/share/applications/mimeapps.list   (这个文件保存了个人的打开方式)</span><br></pre></td></tr></table></figure>
<h3 id="10-Steghide-工具"><a href="#10-Steghide-工具" class="headerlink" title="10. Steghide 工具"></a>10. Steghide 工具</h3><p>一个给音频、图像等加密或嵌入文件的小程序，很实用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">steghide embed -cf 被加密的文件 -ef 加密的内容文件</span><br><span class="line">steghide extract -sf 被加密的文件</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux琐记二</title>
    <url>/2015/08/03/linux02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-dd命令"><a href="#1-dd命令" class="headerlink" title="1. dd命令"></a>1. dd命令</h3><p>win8.1下镜像直接点击setup.exe无效…系统要求都符合，只是我这是双系统且是BIOS引导，也不是UEFI<br>想想要不制作个系统盘，Win32DiskImager制作后还是不行，转到Ubuntu使用<br><code>dd if=en_windows_10_multiple_editions_x64_dvd_6846432.iso of=/dev/sdb bs=2M</code><br>bs=2M情况下最后平均写入速度为7M/s</p>
<p>虽然最终还是失败了、、、</p>
<h3 id="2-格式化u盘"><a href="#2-格式化u盘" class="headerlink" title="2. 格式化u盘"></a>2. 格式化u盘</h3><p>U盘写入到一半时被我中止了，结果就是U盘变成了只读状态，挂载后也无法操作…<br>于是<code>mkfs.vfat -I /dev/sdb</code>或者<code>mkfs -t vfat /dev/sdb -I</code><br><a id="more"></a></p>
<h3 id="3-Shadowsocks"><a href="#3-Shadowsocks" class="headerlink" title="3. Shadowsocks"></a>3. Shadowsocks</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install shadowsocks</span><br><span class="line">sslocal -c conf.json</span><br></pre></td></tr></table></figure>
<p>conf.json自己编写，格式如下：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"my_server_ip"</span>,</span><br><span class="line">    <span class="attr">"server_port"</span>:*****,</span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"*****"</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">600</span>,</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"*****"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-关闭防火墙"><a href="#4-关闭防火墙" class="headerlink" title="4. 关闭防火墙"></a>4. 关闭防火墙</h3><p>ipv4<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chkconfig iptables off</span><br><span class="line">service iptables stop</span><br></pre></td></tr></table></figure><br>ipv6<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chkconfig ip6tables off</span><br><span class="line">service ip6tables stop</span><br></pre></td></tr></table></figure></p>
<h3 id="5-外网出口ip"><a href="#5-外网出口ip" class="headerlink" title="5. 外网出口ip"></a>5. 外网出口ip</h3><p>在终端下输入 <code>curl ip.gs</code> 即可获取当前自己的外网出口IPv4地址</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>开始使用Podcast吧</title>
    <url>/2017/09/24/listening02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>近日看见某友玩兴大发，在荔枝读了几首诗，想起来Kino很久前在podcast订阅了一些节目，可能是当时挑的节目不够有趣或是超出Kino的欣赏水平，渐渐就荒废了，既然又想起它了，那就重新开始玩一玩吧</p>
<a id="more"></a>
<h3 id="1-订阅列表"><a href="#1-订阅列表" class="headerlink" title="1. 订阅列表"></a>1. 订阅列表</h3><p>鉴于上一次的经验，决定在订阅之前先想明白自己的需求是什么，再去找合适的podcast channels<br>主要分为了以下几个方向:</p>
<ul>
<li>诗歌</li>
<li>音乐理论</li>
<li>日语</li>
<li>英语</li>
</ul>
<p>那就逐个寻找吧、<br>诗歌:</p>
<ul>
<li>为你读诗<br>每天一位特别来宾为你读诗，虽然请来的人朗诵水平不一，但大多数还是可以听的，情感也挺饱满</li>
<li>每日英语诗歌English Poem<br>英语发音挺好，可是没什么情感，也找不到更好的纯粹读英文诗歌的channel</li>
</ul>
<p>音乐理论:</p>
<ul>
<li>逗喵音乐教室<br>找遍全网也没有像样地讲解音乐理论的podcast，这是唯一涉及乐理内容且质量也不错的了</li>
</ul>
<p>日语:</p>
<ul>
<li>myrcella的日语corner<br>语法的部分还不错，上一次玩podcast的时候也听了，但是后期的内容不是很感兴趣</li>
<li>桃子的日语朗读<br>声音很好听，而且也是我想要找的类型，纯粹的读一些日语文章，可以锻炼一下听感吧</li>
<li>未来授業<br>看到推荐的，当作练习听感了，还是因为喜欢发音所以加入了列表</li>
</ul>
<p>英语:</p>
<ul>
<li>The English We Speak<br>足够简单</li>
<li>Planet Money<br>内容喜欢，毕竟也是一直在看经济学相关的内容</li>
<li>The New Yorker: Fiction<br>小说还是可以听听的</li>
<li>The New Yorker: Poetry<br>回到诗歌</li>
</ul>
<h3 id="2-使用工具"><a href="#2-使用工具" class="headerlink" title="2. 使用工具"></a>2. 使用工具</h3><p>android上好用的podcast的app不多，以前用的豌豆荚上的盗版pocket casts，现在有了万事达信用卡，想着上google play买个正版的好咯，然而绑定信用卡的时候google play上的地区没有China选项，选了自己google voice所在的美国地区，添加结束，购买却一直失败，和google support的工作人员聊了很久，也没有解决，只好去淘宝买的礼品卡、、、<br>顺便也买了pocket casts的网页版，同步起来方便，不想换其他的产品了，界面足够简洁，但是功能有些缺失，没法添加list是硬伤</p>
]]></content>
      <categories>
        <category>life</category>
        <category>listening</category>
      </categories>
      <tags>
        <tag>poetry</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux琐记五</title>
    <url>/2016/05/09/linux05/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-No-such-file-or-directory"><a href="#1-No-such-file-or-directory" class="headerlink" title="1. No such file or directory"></a>1. No such file or directory</h3><p><code>./pwn1</code>执行后出现错误信息:<em>./pwn1: No such file or directory</em>, 可执行权限Kino已经加上了, 查了查可能是因为库的原因, 直接<code>cat pwn1</code>看到需要<code>/lib/ld-linux.so</code>, 查了下系统的确没有, 用<code>readelf</code>去查看pwn1的各项信息, 反而没有看到. <code>ld-linux.so</code>这个库是Linux下进行动态库链接的链接器, 无它其他动态库就都无法成功链接, 详细说明可以戳<a href="http://linux.die.net/man/8/ld-linux" target="_blank" rel="noopener">这里</a><br>查看怎么安装这个库, 32位系统下是<code>libc6</code>, 64位是<code>libc6-i386</code>, 这是因为64位中默认安装了<code>/lib64/ld-linux-x86-64.so.2</code></p>
<h3 id="2-dmesg"><a href="#2-dmesg" class="headerlink" title="2. dmesg"></a>2. dmesg</h3><p>dmesg用来显示内核环缓冲区(kernel-ring buffer)内容, 内核将各种消息存放在这里. 在系统引导时, 内核将与硬件和模块初始化相关的信息填到这个缓冲区中. 内核环缓冲区中的消息对于诊断系统问题非常有用<br><a id="more"></a></p>
<h3 id="3-ls硬件信息"><a href="#3-ls硬件信息" class="headerlink" title="3. ls硬件信息"></a>3. ls硬件信息</h3><p><code>lsmod</code>  <code>lscpu</code>  <code>lspci</code>  <code>lsusb</code>等</p>
<h3 id="4-时间"><a href="#4-时间" class="headerlink" title="4. 时间"></a>4. 时间</h3><p><a href="http://raspberrypi.stackexchange.com/questions/36674/raspberry-pi-raspbian-tick-rate-in-hz/proc/timer_list" target="_blank" rel="noopener">参考1</a><br><a href="http://raspberrypi.stackexchange.com/questions/7400/how-does-pi-keep-track-of-time-interval" target="_blank" rel="noopener">参考2</a><br><a href="http://www.360doc.com/content/11/1201/09/1317564_168810003.shtml" target="_blank" rel="noopener">参考3</a><br><a href="http://www.advenage.com/topics/linux-timer-interrupt-frequency.php" target="_blank" rel="noopener">参考4</a><br><a href="http://stackoverflow.com/questions/13600592/how-to-determine-timer-frequency-in-linux" target="_blank" rel="noopener">参考5</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /boot/config-`uname -r` | grep HZ</span><br><span class="line">cat /proc/interrupts | grep timer &amp;&amp; sleep 1 &amp;&amp; cat /proc/interrupts | grep timer</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux琐记三</title>
    <url>/2015/11/01/linux03/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-who命令"><a href="#1-who命令" class="headerlink" title="1. who命令"></a>1. who命令</h3><p>who命令查询utmp文件并报告当前登录的每个用户。Who的缺省输出包括用户名、终端类型、登录日期及远程主机。</p>
<h3 id="2-w命令"><a href="#2-w命令" class="headerlink" title="2. w命令"></a>2. w命令</h3><p>执行这项指令可得知目前登入系统的用户有那些人，以及他们正在执行的程序。单独执行linux w命令会显示所有的用户，您也可指定用户名称，仅显示某位用户的相关信息。</p>
<h3 id="3-查看端口使用情况"><a href="#3-查看端口使用情况" class="headerlink" title="3. 查看端口使用情况"></a>3. 查看端口使用情况</h3><p><code>netstat   -anp   |   grep  portno</code><br>比如<code>netstat –apn | grep 8080</code><br><a id="more"></a></p>
<h3 id="4-cat命令高级用法"><a href="#4-cat命令高级用法" class="headerlink" title="4. cat命令高级用法"></a>4. cat命令高级用法</h3><p>搭配<code>EOF</code>和输入输出流<code>&gt;&gt;</code>及<code>&lt;&lt;</code>使用，例如Haskell的官方安装教程：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &gt;&gt; ~/.bashrc &lt;&lt;EOF</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">"\$HOME/.cabal/bin:/opt/cabal/1.20/bin:/opt/ghc/7.10.3/bin:\$PATH"</span></span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">export</span> PATH=~/.cabal/bin:/opt/cabal/1.22/bin:/opt/ghc/7.10.3/bin:<span class="variable">$PATH</span>=<span class="string">"</span></span><br></pre></td></tr></table></figure><br>以上可以实现文件追加功能，在.bashrc文件最后追加两句环境变量。</p>
<h3 id="5-Linux命令行下引号"><a href="#5-Linux命令行下引号" class="headerlink" title="5. Linux命令行下引号"></a>5. Linux命令行下引号</h3><p><code>echo &quot;$PATH&quot;</code>与<code>echo $PATH</code>的结果相同，输出PATH变量的值，而<code>echo &#39;$PATH&#39;</code>输出的结果就是<code>$PATH</code>这个字符串</p>
<h3 id="6-修改ssh-端口号"><a href="#6-修改ssh-端口号" class="headerlink" title="6. 修改ssh 端口号"></a>6. 修改ssh 端口号</h3><p><code>vim /etc/ssh/sshd_config</code> 找到port修改即可，当然还是注意尽量不要使用1024以下的端口，即使你是root用户。<br>之后重启：<code>service ssh restart</code></p>
<h3 id="7-修改用户所属用户组"><a href="#7-修改用户所属用户组" class="headerlink" title="7. 修改用户所属用户组"></a>7. 修改用户所属用户组</h3><p><code>usermod -g newgroup username</code></p>
<h3 id="8-禁止用户登录"><a href="#8-禁止用户登录" class="headerlink" title="8. 禁止用户登录"></a>8. 禁止用户登录</h3><p>主要使用<code>nologin</code>，用户不可以ssh登录但可以使用ftp等登录</p>
<ul>
<li>Method 1:<br><code>usermod -s /usr/sbin/nologin username</code> and <code>echo &quot;/usr/sbin/nologin&quot; &gt;&gt; /etc/shells</code></li>
<li>Method 2:<br>lock the user: <code>passwd -l username</code><br>if we want to unlock: <code>passwd -u username</code></li>
<li>Method 3:<br><code>vim /etc/passwd</code><br>then change <code>test:x:1001:1000:,,,:/home/test:/bin/bash</code> to <code>test:x:1001:1000:,,,:/home/test:/usr/sbin/nologin</code></li>
<li>Method 4:<br><code>touch /etc/nologin</code>, this will deny all users except root to login.</li>
<li>Method 5:<br>We can deny the way to login with username and passwd, just edit <code>/etc/ssh/sshd_config</code>, find <code>PasswordAuthentication yes</code>, change it to <code>PasswordAuthentication no</code>, then <code>service sshd restart</code></li>
</ul>
<h3 id="9-文件夹权限与文件权限的区别"><a href="#9-文件夹权限与文件权限的区别" class="headerlink" title="9. 文件夹权限与文件权限的区别"></a>9. 文件夹权限与文件权限的区别</h3><table>
<thead>
<tr>
<th style="text-align:center">权限</th>
<th style="text-align:center">对文件的作用</th>
<th style="text-align:center">对文件夹的作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">r</td>
<td style="text-align:center">查看文件内容</td>
<td style="text-align:center">列出文件夹中的文件(ls)</td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td style="text-align:center">修改文件内容</td>
<td style="text-align:center">在文件夹中删除、添加或重命名文件(夹)</td>
</tr>
<tr>
<td style="text-align:center">x</td>
<td style="text-align:center">文件可以作为程序执行</td>
<td style="text-align:center">cd 到文件夹</td>
</tr>
</tbody>
</table>
<h3 id="10-将某用户加入sudo权限中"><a href="#10-将某用户加入sudo权限中" class="headerlink" title="10. 将某用户加入sudo权限中"></a>10. 将某用户加入sudo权限中</h3><p><code>visudo</code>命令<br>直接加入<code>username ALL=(ALL) ALL</code></p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>My 10 favorite albums</title>
    <url>/2016/04/10/listening01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>无新歌可听, 翻了翻收藏的专辑, 一直打算把自己最爱的10张专辑挑出来, 但是总觉得有更好的音乐, 不过还是留存一份当前最喜欢的几张专辑吧</p>
<h3 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h3><ul>
<li>The Dark Side of the Moon —— Pink Floyd</li>
<li>The Girl Who Was… Death —— Devil Doll</li>
<li>Famous Blue Raincoat —— Jennifer Warnes</li>
<li>A Sombre Dance —— Estatic Fear</li>
<li>21 —— Adele Laurie Blue Adkins</li>
<li>Where You Live —— Tracy Chapman</li>
<li>万能青年旅店 —— 万能青年旅店</li>
<li>Born to Die —— Lana Del Rey</li>
<li>浮躁 —— 王菲</li>
<li>Diana Ross —— Diana Ross</li>
</ul>
]]></content>
      <categories>
        <category>life</category>
        <category>listening</category>
      </categories>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux琐记六</title>
    <url>/2016/06/07/linux06/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-rename"><a href="#1-rename" class="headerlink" title="1. rename"></a>1. rename</h3><p><code>rename &#39;s/(0-9).txt/file_$1.txt/&#39; *.txt</code></p>
<h3 id="2-查看硬件信息"><a href="#2-查看硬件信息" class="headerlink" title="2. 查看硬件信息"></a>2. 查看硬件信息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lscpu</span><br><span class="line">lshw</span><br><span class="line">hwinfo</span><br><span class="line">lspci</span><br><span class="line">lsusb</span><br><span class="line">lsblk</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="3-查找文件"><a href="#3-查找文件" class="headerlink" title="3. 查找文件"></a>3. 查找文件</h3><p><code>locate file_path</code></p>
<h3 id="4-制作iso文件"><a href="#4-制作iso文件" class="headerlink" title="4. 制作iso文件"></a>4. 制作iso文件</h3><p><code>mkisofs -l -J -L -r -o filename.iso path_to_folder</code></p>
<h3 id="5-查看主机开放端口"><a href="#5-查看主机开放端口" class="headerlink" title="5. 查看主机开放端口"></a>5. 查看主机开放端口</h3><p><code>nmap your-domain-ip</code></p>
<h3 id="6-ffmpeg-剪切拼接视频"><a href="#6-ffmpeg-剪切拼接视频" class="headerlink" title="6. ffmpeg 剪切拼接视频"></a>6. ffmpeg 剪切拼接视频</h3><ul>
<li>剪切:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -ss START -i input.mp4  -t TIME -acodec copy -vcodec copy output.mp4</span><br></pre></td></tr></table></figure>
其中 START/TIME 的格式有两种: 以秒为单位计数  80, 时:分:秒  00:01:20</li>
<li>拼接:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -i <span class="string">"concat:input1.mpg|input2.mpg|input3.mpg"</span> -c copy output.mpg</span><br></pre></td></tr></table></figure>
也可以将要拼接的视频放在一个文件list.txt里:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file <span class="string">'/path/to/file1'</span></span><br><span class="line">file <span class="string">'/path/to/file2'</span></span><br><span class="line">file <span class="string">'/path/to/file3'</span></span><br></pre></td></tr></table></figure>
之后<code>ffmpeg -f concat -i list.txt -c copy output.mp4</code></li>
</ul>
<h3 id="7-Ubuntu-安装特定版本package"><a href="#7-Ubuntu-安装特定版本package" class="headerlink" title="7. Ubuntu 安装特定版本package"></a>7. Ubuntu 安装特定版本package</h3><p>某个包依赖<code>pkg-config</code>，而<code>pkg-config</code>依赖的一个包始终安装不上，因为版本对不上，手动指定版本降级之后可以<br><code>apt install package=version</code></p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵的Jordan标准型求法以及对应的最小多项式</title>
    <url>/2015/03/10/matrix01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-矩阵的Jordan标准型求法"><a href="#1-矩阵的Jordan标准型求法" class="headerlink" title="1. 矩阵的Jordan标准型求法"></a>1. 矩阵的Jordan标准型求法</h3><h3 id="2-对应的最小多项式"><a href="#2-对应的最小多项式" class="headerlink" title="2. 对应的最小多项式"></a>2. 对应的最小多项式</h3>]]></content>
      <categories>
        <category>science</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>matrix</tag>
        <tag>jordan</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习二</title>
    <url>/2015/08/16/machineLearning02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-决策树定义"><a href="#1-决策树定义" class="headerlink" title="1. 决策树定义"></a>1. 决策树定义</h3><p>决策树是一个预测模型；他代表的是对象属性与对象值之间的一种映射关系。树中每个节点表示某个对象，而每个分叉路径则代表的某个可能的属性值，而每个叶结点则对应从根节点到该叶节点所经历的路径所表示的对象的值。决策树仅有单一输出，若欲有复数输出，可以建立独立的决策树以处理不同输出。从数据产生决策树的机器学习技术叫做决策树学习, 通俗说就是决策树。</p>
<a id="more"></a>
<h3 id="2-决策树优缺点"><a href="#2-决策树优缺点" class="headerlink" title="2. 决策树优缺点"></a>2. 决策树优缺点</h3><p>决策树是一种简单但是广泛使用的分类器。通过训练数据构建决策树，可以高效的对未知的数据进行分类。</p>
<ul>
<li>决策数有两大优点：<ul>
<li>1、决策树模型可读性好，具有描述性，有助于人工分析</li>
<li>2、效率高，决策树只需要一次构建，反复使用，每一次预测的最大计算次数不超过决策树的深度。</li>
</ul>
</li>
<li>决策树缺点：可能会产生过度匹配问题</li>
</ul>
<h3 id="3-构造决策树"><a href="#3-构造决策树" class="headerlink" title="3. 构造决策树"></a>3. 构造决策树</h3><h4 id="3-1-构造决策树算法"><a href="#3-1-构造决策树算法" class="headerlink" title="3.1 构造决策树算法"></a>3.1 构造决策树算法</h4><p>决策树算法有ID3算法、C4.5、CART等，以ID3为例:</p>
<ul>
<li>对于当前数据集，计算不同属性(特征)的信息增益，并从中取出信息增益最大的属性(特征)R</li>
<li>用R作为划分root节点的方法，把R属性可能对应的不同值归为不同的子集</li>
<li>对每个子集，递归调用建树算法</li>
<li>若子集只含有单个属性，则分支为叶子节点，(即递归函数的停止条件)，判断其属性值并标上相应的符号，然后返回调用处</li>
</ul>
<h4 id="3-2-度量数据集无序程度"><a href="#3-2-度量数据集无序程度" class="headerlink" title="3.2 度量数据集无序程度"></a>3.2 度量数据集无序程度</h4><p>构造决策树需要解决的第一个问题就是，当前数据集上哪个特征在划分数据分类时起决定性作用。如果按照A特征划分之后已经完全正确的将数据集分类了，那么A特征就足够好，也可以说划分后的数据集无序程度下降了，即划分数据集的最大原则是：将无序的数据变得更加有序。而度量数据集无序程度的方法有熵(entropy)和基尼不纯度(Gini impurity)等，此处使用熵。<br>关于熵，熵定义为信息的期望值，而对于符号\(x_i\)的信息定义为\(l(x_i)=-\log_2p(x_i)\)，为了计算熵，我们需要计算所有类别所有可能值包含的信息期望值，通过以下公式得到: \(H=-\sum_{i=1}^np(x_i)\log_2p(x_i)\)<br>熵越高，数据集的无序程度越大，即混合的数据越多</p>
<p>通过熵度量划分数据集的信息增益，判断按照哪个属性(特征)划分数据集为最好的划分方式</p>
<h3 id="3-3-递归构建决策树"><a href="#3-3-递归构建决策树" class="headerlink" title="3.3 递归构建决策树"></a>3.3 递归构建决策树</h3><p>递归结束的条件是：遍历完所有划分数据集的属性，或者每个分支下的所有实例都具有相同的分类。如果所有实例都具有相同的分类，则得到一个叶子节点或者终止块，任何到达叶子节点的数据必然属于叶子节点的分类</p>
<h3 id="4-Matplotlib注解"><a href="#4-Matplotlib注解" class="headerlink" title="4. Matplotlib注解"></a>4. Matplotlib注解</h3><p>以上构造的决策树为文本描述方式，不够直观，虽然实际应用中大多就是如此，但本着学习的态度，且数据集也很小，使用matplotlib注解直观形象的作出一个决策树，不详述</p>
<h3 id="5-测试算法"><a href="#5-测试算法" class="headerlink" title="5. 测试算法"></a>5. 测试算法</h3><p>决策树构造完毕后，需要使用它来执行分类</p>
<h3 id="6-决策树的存储"><a href="#6-决策树的存储" class="headerlink" title="6. 决策树的存储"></a>6. 决策树的存储</h3><p>决策树的构造过程十分耗时，如果每次使用决策树都需要先构造，会浪费计算时间，可以将训练好的决策树存储起来，需要使用的时候读取出来</p>
<h3 id="7-过渡拟合"><a href="#7-过渡拟合" class="headerlink" title="7. 过渡拟合"></a>7. 过渡拟合</h3><p>这是ID3算法的不足之处，其概念和优化方法可以参见<a href="http://www.cnblogs.com/bourneli/archive/2013/03/15/2961568.html" target="_blank" rel="noopener">http://www.cnblogs.com/bourneli/archive/2013/03/15/2961568.html</a></p>
<h3 id="8-应用示例"><a href="#8-应用示例" class="headerlink" title="8. 应用示例"></a>8. 应用示例</h3><p>Machine Learning in Action 书中使用了隐形眼镜示例，数据来源为UCI数据库，并进行了相应的改造<br>代码可见<a href="https://github.com/zhen-yu/machineLearning/tree/master/decisionTree" target="_blank" rel="noopener">此处</a></p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>ai</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
        <tag>decision tree</tag>
        <tag>ID3</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习一</title>
    <url>/2015/08/11/machineLearning01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>学习此书<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[Machine Learning in Action](http://www2.ift.ulaval.ca/~chaib/IFT-4102-7025/public_html/Fichiers/Machine_Learning_in_Action.pdf)
">[1]</span></a></sup>时的一些记录</p>
<h3 id="2-如何选择合适的算法"><a href="#2-如何选择合适的算法" class="headerlink" title="2. 如何选择合适的算法"></a>2. 如何选择合适的算法</h3><p>考虑使用机器学习算法的目的, 如果想要预测目标变量的值，则可以选择监督学习算法，否则可以选择无监督学习算法。确定选择监督学习算法后，进一步确定目标变量类型，如果目标变量是离散型，如是/否、1/2/3、A/B/C等，则可以选择分类算法；如果目标变量是连续型的数值，如0.0~100.00、-999~999或者+∞~-∞等，则需要选择回归算法, 如果不想预测目标变量的值，则可以选择无监督算法，进一步分析是否需要将数据划分为离散的组。如果这是唯一的要求，则使用聚类算法，如果还需要估计数据与每个分组的相似程度，则需要使用密度估计算法。</p>
<a id="more"></a>
<h3 id="3-开发机器学习程序的应用步骤"><a href="#3-开发机器学习程序的应用步骤" class="headerlink" title="3. 开发机器学习程序的应用步骤"></a>3. 开发机器学习程序的应用步骤</h3><ul>
<li>收集数据</li>
<li>准备数据</li>
<li>分析数据</li>
<li>训练算法</li>
<li>测试算法</li>
<li>使用算法</li>
</ul>
<h3 id="4-kNN算法"><a href="#4-kNN算法" class="headerlink" title="4. kNN算法"></a>4. kNN算法</h3><h4 id="4-1-k-近邻算法的原理"><a href="#4-1-k-近邻算法的原理" class="headerlink" title="4.1 k-近邻算法的原理"></a>4.1 k-近邻算法的原理</h4><p>存在一个样本数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据与所属分类的对应关系。输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据(最近邻)的分类标签。一般来说，我们只选取样本数据集中前k个最相似的数据，这就是k-近邻算法</p>
<h4 id="4-2-kNN的应用"><a href="#4-2-kNN的应用" class="headerlink" title="4.2 kNN的应用"></a>4.2 kNN的应用</h4><p>在书<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[Machine Learning in Action](http://www2.ift.ulaval.ca/~chaib/IFT-4102-7025/public_html/Fichiers/Machine_Learning_in_Action.pdf)
">[1]</span></a></sup>中提供了一个识别数字的实例，对其稍作修改，最终代码<a href="https://github.com/zhen-yu/machineLearning/tree/master/kNN" target="_blank" rel="noopener">在此</a></p>
<h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h3><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)"><a href="http://www2.ift.ulaval.ca/~chaib/IFT-4102-7025/public_html/Fichiers/Machine_Learning_in_Action.pdf" target="_blank" rel="noopener">Machine Learning in Action</a><a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)"><a href="http://research.microsoft.com/en-us/um/people/cmbishop/prml/" target="_blank" rel="noopener">PRML</a><a href="#fnref:2" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>techonology</category>
        <category>ai</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
        <tag>kNN</tag>
        <tag>k-Nearest Neighbour</tag>
      </tags>
  </entry>
  <entry>
    <title>数学方法一</title>
    <url>/2016/04/16/methodologyOfMath01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>Methodology of Mathematics<br>主要记录了《数学方法论稿》<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[数学方法论稿](https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00B7U51XI)
">[1]</span></a></sup> 的内容</p>
<h3 id="2-钱学森对于数学的分类"><a href="#2-钱学森对于数学的分类" class="headerlink" title="2. 钱学森对于数学的分类"></a>2. 钱学森对于数学的分类</h3><p>钱学森在《关于思维科学》中用过一张表进行科学的分类(然而这是Kino在数学方法论稿书中看到的):<br><img src="/images/methodologyOfMath01_1.jpg" alt="01"></p>
<a id="more"></a>
<h3 id="3-重大数学方法与哲学范畴"><a href="#3-重大数学方法与哲学范畴" class="headerlink" title="3. 重大数学方法与哲学范畴"></a>3. 重大数学方法与哲学范畴</h3><h4 id="3-1-数学方法·形式与内容"><a href="#3-1-数学方法·形式与内容" class="headerlink" title="3.1 数学方法·形式与内容"></a>3.1 数学方法·形式与内容</h4><p>数学的研究对象是形式化的思想材料, 整个数学是一个形式化的思想体系. 数学要形式化, 但是不可局限于形式化, 形式是为内容服务的. 因为形式不能更好的表示内容, 因而很多数学论文中的方法被冷落和扬弃了, 或者被更好的数学形式所代替</p>
<h4 id="3-2-数理逻辑方法·原因与结果"><a href="#3-2-数理逻辑方法·原因与结果" class="headerlink" title="3.2 数理逻辑方法·原因与结果"></a>3.2 数理逻辑方法·原因与结果</h4><p>“原因”和”结果”是一对哲学范畴, 它反映事物之间的相互联系和相互制约. 当我们把事物从普遍联系中抽象出来, 就会看到有序的、不断更替的运动, 一种现象会引起另一种现象. 前者为原因, 后者为结果, 这种因果观念是人们一切自觉活动必不可少的逻辑条件<br>数学的表示一个命题, 要用谓词和八个逻辑常量, 即∀, Ǝ, V, Λ, =, ¬(非), →(蕴涵), ⇔(if and only if). 我们用⇒表示”推出”, 谓词S(a)、P(b)即a是S, b是P</p>
<h4 id="3-3-几何方法·时间与空间"><a href="#3-3-几何方法·时间与空间" class="headerlink" title="3.3 几何方法·时间与空间"></a>3.3 几何方法·时间与空间</h4><p>时间与空间是运动着的物质的基本属性和存在形式, 从数学范畴研究时间范畴和空间范畴, 便构成了各种几何学<br>几何方法, 说到底是为了描写、表示、反映现实时空, 为各种时空观提供数学模型</p>
<h4 id="3-4-微积分方法·运动和静止"><a href="#3-4-微积分方法·运动和静止" class="headerlink" title="3.4 微积分方法·运动和静止"></a>3.4 微积分方法·运动和静止</h4><p>“运动”是标志事物、现象变化和过程的哲学范畴, “静止”则是特殊的运动状态. 从数学角度观察运动过程, 分析它的数量方面, 就会得出变量和常量的观念, 以及对剧烈变化和相对稳定等进行数学处理的方法. 函数是描写运动的有力工具.<br>运动和静止的研究还和稳定性问题联系在一起</p>
<h4 id="3-5-概率方法·偶然和必然"><a href="#3-5-概率方法·偶然和必然" class="headerlink" title="3.5 概率方法·偶然和必然"></a>3.5 概率方法·偶然和必然</h4><p>“偶然”和”必然”是反映事物间必然联系和偶然联系的一对范畴, 是对因果范畴的进一步深化. 数学中的概率论就是从数量上研究必然性和偶然性的学科. 它从所考察的偶然性因素和影响中寻找必然的、本质的、数量的规律, 并对这些偶然性影响进行数量的刻画和分析<br>必然性和偶然性现象, 在数学上称为确定性现象和随机性现象, 相应就有确定性数学和随机性数学之分.<br>确定性数学正在随机化, 随机微分方程, 随机积分方程, 随机算子理论, 随机幂级数, 随机整函数, 以至随机微分几何也诞生了</p>
<h4 id="3-6-模糊数学方法·同一与差异"><a href="#3-6-模糊数学方法·同一与差异" class="headerlink" title="3.6 模糊数学方法·同一与差异"></a>3.6 模糊数学方法·同一与差异</h4><p>哲学上把”对立”与”同一”当作一对范畴. 从数学上看, 更重要的是研究”差异”与”同一”. 正与负, 微分与积分, 加与减都是对立物, 是从数量上刻画”对立”规律的学问. 如果从更广的意义上理解, “对立”是从”差异”开始的, 当差异发生到极点时, 就会产生对立. 所以事物间的同一与差异也许是更为普遍的研究课题<br>康托(G.Cantor)集合论 -&gt; 模糊集合 -&gt; 模糊数学<br>康托集合语言可以廓清”白马非马”的诡辩</p>
<h4 id="3-7-分析方法·局部与整体"><a href="#3-7-分析方法·局部与整体" class="headerlink" title="3.7 分析方法·局部与整体"></a>3.7 分析方法·局部与整体</h4><p>“整体”和”局部”也是一对哲学范畴, 全局由各个局部组成, 但并非各个局部的简单总和, 它高于局部. 局部是整体的一部分, 但有时局部会影响整体, 甚至起主要的决定性作用<br>微积分学提供了分析局部的手段. 可以理解”芝诺悖论”<br>数学上的局部是指一点的领域</p>
<h4 id="3-8-计算方法·量-质-度"><a href="#3-8-计算方法·量-质-度" class="headerlink" title="3.8 计算方法·量,质,度"></a>3.8 计算方法·量,质,度</h4><p>任何事物都有”质”和”量”两方面, 是”质”和”量”的统一体, 作为”质”和”量”统一的”度”, 就是保持事物本”质”的量的限度、幅度和范围<br>数学是关于”量”的科学, 但也要反映”质”. 因为当量变发展到质变时, 量往往发生跳跃. 从函数图像上看就是跳跃和间断, 或者发生转折<br>(R.Thom)创立的突变理论, 可参考</p>
<h4 id="3-9-控制论方法·可能与现实"><a href="#3-9-控制论方法·可能与现实" class="headerlink" title="3.9 控制论方法·可能与现实"></a>3.9 控制论方法·可能与现实</h4><p>客观事物处于普遍联系中, 系统科学正是对它的描述. 一个系统的存在1是现实的, 但人们关心的是预示各种发展前途的可能性. 发挥人的主观能动性, 使得某种可能性转变为人们想要实现的现实, 这便是研究”可能”与”现实”这一对哲学范畴的意义<br>数学上研究系统是否可能控制以及如何控制的学科, 称为控制论. 控制理论为现实系统的描述、分析综合和设计、预测和决策等问题提供了成套的理论和方法<br>控制论不是直接研究现实世界的受控对象, 而是研究受控对象的数学模型. 在控制论中, 能观性和能控性是两个基本概念. 一个系统是能控的, 是指输入信号u(t)能对系统的每一状态变量施加独立的影响, 使之能从任意的初态x0出发, 经有限时间后总能到达预先期望的任意值. 一个系统能观是指输出信号受每个状态变量的独立影响, 使之能从观测一段时间的输出值来唯一确定状态变量在某一时刻的值</p>
<h4 id="3-10-数学模型方法·实践与认识"><a href="#3-10-数学模型方法·实践与认识" class="headerlink" title="3.10 数学模型方法·实践与认识"></a>3.10 数学模型方法·实践与认识</h4><p>“实践”和”认识”, 是认知论中的哲学范畴. “认识”是主体对客体的能动反映, 而”实践”则是认识的基础, 它对认识起着决定的作用<br>数学模型方法正是基于实践之上的一种数学认识, 人们用以认识世界和改造世界</p>
<h3 id="4-数学中使用的一般科学方法"><a href="#4-数学中使用的一般科学方法" class="headerlink" title="4. 数学中使用的一般科学方法"></a>4. 数学中使用的一般科学方法</h3><ol>
<li>数学中的观察与实验</li>
<li>数学方法不等于逻辑方法·数学直觉</li>
<li>设定数学猜想的一般方法·归纳与类比</li>
<li>数学证明方法<br>曼宁(Manin): “一个证明只有当它通过’被接纳为证明’这项社会时,它才算被证明”<br>数学证明有助于核实真理, 数学证明最重要的价值是增进理解, 只有弄懂了一个定理的证明, 才能真正该定理的内容</li>
<li>数学证明方法的一般方法·化归与逻辑</li>
</ol>
<h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h3><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)"><a href="https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00B7U51XI" target="_blank" rel="noopener">数学方法论稿</a><a href="#fnref:1" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>science</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>数学方法二</title>
    <url>/2016/04/16/methodologyOfMath02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-构建数学知识的常用数学方法"><a href="#1-构建数学知识的常用数学方法" class="headerlink" title="1. 构建数学知识的常用数学方法"></a>1. 构建数学知识的常用数学方法</h3><h4 id="1-1-数学表示方法"><a href="#1-1-数学表示方法" class="headerlink" title="1.1 数学表示方法"></a>1.1 数学表示方法</h4><h4 id="1-2-等价变换方法"><a href="#1-2-等价变换方法" class="headerlink" title="1.2 等价变换方法"></a>1.2 等价变换方法</h4><ul>
<li>自反性(Reflactive): 对任何a ϵ A, 必有aRa(R条件)</li>
<li>对称性(Symmetry): 对任何a ϵ A, b ϵ A, 若有aRb, 必有bRa(S条件)</li>
<li>传递性(Transitive): 设a、b、c均在A中, 若有aRb,bRc, 则必有aRc(T条件)</li>
</ul>
<h4 id="1-3-公理化方法和结构主义"><a href="#1-3-公理化方法和结构主义" class="headerlink" title="1.3 公理化方法和结构主义"></a>1.3 公理化方法和结构主义</h4><p>公理系的三性:</p>
<ul>
<li>独立性, 即各条公理相互独立, 不能由一条推出另外一条</li>
<li>无矛盾性, 即各条公理之间没有矛盾, 从一条公理推出的结果不能与另一条矛盾</li>
<li>完备性, 即通过它能推出该学科已有的全部重要命题, 不能随便省略公理<a id="more"></a>
公理化的近代发展是”结构主义”. 例如代数结构, 群、环、域、线性空间等都是可以用满足一定公理来定义的代数结构; 还有序结构, 包括半序和全序<br>半序集E: 若E的元素之间定义了一个关系”≤”, 它具有以下性质:</li>
<li>自反性: 若xϵE, 则x≤x</li>
<li>反对称性: 若x,yϵE, x≤y且y≤x, 则x=y</li>
<li>传递性: 若x,y,zϵE, x≤y且y≤z, 则x≤z<br>则称E为半序集</li>
</ul>
<p>全序是在半序基础上加上:</p>
<blockquote>
<p>可比性条件: 任何一对元素a、b, 在a≤b或b≤a中至少有一个成立</p>
</blockquote>
<p>复数可以按照字典建立全序关系, 但是不能定义复数的大小, 因为按照大小关系和代数运算协调性要求, 必须有”加法保序”和”乘正数保序”的原则, 故复数只能有全序而不能有大小<br>布尔巴基学派: 数学学科是按代数结构、序结构和拓扑结构的不同的不同, 以及它们的各种组合而加以区别的</p>
<h4 id="1-4-同构方法"><a href="#1-4-同构方法" class="headerlink" title="1.4 同构方法"></a>1.4 同构方法</h4><blockquote>
<p>一般来说, 若X和Y是两个代数结构, 其间存在一个对一个的满射 f:X→Y, 且f能保持运算, 则称f是同构映射, X与Y同构. 设X中的运算是”·”, Y中的运算是”*“, 保持运算的意思是: f(a·b)=f(a)*f(b)</p>
</blockquote>
<h4 id="1-5-不变量与不变性质"><a href="#1-5-不变量与不变性质" class="headerlink" title="1.5 不变量与不变性质"></a>1.5 不变量与不变性质</h4><h3 id="2-数学应用中的常用数学方法"><a href="#2-数学应用中的常用数学方法" class="headerlink" title="2. 数学应用中的常用数学方法"></a>2. 数学应用中的常用数学方法</h3><h4 id="2-1-概率统计方法"><a href="#2-1-概率统计方法" class="headerlink" title="2.1 概率统计方法"></a>2.1 概率统计方法</h4><ul>
<li>概率统计是研究随机性现象的数学. 随机现象指: 在条件相同的情况下, 做重复试验, 试验结果却不确定, 以至于在试验之前无法预料是哪一个结果出现. 我们把这时的试验结果称为”随机事件”</li>
<li>数据的集中趋势与离中程度</li>
<li>统计方法用数据说话</li>
</ul>
<h4 id="2-2-函数分析方法"><a href="#2-2-函数分析方法" class="headerlink" title="2.2 函数分析方法"></a>2.2 函数分析方法</h4><h4 id="2-3-优化决策方法"><a href="#2-3-优化决策方法" class="headerlink" title="2.3 优化决策方法"></a>2.3 优化决策方法</h4><h4 id="2-4-近似方法与计算机方法"><a href="#2-4-近似方法与计算机方法" class="headerlink" title="2.4 近似方法与计算机方法"></a>2.4 近似方法与计算机方法</h4><p>小学的科普文章里就有吴文俊的故事, 当时只知道他获得了国家最高科学技术奖, 一般书中还会说到袁隆平的故事、、、今天才了解了吴文俊所做数学工作的一小部分, 就是几何定理的机器证明方法</p>
<h3 id="3-形式化原则"><a href="#3-形式化原则" class="headerlink" title="3. 形式化原则"></a>3. 形式化原则</h3><ol>
<li>数学的形式化</li>
<li>中学数学里的半形式化系统</li>
<li>数学概念的形式化</li>
<li>数学问题的各种不同形式之间的转换</li>
<li>运用形式化原则指导数学解题教学</li>
</ol>
<h3 id="4-简单性原理"><a href="#4-简单性原理" class="headerlink" title="4. 简单性原理"></a>4. 简单性原理</h3><ol>
<li>简单性原理的含义</li>
<li>中学数学内容由简到繁的发展</li>
<li>用简单性原理指导解题</li>
</ol>
<h3 id="5-等价变换原则"><a href="#5-等价变换原则" class="headerlink" title="5. 等价变换原则"></a>5. 等价变换原则</h3><ol>
<li>等价变换原则的含义</li>
<li>中学数学中的等价变换</li>
<li>用等价变换原则指导解题</li>
</ol>
<h3 id="6-映射反演原则"><a href="#6-映射反演原则" class="headerlink" title="6. 映射反演原则"></a>6. 映射反演原则</h3><ol>
<li>映射反演原则的含义</li>
<li>中学数学中的映射类型</li>
<li>用映射反演原则指导解题</li>
</ol>
<h3 id="7-逐次逼近渐进原则"><a href="#7-逐次逼近渐进原则" class="headerlink" title="7. 逐次逼近渐进原则"></a>7. 逐次逼近渐进原则</h3><ol>
<li>逐次逼近渐进原则的含义</li>
<li>中学数学解题中的逐次逼近渐进思想</li>
</ol>
<h3 id="8-系统化原理"><a href="#8-系统化原理" class="headerlink" title="8. 系统化原理"></a>8. 系统化原理</h3><ol>
<li>从发生的角度看数学方法的系统化原理</li>
<li>从联系与区别的角度看数学方法的系统化原理</li>
<li>从发展的角度看数学方法的系统化原理</li>
<li>从运用的角度看数学方法的系统化原理</li>
</ol>
]]></content>
      <categories>
        <category>science</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统三</title>
    <url>/2015/09/27/operatingSystem03/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="主存管理"><a href="#主存管理" class="headerlink" title="主存管理"></a>主存管理</h1><h3 id="主存管理概述"><a href="#主存管理概述" class="headerlink" title="主存管理概述"></a>主存管理概述</h3><ol>
<li>主存分片共享</li>
<li>程序的组织逻辑<ul>
<li>一维地址结构</li>
<li>二维地址结构</li>
</ul>
</li>
</ol>
<a id="more"></a>
<h3 id="主存管理的功能"><a href="#主存管理的功能" class="headerlink" title="主存管理的功能"></a>主存管理的功能</h3><ol>
<li>虚拟存储器<ul>
<li>提供虚拟存储器的必要性</li>
<li>虚存的定义</li>
</ul>
</li>
<li>地址映射<ul>
<li>什么是地址映射</li>
<li>地址映射方式<ul>
<li>编程或编译时确定地址映射关系</li>
<li>静态地址映射</li>
<li>动态地址映射</li>
</ul>
</li>
</ul>
</li>
<li>主存分配<br>主存管理存储器的策略有以下三种：<ul>
<li>放置策略</li>
<li>调入策略</li>
<li>淘汰策略</li>
</ul>
</li>
<li>存储保护</li>
</ol>
<h3 id="分区存储管理及存在的问题"><a href="#分区存储管理及存在的问题" class="headerlink" title="分区存储管理及存在的问题"></a>分区存储管理及存在的问题</h3><ol>
<li>动态分区存储管理技术</li>
<li>分区分配机构</li>
<li><p>分区分配与放置策略</p>
<ul>
<li>分区分配</li>
<li><p>放置策略</p>
<ul>
<li>按地址增加或减少的次序分类排序</li>
<li>按区的大小增加或减少的次序分类排序</li>
</ul>
<p>这样就形成了不同的选择空闲区的策略，称为放置策略。常见的有：</p>
<ul>
<li>首次匹配(首次适应算法)</li>
<li>最佳适应算法</li>
<li>最坏适应算法</li>
</ul>
</li>
</ul>
</li>
<li>碎片问题及拼接技术</li>
</ol>
<h3 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h3><ol>
<li>页式系统应解决的问题<ul>
<li>页式系统的地址映射</li>
<li>请调策略</li>
<li>放置策略</li>
<li>淘汰策略</li>
</ul>
</li>
<li>页式地址变换<ul>
<li>1) 页表</li>
<li>2) 虚地址结构</li>
<li>3) 页式地址变换</li>
<li>4) 联想存储器</li>
</ul>
</li>
<li>请调页面的机制<ul>
<li>扩充页表功能</li>
<li>缺页判断与处理</li>
</ul>
</li>
<li>淘汰机制与策略<ul>
<li>页面淘汰机制</li>
<li>置换算法</li>
<li>颠簸</li>
</ul>
</li>
<li>几种置换算法<ul>
<li>最佳算法(OPT算法)</li>
<li>先进先出淘汰算法(FIFO算法)</li>
<li>最久未使用淘汰算法(LRU, Least Recent Used算法)</li>
</ul>
</li>
</ol>
<h3 id="段式和段页式存储管理"><a href="#段式和段页式存储管理" class="headerlink" title="段式和段页式存储管理"></a>段式和段页式存储管理</h3><ol>
<li>段式地址结构</li>
<li>段式地址变换<br>段式地址变换的步骤如下：<ul>
<li>取出程序地址(s, w)</li>
<li>用s检索段表</li>
<li>如w&lt;0或w&gt;=L, 则主存越界</li>
<li>(b+w)即为所需主存地址</li>
</ul>
</li>
<li>扩充段表功能</li>
<li>段页式存储管理功能</li>
</ol>
]]></content>
      <categories>
        <category>science</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>operating system</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统四</title>
    <url>/2015/10/02/operatingSystem04/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><h3 id="设备管理概述"><a href="#设备管理概述" class="headerlink" title="设备管理概述"></a>设备管理概述</h3><ol>
<li>设备管理的功能<ul>
<li>状态跟踪</li>
<li>设备分配</li>
<li>设备控制</li>
</ul>
</li>
<li>设备独立性<ul>
<li>设备独立性概念</li>
<li>设备独立性的实现<ul>
<li>软通道实现设备独立性</li>
<li>通过指派命令实现设备独立性</li>
<li>逻辑设备描述器</li>
</ul>
</li>
<li>设备独立性的优点<ul>
<li>方便用户</li>
<li>提高设备的利用率</li>
<li>提高系统的可适应性和可扩展性</li>
</ul>
</li>
</ul>
</li>
<li>设备控制块<ul>
<li>设备控制块结构</li>
<li>命令转换表</li>
</ul>
</li>
</ol>
<a id="more"></a>
<h3 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h3><ol>
<li>缓冲概述<ul>
<li>什么是缓冲</li>
<li>利用缓冲技术进行I/O操作</li>
<li>缓冲技术解决的问题</li>
</ul>
</li>
<li>常用的缓冲技术<ul>
<li>双缓冲<ul>
<li>双缓冲用于数据输入</li>
<li>双缓冲用于数据输出</li>
</ul>
</li>
<li>缓冲池</li>
</ul>
</li>
<li>UNIX系统的缓冲区管理<ul>
<li>缓冲首部</li>
<li>队列结构<ul>
<li>空闲缓冲区队列</li>
<li>设备缓冲区队列</li>
</ul>
</li>
<li>缓冲管理算法<br>缓冲区管理总的思路分析如下：<ul>
<li>一个缓冲区被分配用于读/写某设备上的字符块时</li>
<li>当需要一个缓冲区时</li>
<li>当一个标有延迟写的缓冲区时移到空闲队列头时</li>
</ul>
</li>
</ul>
</li>
<li>缓冲区的检索<ul>
<li>分配一个缓冲区</li>
<li>释放一个缓冲区 </li>
</ul>
</li>
<li>读磁盘块和写磁盘块<ul>
<li>读磁盘块</li>
<li>写磁盘块</li>
</ul>
</li>
<li>高度缓存的优点和缺点<ul>
<li>优点<ul>
<li>提供了统一的磁盘存取方法</li>
<li>减少访盘次数</li>
<li>确保文件系统的完整性</li>
<li>简化用户程序</li>
</ul>
</li>
<li>缺点</li>
</ul>
</li>
</ol>
<h3 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h3><ol>
<li>设备分配概述<ul>
<li>静态分配和动态分配</li>
<li>I/O设备分配算法<ul>
<li>先请求先服务</li>
<li>优先级最高者优先</li>
</ul>
</li>
</ul>
</li>
<li>独享分配</li>
<li>共享分配</li>
<li>虚拟分配<ul>
<li>虚拟设备和虚拟分配</li>
<li>Spool(假脱机系统)</li>
<li>虚拟打印功能</li>
</ul>
</li>
</ol>
<h3 id="输入-输出控制"><a href="#输入-输出控制" class="headerlink" title="输入/输出控制"></a>输入/输出控制</h3><ol>
<li>输入/输出硬件<ul>
<li>端口(port)</li>
<li>总线(bus)</li>
<li>控制器(cobtroller)</li>
</ul>
</li>
<li>输入/输出控制方式<ul>
<li>循环测试I/O方式</li>
<li>I/O中断方式</li>
<li>通道方式</li>
<li>DMA方式</li>
</ul>
</li>
<li>输入/输出子系统<ul>
<li>输入/输出控制子系统概述</li>
<li>各类设备的接口<ul>
<li>块设备接口</li>
<li>主存映射接口</li>
<li>字符流设备接口</li>
<li>网络套接字接口</li>
</ul>
</li>
<li>输入/输出子系统功能<ul>
<li>解释用户的I/O系统调用</li>
<li>设备驱动</li>
<li>中断处理</li>
</ul>
</li>
<li>调用I/O核心模块的方式<ul>
<li>设备处理进程方式</li>
<li>文件操作方式</li>
</ul>
</li>
</ul>
</li>
<li>输入/输出控制的例子<ul>
<li>通用形式的系统调用<ul>
<li>1)实现使用设备的转换</li>
<li>2)合法性检查</li>
<li>3)形成I/O请求块，发消息给相应的设备处理进程</li>
</ul>
</li>
<li>设备处理进程</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>science</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>operating system</tag>
      </tags>
  </entry>
  <entry>
    <title>如何发表论文</title>
    <url>/2016/04/01/paperPublishing/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>逛学校论坛时看到网友xiaoyaoyou对于如何发SCI的看法, 觉得有参考价值, 就记录下来</p>
<h3 id="2-内容"><a href="#2-内容" class="headerlink" title="2. 内容"></a>2. 内容</h3><ol>
<li>多看看，同一领域内别人文章是怎么写的，怎么个思路、新颖在哪里，甚至是格式和每一部分的篇幅</li>
<li>多思考，平时有些想法就随时记录下来，方便整理</li>
<li>多尝试，想法多了，就多去试，找一些可行性高又能很方便模拟或者容易用简单方法实验的去试，多试试可能成功，或者有更新的点子出来，即使不成功，也可以在此基础上想改进</li>
<li>多交流，经常和导师、同学交流，导师经验更丰富些，和其他同学交流也可以给你很多提示，尤其是其他专业的同学，多交流也可以最大限度地避免自己陷入一个坑里</li>
<li>做实验的时候，有时一个人难以完成，适当请师弟师妹帮忙，请他们帮你一起完成实验，实验也会更顺利；写成论文时记得把他们的名字和所做的工作写上，即使是第三、第四作者，对他们多少也有帮助，他们也会很开心，于己于人都有好处</li>
<li>实验前尽量想得周全一些，多记录数据和图片<a id="more"></a></li>
<li>实验完成后，多做一些相关延伸部分的思考，比如实验分析、应用分析等等，都可以丰富在未来的论文里，这部分我觉得挺重要的，不亚于一个很好的想法</li>
<li>多搜索些SCI期刊的信息，选择契合文章内容而又性价比高的期刊有时候比写文章更重要，同时还需要综合考虑期刊每年的录用数目和回复速度</li>
<li>确定了期刊之后就搜索些之前的文章，模仿他们的写法（开头、结尾、中间每一部分的内容，甚至排版），仔细的编排图片以及文字</li>
<li>仔细对待审稿人的回复，如果需要修改或增加内容，不要怕麻烦，认认真真的把相应的内容加上，该补做实验的就抓紧时间补做</li>
</ol>
<h3 id="3-创新点问题"><a href="#3-创新点问题" class="headerlink" title="3. 创新点问题"></a>3. 创新点问题</h3><p>最重要的是要明确问题，针对问题描绘清楚模型，明确需求<br>研究的方向：提出新问题，或者是公共问题你提出更优的方法</p>
<blockquote>
<p>创新一：别人没用过的方法，你用了<br>创新二：别人没思考的角度，你看了<br>创新三：别人的参数或者分布不同<br>创新四：你的模型融合了好多个已有模型，取长补短<br>创新五：稍微把其它领域的知识使用一点，开辟了新的领域</p>
</blockquote>
]]></content>
      <categories>
        <category>science</category>
        <category>acadamic</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>journal</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统五</title>
    <url>/2015/10/06/operatingSystem05/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h3 id="文件系统概述"><a href="#文件系统概述" class="headerlink" title="文件系统概述"></a>文件系统概述</h3><ol>
<li>文件<ul>
<li>文件的定义与分类</li>
<li>文件名及文件属性</li>
</ul>
</li>
<li>文件系统<br>文件系统是操作系统中负责管理和存取文件信息的软件结构，它由负责文件操作和管理的程序模块、所需的数据结构(如目录表、文件控制块、存储分配表)以及访问文件的一组操作所组成</li>
<li>文件的组织<ul>
<li>文件组织的两种结构<ul>
<li>物理文件</li>
<li>逻辑文件</li>
</ul>
</li>
<li>逻辑记录和块<ul>
<li>逻辑记录</li>
<li>物理记录</li>
</ul>
</li>
</ul>
</li>
</ol>
<a id="more"></a>
<h3 id="文件的逻辑结构和存取方法"><a href="#文件的逻辑结构和存取方法" class="headerlink" title="文件的逻辑结构和存取方法"></a>文件的逻辑结构和存取方法</h3><ol>
<li>文件的逻辑结构<ul>
<li>流式文件</li>
<li>记录式文件</li>
</ul>
</li>
<li>文件的存取方法</li>
</ol>
<h3 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h3><ol>
<li>连续文件<ul>
<li>什么是连续文件</li>
<li>连续文件中存取记录的操作</li>
<li>连续文件的特点</li>
</ul>
</li>
<li>串联文件<ul>
<li>串联文件结构</li>
<li>文件映照结构</li>
</ul>
</li>
<li>索引文件<ul>
<li>直接索引</li>
<li>一级间接索引</li>
<li>二级间接索引</li>
</ul>
</li>
<li>文件物理结构比较</li>
</ol>
<h3 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h3><ol>
<li>空闲文件目录</li>
<li>空闲块链</li>
<li>位示图</li>
<li>分配策略</li>
</ol>
<h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><ol>
<li>文件目录及其内容<ul>
<li>什么是文件目录</li>
<li>文件目录及其内容</li>
</ul>
</li>
<li>以及文件目录及缺点</li>
<li>多级文件目录</li>
</ol>
<h3 id="共享与安全"><a href="#共享与安全" class="headerlink" title="共享与安全"></a>共享与安全</h3><ol>
<li>文件共享与安全性的关系</li>
<li>存取权限的类型及其验证<ul>
<li>访问控制矩阵</li>
<li>存取控制表</li>
<li>用户权限表</li>
<li>口令</li>
<li>密码</li>
</ul>
</li>
<li>用文件路径名加快文件的查找<ul>
<li>建立当前目录</li>
<li>链接技术</li>
</ul>
</li>
</ol>
<h3 id="文件操作与文件备份"><a href="#文件操作与文件备份" class="headerlink" title="文件操作与文件备份"></a>文件操作与文件备份</h3><ol>
<li>文件操作<ul>
<li>常用的文件操作命令</li>
<li>打开文件和关闭文件的操作</li>
</ul>
</li>
<li>文件备份</li>
</ol>
<h3 id="UNIX文件系统的主要结构和实现"><a href="#UNIX文件系统的主要结构和实现" class="headerlink" title="UNIX文件系统的主要结构和实现"></a>UNIX文件系统的主要结构和实现</h3><ol>
<li>UNIX文件系统的特点<ul>
<li>树型层次结构</li>
<li>可安装卸载的文件系统</li>
<li>文件是无结构的字符流式文件</li>
<li>UNIX文件系统把外部设备和文件目录作为文件处理</li>
</ul>
</li>
<li>UNIX系统的索引文件结构<ul>
<li>文件索引节点<ul>
<li>目录项</li>
<li>索引节点结构</li>
</ul>
</li>
<li>UNIX 7版本文件索引结构<ul>
<li>小型文件</li>
<li>大型文件</li>
<li>巨型文件</li>
</ul>
</li>
<li>UNIX system V的索引结构</li>
</ul>
</li>
<li>UNIX系统文件目录结构<ul>
<li>文件目录结构</li>
<li>文件目录结构中的勾链</li>
</ul>
</li>
<li>UNIX系统的打开文件机制<ul>
<li>活动节点表<ul>
<li>主存索引节点状态—反映主存索引节点的使用情况</li>
<li>设备号、索引节点号</li>
<li>引用计数</li>
</ul>
</li>
<li>系统打开文件表</li>
<li>用户文件描述符</li>
<li>用户文件描述符表、系统打开文件表与主存索引节点表的关系</li>
</ul>
</li>
<li>文件存储器空闲块的管理<ul>
<li>文件卷和卷管理块</li>
<li>空闲磁盘块的管理<ul>
<li>空闲盘块的分配</li>
<li>空闲盘块的释放</li>
</ul>
</li>
</ul>
</li>
<li>UNIX文件系统调用<ul>
<li>文件系统调用与底层算法的关系<ul>
<li>缓冲区分配算法</li>
<li>底层文件系统算法</li>
</ul>
</li>
<li>系统调用open</li>
<li>系统调用create</li>
<li>系统调用close</li>
<li>系统调用read</li>
<li>系统调用write</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>science</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>operating system</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统六</title>
    <url>/2015/10/22/operatingSystem06/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-进程同步和P、V操作"><a href="#1-进程同步和P、V操作" class="headerlink" title="1. 进程同步和P、V操作"></a>1. 进程同步和P、V操作</h3><p>若有三个并发进程互斥，如果利用信号灯方式控制其同步关系，那么三个进程的同步过程如下图：<br><img src="/images/operatingSystem06_1.png" alt="first"></p>
<h3 id="2-Linux系统功能调用的实现机制"><a href="#2-Linux系统功能调用的实现机制" class="headerlink" title="2. Linux系统功能调用的实现机制"></a>2. Linux系统功能调用的实现机制</h3><h4 id="2-1-Linux系统调用的进入"><a href="#2-1-Linux系统调用的进入" class="headerlink" title="2.1 Linux系统调用的进入"></a>2.1 Linux系统调用的进入</h4><p>Linux系统的软中断指令是汇编语言指令int 0x80，执行该指令会发生中断，处理机的状态由用户态自陷到内核态(在更新的芯片中添加了sysenter汇编语言指令等)。int 0x80指令使用的异常向量号是128(即16进制的80)，该异常向量包含了内核系统调用程序的入口地址。在内核初始化时，已将系统调用处理程序的入口地址送入向量128的中断描述符表表项中，设置段地址为内核开始的地方，段内偏移则指向系统调用处理程序system_call()。当应用程序请求操作系统服务，发出int 0x80指令时，就会从用户态自陷到内核态，并从system_call()开始执行系统调用处理程序。当系统调用处理完毕后，通过iret汇编语言指令返回到用户态。<br><a id="more"></a></p>
<h4 id="2-2-系统调用号和系统调用表"><a href="#2-2-系统调用号和系统调用表" class="headerlink" title="2.2 系统调用号和系统调用表"></a>2.2 系统调用号和系统调用表</h4><h5 id="2-2-1-系统调用号"><a href="#2-2-1-系统调用号" class="headerlink" title="2.2.1 系统调用号"></a>2.2.1 系统调用号</h5><p>在Linux中，每个系统调用被赋予一个唯一的系统调用号。用户空间的进程通过系统调用号指明要执行的具体系统调用<br>系统调用号定义在include/asm-i386/unistd.h头文件中，这个头文件定义了该系统所有的系统调用号。格式如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_restart_syscall   0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_exit              1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_fork              2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_read              3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_write             4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_open              5</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_mq_getsetattr     282</span></span><br></pre></td></tr></table></figure><br>该文件中的每一行表示为#define_NR_name NNN，其中，”_NR_”是一种约定，name为系统调用的名称，而NNN则是该系统调用对应的号码。该文件的最后，还定义了几个与系统调用相关的关键的宏。</p>
<h5 id="2-2-2-系统调用表"><a href="#2-2-2-系统调用表" class="headerlink" title="2.2.2 系统调用表"></a>2.2.2 系统调用表</h5><p>系统调用表记录了内核中所有已注册的系统调用，它是系统调用的跳转表，实际上是一个函数指针数组，表中依次保存所有系统调用的函数指针，以方便总的系统调用处理函数system_call进行索引。Linux系统调用表保存在arch/i386/kernel/下的entry.S中，其形式如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ENTRY(sys_call_table)</span><br><span class="line">.<span class="keyword">long</span> sys_restart_syscall       <span class="comment">/* 0 */</span></span><br><span class="line">.<span class="keyword">long</span> sys_exit                  <span class="comment">/* 1 */</span></span><br><span class="line">.<span class="keyword">long</span> sys_fork                  <span class="comment">/* 2 */</span></span><br><span class="line">.<span class="keyword">long</span> sys_read                  <span class="comment">/* 3 */</span></span><br><span class="line">.<span class="keyword">long</span> sys_write                 <span class="comment">/* 4 */</span></span><br><span class="line">.<span class="keyword">long</span> sys_open                  <span class="comment">/* 5 */</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">.<span class="keyword">long</span> sys_mq_getsetattr         <span class="comment">/* 6 */</span></span><br></pre></td></tr></table></figure><br>文件中有许多.long SYMBOL_NAME(sys_ni_syscall)的结构，”.”代表当前地址，”sys_call_table”代表数组首地址</p>
<h4 id="2-3-系统调用处理程序"><a href="#2-3-系统调用处理程序" class="headerlink" title="2.3 系统调用处理程序"></a>2.3 系统调用处理程序</h4><p>系统调用处理程序是system_call()，该函数的主要工作如下。</p>
<ul>
<li>通过宏SAVE_ALL保护异常处理程序中要用到的所有寄存器到寄存器到内核堆栈中，其中，指令地址和处理机状态已在中断进入过程中保护(eflags、cs、eip、ss、esp寄存器除外)</li>
<li>进行系统调用正确性检查，如对用户态进程传递来的系统调用号进行有效性检查，若该号大于或等于系统调用表的表项数，系统调用处理程序就终止</li>
<li>根据eax中所包含的系统调用号，调用其对应的服务例程</li>
<li>系统服务例程结束时，通过宏RESTORE_ALL恢复寄存器，最后通过iret指令返回</li>
</ul>
<h3 id="3-增加一个新的系统调用方法"><a href="#3-增加一个新的系统调用方法" class="headerlink" title="3. 增加一个新的系统调用方法"></a>3. 增加一个新的系统调用方法</h3><p>如果需要扩充Linux系统的功能，增加一个新的系统调用需要做的工作包括以下几个方面：</p>
<ul>
<li>描述新增加功能的服务例程</li>
<li>增加一个新的系统调用号</li>
<li>在系统调用表中登记新的系统调用号以及对应的服务例程</li>
<li>新增加的服务例程要被Linux系统接受，必须重新编译内核，生成新的包含新增服务例程的内核</li>
</ul>
<p>当要增加一个新的系统调用时，首先要确定新增的服务例程的名字，因为确定了这个名字后，在系统调用中的几个相关的名字也就确定了。如:</p>
<ul>
<li>新增加的系统调用名为mysyscall</li>
<li>系统调用的编号名字为_NR_mysyscall</li>
<li>内核中系统调用服务例程的名字为sys_mysyscall</li>
</ul>
<h4 id="3-1-添加新的服务例程"><a href="#3-1-添加新的服务例程" class="headerlink" title="3.1 添加新的服务例程"></a>3.1 添加新的服务例程</h4><p>编写新增的服务例程加到内核中去，即在/usr/src/linux/kernel/sys.c文件中增加一个新的函数，该函数的名字是sys_mysyscall。函数体内是新增加的功能描述，在Linux系统增加一个新的系统调用时，首先要保证整个控制过程正确，所以在开始调试时，新增功能尽量简单，如下例，其功能是返回一个整形值。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">int</span> <span class="title">sys_mycall</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-2-增加新的系统调用号"><a href="#3-2-增加新的系统调用号" class="headerlink" title="3.2 增加新的系统调用号"></a>3.2 增加新的系统调用号</h4><p>定义系统调用号，在文件include/asm-i386/unistd.h中添加一项<br><code>#define _NR_mysyscall XX</code><br>XX 为增加的系统调用号，此数字选一未用值，一般在已定义的系统调用号的最后增加一项，如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_restart_syscall    0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_exit                      1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_fork                     2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_read                    3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_write                   4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_open                   5</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_mq_getsetattr    282</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _NR_mysyscall            283</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-修改系统调用表"><a href="#3-3-修改系统调用表" class="headerlink" title="3.3 修改系统调用表"></a>3.3 修改系统调用表</h4><p>在文件/arch/i386/kernel/entry.S中的系统调用表 sys_call_table中添加新增的系统调用，sys_call_table数组包含指向内核中每个系统调用的指针，这样就在数组中增加了新的内核函数的指针。在清单最后添加一行。如下所示：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ENTRY(sys_call_table)</span><br><span class="line">.<span class="keyword">long</span> sys_restart_syscall       <span class="comment">/* 0 */</span></span><br><span class="line">.<span class="keyword">long</span> sys_exit                         <span class="comment">/* 1 */</span></span><br><span class="line">.<span class="keyword">long</span> sys_fork                        <span class="comment">/* 2 */</span></span><br><span class="line">.<span class="keyword">long</span> sys_read                       <span class="comment">/* 3 */</span></span><br><span class="line">.<span class="keyword">long</span> sys_write                      <span class="comment">/* 4 */</span></span><br><span class="line">.<span class="keyword">long</span> sys_open                      <span class="comment">/* 5 */</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">.<span class="keyword">long</span> sys_mq_getsetattr       <span class="comment">/* 6 */</span></span><br><span class="line">.<span class="keyword">long</span> sys_mysyscall               <span class="comment">/* 7 */</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-4-重新编译内核并启动新内核"><a href="#3-4-重新编译内核并启动新内核" class="headerlink" title="3.4 重新编译内核并启动新内核"></a>3.4 重新编译内核并启动新内核</h4><p>为使新的系统调用生效，需要重建Linux的内核。<br>对于不同的计算机配置、Linux不同的版本等，重新编译内核命令可能会有所不同。</p>
]]></content>
      <categories>
        <category>science</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>operating system</tag>
      </tags>
  </entry>
  <entry>
    <title>公共DNS</title>
    <url>/2015/09/08/publicDNS/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="各大公司提供的公共DNS"><a href="#各大公司提供的公共DNS" class="headerlink" title="各大公司提供的公共DNS"></a>各大公司提供的公共DNS</h3><h4 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h4><pre><code>8.8.8.8
</code></pre><h4 id="Alibaba"><a href="#Alibaba" class="headerlink" title="Alibaba"></a>Alibaba</h4><pre><code>223.5.5.5
223.6.6.6
</code></pre><h4 id="Baidu"><a href="#Baidu" class="headerlink" title="Baidu"></a>Baidu</h4><pre><code>180.76.76.76
</code></pre><h4 id="Tecent-DNSPod"><a href="#Tecent-DNSPod" class="headerlink" title="Tecent(DNSPod)"></a>Tecent(DNSPod)</h4><pre><code>119.29.29.29
</code></pre><h4 id="114DNS"><a href="#114DNS" class="headerlink" title="114DNS"></a>114DNS</h4><pre><code>114.114.114.114
114.114.115.115
</code></pre>]]></content>
      <categories>
        <category>techonology</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title>模式识别一</title>
    <url>/2015/08/16/patternRecognition01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-模式识别系统的构成"><a href="#1-模式识别系统的构成" class="headerlink" title="1. 模式识别系统的构成"></a>1. 模式识别系统的构成</h3><p><img src="/images/patternRecognition01_1.png" alt="first"><br>其中：</p>
<ul>
<li>分类器设计，为了把待识别模式分配到各自的模式类中去，必须设计出一套分类判别规则。基本做法是：用一定数量的样本（称为训练样本集）确定出一套分类判别规则，使得按照这套分类判别规则对待模式识别进行分类所造成的错误识别率最小或引起的损失最小。这就是分类器设计的过程。</li>
<li>分类决策，分类器按照已确定的分类判别规则对待识别模式进行分类判别，输出分类结果，这就是分类器的使用过程，也称为分类决策。</li>
</ul>
<a id="more"></a>
<h3 id="2-识别方法"><a href="#2-识别方法" class="headerlink" title="2. 识别方法"></a>2. 识别方法</h3><p>一般来说，描述模式有两种方法：定量描述和结构性描述，定量描述就是用一组数据来描述模式，结构性描述就是用一组基元来描述模式。对应于两种描述方法有两种基本的模式识别方法：</p>
<ul>
<li>统计模式识别：在统计模式识别中，被研究的模式用特征向量来描述，特征向量中的每一个元素代表模式中的一个特征或属性，特征向量构成的空间叫特征空间。如果我们用某种方法来分割特征空间，使得同一类模式大体上都在特征空间的同一区域，那么对于待分类的模式，就可以根据它的特征向量在特征空间中哪一个区域来判定它属于哪一类模式。研究统计模式识别方法的任务就是用不同的方法划分特征空间，从而达到识别的目的。</li>
<li>结构模式识别：此方法主要立足于分析模式的结构信息，由于模式是一些模式基元按一定的结构规则组合而成的，因此结构分析的内容就是分析模式如何由基元构成的规则。目前比较成功的是句法结构模式识别方法，它通过检查代表这个模式的句子是否符合事先给定的某一类文法规则，如果符合，那么这个模式就属于这个文法所代表的那个模式类。</li>
</ul>
]]></content>
      <categories>
        <category>science</category>
        <category>ai</category>
      </categories>
      <tags>
        <tag>pattern recognition</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 琐记二</title>
    <url>/2015/07/16/python02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-zip函数"><a href="#1-zip函数" class="headerlink" title="1. zip函数"></a>1. zip函数</h3><p>zip函数接受任意多个（包括0个和1个）序列作为参数，返回一个tuple列表<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">z = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">xyz = zip(x, y, z)</span><br><span class="line"><span class="keyword">print</span> xyz</span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>), (<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>), (<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>)]</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="2-写入wav-files"><a href="#2-写入wav-files" class="headerlink" title="2. 写入wav files"></a>2. 写入wav files</h3><p><a href="http://stackoverflow.com/questions/3637350/how-to-write-stereo-wav-files-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/3637350/how-to-write-stereo-wav-files-in-python</a></p>
<h3 id="3-矩阵转置"><a href="#3-矩阵转置" class="headerlink" title="3. 矩阵转置"></a>3. 矩阵转置</h3><p>可以用1中的zip函数 zip(*x)<br>一维数组的转置还可以<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">M=<span class="number">10</span></span><br><span class="line">k = np.array(range(M))</span><br><span class="line">k = np.matrix(k).T</span><br></pre></td></tr></table></figure></p>
<h3 id="4-复数表示"><a href="#4-复数表示" class="headerlink" title="4. 复数表示"></a>4. 复数表示</h3><blockquote>
<p>虚数i用j表示，且虚数系数是1时要在j前加上1，如 1+1j<br>math.exp(1+2j)会报错，can’t convert complex to float<br>应使用cmath.exp(1+2j) 或者 (math.e) ** (1+2j)</p>
</blockquote>
<h3 id="5-复数取模"><a href="#5-复数取模" class="headerlink" title="5. 复数取模"></a>5. 复数取模</h3><p>自以为是math.abs 或者 cmath.abs结果发现就是abs</p>
<h3 id="6-读取二维数组的第几列"><a href="#6-读取二维数组的第几列" class="headerlink" title="6. 读取二维数组的第几列"></a>6. 读取二维数组的第几列</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">[t[<span class="number">0</span>] <span class="keyword">for</span> t <span class="keyword">in</span> s]  <span class="comment">#这是第1列</span></span><br><span class="line">[t[<span class="number">1</span>] <span class="keyword">for</span> t <span class="keyword">in</span> s]  <span class="comment">#这是第2列</span></span><br><span class="line"></span><br><span class="line">list(zip(*s)[<span class="number">0</span>])  <span class="comment">#这是第1列</span></span><br><span class="line">list(zip(*s)[<span class="number">1</span>])  <span class="comment">#这是第2列</span></span><br></pre></td></tr></table></figure>
<p>以上两种方法均可以</p>
<h3 id="7-functools-partial"><a href="#7-functools-partial" class="headerlink" title="7. functools.partial"></a>7. functools.partial</h3><p>在map、reduce、filter里如果想传递多个参数给函数，可以查阅functools.partial的用法<br>简单来说就是能使函数用更少的参数进行调用，示例如下:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">add(<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line">plus3 = functools.partial(add, <span class="number">3</span>)</span><br><span class="line">plus5 = functools.partial(add, <span class="number">5</span>)</span><br><span class="line">plus3(<span class="number">4</span>)</span><br><span class="line"><span class="number">7</span></span><br><span class="line">plus3(<span class="number">7</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line">plus5(<span class="number">10</span>)</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>programming language</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Raspberry PI 3 折腾小记一</title>
    <url>/2016/04/09/raspberry01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>下载官方/第三方镜像压缩包, 解压, SD卡插入手机或其他读卡器, dd命令或者Win32DiskImager写入镜像, Over<br>之后将SD卡插入树莓派, 供电</p>
<h3 id="2-ssh连接"><a href="#2-ssh连接" class="headerlink" title="2. ssh连接"></a>2. ssh连接</h3><p>树莓派插上网线, 会自动联网分配一个ip, 可以通过路由器管理界面查看ip地址(如果网线接在路由器上)<br>之后<code>ssh pi@192.168.0.104</code> password:<code>raspberry</code>, 即可连接成功, 默认用户名密码参考<a href="https://github.com/raspberrypi/documentation/blob/master/remote-access/ssh/unix.md" target="_blank" rel="noopener">官方文档</a></p>
<p>官方文档还提到了很多其他远程连接方式, <a href="https://github.com/raspberrypi/documentation/tree/master/remote-access" target="_blank" rel="noopener">自行参考</a><br><a id="more"></a></p>
<h3 id="3-SD卡扩容"><a href="#3-SD卡扩容" class="headerlink" title="3. SD卡扩容"></a>3. SD卡扩容</h3><p>Kino安装的是raspbian-jessie-lite系统, 占有空间更小一点, 但是、、、<br>进入系统后<code>df -h</code>和<code>fdisk -l</code>, 发现16G的SD卡只显示了1.2G, 查找解决方案, 如下:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /sys/block/mmcblk0/mmcblk0p2/start  <span class="comment"># 查看第二分区的起始地址</span></span><br><span class="line">sudo fdisk /dev/mmcblk0                 <span class="comment"># 用fdisk对磁盘进行操作</span></span><br><span class="line"><span class="comment"># 以下步骤在fdisk的交互下操作</span></span><br><span class="line">d          <span class="comment"># 删除分区</span></span><br><span class="line">2          <span class="comment"># 选择删除第二分区</span></span><br><span class="line">n          <span class="comment"># 创建一个新分区</span></span><br><span class="line">p          <span class="comment"># 创建主分区</span></span><br><span class="line">2          <span class="comment"># 分区2</span></span><br><span class="line">131072     <span class="comment"># 第一个sector的地址, 填入刚刚得到的第二分区的起始地址</span></span><br><span class="line">31116287   <span class="comment"># 最后一个sector的地址, 使用默认值即可</span></span><br><span class="line">w          <span class="comment"># 将操作写入分区表</span></span><br><span class="line">sudo init 6             <span class="comment"># 重启系统</span></span><br><span class="line">df -h                   <span class="comment"># 查看发现存储大小没有变化</span></span><br><span class="line">fdisk -l                <span class="comment"># 可以显示14.8G空间了</span></span><br><span class="line">sudo resize2fs /dev/mmcblk0p2     <span class="comment"># 操作完成</span></span><br><span class="line">df -h                             <span class="comment"># 此时可以显示SD卡所有空间</span></span><br></pre></td></tr></table></figure></p>
<h3 id="4-root-权限"><a href="#4-root-权限" class="headerlink" title="4. root 权限"></a>4. root 权限</h3><p><code>sudo passwd root</code> 设置新密码即可<br>顺便允许root用户ssh登录<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line">找到 PermitRootLogin without-password 并注释</span><br><span class="line">添加</span><br><span class="line">PermitRootLogin yes</span><br><span class="line">service ssh restart   <span class="comment"># 重启ssh</span></span><br></pre></td></tr></table></figure></p>
<h3 id="5-连接Wifi"><a href="#5-连接Wifi" class="headerlink" title="5. 连接Wifi"></a>5. 连接Wifi</h3><p>不使用显示器, 想要连接到Wifi<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iwconfig               <span class="comment"># 查看无线接口名, 通常为wlan0</span></span><br><span class="line">ip link <span class="built_in">set</span> wlan0 up   <span class="comment"># 启动此接口服务</span></span><br><span class="line">iw dev wlan0 scan      <span class="comment"># 扫描无线网络</span></span><br><span class="line"><span class="comment"># iwlist wlan0 scan    # 该命令也可扫描</span></span><br><span class="line">iw dev wlan0 scan | grep -n <span class="string">'ssid'</span> <span class="comment"># 用你想要得到的ssid代替, 找到在多少行</span></span><br><span class="line">iw dev wlan0 scan | head -113 | tail -58  <span class="comment"># 截取一段显示</span></span><br></pre></td></tr></table></figure><br>找到或确认了自己的SSID之后, <code>wpa_passphrase your_ssid your_password</code>, 会生成<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">network&#x3D;&#123;</span><br><span class="line">  ssid&#x3D;&quot;your_ssid&quot;</span><br><span class="line">  #psk&#x3D;&quot;your_password&quot;</span><br><span class="line">  psk&#x3D;d262144b57c9bce488ca56cdc02344eefe62cb7705f9cea45747a55d022da722</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>vi /etc/wpa_supplicant/wpa_supplicant.conf</code><br>在末尾添加刚刚生成的内容<br>之后执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wpa_supplicant -i wlan0 -c /etc/wpa_supplicant/wpa_supplicant.conf &amp; <span class="comment"># 若失败根据提示执行 rm /var/run/wpa_supplicant/wlan0</span></span><br><span class="line">dhcpcd wlan0</span><br><span class="line">iwconfig      <span class="comment"># 确认连接成功</span></span><br></pre></td></tr></table></figure></p>
<p>或者每次都手动连接, 该方法未经测试<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig wlan0 up</span><br><span class="line">iwconfig wlan0 essid your_ssid key s:your_key   <span class="comment"># 不加s: 使用加密后的hex值</span></span><br><span class="line">dhclient wlan0</span><br><span class="line">ifconfig wlan0 down   <span class="comment"># 关闭Wifi</span></span><br></pre></td></tr></table></figure></p>
<h3 id="6-更改软件源"><a href="#6-更改软件源" class="headerlink" title="6. 更改软件源"></a>6. 更改软件源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># deb http://mirrordirector.raspbian.org/raspbian/ jessie main contrib non-free rpi</span></span><br><span class="line"><span class="comment"># Uncomment line below then 'apt-get update' to enable 'apt-get source'</span></span><br><span class="line"><span class="comment"># deb-src http://archive.raspbian.org/raspbian/ jessie main contrib non-free rpi</span></span><br><span class="line"></span><br><span class="line">deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ jessie main contrib non-free rpi</span><br><span class="line"><span class="comment"># Uncomment line below then 'apt-get update' to enable 'apt-get source'</span></span><br><span class="line"><span class="comment"># deb-src http://mirrors.ustc.edu.cn/raspbian/raspbian/ jessie main contrib non-free rpi</span></span><br></pre></td></tr></table></figure>
<p>查看中科大树莓派镜像说明, <a href="https://lug.ustc.edu.cn/wiki/mirrors/help/raspbian" target="_blank" rel="noopener">Here</a></p>
<h3 id="7-设置静态IP地址"><a href="#7-设置静态IP地址" class="headerlink" title="7. 设置静态IP地址"></a>7. 设置静态IP地址</h3><p>为了防止每次重启会获得不同的IP地址<br><code>vim /etc/dhcpcd.conf</code>, 对于有线网卡, 在末尾添加:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">interface eth0</span><br><span class="line">static ip_address=192.168.1.200/24      <span class="comment">#用CIDR的格式配置地址</span></span><br><span class="line">static routers-192.168.1.1              <span class="comment">#配置网关</span></span><br><span class="line">static domain_name_servers=192.168.1.1  <span class="comment">#这里配置域名服务器地址</span></span><br></pre></td></tr></table></figure><br>对于无线网卡, 在末尾添加:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">interface wlan0</span><br><span class="line">static ip_address=192.168.1.20/24</span><br><span class="line">static routers=192.168.1.1</span><br><span class="line">static domain_name_servers=119.29.29.29 8.8.8.8 8.8.4.4</span><br></pre></td></tr></table></figure></p>
<p>以下是较老版本系统或者未使用dhcpcd软件系统的配置:<br><code>vim /etc/network/interfaces</code><br>如果设置有线网卡地址:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iface eth0 inet static</span><br><span class="line">address 192.168.1.200   <span class="comment"># 设定的静态IP地址</span></span><br><span class="line">netmask 255.255.255.0   <span class="comment"># 网络掩码</span></span><br><span class="line">gateway 192.168.1.1     <span class="comment"># 网关</span></span><br></pre></td></tr></table></figure></p>
<p>若是无线网卡:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iface wlan0 inet static</span><br><span class="line">    wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf</span><br><span class="line">address 192.168.1.200 <span class="comment"># 设定的静态IP地址</span></span><br><span class="line">netmask 255.255.255.0 <span class="comment"># 网络掩码</span></span><br><span class="line">gateway 192.168.1.1   <span class="comment"># 网关</span></span><br><span class="line">network 192.168.1.1   <span class="comment"># 网络地址</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>raspberrypi</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 琐记一</title>
    <url>/2015/03/15/python01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-BOOL"><a href="#1-BOOL" class="headerlink" title="1. BOOL"></a>1. BOOL</h3><p>Python 中bool类型把数0看作false<br><code>bool(0)</code></p>
<h3 id="2-range"><a href="#2-range" class="headerlink" title="2. range"></a>2. range</h3><p>最常用的函数range，可传递1、2或3个参数，只有1个则是下边界，两个就是上下边界，三个则加上了步长。</p>
<a id="more"></a>
<h3 id="3-lambda"><a href="#3-lambda" class="headerlink" title="3. lambda"></a>3. lambda</h3><p>类似于函数式程序语言Lisp，Python提供了lambda<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x,y: x+y</span><br><span class="line"><span class="keyword">print</span> f(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><br>但是lambda功能有限，它只是一个表达式，不是一个语句，lambda会返回一个值，而不需要return，事实上使用了return就会出现语法错误<br>lambda实际上就是def的简化形式，但是它可以在列表等数据容器中出现</p>
<h3 id="4-map"><a href="#4-map" class="headerlink" title="4. map"></a>4. map</h3><p>map函数处理的是函数，它对一个List对象的每一项都调用了一个传递的函数，并返回一个包含所有调用结果的列表<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inc2times</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+x;</span><br><span class="line">r = map(inc2times,l)</span><br><span class="line"><span class="keyword">print</span> r</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> map(<span class="keyword">lambda</span> x: x+x, l)</span><br></pre></td></tr></table></figure></p>
<h3 id="5-函数式编程"><a href="#5-函数式编程" class="headerlink" title="5. 函数式编程"></a>5. 函数式编程</h3><p>python事实上完全支持函数式编程，函数即对象，这与JavaScript一致，函数可以作为对象来传递、调用，被作为列表的元素等</p>
<h3 id="6-嵌套函数的作用域"><a href="#6-嵌套函数的作用域" class="headerlink" title="6. 嵌套函数的作用域"></a>6. 嵌套函数的作用域</h3><p>嵌套的函数对自己的局部作用域，包含自己模块的全局作用域以及内置的名字作用域有访问权，它对包含自己的函数的作用域无访问权。无论多深的函数嵌套都只能看见三个作用域。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(i)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> i</span><br><span class="line">        <span class="keyword">if</span>(i):</span><br><span class="line">            innenr(i<span class="number">-1</span>)</span><br><span class="line">    inner(x)</span><br><span class="line"></span><br><span class="line">outer(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><br>上述代码就会语法出错。</p>
<h3 id="7-name"><a href="#7-name" class="headerlink" title="7. name"></a>7. <strong>name</strong></h3><p>每一个模块都有一个内置属性<strong>name</strong><br>如果文件作为程序运行，在启动时，<strong>name</strong>设置为字符串<strong>main</strong><br>如果文件是被导入的，<strong>name</strong>设置为用户已知的模块名</p>
<h3 id="8-site-packages和disk-packages的区别"><a href="#8-site-packages和disk-packages的区别" class="headerlink" title="8.site-packages和disk-packages的区别"></a>8.site-packages和disk-packages的区别</h3><blockquote><br>dist-packages is a Debian-specific convention that is also present in its derivatives, like Ubuntu. Modules are installed to dist-packages when they come from the Debian package manager into this location:<br>/usr/lib/python2.7/dist-packages<br>Since easy_install and pip are installed from the package manager, they also use dist-packages, but they put packages here:<br>/usr/local/lib/python2.7/dist-packages<br>From the Debian Python Wiki:<br>dist-packages instead of site-packages. Third party Python software  installed from Debian packages goes into dist-packages, not  site-packages. This is to reduce conflict between the system Python,  and any from-source Python build you might install manually.<br>This means that if you manually install Python from source, it uses the site-packages directory. This allows you to keep the two installations separate, especially since Debian and Ubuntu rely on the system version of Python for many system utilities.<br></blockquote>


<h3 id="9-中文注释"><a href="#9-中文注释" class="headerlink" title="9. 中文注释"></a>9. 中文注释</h3><p>在Linux中Python代码中加入中文注释提示编码错误，解决方案：<br>文件头加入<code># coding:utf-8</code></p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>programming language</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Raspberry PI 3 折腾小记二</title>
    <url>/2016/04/09/raspberry02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-安装Java"><a href="#1-安装Java" class="headerlink" title="1. 安装Java"></a>1. 安装Java</h3><p>安装的raspbian-jessie-lite系统没有自带Java<br><code>apt-get install oracle-java7-jdk</code></p>
<h3 id="2-安装tomcat7"><a href="#2-安装tomcat7" class="headerlink" title="2. 安装tomcat7"></a>2. 安装tomcat7</h3><p>出现Size mismatch<br><code>wget http://mirrors.ustc.edu.cn/raspbian/raspbian/pool/main/j/java-common/java-common_0.52_all.deb</code><br><code>dpkg -i java-common_0.52_all.deb</code><br>再次<code>apt-get install tomcat7</code><br><a id="more"></a><br>安装成功提示:</p>
<blockquote>
<p>Creating config file /etc/default/tomcat7 with new version<br>Adding system user <code>tomcat7&#39; (UID 109) ...
Adding new user</code>tomcat7’ (UID 109) with group <code>tomcat7&#39; ...
Not creating home directory</code>/usr/share/tomcat7’.<br>Creating config file /etc/logrotate.d/tomcat7 with new version</p>
</blockquote>
<p><code>vim /etc/tomcat/server.xml</code> 修改默认webapp位置, <code>mv /var/lib/tomcat7/webapps new_loc</code></p>
<p>解压war包<code>jar xvf some.war</code>, 将解压出的内容<code>mv * ROOT</code>, 即可根目录访问</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>raspberrypi</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记二</title>
    <url>/2013/04/29/reading02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-Preface"><a href="#1-Preface" class="headerlink" title="1. Preface"></a>1. Preface</h3><p>From <em>Of Human Bondage(Part)</em> writen by W. Somerset Maugham</p>
<h3 id="2-Content"><a href="#2-Content" class="headerlink" title="2. Content"></a>2. Content</h3><blockquote>
<p>It is an illusion that youth is happy, an illusion of those who have lost it; but the young know they are wretched for they are full of the truthless ideal which have been instilled into them, and each time they come in contact with the real, they are bruised and wounded. It looks as if they were victims of a conspiracy; for the books they read, ideal by the necessity of selection, and the conversation of their elders, who look back upon the past through a rosy haze of forgetfulness, prepare them for an unreal life. They must discover for themselves that all they have read and all they have been told are lies, lies, lies; and each discovery is another nail driven into the body on the cross of life.</p>
</blockquote>
]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>novel</tag>
        <tag>motto</tag>
      </tags>
  </entry>
  <entry>
    <title>postgreSQL</title>
    <url>/2016/03/23/postgresql/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>以前只用过数据库MySQL和Rails自带的sqlite3, 最近打算在一个项目里使用postgreSQL, 简要记录下。</p>
<h3 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h3><p>去<a href="http://www.postgresql.org/download/" target="_blank" rel="noopener">官网</a>找对应版本下载, 不喜欢exe文件,感觉不在可控范围内, 于是下载了zip版本</p>
<p>解压之后, 设置路径:<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">path</span> = <span class="variable">%path%</span>;D:\Programs\pgsql\bin</span><br><span class="line"><span class="built_in">set</span> pghost=localhost</span><br><span class="line"><span class="built_in">set</span> pglib=D:\Programs\pgsql\lib</span><br><span class="line"><span class="built_in">set</span> pgdata=D:\Programs\pgsql\data</span><br></pre></td></tr></table></figure><br><a id="more"></a><br>在解压目录下<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir data</span><br><span class="line"><span class="built_in">cd</span> data</span><br><span class="line">initdb .</span><br></pre></td></tr></table></figure></p>
<p>成功之后console会显示:</p>
<blockquote>
<p>WARNING: enabling “trust” authentication for local connections. You can change this by editing pg_hba.conf or using the option -A, or –auth-local and –auth-host, the next time you run initdb.</p>
<p>Success.</p>
<p>You can now start the database server using: “pg_ctl” -D “.” -l logfile start</p>
</blockquote>
<p>按照提示,<code>pg_ctl.exe -D . -l logfile start</code>, 显示 “server starting”, 若要停止, <code>pg_ctl.exe -D . stop</code><br>注意若不在安装目录下, 则将上述 . 改为data的绝对/相对路径</p>
<h3 id="3-注册为Windows服务"><a href="#3-注册为Windows服务" class="headerlink" title="3. 注册为Windows服务"></a>3. 注册为Windows服务</h3><p><code>pg_ctl.exe register -N postgreSQL -D .</code><br>注册成为服务后, <code>net start postgreSQL</code>即可</p>
<h3 id="4-用户权限"><a href="#4-用户权限" class="headerlink" title="4. 用户权限"></a>4. 用户权限</h3><p>之后运行postgres.exe会告诉你不能使用管理员权限登录, 故:<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> user postgres your_password /add</span><br><span class="line">runas /user:postgres <span class="built_in">cmd</span>.exe    # 我用的是cmder.exe</span><br></pre></td></tr></table></figure><br>之后可以通过<code>whoami</code>查询运行该程序的当前用户</p>
<h3 id="5-目录设置"><a href="#5-目录设置" class="headerlink" title="5. 目录设置"></a>5. 目录设置</h3><p>再次运行 postgres.exe, 发现提示<strong>You must specify the –config-file or -D invocation option or set the PGDATA environment variable.</strong><br>再次<code>set pgdata=D:\Programs\pgsql\data</code></p>
<h3 id="6-用户不存在"><a href="#6-用户不存在" class="headerlink" title="6. 用户不存在"></a>6. 用户不存在</h3><p>提示此错误, <code>role &quot;postgres&quot; does not exist</code>, 因为我们最开始initdb是在默认账户下,应当runas postgres之后再initdb</p>
<h3 id="7-运行"><a href="#7-运行" class="headerlink" title="7. 运行"></a>7. 运行</h3><p>重启一下服务, 运行psql.exe即可<br>或者不启动服务,直接postgres.exe, 再另开一个窗口执行psql.exe, 执行\?可以得到帮助</p>
<h3 id="8-操作"><a href="#8-操作" class="headerlink" title="8. 操作"></a>8. 操作</h3><p>注意windows下大多数操作关键字前面都有”\”<br>之后查看文档, 运行一些操作, 如:<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">database</span> hlademo;  <span class="comment"># 创建数据库, 或使用createdb命令</span></span><br><span class="line">\l                        <span class="comment"># 列出所有数据库</span></span><br><span class="line">\c hlademo;               <span class="comment"># 连接到数据库</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> [ <span class="keyword">IF</span> <span class="keyword">EXISTS</span> ] hlademo;  <span class="comment"># 删除数据库,也可以使用dropdb</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tank(</span><br><span class="line">  <span class="keyword">ID</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">NAME</span> <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="built_in">time</span> <span class="built_in">TEXT</span></span><br><span class="line">);                        <span class="comment"># 创建表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> tank;          <span class="comment"># 删除表</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tank(<span class="keyword">ID</span>,<span class="keyword">name</span>,<span class="built_in">time</span>) <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">'apollo'</span>, <span class="string">'20160323'</span>); <span class="comment"># 插入, 注意用单引号</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tank;       <span class="comment"># 查询表</span></span><br></pre></td></tr></table></figure></p>
<h3 id="9-其他命令"><a href="#9-其他命令" class="headerlink" title="9. 其他命令"></a>9. 其他命令</h3><p>模式(schema)实际上一个命名表的集合。也可以包含一个schema视图、索引、序列、数据类型、运算符和函数。Schema是满足类似于在操作系统级别的目录,但该模式不能嵌套。CREATE SCHEMA PostgreSQL语句创建一个模式(schema)<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">schema</span> enemy;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> enemy.missile (</span><br><span class="line">  <span class="keyword">ID</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">NAME</span> <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="built_in">time</span> <span class="built_in">TEXT</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> enemy.missile;</span><br></pre></td></tr></table></figure></p>
<h3 id="10-修改密码"><a href="#10-修改密码" class="headerlink" title="10. 修改密码"></a>10. 修改密码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su - postgres -c psql</span><br><span class="line">ALTER USER <span class="string">"user_name"</span> WITH PASSWORD <span class="string">'new_password'</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>postgresql</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记三</title>
    <url>/2013/06/20/reading03/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-Preface"><a href="#1-Preface" class="headerlink" title="1. Preface"></a>1. Preface</h3><p>From <em>The storied life of A.J.Fikry</em> by Gabrielle Zevin. <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[The Storied Life of A. J. Fikry](https://book.douban.com/subject/25888148/)
">[1]</span></a></sup></p>
<a id="more"></a>
<h3 id="2-Content"><a href="#2-Content" class="headerlink" title="2. Content"></a>2. Content</h3><blockquote>
<ol>
<li>You shouldn’t look a gift horse in the mouth.</li>
<li>The tough rose mouth says no one can hurt me, but the soft blue eyes say Yes you can and you probably will. And he had made that big dandelion of a girl cry.</li>
<li>A.J. had found the reverent tone of the eulogies to be insufferable.</li>
<li>She runs her fingers through her short hair.</li>
<li>Ismay has chosen a collage because she had liked the pictures in the brochure, had married a man because he looked splendid in a tuxedo, and had started teaching because she’d seen a movie about a inspirational teacher.</li>
<li>she was young and beautiful, which makes her death a tragedy. she was poor and black, which means people say they saw it coming.</li>
<li>“it’s about a detective. but it moves kind of slow, and most things go unsolved, but then i thought, that’s how life is, that’s how the job really is.”<br>“there’s a sequel.”A.J informs him.</li>
<li>villains get punished, good guys triumph.</li>
<li>You think child is enough, but child grows old. You think work is enough, but work is not warm body.</li>
<li>Sales reps come to town with their summer offerings, and A.J. goes out of his way to be hospitable to them.</li>
<li>A.J. mimes the universal gesture for toking up.</li>
<li>No one travels without purpose. Those who are lost wish to be lost.</li>
<li>It is the secret fear that we are unlovable that isolates us, but it is only because we are isolated that we think we are unlovable. Someday, you do not know when, you will be driving down a road. And someday, you do not know when, he, or indeed she, will be there. You will be loved because for the first time in your life, you will truly not be alone. You will have chosen to not be alone.</li>
<li>For instance, two out of the three finalists were women, which might have tipped the scales toward the male.</li>
</ol>
</blockquote>
<h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h3><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)"><a href="https://book.douban.com/subject/25888148/" target="_blank" rel="noopener">The Storied Life of A. J. Fikry</a><a href="#fnref:1" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>novel</tag>
        <tag>motto</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记一</title>
    <url>/2013/03/06/reading01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>摘自梁漱溟的《朝话:人生的省悟》<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[朝话:人生的省悟](https://book.douban.com/subject/1320925/)
">[1]</span></a></sup></p>
<a id="more"></a>
<h3 id="2-内容"><a href="#2-内容" class="headerlink" title="2. 内容"></a>2. 内容</h3><blockquote>
<p>在这个时代的青年，能够把自己安排对了的很少。</p>
<p>在这个时代，有一个大的欺骗他，或耽误他，容易让他误会，或让他不留心的一件事，就是把欲望当志气。</p>
<p>也许他很卖力气，却很不自然，很苦，且难以长进，因为背后存个贪的心，虽有时也会起一个大的反动，也许勉强干。但当自己勉强自己时，读书做事均难入，无法全副精神放在事情上。甚且会自己搪塞自己。</p>
<p>越聪明的人，越容易有欲望，越不知应在哪个地方搁下那个心。心实在应该搁在当下的。可是聪明的人，老是搁不在当下，老往远处跑，烦躁而不宁。所以没有志气的固不用说，就是自以为有志气的，往往不是志气而是欲望。仿佛他期望自己能有成就，要成功怎么个样子，这样不很好吗？无奈在这里常藏着不合适的地方，自己不知道。自己越不宽松，越不能耐，病就越大。所以前人讲学，志气欲望之辩很严，必须不是从自己躯壳动念，而念头真切，才是真志气。张横渠先生颇反对欲望，谓民胞物与之心，时刻不能离的。自西洋风气进来，反对欲望的话没人讲，不似从前的严格，殊不知正在这些地方，是自己骗自己害自己。</p>
</blockquote>
<h3 id="3-琐言"><a href="#3-琐言" class="headerlink" title="3. 琐言"></a>3. 琐言</h3><p>初次看到这段话的时候觉得梁老好像是在针对Kino一样，说的太准确让Kino害怕去相信。对于Kino来说，欲望就是金钱，一切都向钱看，学什么做什么都习惯用金钱去衡量，哪怕是考虑未来，也是在考虑未来能挣到多少钱。后来发现，并不是只有Kino，周围很多人都是这样，这应该是存在些共性原因的。</p>
<ul>
<li>一是客观的家庭环境影响。把金钱放在第一位的人，很大一部分应该是小时候家庭环境不好的，所谓穷山恶水出刁民，Kino的生活环境与此有相似之处，所以也还算有所感触。一个人小时候若是生活艰苦了，自然会更羡慕那些经济宽松的人，希望自己也能得到同样的东西。有这种想法的孩子所做的行为却大相径庭，那些父母口中懂事的孩子，会明白父母的难处，对自己的行为束手束脚，也会容易陷入自卑，不怎么愿意交朋友；那些缺少监护人教育的，和彼此情况相似的孩子抱成一团的，因此而聚众欺负更加弱小的孩子，以此获得满足感；那些更加弱小的孩子，父母也不在身边，没有强有力的关爱，因而陷入违法犯罪行为的也有不少；那些和家境较好的孩子们玩在一起的，接触到更多不属于他的家庭环境他的年龄应该接触到的东西，往往会吵着闹着让父母买一些父母难以承受之物，若是得手，再将这些东西拿到家境困难的孩子中炫耀，懂事的孩子们会感觉到一丝心酸，却不会张口要买，聚众混混们会要求更加弱小的孩子买给他们，弱小的孩子们不敢向父母张口，只好去行偷窃之事。这样说并不是想要贬低任何一方，这里所有的人都是一个悲剧，你说穷山恶水出刁民，Kino无法反驳，能在这种环境中出人头地的能有几个呢，这些人可以被骂，但是不可以被嘲笑，你永远不知道一个人苦苦维持的自尊心会在什么时候破碎，情绪会在什么时候崩溃。无论怎样，一个人小时候若是缺乏什么，他长大就越想追求什么，所以家庭环境的影响是无法排除的。</li>
<li>二是媒体的宣传导向和社会的价值观取向所带来的影响。学校、企业、政府机关中总是有领导阶级的人喜欢拿今人与古人做比较，对今人的一切向钱看的思维批判一番，有时候媒体也喜欢这样批判。但Kino觉得这是没有道理的，今人对金钱的疯狂崇拜，很大一部分也是媒体的宣传所带来的，总是把财富值是多少当作成功的标志，然后反过来再说普通人追求财富没有情怀，这简直就是无理取闹。在这样的社会背景下，孩子在很小的时候就被灌输了财富的多少决定成功的观念，父母也是以子女财富多为骄傲，父母一辈间的交流就是孩子的工资、车、房，这样的社会很难让人坚守本心。所以说媒体的宣传和因此导致的社会价值取向的影响很大。</li>
<li>三是政策变化带来的社会阶级变化。Kino在读近代史时，会发现那个时代的风云人物有不少却是出身寒门，这种时代差异性实在太过巨大，民国时期社会处于动荡变革之中，每个人的生活都可能发生巨变，人们可能更多的是求生存，而少了一些其他的追求，到了抗战和新中国刚成立时，共产党做的是打土豪劣绅，进行土地改革，这个时候敛财者刚被打下去，大家的生活都很差不多，整个社会也是农民居多，又是吃大锅饭，个体缺少了追求财富的权力，自然与现在的社会不同。到了改革开放之后，个人拥有财富不再被当作资本主义毒瘤了，贫富分化渐渐明显了，社会阶级的流动十分迅速，很多人看到了机会，通过把握改革开放的红利迅速实现阶级上升，加之上述提到的媒体宣传，对这些成功者的崇拜，释放了被压抑许久的国人的追求个人财富的心性，然而成功者毕竟是少数。这时候成长起来的人就是Kino的父母一辈了，再通过他们向下释放信号，使孩子们从小就认识到了阶级性，在长大之后，看到光怪陆离的社会，没有人脉关系没有父母财富积累的人只能追求财富以实现阶级上升，而这条上升之路又没有完全封死，使人们还有一点希望，从而在追求财富中度过了自己的青春。</li>
<li>最后是人性的固有影响。人的本性总是想要活得轻松的，而财富自由就是实现轻松生活的最明确的答案，人们追求金钱也不奇怪了，当然这一点和人们想要寻求阶级上升其实是相似的。</li>
</ul>
<p>即使说了这么多汲汲于追求金钱的原因，但还是有很多人有自己的想法与追求，除却父母已经有积累的，社会环境相同，社会舆论相同，家庭经济环境相同的人，依然有很多不把金钱放在第一顺位，这些人可以说是极为幸运的，他们遇到了好的父母、好的老师、好的同学，Kino也算是半个幸运儿吧。</p>
<p>说了这些，虽说把财富当欲望这种事有种种原因，也难以避免，但再看梁老的这段话，说的却仍是正中要害，把欲望当志气，想要致富想要改变阶级的欲望，无时无刻不在脑海中环绕，这样的想法在一定程度上会摧残一个人的意志，具体到学术/技术上，会使人盲目追求各种热点，而无法在一个方向沉下来，心不静则神不宁，梁老说越是聪明的人越是有欲望也没错，不过是Kino这种小聪明而无大才的，真有智商超群的无论做多少件事也能成功。这种把欲望当志气的想法也会带来思维的局限性，看待社会中的很多事容易陷入死胡同。说彻底改变自己的想法太过决绝，也难以实现，只能希望以后自己在学习生活中，除却陷入对未来的恐慌，更多一丝人情味。</p>
<h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h3><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)"><a href="https://book.douban.com/subject/1320925/" target="_blank" rel="noopener">朝话:人生的省悟</a><a href="#fnref:1" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>motto</tag>
        <tag>梁漱溟</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记四</title>
    <url>/2013/07/16/reading04/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-Preface"><a href="#1-Preface" class="headerlink" title="1. Preface"></a>1. Preface</h3><p>From <em>Waiting for godot</em> by Samuel Beckett.<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[Waiting for Godot](https://book.douban.com/subject/1419152/)
">[1]</span></a></sup></p>
<a id="more"></a>
<h3 id="2-Content"><a href="#2-Content" class="headerlink" title="2. Content"></a>2. Content</h3><blockquote>
<p>It’s so we won’t think.<br>We have that excuse.<br>It’s so we won’t hear.<br>We have our reasons.<br>All the dead voices.<br>They make a noise like wings.<br>Like leaves.<br>Like sand.<br>Like leaves.<br>They all speak at once.<br>Each one to itself.<br>Rather they whisper.<br>They rustle.<br>They murmur.<br>They rustle.<br>What do they say?<br>They talk about their lives.<br>To have lived is not enough for them.<br>They have to talk about it.<br>To be dead is not enough for them.<br>It is not sufficient.<br>They make a noise like feathers .<br>Like leaves.<br>Likes ashes.<br>Like leaves.</p>
</blockquote>
<h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h3><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)"><a href="https://book.douban.com/subject/1419152/" target="_blank" rel="noopener">Waiting for Godot</a><a href="#fnref:1" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>novel</tag>
        <tag>motto</tag>
        <tag>drama</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记六</title>
    <url>/2013/12/17/reading06/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-Preface"><a href="#1-Preface" class="headerlink" title="1. Preface"></a>1. Preface</h3><p>From <em>The Wise King</em> by Kahlil Gibran</p>
<h3 id="2-Content"><a href="#2-Content" class="headerlink" title="2. Content"></a>2. Content</h3><blockquote>
<p>从前，一位威严而聪明的国王统治着远方的维兰尼城。他的威严使人敬畏，他的智慧令他倍受爱戴。 </p>
<p>市中心有一口水井，井水清洌透澈，全城居民都从这口水井中汲水饮用，即使国王与大臣也不例外，因为这是城中唯一的一口井。 </p>
<p>一天夜里，当大地万物都沉沉睡去，一个女巫进入城中，在井中点下七滴魔液，然后说：从现在起，凡喝了这井水的人就会发疯。 </p>
<p>第二天清晨，除了国王和侍卫，所有居民都喝了这井里的水，正如女巫预言的那样，全都变成了疯人。 </p>
<p>这一天，狭窄的街道上，市场中，人们都在窃窃私语，除此以外甚么事情也不做：“国王疯了，我们的国王与侍卫都失去了理智！我们不能让一个疯国王统治国家，我们必须废黜他。”</p>
<p>这天晚上，国王命人从井里汲来满满的一金杯水。水一送到，国王便大喝了一口，然后把剩下的水赏与侍卫。 </p>
<p>于是遥远的维兰尼城热烈欢庆，因为他们的国王及其侍卫又恢复了理智。</p>
</blockquote>
]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>poetry</tag>
        <tag>kahlil gibran</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记五</title>
    <url>/2013/09/16/reading05/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-Preface"><a href="#1-Preface" class="headerlink" title="1. Preface"></a>1. Preface</h3><p>From <em>A song of ice and fire</em></p>
<a id="more"></a>
<h3 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h3><blockquote>
<ol>
<li>fear filled his gut like a meal he could not digest.</li>
<li>Ser Waymar was panting from the effort now, his breath steaming in the moonlight.</li>
<li></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>novel</tag>
        <tag>motto</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记十</title>
    <url>/2017/11/12/reading10/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>被<em>梁启超致徐志摩函</em>里的几句话启发了, 就找了找原文. 原文颇难寻, <em>饮冰室合集</em><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[饮冰室合集](https://zh.wikipedia.org/wiki/%E9%A5%AE%E5%86%B0%E5%AE%A4%E5%90%88%E9%9B%86)
">[1]</span></a></sup>应该是有的, 只是太过厚重网上无资源, Kino网上搜索后在<em>爱眉小札-志摩日记、书信集</em><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[爱眉小札-志摩日记、书信集](https://read.douban.com/ebook/10325492/)
">[2]</span></a></sup>找到了.<br>不过也因此想读读梁公的文章, 还将粱公所云<strong>以今日之我与昨日之我战</strong>作为Kino新的签名. 查阅资料了解到<em>饮冰室合集</em><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[饮冰室合集](https://zh.wikipedia.org/wiki/%E9%A5%AE%E5%86%B0%E5%AE%A4%E5%90%88%E9%9B%86)
">[1]</span></a></sup>是最全的, 可是太长必然没法看完吧, 看到还有<em>饮冰室文集</em><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[饮冰室文集](https://zh.wikipedia.org/wiki/%E9%A5%AE%E5%86%B0%E5%AE%A4%E6%96%87%E9%9B%86)
">[3]</span></a></sup>, 较短, 就找了Kindle版本的来看.</p>
<a id="more"></a>
<h3 id="1-梁启超致徐志摩函"><a href="#1-梁启超致徐志摩函" class="headerlink" title="1. 梁启超致徐志摩函"></a>1. 梁启超致徐志摩函</h3><p>嘛, 这一篇不是<em>饮冰室文集</em>里的, 虽然文集里的文章气势磅礴的多, 思想深刻的也有, 此时此刻Kino却最爱粱公这篇<em>梁启超致徐志摩函</em>.</p>
<blockquote>
<p>君劢濒行之前两夕，语及弟事，令吾颇起异感。吾昔以为吾弟与夫人(此名或不当，但吾愿姑用之)实有不能相处者存，故不忍复置一词。今闻弟归后尚通信不绝，且屡屡称誉，然则何故有畴昔之举？真神秘不可思议矣。吾初又疑弟亦如君劢然，喜作独身生活，今据劢所云，似又不然，吾益用迷惑。兹事自非局外人所能参末议，然以吾与弟之交，有两事不能为弟忠告者：其一，人类恃有同情心以自贵于万物，义不容以他人之苦痛易自己之快乐，弟之此举，其以弟将来之快乐能得与否，殆茫如捕风，然先已予多数人以无量之苦痛，重闱之悲诧，微，君劢言吾亦可以推想得之，君劢家之老人，当亦同兹感。夫人或与弟同怀抱所痛灭杀(？)然最难堪者两儿，弟既已育之，胡能置之，兹事恐弟将终身受良心上之重罚无以自宁也。其二，恋爱神圣为今之少年所最乐道，吾于兹义固不反对，然吾以为天下神圣之事亦多矣，以兹事为唯一之神圣，非吾之所敢闻，且兹事尽可遇而不可求，非可谓吾欲云云即云云也。况多情多感之人，其幻象起落鹘突，而得满足得宁贴也极难，所梦想之神圣境界，恐终不可得，徒以烦恼终其身已耳。呜呼。志摩，天下岂有圆满之宇宙若尔尔者？孔子赞易无取，以未济终矣，当知吾侪以不求圆满为生活态度。斯可以领略生活之妙味矣。吾以为人类对于两性间相互最好是以“无着落”之态度行之(君劢最能如此，吾亦颇如此。)，则最少亦可以减无量苦痛。吾固知弟为富于情感之人，未易语此，然吾自审吾之情感并不视弟为贫弱，吾固有与弟言此之资格也。呜呼。志摩，当知人生树立甚难，消磨甚易，如志摩之年，实一生最可贵之时期，亦最危险之时期也，若沉迷于不可必得之梦境，挫折数次，生意尽矣，郁邑侘傺以死，死为无名；死犹可也，最可畏者，不死不生，而堕落至不复能自拔，呜呼。志摩，可无愧耶!可无惧耶!吾与志摩相处之日殊浅，吾所虑者或皆不衷于事实，然吾之爱惜吾志摩者至厚，自闻君劢言后，耿耿于中，无一时能释。顷辍课来沪，夜中思此，不复成寐，披衣起，作此数纸。或非志摩所乐闻，然吾终望志摩知我对志摩用情之深，虽今日不寝，终有日能寝也。旬日后即北归，当约志摩就我，再罄其怀抱耳。惓惓之极，不尽欲言，专上<br>志摩爱弟<br>启超  一月二日夜三时上海沧洲旅馆<br>《政治思想史》全部脱稿矣，甚盼，弟能迻译也。</p>
</blockquote>
<p>若谈及为何此时此刻最爱这篇信件, 主要是因为这篇信的背景和粱公关于恋爱的论述.<br>彼时, 徐志摩已与张幼仪离婚, 正与林徽因爱恋, 这时粱公写了这封信给徐志摩, 随后徐志摩的回信中有那句著名的<strong>得之我幸,不得我命</strong><br>通篇最喜<strong>其二，恋爱神圣为今之少年所最乐道，吾于兹义固不反对，然吾以为天下神圣之事亦多矣，以兹事为唯一之神圣，非吾之所敢闻，且兹事尽可遇而不可求，非可谓吾欲云云即云云也。况多情多感之人，其幻象起落鹘突，而得满足得宁贴也极难，所梦想之神圣境界，恐终不可得，徒以烦恼终其身已耳。呜呼。志摩，天下岂有圆满之宇宙若尔尔者？孔子赞易无取，以未济终矣，当知吾侪以不求圆满为生活态度。斯可以领略生活之妙味矣</strong>, 论及其中原因, 便是这段话最能麻醉Kino了, 让Kino不要继续陷在难过之中了, 也能用多情多感之人的说辞为对方开脱, 好让彼此心安.<br>PS: 徐志摩的爱情观与Kino当前观念，恰好对立</p>
<h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h3><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)"><a href="https://zh.wikipedia.org/wiki/%E9%A5%AE%E5%86%B0%E5%AE%A4%E5%90%88%E9%9B%86" target="_blank" rel="noopener">饮冰室合集</a><a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)"><a href="https://read.douban.com/ebook/10325492/" target="_blank" rel="noopener">爱眉小札-志摩日记、书信集</a><a href="#fnref:2" rev="footnote"> ↩</a></span></div><div id="fn:3" style="display:flex"><span style="width:20px">3.</span><span style="width:calc(100% - 20px)"><a href="https://zh.wikipedia.org/wiki/%E9%A5%AE%E5%86%B0%E5%AE%A4%E6%96%87%E9%9B%86" target="_blank" rel="noopener">饮冰室文集</a><a href="#fnref:3" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>梁启超</tag>
        <tag>徐志摩</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记十一</title>
    <url>/2017/11/12/reading11/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>毛选4卷版本买了有一年了，还是只看了前两卷，最近又补了下，深感只读一遍是无法理解其中的很多思想的。至于流传的五卷版本，网上找了mobi格式的放kindle上看了。</p>
<a id="more"></a>
<h3 id="1-关于阶级"><a href="#1-关于阶级" class="headerlink" title="1. 关于阶级"></a>1. 关于阶级</h3><p>// To do<br>// 都是草稿, 先存着…</p>
<h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h3><p> <a href="https://zh.wikipedia.org/wiki/%E6%AF%9B%E6%B3%BD%E4%B8%9C%E9%80%89%E9%9B%86" target="_blank" rel="noopener">毛泽东选集</a></p>
]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>毛泽东</tag>
      </tags>
  </entry>
  <entry>
    <title>Rails Session</title>
    <url>/2016/03/07/rubyOnRails01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1. 相关概念"></a>1. 相关概念</h3><h4 id="1-1-session"><a href="#1-1-session" class="headerlink" title="1.1 session"></a>1.1 session</h4><p>多数Web框架都有某种形式的Session管理: 为特定于某个客户端浏览会话的数据提供一个持久化的服务器端存储机制<br>Rails session存储方法提供了如下特性:</p>
<ul>
<li>机密性(Confidentiality): 除了服务器无人能读取在session中的数据</li>
<li>完整性(Integrity): 服务器端之外无人能修改存储在session中的数据,除非抛弃旧的session再获取一个新的</li>
</ul>
<p>Rails可以将所有session数据存储在服务器端,或者是基于cookies的session存储方案</p>
<h4 id="2-2-csrf"><a href="#2-2-csrf" class="headerlink" title="2.2 csrf"></a>2.2 csrf</h4><p>跨站请求伪造(Cross-Sire Reuqest Forgery)攻击的步骤如下:</p>
<ul>
<li>通过被攻破的服务器或者攻击者在第三方Web站点上的script/img标签(很可能是通过XSS放置的),客户端可以从攻击者处接收代码。代码引用了目标应用程序上执行某个action的URI</li>
<li>客户端请求来自目标应用程序的URI,发送认证cookies(因为客户端已经通过了目标站点的认证)。目标站点会执行客户端要的action,即使最终用户没有授权该action</li>
</ul>
<p>用图表示:<br><img src="/images/rubyOnRails02_01.png" alt="csrf"></p>
<a id="more"></a>
<h3 id="2-问题"><a href="#2-问题" class="headerlink" title="2. 问题"></a>2. 问题</h3><p>redirect_to 到 某页面认证,之后post数据回来, session为null. 具体过程是用户访问A站点, A站点会验证用户的session, 若空session, 则跳转到B站点登录, 在B站点登录成功后, B站点后端会post登录用户的信息到A站点的一个api, 同时B站点再跳转回A, A站点通过B Post过来的数据进行用户验证, 保存Session, 于是用户愉快地登录了。然而我的问题是 B站点跳转回A的时候发现Session仍然是null, 于是陷入了无限跳转过程中。</p>
<h3 id="3-解决"><a href="#3-解决" class="headerlink" title="3. 解决"></a>3. 解决</h3><p>假设B Post数据到A 的api是 <a href="http://hostofa:port/user">http://hostofa:port/user</a>, 而A在UserController的create方法中处理该事件, 则<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeController</span> &lt; ApplicationController</span></span><br><span class="line">layout <span class="literal">false</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span></span></span><br><span class="line">/<span class="regexp">/ code to dispose data from B, then save session</span></span><br><span class="line"><span class="regexp">end</span></span><br></pre></td></tr></table></figure><br>以上为原代码, 无法生成session, 调试发现根本无法进入cretae方法<br>修改后的代码为:<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeController</span> &lt; ApplicationController</span></span><br><span class="line">protect_from_forgery <span class="symbol">:except</span> =&gt; <span class="symbol">:create</span></span><br><span class="line">layout <span class="literal">false</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span></span></span><br><span class="line">/<span class="regexp">/ code to dispose data from B, then save session</span></span><br><span class="line"><span class="regexp">end</span></span><br></pre></td></tr></table></figure><br>问题得以解决。其实原因就是由于ApplicationController中会默认启用protect_from_forgery, 由于csrf的机制, A站点无法处理B站点Post过来的数据, 所以只要针对性的开放某api即可</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>ruby</tag>
        <tag>rails</tag>
        <tag>session</tag>
        <tag>csrf-token</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记九</title>
    <url>/2017/10/08/reading09/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>想重新认真地读一读鲁迅的文章，就买了鲁迅小全集<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[鲁迅小全集](https://item.jd.com/11338330.html)
">[1]</span></a></sup>共5册<br>在此摘录一些句子，颓废的时候用于警醒自己（或者暗示自己接着颓，毕竟鲁迅也曾颓废过</p>
<a id="more"></a>
<h3 id="1-小说全集"><a href="#1-小说全集" class="headerlink" title="1. 小说全集"></a>1. 小说全集</h3><p>先从较能吸引人的小说全集开始读起</p>
<ol>
<li>所谓回忆者，虽说可以使人欢欣，有时也不免使人寂寞，使精神的丝缕还牵着己逝的寂寞的时光，又有什么意味呢，而我偏苦于不能全忘却……</li>
<li>凡有一人的主张，得了赞和，是促其前进的，得了反对，是促其奋斗的，独有叫喊于生人中，而生人并无反应，既非赞同，也无反对，如置身毫无边际的荒原，无可措手了，这是怎样的悲哀呵，我于是以我所感到者而寂寞<br>评：这句一直到<strong>“独有叫喊于生人中”</strong>还是积极的，在生活中一个人也确是须先得把自己的想法说出来，才能有进步，无论是被人赞同还是反对，闭门造车总是行不通的</li>
<li>喵喵</li>
</ol>
<h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h3><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)"><a href="https://item.jd.com/11338330.html" target="_blank" rel="noopener">鲁迅小全集</a><a href="#fnref:1" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>鲁迅</tag>
      </tags>
  </entry>
  <entry>
    <title>Shadowsocks 高级教程</title>
    <url>/2015/07/19/shadowsocks/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-HTTP代理"><a href="#1-HTTP代理" class="headerlink" title="1. HTTP代理"></a>1. HTTP代理</h3><p>在网上看到建立shadowsocks之后会自动建立一个http的代理，使用8123端口，知道这一点就可以使用http代理而不仅只是socks5了</p>
<h3 id="2-Shadowsocks服务端配置"><a href="#2-Shadowsocks服务端配置" class="headerlink" title="2. Shadowsocks服务端配置"></a>2. Shadowsocks服务端配置</h3><p>曾在DigitalOcean上自建了一个Shadowsocks服务端，虽然后来被封了，但幸而在电脑上记录下一下重点，Shadowsocks服务端的配置文件为:<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">#ipv4</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"0.0.0.0"</span>,</span><br><span class="line">    "server_port":443,      #经尝试，443端口比其他端口要快一点</span><br><span class="line">    "local_port":1080,</span><br><span class="line">    "password":"******",</span><br><span class="line">    "timeout":600,</span><br><span class="line">    "method":"aes-256-cfb"</span><br><span class="line">&#125;</span><br><span class="line">#ipv6</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"::"</span>,</span><br><span class="line">    <span class="attr">"server_port"</span>:<span class="number">443</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"******"</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">600</span>,</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="3-Shadowsocks服务端的安装"><a href="#3-Shadowsocks服务端的安装" class="headerlink" title="3. Shadowsocks服务端的安装"></a>3. Shadowsocks服务端的安装</h3><p>源码在<a href="https://github.com/shadowsocks/shadowsocks" target="_blank" rel="noopener">此处</a><br>先安装pip再安装SS：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install python-pip</span><br><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure><br>如果默认Python版本不对则需要先安装Python，不赘述。</p>
<h3 id="4-Shadowsocks服务端的启动与关闭"><a href="#4-Shadowsocks服务端的启动与关闭" class="headerlink" title="4. Shadowsocks服务端的启动与关闭"></a>4. Shadowsocks服务端的启动与关闭</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssserver -c config -d start</span><br><span class="line">ssserver -c config -d stop</span><br></pre></td></tr></table></figure>
<p>其中config即前面配好的配置文件</p>
<h3 id="5-检查日志"><a href="#5-检查日志" class="headerlink" title="5. 检查日志"></a>5. 检查日志</h3><p><code>sudo less /var/log/shadowsocks.log</code></p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>proxy</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title>Ruby 琐记一</title>
    <url>/2016/01/01/ruby01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1、嵌入字符串"><a href="#1、嵌入字符串" class="headerlink" title="1、嵌入字符串"></a>1、嵌入字符串</h3><p>在字符串中使用#{…}这样的写法, 可以把通过计算得到的值嵌入到字符串中, 输出结果除了可以嵌入变量名也可以嵌入公式<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">puts <span class="string">"Area = <span class="subst">#&#123;area&#125;</span>"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2、times"><a href="#2、times" class="headerlink" title="2、times"></a>2、times</h3><p>循环次数固定使用times方法会更简单<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>.times <span class="keyword">do</span></span><br><span class="line">    puts <span class="string">'hahaha'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><br><a id="more"></a></p>
<h3 id="3、symbol"><a href="#3、symbol" class="headerlink" title="3、symbol"></a>3、symbol</h3><p>符号(symbol)与字符串对象相似,符号也是一种对象,一般作为名称标签来使用,用来表示方法等对象的名称<br>可以将符号简单理解为一种轻量级的字符串<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">symbol1 = <span class="symbol">:foo</span>    <span class="comment">#表示符号:foo</span></span><br><span class="line">symbol2 = <span class="symbol">:<span class="string">"foo"</span></span> <span class="comment">#意义同上</span></span><br></pre></td></tr></table></figure></p>
<h3 id="4、变量"><a href="#4、变量" class="headerlink" title="4、变量"></a>4、变量</h3><p>变量的命名决定了变量的种类</p>
<pre><code>+ 局部变量: 以英文字母或\_开头
+ 全局变量: 以$开头
+ 实例变量: 以@开头
+ 类 变 量 : 以@@开头
</code></pre><h3 id="5、多重赋值"><a href="#5、多重赋值" class="headerlink" title="5、多重赋值"></a>5、多重赋值</h3><p>一些小技巧:<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">a, b, *c = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]          <span class="comment"># a=1,b=2,c=[3,4,5]</span></span><br><span class="line">a, *b, c = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]          <span class="comment"># a=1,b=[2,3,4],c=5</span></span><br><span class="line"></span><br><span class="line">a, b = <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">b, a = a,b</span><br></pre></td></tr></table></figure><br>只要左边的变量结构与数组结构一致, 即使再复杂的结构, 多重赋值都可以轻松解决</p>
<h3 id="6、比较的方法"><a href="#6、比较的方法" class="headerlink" title="6、比较的方法"></a>6、比较的方法</h3><p><code>==</code> <code>===</code> <code>equal?</code> <code>eql?</code></p>
<h3 id="7、定义带块的方法"><a href="#7、定义带块的方法" class="headerlink" title="7、定义带块的方法"></a>7、定义带块的方法</h3><p><code>yield</code>是定义带块的方法时最重要的关键字,调用方法时通过块传进来的处理会在yield定义的地方执行</p>
<h3 id="8、zip方法"><a href="#8、zip方法" class="headerlink" title="8、zip方法"></a>8、zip方法</h3><p>zip方法可以将接收器和参数传来的数组元素逐一取出,而且每次都会启动块. 参数可以是一个也可以是多个<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">arr2 = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>]</span><br><span class="line">arr3 = [<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">400</span>,<span class="number">500</span>]</span><br><span class="line"></span><br><span class="line">result = []</span><br><span class="line">arr1.zip(arr2,arr3) <span class="keyword">do</span> <span class="params">|a,b,c|</span></span><br><span class="line">    result &lt;&lt; a+b+c</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">p result</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>programming language</tag>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title>Ruby 琐记二</title>
    <url>/2016/03/21/ruby02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1、单例类"><a href="#1、单例类" class="headerlink" title="1、单例类"></a>1、单例类</h3><p>单例类这个概念存在于很多编程语言中,包括Java,其基本要求有:</p>
<ul>
<li>1、单例类只能有一个实例</li>
<li>2、单例类必须自己创建自己的唯一实例</li>
<li>3、单例类必须给所有其他对象提供这一实例</li>
</ul>
<p>详细的单例模式讲解可以戳<a href="https://en.wikipedia.org/wiki/Singleton_pattern" target="_blank" rel="noopener">这里</a><br><a id="more"></a><br>在Ruby中创建一个单例类的方法是:<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">objA = A.new</span><br><span class="line"><span class="class"><span class="keyword">class</span> &lt;&lt; objA   <span class="comment"># 打开objA的单例类</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span></span><br><span class="line">    <span class="string">"Object A, Woooo"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p><code>objA.to_s</code>即可调用</p>
<p>因为Ruby中类本身也是对象,类对象自然也有自己的单例类<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> &lt;&lt; A</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span></span><br><span class="line">    <span class="string">"Hahahaha"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p><code>A.to_s</code>即可调用,结果显然是”Hahahaha”, 但是如果我们在此基础上接着:<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">objA1 = A.new</span><br><span class="line">objA2 = A.new</span><br><span class="line"><span class="class"><span class="keyword">class</span> &lt;&lt; objA2</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span></span><br><span class="line">    <span class="string">"Miao"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">p objA1.to_s</span><br></pre></td></tr></table></figure><br>输出结果则类似: <code>&quot;#&lt;A:0x30a4070&gt;&quot;</code>, 这是由于我们只是在类A的单例类中进行了to_s的重定义,它只对类A自身的对象有效,是类A对象的一个单例类方法。用图来表示上述类和对象实例间的关系为:<br><img src="/images/ruby02_01.png" alt="singleton"></p>
<p>所有指向Class的klass指针都省略了</p>
<p>由于类或模块的定义中,self总是指向类或模块对象,故也可以采用这种写法:<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> &lt;&lt; self</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span></span><br><span class="line">      <span class="string">"Hahahaha"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2、实例变量-类变量"><a href="#2、实例变量-类变量" class="headerlink" title="2、实例变量,类变量"></a>2、实例变量,类变量</h3><p>类变量以@@开头,可被定义它的类以及其子类访问,也可被定义它的类和子类的实例访问。即类变量被共享在整个继承链中,在子类改变一个类变量时其父类的类变量值也改变<br>在类对象上定义的变量是实例变量,以@开头,实例变量因为存在于在对象上,所以整个对象的类的继承链都可以使用。父类里定义的实例变量,子类方法可以使用;子类里定义的变量,父类方法也可以使用。<br>类本身也是一种对象,它是Class类的实例,在类上定义的变量,叫类实例变量。类实例变量只能被类方法访问。类实例变量因为存放在类对象上,所以能够被继承链上的类方法访问到。比如子类定义的类实例变量,父类的类方法也能访问</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">  @v1  = <span class="string">"Variable 1"</span>   <span class="comment"># 类实例变量</span></span><br><span class="line">  @@v2 = <span class="string">"Variable 2"</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">var1</span>              <span class="comment"># 实例方法无法访问类实例变量</span></span></span><br><span class="line">    @v1</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">var2</span>              <span class="comment"># 实例方法可访问类变量</span></span></span><br><span class="line">    @@v2</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">A</span>.<span class="title">var3</span>            <span class="comment"># 类方法可访问类实例变量</span></span></span><br><span class="line">    @v1</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">A</span>.<span class="title">var4</span>            <span class="comment"># 类方法可访问类变量</span></span></span><br><span class="line">    @@v2</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">var5</span></span></span><br><span class="line">    @v3 = <span class="string">"Variable 3"</span>  <span class="comment"># 实例变量,定义在类对象上</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &lt; A</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">var6</span>              <span class="comment"># 子类的实例方法可以访问父类的实例变量</span></span></span><br><span class="line">    @v3</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">B</span>.<span class="title">var7</span></span></span><br><span class="line">    @v3</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p A.var1</span></span><br><span class="line"><span class="comment">#p A.var2</span></span><br><span class="line">p A.var3</span><br><span class="line">p A.var4</span><br><span class="line">objA = A.new</span><br><span class="line">p objA.var1</span><br><span class="line">p objA.var2</span><br><span class="line"><span class="comment">#p objA.var3</span></span><br><span class="line"><span class="comment">#p objA.var4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p B.var6</span></span><br><span class="line">p B.var7</span><br><span class="line">objB = B.new</span><br><span class="line">objB.var5       <span class="comment"># 先定义实例变量<span class="doctag">@v</span>3</span></span><br><span class="line">p objB.var6</span><br><span class="line"><span class="comment">#p objB.var7</span></span><br></pre></td></tr></table></figure>
<p>输出结果是<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Variable 1&quot;</span><br><span class="line">&quot;Variable 2&quot;</span><br><span class="line">nil</span><br><span class="line">&quot;Variable 2&quot;</span><br><span class="line">nil</span><br><span class="line">&quot;Variable 3&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="3、闭包"><a href="#3、闭包" class="headerlink" title="3、闭包"></a>3、闭包</h3><p>在代码块或者过程访问定义在其作用范围以外的变量时,就会创建闭包(Closure),即使包含原始变量的代码块已经超出作用范围了,但那些被其他块和过程引用的变量也会被一直保留着,直到引用他们的块和过程全部超出作用范围</p>
<p>闭包的概念是通用的,就像Javascript里也有闭包的概念</p>
<h3 id="4、生成式编程-在运行中编写代码"><a href="#4、生成式编程-在运行中编写代码" class="headerlink" title="4、生成式编程: 在运行中编写代码"></a>4、生成式编程: 在运行中编写代码</h3><h3 id="5、Continuation"><a href="#5、Continuation" class="headerlink" title="5、Continuation"></a>5、Continuation</h3><p>Continuation是一种强大的控制流机制。一个Continuation代表了调用栈和词法变量的特定状态,它是Ruby代码执行过程中特定点的一个快照</p>
<ul>
<li>Continuations其实就是一些对象。它们可以被传递在函数间</li>
<li>可以从任何位置调用Continuations。只要持有对Continuations的引用,就可以对其进行调用</li>
<li>Continuations是可重入的。可以使用Continuations从一个函数多次返回</li>
</ul>
<h3 id="6、Array"><a href="#6、Array" class="headerlink" title="6、Array"></a>6、Array</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] * <span class="string">'; '</span>    =&gt;   <span class="string">"1; 2; 3"</span></span><br><span class="line">[<span class="number">0</span>] * <span class="number">5</span>           =&gt;   [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>techonology</category>
      </categories>
      <tags>
        <tag>programming language</tag>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器配置</title>
    <url>/2013/01/21/serverConfig/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-ssh"><a href="#1-ssh" class="headerlink" title="1. ssh"></a>1. ssh</h3><h4 id="1-1-安装open-ssh"><a href="#1-1-安装open-ssh" class="headerlink" title="1.1 安装open ssh"></a>1.1 安装open ssh</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install openssh-server</span><br><span class="line">/etc/init.d/ssh restart</span><br><span class="line">vim /etc/ssh/sshd_config    <span class="comment"># 根据需要修改</span></span><br></pre></td></tr></table></figure>
<h4 id="1-2-生成密钥"><a href="#1-2-生成密钥" class="headerlink" title="1.2 生成密钥"></a>1.2 生成密钥</h4><p><code>ssh-keygen</code>生成公钥、私钥, 公钥放在服务器改名为authorizedkeys, 私钥放在客户端</p>
<h4 id="1-3-修改密钥权限"><a href="#1-3-修改密钥权限" class="headerlink" title="1.3 修改密钥权限"></a>1.3 修改密钥权限</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 700 ~/.ssh</span><br><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="2-nginx-amp-let’s-encrypt"><a href="#2-nginx-amp-let’s-encrypt" class="headerlink" title="2. nginx &amp; let’s encrypt"></a>2. nginx &amp; let’s encrypt</h3><h4 id="2-1-Ref"><a href="#2-1-Ref" class="headerlink" title="2.1 Ref"></a>2.1 Ref</h4><p><a href="https://www.nginx.com/resources/wiki/" target="_blank" rel="noopener">https://www.nginx.com/resources/wiki/</a><br><a href="https://github.com/certbot/certbot" target="_blank" rel="noopener">https://github.com/certbot/certbot</a></p>
<h4 id="2-2-安装nginx"><a href="#2-2-安装nginx" class="headerlink" title="2.2 安装nginx"></a>2.2 安装nginx</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add-apt-repository -y ppa:nginx/stable</span><br><span class="line">apt update</span><br><span class="line">apt install nginx</span><br></pre></td></tr></table></figure>
<h4 id="2-3-查看nginx安装的模块"><a href="#2-3-查看nginx安装的模块" class="headerlink" title="2.3 查看nginx安装的模块"></a>2.3 查看nginx安装的模块</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -V</span><br><span class="line">ls /usr/lib/nginx/modules   <span class="comment"># 可选方式</span></span><br></pre></td></tr></table></figure>
<h4 id="2-4-配置-etc-nginx-nginx-conf"><a href="#2-4-配置-etc-nginx-nginx-conf" class="headerlink" title="2.4 配置/etc/nginx/nginx.conf"></a>2.4 配置/etc/nginx/nginx.conf</h4><p>查看bitbucket仓库</p>
<h4 id="2-5-配置nginx-server"><a href="#2-5-配置nginx-server" class="headerlink" title="2.5 配置nginx server"></a>2.5 配置nginx server</h4><p>删除/etc/nginx/sites-available/default /etc/nginx/sites-enabled/default<br>添加/etc/nginx/sites-available/yourdomain, 查看bitbucket仓库</p>
<h4 id="2-6-建立软链接"><a href="#2-6-建立软链接" class="headerlink" title="2.6 建立软链接"></a>2.6 建立软链接</h4><p><code>ln -s /etc/nginx/sites-available/yourdomain /etc/nginx/sites-enabled/yourdomain</code></p>
<h4 id="2-7-启动nginx"><a href="#2-7-启动nginx" class="headerlink" title="2.7 启动nginx"></a>2.7 启动nginx</h4><p><code>service nginx start</code>或<code>nginx -s start</code></p>
<h4 id="2-8-签发证书"><a href="#2-8-签发证书" class="headerlink" title="2.8 签发证书"></a>2.8 签发证书</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install software-properties-common</span><br><span class="line">add-apt-repository ppa:certbot/certbot</span><br><span class="line">apt update</span><br><span class="line">apt install python-certbot-nginx</span><br><span class="line">certbot --nginx certonly  <span class="comment"># if error, next</span></span><br><span class="line">certbot --authenticator standalone --installer nginx -d example.com --pre-hook <span class="string">"service nginx stop"</span> --post-hook <span class="string">"ser vice nginx start"</span></span><br></pre></td></tr></table></figure>
<h4 id="2-9-配置证书到站点"><a href="#2-9-配置证书到站点" class="headerlink" title="2.9 配置证书到站点"></a>2.9 配置证书到站点</h4><p>在<code>/etc/nginx/sites-available/yourdomain</code>里<br><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line"><span class="attribute">listen</span> [::]:<span class="number">443</span> ssl;</span><br><span class="line"><span class="attribute">ssl_certificate</span> /etc/letsencrypt/live/yourdomain/fullchain.pem;</span><br><span class="line"><span class="attribute">ssl_certificate_key</span> /etc/letsencrypt/live/yourdomain/privkey.pem;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-10-自动更新证书"><a href="#2-10-自动更新证书" class="headerlink" title="2.10 自动更新证书"></a>2.10 自动更新证书</h4><p><code>crontab</code>和<code>certbot renew</code>. 由于Cloudflare有HTTP Proxy, 域名对应IP非原始IP, 故无法自动更新, 需要先取消代理, 再更新</p>
<h4 id="2-11-撤销删除证书"><a href="#2-11-撤销删除证书" class="headerlink" title="2.11 撤销删除证书"></a>2.11 撤销删除证书</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">certbot revoke --cert-path /etc/letsencrypt/live/CERTNAME/cert.pem</span><br><span class="line">certbot delete --cert-name example.com</span><br></pre></td></tr></table></figure>
<h3 id="3-配置mail"><a href="#3-配置mail" class="headerlink" title="3. 配置mail"></a>3. 配置mail</h3><h4 id="3-1-设置DNS记录"><a href="#3-1-设置DNS记录" class="headerlink" title="3.1 设置DNS记录"></a>3.1 设置DNS记录</h4><h4 id="3-2-安装Postfix"><a href="#3-2-安装Postfix" class="headerlink" title="3.2 安装Postfix"></a>3.2 安装Postfix</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install postfix</span><br></pre></td></tr></table></figure>
<p>安装时选择Internet Site, 之后System mail name填写yourdomain</p>
<h4 id="3-3-查看Postfix配置"><a href="#3-3-查看Postfix配置" class="headerlink" title="3.3 查看Postfix配置"></a>3.3 查看Postfix配置</h4><p><code>postconf</code>可以查看所有配置, 如<code>postconf mail_version</code>查看版本, <code>postconf mail_spool_directory</code>查看邮件保存位置</p>
<h4 id="3-4-修改AWS-Security-Groups"><a href="#3-4-修改AWS-Security-Groups" class="headerlink" title="3.4 修改AWS Security Groups"></a>3.4 修改AWS Security Groups</h4><p><code>Edit inbound rules</code>添加SMTP TCP 25端口</p>
<h4 id="3-5-测试"><a href="#3-5-测试" class="headerlink" title="3.5 测试"></a>3.5 测试</h4><p><code>echo &quot;Test mail&quot; | sendmail youraccount@example.com</code></p>
<h4 id="3-6-用Nginx代理邮件"><a href="#3-6-用Nginx代理邮件" class="headerlink" title="3.6 用Nginx代理邮件"></a>3.6 用Nginx代理邮件</h4><p><a href="https://www.nginx.com/resources/admin-guide/mail-proxy/" target="_blank" rel="noopener">https://www.nginx.com/resources/admin-guide/mail-proxy/</a><br><a href="https://www.nginx.com/resources/wiki/start/topics/examples/imapauthenticatewithapachephpscript/" target="_blank" rel="noopener">https://www.nginx.com/resources/wiki/start/topics/examples/imapauthenticatewithapachephpscript/</a></p>
<h3 id="4-jupyter"><a href="#4-jupyter" class="headerlink" title="4. jupyter"></a>4. jupyter</h3><p><a href="http://jupyter.org/documentation.html" target="_blank" rel="noopener">Official</a></p>
<h4 id="4-1-Install"><a href="#4-1-Install" class="headerlink" title="4.1 Install"></a>4.1 Install</h4><p><code>pip3 install jupyter</code></p>
<h4 id="4-2-Change-config"><a href="#4-2-Change-config" class="headerlink" title="4.2 Change config"></a>4.2 Change config</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter notebook --generate-config    <span class="comment"># This will generate a file ~/.jupyter/jupyter_notebook_config.py</span></span><br><span class="line">vim ~/.jupyter/jupyter_notebook_config.py</span><br></pre></td></tr></table></figure>
<p>generate passwd:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ipython</span><br><span class="line"><span class="keyword">from</span> notebook.auth <span class="keyword">import</span> passwd</span><br><span class="line">passwd()</span><br></pre></td></tr></table></figure><br>Create dir: <code>mkdir Jupyter</code><br>Change ip, port, password and so on:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c.NotebookApp.ip = <span class="string">'127.0.0.1'</span></span><br><span class="line">c.NotebookApp.port = <span class="string">'10010'</span></span><br><span class="line">c.NotebookApp.password = <span class="string">'yourpasswd'</span></span><br><span class="line">c.NotebookApp.notebook_dir = <span class="string">'/home/username/Jupyter'</span>   <span class="comment"># If use relative path, just Jupyter</span></span><br></pre></td></tr></table></figure></p>
<h4 id="4-3-Run"><a href="#4-3-Run" class="headerlink" title="4.3 Run"></a>4.3 Run</h4><p><code>jupyter notebook</code></p>
<h4 id="4-4-Nginx-反向代理"><a href="#4-4-Nginx-反向代理" class="headerlink" title="4.4 Nginx 反向代理"></a>4.4 Nginx 反向代理</h4><p>上述运行之后的jupyter只能在本地浏览器打开, 因为ip配置的是127.0.0.1而不是0.0.0.0, 端口号10010也没有在aws安全组策略中开启<br>有意这样做的原因是想利用Nginx反代指向jupyter, 这样可以使用80端口.<br>其中需要注意的一点是在配置文件里添加:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c.NotebookApp.allow_origin = <span class="string">'http://yourdomain'</span></span><br><span class="line">c.NotebookApp.allow_remote_access = <span class="literal">True</span></span><br><span class="line">c.NotebookApp.trust_xheaders = <span class="literal">True</span></span><br></pre></td></tr></table></figure><br>之后 <code>jupyter notebook &amp;&gt; /dev/null &amp;</code> 后台运行jupyter<br>Nginx反向代理配置可以从Bitbucket仓库获得, 注意代理中添加的 WebSocket support 相关配置</p>
<h4 id="4-5-Install-kernels"><a href="#4-5-Install-kernels" class="headerlink" title="4.5 Install kernels"></a>4.5 Install kernels</h4><p>Please Refer to <a href="https://github.com/jupyter/jupyter/wiki/Jupyter-kernels" target="_blank" rel="noopener">https://github.com/jupyter/jupyter/wiki/Jupyter-kernels</a><br>for example:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install octave_kernel</span><br><span class="line">python -m octave_kernel.install</span><br></pre></td></tr></table></figure></p>
<h3 id="5-VPN"><a href="#5-VPN" class="headerlink" title="5. VPN"></a>5. VPN</h3><h4 id="5-1-Install"><a href="#5-1-Install" class="headerlink" title="5.1 Install"></a>5.1 Install</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://git.io/vpnsetup -O vpnsetup.sh &amp;&amp; sudo \</span><br><span class="line">VPN_IPSEC_PSK=<span class="string">'your_ipsec_pre_shared_key'</span> \</span><br><span class="line">VPN_USER=<span class="string">'your_vpn_username'</span> \</span><br><span class="line">VPN_PASSWORD=<span class="string">'your_vpn_password'</span> sh vpnsetup.sh</span><br></pre></td></tr></table></figure>
<p>Can also edit pre shared key, username, password in vpnsetup.sh<br>Then edit inbound rule, add 500,4500 port.</p>
<h4 id="5-2-Clients"><a href="#5-2-Clients" class="headerlink" title="5.2 Clients"></a>5.2 Clients</h4><p>Ubuntu: <a href="https://github.com/nm-l2tp/network-manager-l2tp" target="_blank" rel="noopener">https://github.com/nm-l2tp/network-manager-l2tp</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/nm-l2tp/network-manager-l2tp.git</span><br><span class="line"><span class="built_in">cd</span> network-manager-l2tp</span><br><span class="line">apt install autoconf autogen intltool</span><br><span class="line">apt install libglib2.0-dev</span><br><span class="line">apt install ppp-dev</span><br><span class="line">./autogen.sh</span><br><span class="line">./configure \</span><br><span class="line">  --<span class="built_in">disable</span>-static --prefix=/usr \</span><br><span class="line">  --sysconfdir=/etc --libdir=/usr/lib/x86_64-linux-gnu \</span><br><span class="line">  --libexecdir=/usr/lib/NetworkManager \</span><br><span class="line">  --localstatedir=/var \</span><br><span class="line">  --with-pppd-plugin-dir=/usr/lib/pppd/2.4.7</span><br><span class="line">make</span><br></pre></td></tr></table></figure></p>
<h4 id="5-3-Uninstall"><a href="#5-3-Uninstall" class="headerlink" title="5.3 Uninstall"></a>5.3 Uninstall</h4><p><a href="https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/docs/uninstall.md" target="_blank" rel="noopener">https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/docs/uninstall.md</a></p>
<h3 id="6-配置Docker"><a href="#6-配置Docker" class="headerlink" title="6. 配置Docker"></a>6. 配置Docker</h3><h4 id="6-1-Docker-Hub"><a href="#6-1-Docker-Hub" class="headerlink" title="6.1 Docker Hub"></a>6.1 Docker Hub</h4><p>Create a repo in <a href="https://hub.docker.com/" target="_blank" rel="noopener">docker hub</a></p>
<h4 id="6-2-Source-file"><a href="#6-2-Source-file" class="headerlink" title="6.2 Source file"></a>6.2 Source file</h4><p>Create a repo in bitbucket</p>
<h4 id="6-3-Webhook"><a href="#6-3-Webhook" class="headerlink" title="6.3 Webhook"></a>6.3 Webhook</h4><p>Add webhook to docker hub repo.</p>
<h4 id="6-4-Pull-amp-Run"><a href="#6-4-Pull-amp-Run" class="headerlink" title="6.4 Pull &amp; Run"></a>6.4 Pull &amp; Run</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull username/repo</span><br><span class="line">docker run -p 80:80 -p 443:443 -dit username/repo</span><br></pre></td></tr></table></figure>
<h4 id="6-5-Other-command"><a href="#6-5-Other-command" class="headerlink" title="6.5 Other command"></a>6.5 Other command</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker ps -a</span><br><span class="line">docker images -a</span><br><span class="line">docker attach <span class="variable">$ID</span></span><br><span class="line">docker stop <span class="variable">$ID</span></span><br></pre></td></tr></table></figure>
<h3 id="7-MOTD"><a href="#7-MOTD" class="headerlink" title="7. MOTD"></a>7. MOTD</h3><h4 id="7-1-Install-fortune-and-cowsay"><a href="#7-1-Install-fortune-and-cowsay" class="headerlink" title="7.1 Install fortune and cowsay"></a>7.1 Install fortune and cowsay</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install fortune</span><br><span class="line">apt install fortunes</span><br><span class="line">apt install cowsay</span><br></pre></td></tr></table></figure>
<h4 id="7-2-Change-motd"><a href="#7-2-Change-motd" class="headerlink" title="7.2 Change motd"></a>7.2 Change motd</h4><p><code>vim /etc/update-motd.d/999-fortune</code><br>Add:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!bin&#x2F;sh</span><br><span class="line">&#x2F;usr&#x2F;games&#x2F;fortune | &#x2F;usr&#x2F;games&#x2F;cowsay</span><br></pre></td></tr></table></figure><br>Then: <code>chmod 755 /etc/update-motd.d/999-fortune</code><br>To test: <code>run-parts /etc/update-motd.d</code></p>
<h3 id="8-Shadowsocks"><a href="#8-Shadowsocks" class="headerlink" title="8. Shadowsocks"></a>8. Shadowsocks</h3><h4 id="8-1-Install"><a href="#8-1-Install" class="headerlink" title="8.1 Install"></a>8.1 Install</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install python-pip</span><br><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure>
<h4 id="8-2-Run"><a href="#8-2-Run" class="headerlink" title="8.2 Run"></a>8.2 Run</h4><p><code>sudo ssserver -c shadowsocks.conf -d start</code></p>
]]></content>
      <categories>
        <category>techonology</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title>simhash与重复信息识别</title>
    <url>/2015/09/02/simhash/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="Simhash-Minhash"><a href="#Simhash-Minhash" class="headerlink" title="Simhash, Minhash"></a>Simhash, Minhash</h3><p>参考这些文章<br><a href="http://grunt1223.iteye.com/blog/964564" target="_blank" rel="noopener">http://grunt1223.iteye.com/blog/964564</a><br><a href="http://blog.csdn.net/heiyeshuwu/article/details/44117473" target="_blank" rel="noopener">http://blog.csdn.net/heiyeshuwu/article/details/44117473</a></p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>simhash</tag>
        <tag>minhash</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑学入门二</title>
    <url>/2016/01/01/topology02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>江辉有《拓扑学》的内容很全面, 以后再看拓扑学大概就可以对照这这本书的目录来了</p>
<h3 id="点集拓扑学"><a href="#点集拓扑学" class="headerlink" title="点集拓扑学"></a>点集拓扑学</h3><h4 id="拓扑空间之间的连续映射与同胚"><a href="#拓扑空间之间的连续映射与同胚" class="headerlink" title="拓扑空间之间的连续映射与同胚"></a>拓扑空间之间的连续映射与同胚</h4><ol>
<li>连续映射的定义</li>
<li>连续映射的性质</li>
<li>同胚映射</li>
<li>嵌入与嵌入映射</li>
</ol>
<h4 id="拓扑基与Tychonoff积空间"><a href="#拓扑基与Tychonoff积空间" class="headerlink" title="拓扑基与Tychonoff积空间"></a>拓扑基与Tychonoff积空间</h4><ol>
<li>拓扑基与子基 </li>
<li>乘积空间 <a id="more"></a>
<h4 id="分离性公理与可数性公理"><a href="#分离性公理与可数性公理" class="headerlink" title="分离性公理与可数性公理"></a>分离性公理与可数性公理</h4></li>
<li>分离性公理 </li>
<li>可数性公理 </li>
<li>拓扑性质的可遗传性与可乘性 </li>
</ol>
<h4 id="Uryshon引理及其应用"><a href="#Uryshon引理及其应用" class="headerlink" title="Uryshon引理及其应用"></a>Uryshon引理及其应用</h4><ol>
<li>Uryshon引理 </li>
<li>Tietze扩张引理 </li>
<li>Uryshon度量化定理 </li>
</ol>
<h4 id="拓扑空间的紧致性与列紧性"><a href="#拓扑空间的紧致性与列紧性" class="headerlink" title="拓扑空间的紧致性与列紧性"></a>拓扑空间的紧致性与列紧性</h4><ol>
<li>紧致与列紧的定义 </li>
<li>列紧空间的性质 </li>
<li>紧致空间的性质 </li>
</ol>
<h4 id="局部紧性与仿紧性"><a href="#局部紧性与仿紧性" class="headerlink" title="局部紧性与仿紧性"></a>局部紧性与仿紧性</h4><ol>
<li>局部紧性</li>
<li>仿紧性 </li>
</ol>
<h4 id="连通性与道路连通性"><a href="#连通性与道路连通性" class="headerlink" title="连通性与道路连通性"></a>连通性与道路连通性</h4><ol>
<li>连通性的定义及例子 </li>
<li>连通空间的性质 </li>
<li>连通分支 </li>
<li>局部连通性 </li>
<li>道路及其运算 </li>
<li>道路连通空间 </li>
<li>道路连通分支 </li>
<li>局部道路连通 </li>
</ol>
<h4 id="商空间与商映射"><a href="#商空间与商映射" class="headerlink" title="商空间与商映射"></a>商空间与商映射</h4><ol>
<li>商空间 </li>
<li>拓扑锥 </li>
<li>贴空间 </li>
<li>映射柱与映射锥 </li>
<li>商映射 </li>
</ol>
<h4 id="闭曲面及其分类"><a href="#闭曲面及其分类" class="headerlink" title="闭曲面及其分类"></a>闭曲面及其分类</h4><ol>
<li>拓扑流形的概念 </li>
<li>闭曲面 </li>
<li>两类闭曲面 </li>
<li>闭曲面分类定理 </li>
</ol>
<h4 id="点网、滤子与收敛性概念的扩张"><a href="#点网、滤子与收敛性概念的扩张" class="headerlink" title="点网、滤子与收敛性概念的扩张"></a>点网、滤子与收敛性概念的扩张</h4><ol>
<li>点网 </li>
<li>滤子 </li>
</ol>
<h4 id="函数空间"><a href="#函数空间" class="headerlink" title="函数空间"></a>函数空间</h4><ol>
<li>点态收敛拓扑 </li>
<li>X上的一致收敛拓扑 </li>
<li>紧开拓扑 </li>
<li>k-空间与Ascoli定理 </li>
</ol>
<h3 id="代数拓扑学"><a href="#代数拓扑学" class="headerlink" title="代数拓扑学"></a>代数拓扑学</h3><h4 id="映射的同伦与基本群的定义"><a href="#映射的同伦与基本群的定义" class="headerlink" title="映射的同伦与基本群的定义"></a>映射的同伦与基本群的定义</h4><ol>
<li>映射的同伦 </li>
<li>道路类的逆与乘积 </li>
<li>道路类的运算性质 </li>
<li>空间的基本群定义 </li>
<li>连续映射诱导的基本群同态 </li>
<li>基本群与基点的关系 </li>
</ol>
<h4 id="球面Sn的基本群"><a href="#球面Sn的基本群" class="headerlink" title="球面Sn的基本群"></a>球面Sn的基本群</h4><ol>
<li>S1的基本群</li>
<li>n≥2时Sn是单连通的</li>
<li>T2的基本群</li>
</ol>
<h4 id="基本群的同伦不变性"><a href="#基本群的同伦不变性" class="headerlink" title="基本群的同伦不变性"></a>基本群的同伦不变性</h4><ol>
<li>同伦的映射所诱导的基本群的同态之间的关系</li>
<li>拓扑空间的同伦等价</li>
<li>形变收缩核</li>
<li>可缩空间</li>
</ol>
<h4 id="基本群的计算"><a href="#基本群的计算" class="headerlink" title="基本群的计算"></a>基本群的计算</h4><ol>
<li>Seifert-VanKampen定理</li>
<li>Seifert-VanKampen定理应用举例</li>
<li>轨道空间与基本群</li>
</ol>
<h4 id="基本群的若干应用"><a href="#基本群的若干应用" class="headerlink" title="基本群的若干应用"></a>基本群的若干应用</h4><ol>
<li>闭曲面分类定理证明的完成</li>
<li>Brouwer不动点定理2维情形的证明</li>
<li>代数基本定理的证明</li>
<li>曲面的边界问题</li>
<li>扭结群的Wirtinger表示</li>
<li>平面的分离问题</li>
</ol>
<h4 id="复叠空间及其基本性质"><a href="#复叠空间及其基本性质" class="headerlink" title="复叠空间及其基本性质"></a>复叠空间及其基本性质</h4><ol>
<li>复叠映射与复叠空间</li>
<li>映射的提升问题</li>
<li>复叠空间的基本群</li>
<li>复叠空间的分类</li>
</ol>
<h4 id="复叠变换与正则复叠空间"><a href="#复叠变换与正则复叠空间" class="headerlink" title="复叠变换与正则复叠空间"></a>复叠变换与正则复叠空间</h4><ol>
<li>复叠变换</li>
<li>正则复叠空间</li>
<li>泛复叠空间</li>
<li>四元数简介</li>
</ol>
<h4 id="单纯复形的同调群"><a href="#单纯复形的同调群" class="headerlink" title="单纯复形的同调群"></a>单纯复形的同调群</h4><ol>
<li>单纯形</li>
<li>单纯复(合)形</li>
<li>多面体与可剖分空间</li>
<li>承载单形</li>
<li>单形的定向</li>
<li>链群</li>
<li>边缘同态</li>
<li>同调群</li>
</ol>
<h4 id="同调群的简单性质、G系数同调群"><a href="#同调群的简单性质、G系数同调群" class="headerlink" title="同调群的简单性质、G系数同调群"></a>同调群的简单性质、G系数同调群</h4><ol>
<li>同调群的简单性质</li>
<li>0维同调群</li>
<li>1维同调群与基本群的关系</li>
<li>Euler Poincare公式</li>
<li>以交换群G为系数群的同调群</li>
</ol>
<h4 id="同调群的基本计算"><a href="#同调群的基本计算" class="headerlink" title="同调群的基本计算"></a>同调群的基本计算</h4><h4 id="单纯映射与单纯逼近"><a href="#单纯映射与单纯逼近" class="headerlink" title="单纯映射与单纯逼近"></a>单纯映射与单纯逼近</h4><ol>
<li>单纯映射</li>
<li>单纯映射诱导的同调群的同态</li>
<li>单纯逼近</li>
<li>重心重分</li>
<li>单纯逼近存在定理</li>
</ol>
<h4 id="连续映射诱导的同调群同态"><a href="#连续映射诱导的同调群同态" class="headerlink" title="连续映射诱导的同调群同态"></a>连续映射诱导的同调群同态</h4><ol>
<li>链复形、链映射和链同伦</li>
<li>同调群的重分不变性</li>
<li>诱导同调f*q的定义</li>
<li>多面体与可剖分空间的同调群</li>
</ol>
<h4 id="同调群的同伦不变性"><a href="#同调群的同伦不变性" class="headerlink" title="同调群的同伦不变性"></a>同调群的同伦不变性</h4><ol>
<li>同调群的同伦不变性</li>
<li>同调群计算再举例</li>
</ol>
<h4 id="Mayer-Vietoris同调序列"><a href="#Mayer-Vietoris同调序列" class="headerlink" title="Mayer-Vietoris同调序列"></a>Mayer-Vietoris同调序列</h4><ol>
<li>简约同调群</li>
<li>相对同调群</li>
<li>同调代数的基本知识，正合同调序列</li>
<li>Mayer？Vietoris同调序列</li>
</ol>
<h4 id="球面自映射的映射度及其应用"><a href="#球面自映射的映射度及其应用" class="headerlink" title="球面自映射的映射度及其应用"></a>球面自映射的映射度及其应用</h4><ol>
<li>球面自映射的映射度的定义和性质</li>
<li>对径映射的映射度及其应用</li>
<li>保径映射的映射度</li>
<li>Borsuk-Ulam定理</li>
</ol>
<h4 id="Lefschetz不动点定理"><a href="#Lefschetz不动点定理" class="headerlink" title="Lefschetz不动点定理"></a>Lefschetz不动点定理</h4><ol>
<li>代数准备</li>
<li>有限复形K的迹数</li>
<li>可剖分空间的Lefschetz数</li>
</ol>
<h3 id="拓扑群基础"><a href="#拓扑群基础" class="headerlink" title="拓扑群基础"></a>拓扑群基础</h3><h4 id="拓扑群的基本概念与基本性质"><a href="#拓扑群的基本概念与基本性质" class="headerlink" title="拓扑群的基本概念与基本性质"></a>拓扑群的基本概念与基本性质</h4><ol>
<li>拓扑群的概念</li>
<li>拓扑群的性质</li>
</ol>
<h4 id="拓扑群的子群、商群与拓扑变换群"><a href="#拓扑群的子群、商群与拓扑变换群" class="headerlink" title="拓扑群的子群、商群与拓扑变换群"></a>拓扑群的子群、商群与拓扑变换群</h4><ol>
<li>拓扑群的子群</li>
<li>拓扑群的商群</li>
<li>拓扑变换群</li>
</ol>
<h4 id="拓扑群的可乘性、分离性、连通性与逆极限"><a href="#拓扑群的可乘性、分离性、连通性与逆极限" class="headerlink" title="拓扑群的可乘性、分离性、连通性与逆极限"></a>拓扑群的可乘性、分离性、连通性与逆极限</h4><ol>
<li>拓扑群的积</li>
<li>拓扑群的分离性</li>
<li>拓扑群的连通性</li>
<li>逆极限</li>
</ol>
]]></content>
      <categories>
        <category>science</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>topology</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑学入门一</title>
    <url>/2015/10/21/topology01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>读江辉有《拓扑学》<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[拓扑学](https://book.douban.com/subject/22420911/)
">[1]</span></a></sup>笔记</p>
<h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h3><h4 id="1-1-一笔画问题和哥尼斯堡七桥问题"><a href="#1-1-一笔画问题和哥尼斯堡七桥问题" class="headerlink" title="1.1 一笔画问题和哥尼斯堡七桥问题"></a>1.1 一笔画问题和哥尼斯堡七桥问题</h4><h4 id="1-2-欧拉-Euler-示性数"><a href="#1-2-欧拉-Euler-示性数" class="headerlink" title="1.2 欧拉(Euler)示性数"></a>1.2 欧拉(Euler)示性数</h4><h4 id="1-3-图的可平面化处理问题"><a href="#1-3-图的可平面化处理问题" class="headerlink" title="1.3 图的可平面化处理问题"></a>1.3 图的可平面化处理问题</h4><ul>
<li>对于由顶点和线构成的图，如果每个顶点间都有线相连，则这样的图称之为完全图。下图中的K5是完全图，K33不是完全图<br><img src="/images/topology01_1.png" alt="first"></li>
</ul>
<p>所谓图的可平面化问题就是：一个图应当满足什么条件，才可以在平面上不自交的被画出来?这也就是通常说的可嵌入平面的问题。这里说的不自交指的是不同的线不会相交，至于线如何回还转曲不加限制。</p>
<ul>
<li>Kuratowsky定理<ul>
<li>一个图G可以嵌入平面当且仅当G不含有K5或K33同构的子图</li>
<li>有意思的是，K33虽然不能嵌入平面，却可以嵌入Mobius带。</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h4 id="1-4-扭结论-Knot-theory-研究"><a href="#1-4-扭结论-Knot-theory-研究" class="headerlink" title="1.4 扭结论(Knot theory)研究"></a>1.4 扭结论(Knot theory)研究</h4><h4 id="1-5-四色问题"><a href="#1-5-四色问题" class="headerlink" title="1.5 四色问题"></a>1.5 四色问题</h4><h3 id="2-点集拓扑学"><a href="#2-点集拓扑学" class="headerlink" title="2. 点集拓扑学"></a>2. 点集拓扑学</h3><h4 id="2-1-预备知识"><a href="#2-1-预备知识" class="headerlink" title="2.1 预备知识"></a>2.1 预备知识</h4><h5 id="2-1-1-集合代数与关系"><a href="#2-1-1-集合代数与关系" class="headerlink" title="2.1.1 集合代数与关系"></a>2.1.1 集合代数与关系</h5><ul>
<li>X所有子集构成的集族，称为X的幂集，用2^X表示</li>
<li>笛卡尔积: \(X\times Y=\{(x,y):x\in X,y\in Y\}\). \(X\times Y\)的任一子集R称为X到Y的一个关系。若\((x,y)\in R\)，则称x与y是R-相关的，也记为xRy。若R是X到Y的一个关系，则其定义集为\(\{x\in X: \exists y\in Y, xRy\}\)(为方便也常记为DR)，也称为定义域。而其值集则定义为\(\{y\in Y: \exists x\in X, xRy\}\)。</li>
</ul>
<h5 id="2-1-2-函数与等价关系"><a href="#2-1-2-函数与等价关系" class="headerlink" title="2.1.2 函数与等价关系"></a>2.1.2 函数与等价关系</h5><ul>
<li>包含映射(含入映射)</li>
<li>自反&amp;对称&amp;传递\(\Rightarrow\)等价关系</li>
<li>商集, 自然映射</li>
<li>划分</li>
</ul>
<h5 id="2-1-3-序关系与选择公理"><a href="#2-1-3-序关系与选择公理" class="headerlink" title="2.1.3 序关系与选择公理"></a>2.1.3 序关系与选择公理</h5><ul>
<li>设R是X上的一个关系，如果\(xRy\wedge yRx\)，则必有x=y，那么我们称R在X上是反对称的。X上的一个自反、反对称且传递的关系R就称为X上的一个<strong>偏序</strong>。当R是X上的一个偏序时，偶对(X,R)称为一个偏序集。在偏序关系R明确的情况下，有时也简称X为一个偏序集。偏序关系常用≤来表示</li>
<li>全序(也称线性序)；全序集(或线性序集)，也称为链</li>
<li>良序；良序集</li>
<li>闭区间，左闭右开区间，开区间，闭右射线，开右射线，区间，诱导偏序，偏序子集</li>
<li>选择公理\(\Leftrightarrow\)Zermelo良序定理\(\Leftrightarrow\)Teichmuller-Tukey引理\(\Leftrightarrow\)Kuratowski-Zorn引理</li>
</ul>
<h5 id="2-1-4-集合的可数性"><a href="#2-1-4-集合的可数性" class="headerlink" title="2.1.4 集合的可数性"></a>2.1.4 集合的可数性</h5><p>如果集合A的元素是只有有限个，就称它是有限集，否则为无限集。如今我们把能与自然数集形成一一对应的集合称为<strong>可数无限集</strong>(也称<strong>可列集</strong>)，而把有限集和可数无限集统称为<strong>可数(countable)集</strong>，也就是说，能够与自然数集的某个子集形成一一对应的集合都称为可数集。不是可数集的集合不可数</p>
<h5 id="2-1-5-基数简介"><a href="#2-1-5-基数简介" class="headerlink" title="2.1.5 基数简介"></a>2.1.5 基数简介</h5><ul>
<li>定义：如果在集合A和集合B之间存在一一对应\(f: A\rightarrow B\)，则称集合A和集合B是等势的，记为A~B。如果存在自然数n使得A~{1,2,…,n}，则称集合A是有限的；不是有限的集合就是无限的。如果A~N(正整数集)，则称A是可数无限的(或者可列的)；有限的或可数无限的统称为可数的。</li>
<li>定理：集合间的等势关系是一个等价关系，即对任意集合A,B,C，有：<ul>
<li>\(A\sim A\)</li>
<li>\(A\sim B \Rightarrow B\sim A\)</li>
<li>\((A\sim B)\wedge (B\sim C)\Rightarrow A\sim C\)</li>
</ul>
</li>
<li>定义：对于每个集合A，对应一个符号|A|，称为A的基数，它满足以下条件：<ul>
<li>如果A~B，则|A|=|B|</li>
<li>\(|\varnothing| = 0\)</li>
<li>如果有自然数n使得A~{1,2,…,n}，则|A|=n</li>
<li>显然基数就是通常个数概念的推广</li>
<li>……</li>
</ul>
</li>
</ul>
<h3 id="3-拓扑空间的基本概念"><a href="#3-拓扑空间的基本概念" class="headerlink" title="3. 拓扑空间的基本概念"></a>3. 拓扑空间的基本概念</h3><h4 id="3-1-拓扑空间的定义"><a href="#3-1-拓扑空间的定义" class="headerlink" title="3.1 拓扑空间的定义"></a>3.1 拓扑空间的定义</h4><p>设X是一个非空集合，其子集族\(\Im \subset 2^X\)称为X上的一个拓扑，如果它满足：</p>
<ul>
<li>\(X,\varnothing\)均为\(\Im\)中元素</li>
<li>\(\Im\)中任意多个元素的并集仍为\(\Im\)中元素(也称\(\Im\)对并运算封闭)</li>
<li>\(\Im\)有限个元素的交集仍为\(\Im\)中元素(也称\(\Im\)对有限交运算封闭)</li>
<li>此外，偶对\((X,\Im)\)称为一个拓扑空间，通常简记为X</li>
</ul>
<blockquote>
<p>这时拓扑空间的每一个元叫做开集，同样还可以定义闭集(后续会说)，所以也可以用闭集来定义拓扑空间。</p>
</blockquote>
<h4 id="3-2-度量拓扑"><a href="#3-2-度量拓扑" class="headerlink" title="3.2 度量拓扑"></a>3.2 度量拓扑</h4><ul>
<li>非空集合X上的一个度量d是指一个满足如下三条度量公理的映射\(d: X\times X \rightarrow R\)<ul>
<li>1) 非负性：\(d(x,y)\geq 0,\forall x,y\in X\), 等号当且仅当x=y时成立</li>
<li>2) 对称性：\(d(x,y)=d(y,x),\forall x,y\in X\)</li>
<li>3) 三角不等式：\(d(x,z)\leq d(x,y)+d(y,z),\forall x,y\in X\)</li>
</ul>
</li>
<li>示例：<ul>
<li>1) 在n维欧式空间\(\mathbb{R}^n\),如下定义的映射\(d:\mathbb{R}^n \times \mathbb{R}^n\),\(d(x,y)=\parallel x-y\parallel =\sqrt{\sum_{i=1}^{n}(x_i-y_i)^2},\forall x=(x_1,x_2,\cdots,x_n),y=(y_1,y_2,\cdots,y_n)\in \mathbb{R}^n\)是一个度量，称为欧式度量</li>
<li>2) 在\(C[a,b]\)上，对于两个函数\(f,g\in C[a,b]\)，由\(d(f,g)=\int_a^b|f-g|dx\)定义的映射给出了\(C[a,b]\)上的一个变量</li>
<li>3) 在任意一个非空集X上，\(d(x,y)=\begin{cases} 0,x=y\\1,x\neq y \end{cases}\forall x,y\in X\)定义了一个度量，这个度量通常称为离散度量</li>
<li>4) 在集合\(H=\left\{x=(x_1,x_2,\cdots,x_n,\cdots)|\sum_{i=1}^{\infty}x_i^2&lt;+\infty,x_i\in \mathbb{R}\right\}\)上，定义\(d(x,y)=\sqrt{\sum_{i=1}^{\infty}(x_i-y_i)^2},\forall x=(x_1,x_2,\cdots),y=(x_1,y_2,\cdots)\in H\)，则d是H上的一个度量</li>
</ul>
</li>
<li>度量空间：<br>对于定义了度量\(d:X\times X\rightarrow \mathbb{R}\)的集合X而言，\(\forall x_0\in X,\forall \epsilon &gt;0\)，称\(B(x_0,\epsilon)=\{x\in X|d(x,x_0)&lt;\epsilon\}\)为以\(x_0\)为中心，\(\epsilon\)为半径的球形领域(开球)，再令\(\Im_d=\{U\subset X|U是X中若干个球形领域的并集\}\)，则很容易验证：\(\Im_d\)是X上的一个拓扑，称为由度量d诱导的拓扑（简称度量拓扑）。此时，拓扑空间\((X,\Im_d)\)通常简记为(X,d)，甚至在不引起混乱的情况下直接记为X，称为度量空间</li>
</ul>
<h4 id="3-3-拓扑空间的几个基本概念"><a href="#3-3-拓扑空间的几个基本概念" class="headerlink" title="3.3 拓扑空间的几个基本概念"></a>3.3 拓扑空间的几个基本概念</h4><ul>
<li>闭集：拓扑空间中的一个集合F，如果其补集为开集，则称它为闭集</li>
<li>在一个拓扑空间中，能表示为可数多个闭集的并集的集合称为\(F_\sigma -\)集</li>
<li>在一个拓扑空间中，能表示为可数多个闭集的并集的集合称为\(G_\sigma -\)集</li>
<li>集合X的一个非空子集族\(\Sigma\)称为一个\(\sigma -\)环，是指它满足：<ul>
<li>1) 对余运算封闭：\(A\in \Sigma\Rightarrow A^C\in \Sigma\)</li>
<li>2) 对可数交运算封闭：\(A_i\in \Sigma(i\in \mathbb{N})\Rightarrow \bigcap_{i\in \mathbb{N}}A_i\in \Sigma\)</li>
</ul>
</li>
<li>邻域、内点和内部</li>
<li>聚点与闭包</li>
<li>序列的收敛性</li>
</ul>
<h4 id="3-4-子空间"><a href="#3-4-子空间" class="headerlink" title="3.4 子空间"></a>3.4 子空间</h4><h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h3><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)"><a href="https://book.douban.com/subject/22420911/" target="_blank" rel="noopener">拓扑学</a><a href="#fnref:1" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>science</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>topology</tag>
      </tags>
  </entry>
  <entry>
    <title>安装Ubuntu 15.04之后</title>
    <url>/2015/05/26/ubuntu01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>重装了系统, 不小心点错了键盘, 用户名设置错了, 再折腾一下其他东西又是一晚上, 幸亏以前用过Ubuntu, 还有点印象，重装前Kali也算是和Ubuntu同源的，都来自Debian，所以没有走太多弯路。</p>
<a id="more"></a>
<h3 id="1-SourceList"><a href="#1-SourceList" class="headerlink" title="1. SourceList"></a>1. SourceList</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### Aliyun</span><br><span class="line"># deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; vivid main restricted universe multiverse</span><br><span class="line"># deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; vivid-security main restricted universe multiverse</span><br><span class="line"># deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; vivid-updates main restricted universe multiverse</span><br><span class="line"># deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; vivid-proposed main restricted universe multiverse</span><br><span class="line"># deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; vivid-backports main restricted universe multiverse</span><br><span class="line"># deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; vivid main restricted universe multiverse</span><br><span class="line"># deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; vivid-security main restricted universe multiverse</span><br><span class="line"># deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; vivid-updates main restricted universe multiverse</span><br><span class="line"># deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; vivid-proposed main restricted universe multiverse</span><br><span class="line"># deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; vivid-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">### Netease</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; vivid main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; vivid-security main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; vivid-updates main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; vivid-proposed main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; vivid-backports main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; vivid main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; vivid-security main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; vivid-updates main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; vivid-proposed main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; vivid-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">### Bit</span><br><span class="line"># deb http:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;ubuntu&#x2F; vivid main restricted universe multiverse</span><br><span class="line"># deb http:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;ubuntu&#x2F; vivid-security main restricted universe multiverse</span><br><span class="line"># deb http:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;ubuntu&#x2F; vivid-updates main restricted universe multiverse</span><br><span class="line"># deb http:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;ubuntu&#x2F; vivid-proposed main restricted universe multiverse</span><br><span class="line"># deb http:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;ubuntu&#x2F; vivid-backports main restricted universe multiverse</span><br><span class="line"># deb-src http:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;ubuntu&#x2F; vivid main restricted universe multiverse</span><br><span class="line"># deb-src http:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;ubuntu&#x2F; vivid-security main restricted universe multiverse</span><br><span class="line"># deb-src http:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;ubuntu&#x2F; vivid-updates main restricted universe multiverse</span><br><span class="line"># deb-src http:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;ubuntu&#x2F; vivid-proposed main restricted universe multiverse</span><br><span class="line"># deb-src http:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;ubuntu&#x2F; vivid-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">### Bit ipv6</span><br><span class="line"># deb http:&#x2F;&#x2F;mirror.bit6.edu.cn&#x2F;ubuntu&#x2F; vivid main restricted universe multiverse</span><br><span class="line"># deb http:&#x2F;&#x2F;mirror.bit6.edu.cn&#x2F;ubuntu&#x2F; vivid-security main restricted universe multiverse</span><br><span class="line"># deb http:&#x2F;&#x2F;mirror.bit6.edu.cn&#x2F;ubuntu&#x2F; vivid-updates main restricted universe multiverse</span><br><span class="line"># deb http:&#x2F;&#x2F;mirror.bit6.edu.cn&#x2F;ubuntu&#x2F; vivid-proposed main restricted universe multiverse</span><br><span class="line"># deb http:&#x2F;&#x2F;mirror.bit6.edu.cn&#x2F;ubuntu&#x2F; vivid-backports main restricted universe multiverse</span><br><span class="line"># deb-src http:&#x2F;&#x2F;mirror.bit6.edu.cn&#x2F;ubuntu&#x2F; vivid main restricted universe multiverse</span><br><span class="line"># deb-src http:&#x2F;&#x2F;mirror.bit6.edu.cn&#x2F;ubuntu&#x2F; vivid-security main restricted universe multiverse</span><br><span class="line"># deb-src http:&#x2F;&#x2F;mirror.bit6.edu.cn&#x2F;ubuntu&#x2F; vivid-updates main restricted universe multiverse</span><br><span class="line"># deb-src http:&#x2F;&#x2F;mirror.bit6.edu.cn&#x2F;ubuntu&#x2F; vivid-proposed main restricted universe multiverse</span><br><span class="line"># deb-src http:&#x2F;&#x2F;mirror.bit6.edu.cn&#x2F;ubuntu&#x2F; vivid-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>
<h3 id="2-Flash"><a href="#2-Flash" class="headerlink" title="2. Flash"></a>2. Flash</h3><p><code>cp libflashplayer.so /usr/lib/mozilla/plugins/</code></p>
<h3 id="3-Input-Method"><a href="#3-Input-Method" class="headerlink" title="3. Input Method"></a>3. Input Method</h3><p>先<code>apt-get install fcitx-table-wbpy</code>, 再在Language Support里改框架为fcitx，修改配置重启</p>
<h3 id="4-Desktop"><a href="#4-Desktop" class="headerlink" title="4. Desktop"></a>4. Desktop</h3><p>修改一下桌面背景、透明度、终端配色等</p>
<h3 id="5-hostname-username"><a href="#5-hostname-username" class="headerlink" title="5. hostname username"></a>5. hostname username</h3><ol>
<li>对于hostname<ul>
<li>首先修改 /etc/hostname文件</li>
<li>sudo vim /etc/hostname</li>
<li>将其中的主机名改为你所要修改的主机名</li>
<li>再修改 /etc/hosts文件</li>
<li>sudo vim /etc/hosts</li>
<li>127.0.0.1   主机名</li>
<li>这里的主机名要和上面修改的一致</li>
<li>修改完成后需重启</li>
</ul>
</li>
<li>对于username<ul>
<li>先切换到tty终端下，如tty1为Ctrl+Alt+F1</li>
<li>chfn hypocisy</li>
<li>usermod -l hypocrisy hypocisy</li>
<li>usermod -d /home/hypocrisy/ -m /home/hypocisy/</li>
<li>groupmod -n hypocrisy hypocisy</li>
<li>实际信息可以看/etc/passwd和/etc/shadow</li>
</ul>
</li>
</ol>
<h3 id="6-Default-root"><a href="#6-Default-root" class="headerlink" title="6. Default root"></a>6. Default root</h3><blockquote><br>修改lightdm配置<br>对于早期的系统，打开root登陆，修改 /etc/lightdm/lightdm.conf.d/50-unity-greeter.conf<br>添加：greeter-show-manual-login=true<br>allow-guest=true<br>说明：greeter-show-manual-login=true    #允许手工输入登陆系统的用户名和密码<br>allow-guest=true  #允许guest登录，可以根据自己的需要修改<br>保存后重启，就可以通过输入用户名root登陆了<br>而在15.04中，配置文件位置改变了，为<br>/user/share/lightdm/lightdm.conf.d/<br>加入greeter-show-manual-login=true<br>之后重启会有错误，再修改/root/.profile<br>tty -s &amp;&amp; mesg n<br></blockquote>


<h3 id="7-Proxy"><a href="#7-Proxy" class="headerlink" title="7. Proxy"></a>7. Proxy</h3><p>Shadowsocks</p>
<h3 id="8-root后的问题"><a href="#8-root后的问题" class="headerlink" title="8. root后的问题"></a>8. root后的问题</h3><p>root登录后发现他把键有些不能补全，修改/root/.bashrc文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#if [ -f /etc/bash_completion ] &amp;&amp; ! shopt -oq posix; then</span></span><br><span class="line"><span class="comment">#    . /etc/bash_completion</span></span><br><span class="line"><span class="comment">#fi</span></span><br></pre></td></tr></table></figure><br>将上述注释去了即可<br>root后无声音：修改/root/.profile，最后加一句<br><code>pulseaudio --start --log-target=syslog</code></p>
<p>或者运行alsamixer，修改auto-mute-mode</p>
<h3 id="9-Github"><a href="#9-Github" class="headerlink" title="9. Github"></a>9. Github</h3><p><a href="https://help.github.com/articles/generating-ssh-keys/" target="_blank" rel="noopener">https://help.github.com/articles/generating-ssh-keys/</a><br>创建ssh key先，<code>ls -al ~/.ssh</code>查询该主机没有ssh key，于是创建：<br><code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code><br>Ensure ssh-agent is enabled:<br><code>eval &quot;$(ssh-agent -s)&quot;</code><br>Add your SSH key to the ssh-agent:<br><code>ssh-add ~/.ssh/id_rsa</code></p>
<p>open the ~/.ssh/id_rsa.pub file.<br>Select the entire contents of the file and copy it to your clipboard. Do not add any newlines or whitespace.<br>Add the copied key to GitHub:</p>
<p>Test the connection:<br><code>ssh -T git@github.com</code></p>
<h3 id="10-Font"><a href="#10-Font" class="headerlink" title="10. Font"></a>10. Font</h3><p>YaHei.Consolas.1.12</p>
<h3 id="11-Telegram"><a href="#11-Telegram" class="headerlink" title="11. Telegram"></a>11. Telegram</h3><p>挂代理下载包，解压缩直接运行即可。</p>
<h3 id="12-Vim"><a href="#12-Vim" class="headerlink" title="12. Vim"></a>12. Vim</h3><h3 id="13-PDF"><a href="#13-PDF" class="headerlink" title="13. PDF"></a>13. PDF</h3><p><code>evince ***.pdf</code></p>
<h3 id="14-Codeblocks"><a href="#14-Codeblocks" class="headerlink" title="14. Codeblocks"></a>14. Codeblocks</h3><h3 id="15-irc-命令行工具"><a href="#15-irc-命令行工具" class="headerlink" title="15. irc 命令行工具"></a>15. irc 命令行工具</h3><p>irssi<br>weechat</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>三字符构成字符串</title>
    <url>/2015/06/15/threeCharacters/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h3><p>仅由三个字符A、B、C构成字符串，且字符串任意相邻三个元素不能完全相同。如“ACCCAB”不合法，“ABBCBCA”合法。求满足条件的长度为n的字符串个数。假定不考虑整数溢出，要求时间和空间复杂度不高于O(N)。</p>
<h3 id="2-Hints"><a href="#2-Hints" class="headerlink" title="2. Hints"></a>2. Hints</h3><ul>
<li>1、考虑使用动态规划，将长度为N的字符串个数表示成长度为N-1的字符串个数的递归关系；</li>
<li>2、使用滚动数组降低空间复杂度；</li>
<li>3、矩阵乘幂降低时间复杂度。</li>
</ul>
<a id="more"></a>
<h3 id="3-Solution"><a href="#3-Solution" class="headerlink" title="3. Solution"></a>3. Solution</h3><p>若当前已经有长度为n-1的合法字符串，则在末端增加一个字符，形成长度为n的字符串，n-1的字符串可分为“末端两字符相等”和“末端两字符不等”，分别记为\(dp[n-1][0]\)和\(dp[n-1][1]\)，长度为n的字符串都可以这样划分，于是:<br>$$<br>\begin{cases}<br>dp[n][0] = dp[n-1][0]*2 + dp[n-1][1]*2 \\<br>dp[n][1] = dp[n-1][0]<br>\end{cases}<br>$$<br>其初始条件为\(dp[1][0] = 3, dp[1][1] = 0\);</p>
<p>状态转移方程为<br>$$<br>\begin{cases}<br>dp[n][0] = dp[n-1][0]*2 + dp[n-1][1]*2 \\<br>dp[n][1] = dp[n-1][0]<br>\end{cases}<br>$$<br>其可以通过滚动数组简化：<br>$$<br>\begin{cases}<br>dp[0] = dp[0]*2 + dp[1]*2 \\<br>dp[1] = dp[0]<br>\end{cases}<br>$$<br>由此可以将空间复杂度降为O(1)</p>
<h3 id="4-代码"><a href="#4-代码" class="headerlink" title="4. 代码"></a>4. 代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculateCount</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> accumulation = calculateCount(n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; accumulation &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculateCount</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> accumulation = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp0 = <span class="number">3</span>, dp1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = dp0;</span><br><span class="line">        dp0 = <span class="number">2</span>*dp0 + <span class="number">2</span>*dp1;</span><br><span class="line">        dp1 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    accumulation = dp0+dp1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> accumulation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-优化"><a href="#5-优化" class="headerlink" title="5. 优化"></a>5. 优化</h3><p>此题还可以简化时间复杂度，方法就是题目中的提示3。<br>由矩阵的状态方程：<br>$$<br>\begin{cases}<br>dp[0] = 2*dp[0] + 2*dp[1] \\<br>dp[1] = dp[0]<br>\end{cases}<br>$$<br>得到矩阵形式：<br>$$<br>\begin{equation}<br>(dp[0] dp[1])_{new} = (dp[0] dp[1])_{old} \cdot \bigl( \begin{matrix} 2 &amp; 1 \\ 2 &amp; 0 \end{matrix} \bigr)<br>\nonumber<br>\end{equation}<br>$$<br>从而得到：<br>$$<br>\begin{equation}<br>\begin{split}<br>(dp[0] dp[1])_{n} &amp;= (dp[0] dp[1])_{n-1} \cdot \bigl( \begin{matrix} 2 &amp; 1 \\ 2 &amp; 0 \end{matrix} \bigr) \\<br>&amp;= (dp[0] dp[1])_{n-2} \cdot \bigl( \begin{matrix} 2 &amp; 1 \\ 2 &amp; 0 \end{matrix} \bigr) \bigl( \begin{matrix} 2 &amp; 1 \\ 2 &amp; 0 \end{matrix} \bigr) \\<br>&amp;= \ldots \\<br>&amp;= (dp[0] dp[1])_{1} \cdot \bigl( \begin{matrix} 2 &amp; 1 \\ 2 &amp; 0 \end{matrix} \bigr)^{n-1}<br>\end{split}<br>\nonumber<br>\end{equation}<br>$$</p>
<p>新建一个矩阵求幂的类，并据此写出完整代码，以下只给出类实现:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> POWMATRIX_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POWMATRIX_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PowMatrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        PowMatrix(<span class="keyword">int</span> dimension);   <span class="comment">//构造函数</span></span><br><span class="line">        <span class="keyword">virtual</span> ~PowMatrix();       <span class="comment">//析构函数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setMatrix</span><span class="params">(<span class="keyword">int</span>* matrix)</span></span>;    <span class="comment">//设置矩阵</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> column)</span></span>;   <span class="comment">//两数组对应相乘</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> count)</span></span>;        <span class="comment">//求幂函数</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span>* <span class="title">getResult</span><span class="params">()</span> </span>&#123;          <span class="comment">//得到结果</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> dimension;      <span class="comment">//矩阵维度</span></span><br><span class="line">        <span class="keyword">int</span>* matrix;        <span class="comment">//需要求幂的初始矩阵</span></span><br><span class="line">        <span class="keyword">int</span>* result;        <span class="comment">//求幂之后存放结果的矩阵</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// POWMATRIX_H</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PowMatrix::PowMatrix(<span class="keyword">int</span> dimension) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;dimension = dimension;            <span class="comment">//初始化维度</span></span><br><span class="line">    matrix = <span class="keyword">new</span> <span class="keyword">int</span>[dimension*dimension];  <span class="comment">//初始化分配matrix空间</span></span><br><span class="line">    result = <span class="keyword">new</span> <span class="keyword">int</span>[dimension*dimension];  <span class="comment">//初始化分配存放结果的矩阵的内存空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PowMatrix::~PowMatrix() &#123;</span><br><span class="line">    <span class="keyword">delete</span> matrix;</span><br><span class="line">    <span class="keyword">delete</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PowMatrix::setMatrix</span><span class="params">(<span class="keyword">int</span>* matrix)</span> </span>&#123;    <span class="comment">//设置需要自乘的矩阵值,用一维数组形式逐行存放</span></span><br><span class="line">    <span class="keyword">int</span> len = dimension*dimension;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        (<span class="keyword">this</span>-&gt;matrix)[i] = matrix[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PowMatrix::multiply</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;  <span class="comment">//result矩阵第row行和matrix矩阵第column列相乘</span></span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; dimension; i++,j++) &#123;</span><br><span class="line">        val += ( result[row*dimension+i] ) * ( matrix[j*dimension+column] );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PowMatrix::pow</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;                <span class="comment">//矩阵求幂函数</span></span><br><span class="line">    <span class="comment">//以下为建立单位矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dimension*dimension; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i/dimension == i%dimension) &#123;        <span class="comment">//判断一维数组模拟矩阵的实际对角线位置</span></span><br><span class="line">            result[i] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//矩阵的count次幂</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; count; k++) &#123;            <span class="comment">//第k次自乘</span></span><br><span class="line">        <span class="keyword">int</span>* temp = <span class="keyword">new</span> <span class="keyword">int</span>[dimension*dimension];</span><br><span class="line">        <span class="comment">//以下循环,逐次求出矩阵row行column列的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; dimension; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; dimension; column++) &#123;</span><br><span class="line">                temp[row*dimension+column] = multiply(row,column);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将temp矩阵赋值给result矩阵,即更新result矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dimension*dimension; j++) &#123;</span><br><span class="line">            result[j] = temp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码可在<a href="https://github.com/zhen-yu/Miscellaneous/tree/master/ThreeCharacters" target="_blank" rel="noopener">此处</a>下载</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>升级Ubuntu 17.10之后</title>
    <url>/2017/11/19/ubuntu02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前写过一篇<a href="/2015/05/26/ubuntu01/">安装Ubuntu 15.04之后</a>. 基本上14.04到17.04应该都可以参照, 在自己电脑上这些版本基本都用过, 没什么大问题.<br>前两天在实验室把Ubuntu更新到了17.10, 可能是太久没用Gnome桌面了, 比想象中的好、那就用下去呗</p>
<p>不过也带来了一些问题, 需要一步一步解决</p>
<a id="more"></a>
<h3 id="1-Root登录"><a href="#1-Root登录" class="headerlink" title="1. Root登录"></a>1. Root登录</h3><p>预警: 一般还是遵循医嘱, 不要学我这种野路子默认root登录…<br>两个地方, 一是<code>/etc/gdm3/custom.conf</code>处, 在<code>[Security]</code>下添加<code>AllowRoot=true</code>; 二是<code>/etc/pam.d/gdm-password</code>处, 将<code>auth    required    pam_succeed_if.so user != root quiet_success</code>注释</p>
<h3 id="2-Root使用Chrome"><a href="#2-Root使用Chrome" class="headerlink" title="2. Root使用Chrome"></a>2. Root使用Chrome</h3><p>Unity下使用root登录chrome只需要指定<code>user-data-dir</code>就可以了, gnome不行, 还需要额外指定<code>--no-sandbox</code>, 为了使用以前的<code>user-data-dir</code>和指定<code>no-sandbox</code>, 执行了两步.</p>
<ul>
<li>将Chrome的默认配置位置软链接到以前的Data保存位置: <code>ln -s &lt;your-user-data-dir&gt; /root/.config/google-chrome</code></li>
<li>修改google-chrome可执行文件<code>/usr/bin/google-chrome</code>, 将<code>exec -a &quot;$0&quot; &quot;$HERE/chrome&quot; &quot;$@&quot;</code>改为:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ <span class="variable">$EUID</span> -ne 0 ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">exec</span> -a <span class="string">"<span class="variable">$0</span>"</span> <span class="string">"<span class="variable">$HERE</span>/chrome"</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">exec</span> -a <span class="string">"<span class="variable">$0</span>"</span> <span class="string">"<span class="variable">$HERE</span>/chrome"</span> <span class="string">"<span class="variable">$@</span>"</span> --no-sandbox</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-解决出现Invalid-MIT-MAGIC-COOKIE-1-key的问题"><a href="#3-解决出现Invalid-MIT-MAGIC-COOKIE-1-key的问题" class="headerlink" title="3. 解决出现Invalid MIT-MAGIC-COOKIE-1 key的问题"></a>3. 解决出现<code>Invalid MIT-MAGIC-COOKIE-1 key</code>的问题</h3><p>该问题出现在和X桌面相关的程序中, 比如vim运行之后退出就会出现该信息. 解决方法是删除用户目录下的<code>.Xauthority</code>文件即可, 笔者顺手还删了<code>.xsession-errors</code>和<code>.xsession-errors.old</code></p>
<h3 id="4-更改源"><a href="#4-更改源" class="headerlink" title="4. 更改源"></a>4. 更改源</h3><p>更新系统之后, <code>/etc/apt/sources.list.d/</code>里添加的第三方源默认会被注释掉, 取消注释, 顺便把冗余文件删除.<br>清华的Tuna源很好用, 在上一篇没有提到, 现在改用.</p>
<h3 id="5-卸载Unity"><a href="#5-卸载Unity" class="headerlink" title="5. 卸载Unity"></a>5. 卸载Unity</h3><p><code>apt remove unity</code></p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>RESTful推送与异步通信</title>
    <url>/2016/05/20/web02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-服务器-浏览器通信技术"><a href="#1-服务器-浏览器通信技术" class="headerlink" title="1. 服务器-浏览器通信技术"></a>1. 服务器-浏览器通信技术</h3><p>服务器-浏览器通信也可以称为服务器端推送技术, 是一种当服务器端的业务数据、资源状态发生改变时, 服务器可以主动将这一信息通知给相关的浏览器的通信技术。如果服务器与客户端使用TCP/IP协议建立连接, 这样的Socket通信并无特别之处, 一旦连接建立, 在这样的双向通信链路中随时都可以发送通知. 然而REST通信是基于HTTP的通信, 而HTTP是无状态的通信协议, 每一次请求-响应都是基于一个新建立的HTTP的连接, 这就是使服务器主动通知浏览器成为一个难点. 这是因为在基于请求-响应的模式下, 服务器的角色是主动应答, 无法主动通知浏览器; 另一个原因是每次请求后HTTP连接断开, 服务器无法再获取客户端的地址, 也就无法将通知发送给浏览器端<br><a id="more"></a></p>
<h4 id="1-1-Polling-客户端轮询-技术"><a href="#1-1-Polling-客户端轮询-技术" class="headerlink" title="1.1 Polling(客户端轮询) 技术"></a>1.1 Polling(客户端轮询) 技术</h4><p>即浏览器周期性地主动访问服务器的特定地址, 以获取服务器端数据状态的变化<br>优点: </p>
<ul>
<li>易于实现</li>
<li>对设计没有注入性污染<br>缺点:</li>
<li>如果服务器的业务数据在两次定时任务发起的请求过程中没有变化, 后一次请求的做功实际为负数——浪费了服务器的带宽, 而且没有获得有效负载</li>
<li>浏览器端的定时器间隔时间参数的设置比较尴尬, 过短频发第一个问题, 过长无法及时获取服务器端数据, 且该值往往难以抽象出来, 不同业务的定时间隔都是一个独立的经验值</li>
</ul>
<h4 id="1-2-Comet技术"><a href="#1-2-Comet技术" class="headerlink" title="1.2 Comet技术"></a>1.2 Comet技术</h4><p>Comet是反向AJAX技术集, 包括长轮训(Long Polling)和流(Streaming)两种技术.<br>反向AJAX(Reverse AJAX)技术从请求方向上看并没有反向, 该”反向”是从结果上看的, 即从服务器端(通过保持连接的HTTP通道)向客户端发送数据, 以实现低延迟地通知客户端的技术, 其底层实现依赖于HTTP连接不能断开这一前提条件. 长轮询和流技术是反向AJAX的两种技术手段.</p>
<p><img src="/images/web03_01.png" alt="long polling"></p>
<p>如图所示, 长轮询通过KeepAlive使HTTP连接得以保持连接. 为何需要保持连接? 因为在请求发出后的一段时间内, 服务器一直没有做出响应, 该连接会因连接超时而断开. Comet利用HTTP1.1的keepAlive的持久性连接技术, 在浏览器发出请求后, 通过keepAlive保存服务器向浏览器做出响应的通信, 如此解决了连接超时断开的问题. 那么连接的关闭只有两种情况, 一种是浏览器主动断开, 一种是服务器端特定数据发生变化， 并将这一信息响应给浏览器, 主动断开连接来完成请求-响应模式的一次请求</p>
<p>相比Polling, 实现Comet困难许多, 服务器和浏览器都需要第三方库来支持. Atmosphere和CometD库是实现Comet技术的第三方工具包</p>
<p>优点: 解决了Polling的低效性, 且有很好的低延迟性<br>缺点: 需要额外的技术实现支持, 引入第三方包, 较为复杂</p>
<h4 id="1-3-SSE技术"><a href="#1-3-SSE技术" class="headerlink" title="1.3 SSE技术"></a>1.3 SSE技术</h4><p>SSE是HTML5技术集的一部分, 定义了服务器推送技术的标准规范<br>SSE规范地址可以<a href="https://html.spec.whatwg.org/multipage/comms.html#server-sent-events" target="_blank" rel="noopener">点此</a>. 其核心是基于EventSource接口的事件监听机制, 包括onopen、onmessage和onerror三个事件监听器. SSE服务器响应数据的媒体类型(Content-Type)是text/event-stream.</p>
<p>优点: 是HTML5标准一部分, 具备编程语言无关性, 且支持跨语言的调用<br>缺点: 和Comet一样, 浏览器无法在同一条连接上做出二次请求或者对服务器的响应做出”响应”</p>
<h4 id="1-4-WebSocket技术"><a href="#1-4-WebSocket技术" class="headerlink" title="1.4 WebSocket技术"></a>1.4 WebSocket技术</h4><p>WebSocket是HTML5技术集一部分, 提供了一个双向的、在一条TCP信道中的客户端和服务端全双工的通信<br>WebSocket消除了所有与HTTP连接的无状态特性相关的限制</p>
<p>优点: 是HTML5标准之一, 逐渐流行,功能强大,性能突出,双向、双工通信<br>缺点: 相对于SSE实现较为复杂</p>
<h3 id="2-SSE通信模式"><a href="#2-SSE通信模式" class="headerlink" title="2. SSE通信模式"></a>2. SSE通信模式</h3><p>Java的Jersey框架的SSE支持包提供两种通信模式, 发布-订阅模式和广播模式. 前者是一种端到端的通信, 后者是多播通信</p>
<h3 id="3-异步通信"><a href="#3-异步通信" class="headerlink" title="3. 异步通信"></a>3. 异步通信</h3><h4 id="3-1-Polling异步通信"><a href="#3-1-Polling异步通信" class="headerlink" title="3.1 Polling异步通信"></a>3.1 Polling异步通信</h4><p>该技术结合了HATEOAS和Web Link, 以及Polling技术<br><img src="/images/web03_02.png" alt="asyn01"></p>
<h4 id="3-2-Web-Hook异步通信"><a href="#3-2-Web-Hook异步通信" class="headerlink" title="3.2 Web Hook异步通信"></a>3.2 Web Hook异步通信</h4><p>该解决方案是指在客户端发送请求时, 将一个回调地址同时发送给服务器, 服务器接收响应后, 异步处理请求并对此次请求即刻做出响应, 客户端随即处理其他业务并监听回调. 服务器在响应客户端后, 继续以异步的方式处理刚才的请求, 在处理完毕后, 通过回调地址通知客户端处理结果<br>优点是覆盖了Polling方案并且没有Polling方案中无效的轮询负载. 但是, 这种方案无法在浏览器作为客户端的场景中实施, 因为浏览器无法提供一个回调地址给服务器. 因此该方案适用于另外一个服务器作为客户端的场景. 另外, 和后面的解决方案比起来, 该方案还是多出了一次服务器回调客户端的HTTP连接<br><img src="/images/web03_03.png" alt="asyn02"></p>
<h4 id="3-3-Comet异步通信"><a href="#3-3-Comet异步通信" class="headerlink" title="3.3 Comet异步通信"></a>3.3 Comet异步通信</h4><p>Comet技术在服务器推送业务中的处理流程同样适用于这里的异步通信, 客户端发送请求后可以继续执行后续业务并监听服务器返回的处理结果的通知, 优点是异步通信可以在一次请求-响应的模型中完成<br><img src="/images/web03_04.png" alt="asyn03"></p>
<h4 id="3-4-HTML5异步通信"><a href="#3-4-HTML5异步通信" class="headerlink" title="3.4 HTML5异步通信"></a>3.4 HTML5异步通信</h4><p>包含SSE和Web Socket, 均有处理异步通信的能力</p>
<h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h3><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)"><a href="https://book.douban.com/subject/26022847/" target="_blank" rel="noopener">Mastering Web Application Development with AngularJS</a><a href="#fnref:1" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>communicate</tag>
      </tags>
  </entry>
  <entry>
    <title>Movie Projector 01</title>
    <url>/2016/02/12/watching01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-Planet-Earth-EP01"><a href="#1-Planet-Earth-EP01" class="headerlink" title="1. Planet Earth EP01"></a>1. Planet Earth EP01</h3><blockquote>
<ol>
<li>At this stage, the odds are even.</li>
<li>Midsummer on the tundra and the sun does not set.</li>
<li>The character of the forest changes as you descend, becoming ever darker and damper, faouring different kinds of animals amd plants.</li>
<li>It’s hard not to feel deflated when even your best isn’t good enough.</li>
<li>Its richest parts are those where waves and currents bring fertilising nutrients to surface waters that are bathed in sunlight.</li>
<li>The strike of a great white shark lasts a mere second, slowing it down 40 times reveals the technique and immense strength of this massive predator.<a id="more"></a></li>
<li>it’s agility versus power.</li>
<li>It’s a seasonal feast for animals of all kinds.</li>
<li>The lives of these elephants are.dominated by the annual rhythm of wet and dry, a seasonal cycle created by sun.</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>life</category>
        <category>watching</category>
      </categories>
      <tags>
        <tag>documentary</tag>
      </tags>
  </entry>
  <entry>
    <title>Union-Find Structure</title>
    <url>/2015/11/17/unionFind/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p><a href="http://blog.csdn.net/dellaserss/article/details/7724401" target="_blank" rel="noopener">这篇文章</a>写的很好懂</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>union find</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 琐记一</title>
    <url>/2015/08/03/windows01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-Word中字体大小与磅值对应关系"><a href="#1-Word中字体大小与磅值对应关系" class="headerlink" title="1. Word中字体大小与磅值对应关系"></a>1. Word中字体大小与磅值对应关系</h3><p>字号”八号”对应磅值5<br>字号”七号”对应磅值5.5<br>字号”小六”对应磅值6.5<br>字号”六号”对应磅值7.5<br>字号”小五”对应磅值9<br>字号”五号”对应磅值10.5<br>字号”小四”对应磅值12<br>字号”四号”对应磅值14<br>字号”小三”对应磅值15<br>字号”三号”对应磅值16<br>字号”小二”对应磅值18<br>字号”二号”对应磅值22<br>字号”小一”对应磅值24<br>字号”一号”对应磅值26<br>字号”小初”对应磅值36<br>字号”初号”对应磅值42</p>
<a id="more"></a>
<h3 id="2-比较文件命令"><a href="#2-比较文件命令" class="headerlink" title="2. 比较文件命令"></a>2. 比较文件命令</h3><p>本想用windows自带的fc命令,却发现只可以比较两文件无法比较文件夹,于是加上自己用的cmder自带很多linux命令(其实应该是msysgit带的),于是考虑使用diff命令, 用-r选项即可<br><code>diff -r &#39;E:\Amusement\music\&#39; &#39;F:\Recreation\Music\&#39;</code></p>
<h3 id="3-markdown文件中加入html代码"><a href="#3-markdown文件中加入html代码" class="headerlink" title="3. markdown文件中加入html代码"></a>3. markdown文件中加入html代码</h3><p>例如加上<code>&lt;p align=&quot;center&quot;&gt;Test&lt;/p&gt;</code>，则必须在后面加一空行，否则不会输出理想结果，原因暂时未知。</p>
<h3 id="4-cmd设置为utf-8编码"><a href="#4-cmd设置为utf-8编码" class="headerlink" title="4. cmd设置为utf-8编码"></a>4. cmd设置为utf-8编码</h3><p><code>CHCP 65001</code><br>切换回GBK可用<code>chcp 936</code></p>
<h3 id="5-cmder切为PowerShell模式下无法使用git等"><a href="#5-cmder切为PowerShell模式下无法使用git等" class="headerlink" title="5. cmder切为PowerShell模式下无法使用git等"></a>5. cmder切为PowerShell模式下无法使用git等</h3><p>将git的bin目录加入系统path下，加入用户组的path貌似不可以，至少我的电脑上是这样<br>若还不行可以尝试<code>Set-ExecutionPolicy RemoteSigned</code></p>
<h3 id="6-Windows-录音"><a href="#6-Windows-录音" class="headerlink" title="6. Windows 录音"></a>6. Windows 录音</h3><p>命令行输入<code>soundrecorder /file outputfile.wav</code></p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>skills</tag>
      </tags>
  </entry>
  <entry>
    <title>前端相关</title>
    <url>/2015/07/25/web01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-响应式网页图标"><a href="#1-响应式网页图标" class="headerlink" title="1. 响应式网页图标"></a>1. 响应式网页图标</h3><p><a href="http://www.gbtags.com/gb/share/2774.htm" target="_blank" rel="noopener">http://www.gbtags.com/gb/share/2774.htm</a><br><a href="http://fortawesome.github.io/Font-Awesome/" target="_blank" rel="noopener">http://fortawesome.github.io/Font-Awesome/</a></p>
<h3 id="2-html编码"><a href="#2-html编码" class="headerlink" title="2. html编码"></a>2. html编码</h3><p>Ascii编码见<a href="http://www.w3chtml.com/html/ref/ascii.html" target="_blank" rel="noopener">这里</a><br>Unicode编码太多, 可网上找工具转换<br>例如”你好”可以Unicode编码为<code>\u4f60\u597d</code></p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>icon</tag>
        <tag>html encoding</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 琐记三</title>
    <url>/2016/03/15/windows03/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-cmd下设置字符集"><a href="#1-cmd下设置字符集" class="headerlink" title="1. cmd下设置字符集"></a>1. cmd下设置字符集</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chcp</span> <span class="number">437</span>     // <span class="built_in">set</span> english       environment</span><br><span class="line"><span class="built_in">chcp</span> <span class="number">932</span>     // <span class="built_in">set</span> japanese      environment</span><br><span class="line"><span class="built_in">chcp</span> <span class="number">936</span>     // <span class="built_in">set</span> chinese(sim)  environment</span><br><span class="line"><span class="built_in">chcp</span> <span class="number">949</span>     // <span class="built_in">set</span> chinese(tra)  environment</span><br><span class="line"><span class="built_in">chcp</span> <span class="number">950</span>     // <span class="built_in">set</span> korean        environment</span><br><span class="line"><span class="built_in">chcp</span> <span class="number">65001</span>   // <span class="built_in">set</span> utf-<span class="number">8</span>         environment</span><br></pre></td></tr></table></figure>
<p>改成437后可以解决一些乱码问题, 奇怪的是明明装的是英文系统竟然默认是936</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>cmd</tag>
        <tag>charset</tag>
      </tags>
  </entry>
  <entry>
    <title>傅里叶变换窗函数</title>
    <url>/2015/06/27/windowFunction/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>用窗函数分析信号，相当于将一个待分析信号x1通过一个传输函数为窗函数傅里叶变换的滤波器得到输出信号或分析信号y1</p>
<p><a href="http://www.cnblogs.com/gaozehua/p/3516556.html" target="_blank" rel="noopener">http://www.cnblogs.com/gaozehua/p/3516556.html</a><br><a href="http://people.ece.cornell.edu/land/courses/ece4760/FinalProjects/s2010/gjm76_asr96/gjm76_asr96/" target="_blank" rel="noopener">http://people.ece.cornell.edu/land/courses/ece4760/FinalProjects/s2010/gjm76_asr96/gjm76_asr96/</a></p>
]]></content>
      <categories>
        <category>science</category>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
        <tag>fourier</tag>
        <tag>window function</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 琐记二</title>
    <url>/2015/09/14/windows02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-修复U盘"><a href="#1-修复U盘" class="headerlink" title="1. 修复U盘"></a>1. 修复U盘</h3><p>以前用U盘制作Linux启动盘时，制作之后windows下都无法读取了，必须格式化，而格式化之后的U盘容量骤减为几M……磁盘管理里查看直接显示为黑色区域，估计是某些分区读不出来，搜了下解决方法：<br>先输入命令diskpart，之后：<br><img src="/images/repairUdisk.png" alt="repairUdisk"></p>
<p>即<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">diskpart</span><br><span class="line">list disk</span><br><span class="line">select disk <span class="number">2</span></span><br><span class="line">clean</span><br><span class="line">create partition primary</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="2-U盘制作系统盘"><a href="#2-U盘制作系统盘" class="headerlink" title="2. U盘制作系统盘"></a>2. U盘制作系统盘</h3><p>用u盘制作系统启动盘时，以前常用Win32DiskImager，有一次失败了，用Linux的dd命令也失败了，使用了下面的方法成功：<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">diskpart</span><br><span class="line">list disk</span><br><span class="line">select disk #</span><br><span class="line">clean</span><br><span class="line">create partition primary</span><br><span class="line">select partition <span class="number">1</span></span><br><span class="line">active</span><br><span class="line"><span class="built_in">format</span> <span class="built_in">fs</span>=fat32 quick   #这里我经常使用ntfs文件格式，也可以</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><br>之后将iso镜像解压至u盘即可</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>udisk</tag>
      </tags>
  </entry>
  <entry>
    <title>Android TabHost的使用</title>
    <url>/2014/08/27/android01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1. 写在前面"></a>1. 写在前面</h2><p>出于对新事物的好奇, 接触了一下Android, 主要是看书(《Anroid应用开发深入学习实录》 关立勋)、Google和看文档。使用的android-sdk的platform最低是android-14, 然后有android-17,android-20以及android-L(电脑配置暂时比较低,没法把每个版本都测试一遍）<br>此时此刻Intellij IDEA社区版还没法渲染出android-20和android-L，所以我基本都是用的android-17<br><em>虽然书的出版日期比较新, 但其中有些内容还是已经过时了</em><br><a id="more"></a></p>
<h2 id="2-TabHost的使用详解"><a href="#2-TabHost的使用详解" class="headerlink" title="2. TabHost的使用详解"></a>2. TabHost的使用详解</h2><h3 id="2-1-项目结构"><a href="#2-1-项目结构" class="headerlink" title="2.1 项目结构"></a>2.1 项目结构</h3><p>先新建一个项目，使用以前构建项目的方法(虽然现在有了Gradle, 但是对于初学者来说学习成本稍高, 暂时搁置):<br>MySetting.java在这里没用，忽略它……</p>
<p><img src="/images/android_tabhost_1.png" alt="project structure"></p>
<h3 id="2-2-App布局"><a href="#2-2-App布局" class="headerlink" title="2.2 App布局"></a>2.2 App布局</h3><p>布局main.xml:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TabHost</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/tabHost"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TabWidget</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@android:id/tabs"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">TabWidget</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@android:id/tabcontent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:text</span>=<span class="string">"@string/textview1"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">"@+id/textView1"</span> <span class="attr">android:layout_gravity</span>=<span class="string">"left|top"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:text</span>=<span class="string">"@string/textview2"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">"@+id/textView2"</span> <span class="attr">android:layout_gravity</span>=<span class="string">"center_horizontal|top"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:text</span>=<span class="string">"@string/textview3"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">"@+id/textView3"</span> <span class="attr">android:layout_gravity</span>=<span class="string">"right|top"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">TabHost</span>&gt;</span></span><br></pre></td></tr></table></figure><br>strings.xml不放了, 随便什么字符串无所谓</p>
<h3 id="2-3-逻辑代码"><a href="#2-3-逻辑代码" class="headerlink" title="2.3 逻辑代码"></a>2.3 逻辑代码</h3><p>想要实现的就是添加三个Tab标签, 改变Tab标签的时候会弹出一个对话框, 按照书上及网上搜到的大部分代码, MyActivity.java应该是:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">( Bundle savedInstanceState )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.main);</span><br><span class="line">        mTabHost = getTabHost();</span><br><span class="line">        mTabHost.addTab...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样的话有个问题: 查文档发现TabActivity在API Level 13中已经被弃用了。有:<br><em>This class was deprecated in API level 13. New applications should use Fragments instead of this class; to continue to run on older devices, you can use the v4 support library which provides a version of theFragment API that is compatible down to DONUT.</em><br>还有一句：<br><em>A replacement for TabActivity can also be implemented by directly using TabHost.</em><br>这其实意味着如果我们不考虑向下兼容的问题, 其实可以直接将上述代码写成:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hecate.Apollo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.app.AlertDialog;</span><br><span class="line"><span class="keyword">import</span> android.app.Dialog;</span><br><span class="line"><span class="keyword">import</span> android.content.DialogInterface;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.TabHost;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called when the activity is first created.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.main);</span><br><span class="line">        TabHost mTabHost = (TabHost) findViewById(R.id.tabHost);</span><br><span class="line">        mTabHost.setup();</span><br><span class="line">        mTabHost.addTab( mTabHost.newTabSpec(<span class="string">"first"</span>).setIndicator(<span class="string">"Tab 1"</span>,getResources().getDrawable(R.drawable.img1)).setContent(R.id.textView1) );</span><br><span class="line">        mTabHost.addTab( mTabHost.newTabSpec(<span class="string">"second"</span>).setIndicator(<span class="string">"Tab 2"</span>,getResources().getDrawable(R.drawable.img2)).setContent(R.id.textView2) );</span><br><span class="line">        mTabHost.addTab( mTabHost.newTabSpec(<span class="string">"third"</span>).setIndicator(<span class="string">"Tab 3"</span>,getResources().getDrawable(R.drawable.img3)).setContent(R.id.textView3) );</span><br><span class="line"></span><br><span class="line">        mTabHost.setBackgroundColor(Color.parseColor(<span class="string">"blue"</span>));</span><br><span class="line">        mTabHost.setBackgroundResource(R.drawable.background);</span><br><span class="line">        mTabHost.setCurrentTab(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        mTabHost.setOnTabChangedListener( <span class="keyword">new</span> TabHost.OnTabChangeListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTabChanged</span><span class="params">( String tabId )</span> </span>&#123;</span><br><span class="line">                Dialog dialog = <span class="keyword">new</span> AlertDialog.Builder( MyActivity.<span class="keyword">this</span> )</span><br><span class="line">                        .setTitle(<span class="string">"Change Tabs"</span>)</span><br><span class="line">                        .setMessage(<span class="string">"You chosen "</span>+tabId+<span class="string">" Tab"</span>)</span><br><span class="line">                        .setPositiveButton(<span class="string">"OK"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">( DialogInterface dialogInterface, <span class="keyword">int</span> whichButton )</span> </span>&#123;</span><br><span class="line">                                dialogInterface.cancel();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;).create();</span><br><span class="line">                dialog.show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>也就是直接继承Activity, 然后不使用getTabHost()方法而是findViewById(), 这时候又有一个注意点, 在TabHost文档的setup()方法中有:<br><em>Call setup() before adding tabs if loading TabHost using findViewById().</em><br>就是说如果你不是用getTabHost而是findViewById获取的TabHost，那在使用addTab()方法前要使用setup()方法。</p>
<h3 id="2-4-运行测试"><a href="#2-4-运行测试" class="headerlink" title="2.4 运行测试"></a>2.4 运行测试</h3><p>按照以上完成之后, 再添加相应的资源文件就可以成功运行了(在API Level 13以上):<br><img src="/images/android_tabhost_2.png" alt="tabhost_layout"><br>原谅我的背景图片、、、点击TAB2后弹窗:<br><img src="/images/android_tabhost_3.png" alt="tabhost_popup"></p>
<h3 id="2-5-向下兼容"><a href="#2-5-向下兼容" class="headerlink" title="2.5 向下兼容"></a>2.5 向下兼容</h3><p>说完了不向下兼容的方法, 那如果需要向下兼容呢? 正如一开始的文档所说, 使用Fragments和android.support.v4 library即可, 具体可以去查看详细的文档, 里面给了一个示例, 我把示例代码贴出来, 就不分析了:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">android.support.v4.app.FragmentTabHost</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@android:id/tabhost"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TabWidget</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@android:id/tabs"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@android:id/tabcontent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/realtabcontent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.v4.app.FragmentTabHost</span>&gt;</span></span><br></pre></td></tr></table></figure><br>Java代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.android.supportv4.R;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.app.FragmentActivity;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.app.FragmentTabHost;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This demonstrates how you can implement switching between the tabs of a</span></span><br><span class="line"><span class="comment"> * TabHost through fragments, using FragmentTabHost.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FragmentTabs</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FragmentTabHost mTabHost;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        setContentView(R.layout.fragment_tabs);</span><br><span class="line">        mTabHost = (FragmentTabHost)findViewById(android.R.id.tabhost);</span><br><span class="line">        mTabHost.setup(<span class="keyword">this</span>, getSupportFragmentManager(), R.id.realtabcontent);</span><br><span class="line"></span><br><span class="line">        mTabHost.addTab(mTabHost.newTabSpec(<span class="string">"simple"</span>).setIndicator(<span class="string">"Simple"</span>),</span><br><span class="line">                FragmentStackSupport.CountingFragment<span class="class">.<span class="keyword">class</span>, <span class="title">null</span>)</span>;</span><br><span class="line">        mTabHost.addTab(mTabHost.newTabSpec(<span class="string">"contacts"</span>).setIndicator(<span class="string">"Contacts"</span>),</span><br><span class="line">                LoaderCursorSupport.CursorLoaderListFragment<span class="class">.<span class="keyword">class</span>, <span class="title">null</span>)</span>;</span><br><span class="line">        mTabHost.addTab(mTabHost.newTabSpec(<span class="string">"custom"</span>).setIndicator(<span class="string">"Custom"</span>),</span><br><span class="line">                LoaderCustomSupport.AppListFragment<span class="class">.<span class="keyword">class</span>, <span class="title">null</span>)</span>;</span><br><span class="line">        mTabHost.addTab(mTabHost.newTabSpec(<span class="string">"throttle"</span>).setIndicator(<span class="string">"Throttle"</span>),</span><br><span class="line">                LoaderThrottleSupport.ThrottledLoaderListFragment<span class="class">.<span class="keyword">class</span>, <span class="title">null</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>tabhost</tag>
      </tags>
  </entry>
  <entry>
    <title>Android ViewPager的使用</title>
    <url>/2014/09/01/android03/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><blockquote>
<p>ViewPager需要import android.support.v4这个jar包才可以使用<br>ViewPager的效果就是能够轻松实现左右滑动屏幕, 不需要使用GestureDetector。在ViewPager的内部可以嵌入PagerTitleStrip或PagerTabStrip, 可以用来设置显示页面的title内容, 但是不要妄想把它当作Tab来用(虽然我的意图本来就是这样, 但是很悲剧), 因为它不是固定的<br>首先获取ViewPager布局mViewPager, 或者自己用Java实现不用xml, 然后要想实现滑动翻页必须得设置它的Adapter, mViewPager.setAdapter(mAdapter)<br>而mAdapter应该是一个继承FragmentPagerAdapter或者FragmentStatePagerAdapter的类的实例, 它应该实现滑动时所需要展示的页面, 而这些页面可以另外用一个继承Fragment的类实现, 然后将所需要的这些页面加入一个List中<br>需要注意的地方有: 这其中用到的Fragment应使用android.support.v4.app.Fragment而不是android.app.Fragment, FragmentManager也是如此(因为其中用了getSupportFragmentManager方法, 它的返回值是v4包里的FragmentManager)</p>
</blockquote>
<p>以上</p>
<a id="more"></a>
<h3 id="2-项目结构"><a href="#2-项目结构" class="headerlink" title="2. 项目结构"></a>2. 项目结构</h3><p><img src="/images/android_viewpager_1.png" alt="project structure"></p>
<h3 id="3-布局"><a href="#3-布局" class="headerlink" title="3. 布局"></a>3. 布局</h3><p>main.xml:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v4.view.ViewPager</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/pager"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">android.support.v4.view.PagerTabStrip</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/pager_tab_strip"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">"bottom"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">"#636363"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">"#fff"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingTop</span>=<span class="string">"4dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingBottom</span>=<span class="string">"4dp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">android.support.v4.view.ViewPager</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="4-逻辑代码"><a href="#4-逻辑代码" class="headerlink" title="4. 逻辑代码"></a>4. 逻辑代码</h3><h4 id="4-1-主Java程序"><a href="#4-1-主Java程序" class="headerlink" title="4.1 主Java程序:"></a>4.1 主Java程序:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hecate.Apollo;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hecate-xw on 2014/8/30.</span></span><br><span class="line"><span class="comment"> * It's a demo that display how to swipe pages via class ViewPager.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> android.support.v4.app.Fragment;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.app.FragmentManager;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.app.FragmentPagerAdapter;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.app.FragmentActivity;</span><br><span class="line"><span class="keyword">import</span> android.support.v4.view.ViewPager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">FragmentActivity</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 多个页面的list **/</span></span><br><span class="line">    List&lt;Fragment&gt; fragmentList = <span class="keyword">new</span> ArrayList&lt;Fragment&gt;();</span><br><span class="line">    <span class="comment">/** 多个页面的title list,用来显示PagerTabStrip的内容 **/</span></span><br><span class="line">    List&lt;String&gt; titleList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.main);</span><br><span class="line">        ViewPager mViewPager = (ViewPager) findViewById(R.id.pager);</span><br><span class="line">        fragmentList.add(<span class="keyword">new</span> MyFragment(<span class="string">"page1"</span>));</span><br><span class="line">        fragmentList.add(<span class="keyword">new</span> MyFragment(<span class="string">"page2"</span>));</span><br><span class="line">        fragmentList.add(<span class="keyword">new</span> MyFragment(<span class="string">"page3"</span>));</span><br><span class="line"></span><br><span class="line">        titleList.add(<span class="string">"Artist"</span>);</span><br><span class="line">        titleList.add(<span class="string">"Song"</span>);</span><br><span class="line">        titleList.add(<span class="string">"Favorite"</span>);</span><br><span class="line">        MyFragmentPagerAdapter myFragmentPagerAdapter = <span class="keyword">new</span> MyFragmentPagerAdapter(</span><br><span class="line">                getSupportFragmentManager(),fragmentList,titleList);</span><br><span class="line">        mViewPager.setAdapter(myFragmentPagerAdapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyFragmentPagerAdapter</span> <span class="keyword">extends</span> <span class="title">FragmentPagerAdapter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;Fragment&gt; fragmentList;</span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; titleList;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyFragmentPagerAdapter</span><span class="params">(FragmentManager supportFragmentManager, List&lt;Fragment&gt; fragmentList, List&lt;String&gt; titleList)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(supportFragmentManager);</span><br><span class="line">            <span class="keyword">this</span>.fragmentList = fragmentList;</span><br><span class="line">            <span class="keyword">this</span>.titleList = titleList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Fragment <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (fragmentList == <span class="keyword">null</span> || fragmentList.size() == <span class="number">0</span>) ? <span class="keyword">null</span> : fragmentList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ( fragmentList == <span class="keyword">null</span> ) ? <span class="number">0</span> : fragmentList.size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> CharSequence <span class="title">getPageTitle</span><span class="params">( <span class="keyword">int</span> position )</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (titleList.size() &gt; position) ? titleList.get(position) : <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-MyFragment-java"><a href="#4-2-MyFragment-java" class="headerlink" title="4.2 MyFragment.java:"></a>4.2 MyFragment.java:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hecate.Apollo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.support.v4.app.Fragment;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hecate-xw on 2014/8/30.</span></span><br><span class="line"><span class="comment"> * Override some methods of class Fragment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String page;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyFragment</span><span class="params">(String page)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.page = page;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">( LayoutInflater inflater,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The last two arguments ensure LayoutParams are inflated</span></span><br><span class="line">        <span class="comment">// properly.</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="string">"page1"</span>.equals(page) ) &#123;</span><br><span class="line">            View view = inflater.inflate(</span><br><span class="line">                    R.layout.swipe_fragment_1, container, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( <span class="string">"page2"</span>.equals(page) ) &#123;</span><br><span class="line">            View view = inflater.inflate(</span><br><span class="line">                    R.layout.swipe_fragment_2, container, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( <span class="string">"page3"</span>.equals(page) ) &#123;</span><br><span class="line">            View view = inflater.inflate(</span><br><span class="line">                    R.layout.swipe_fragment_3, container, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            View view = inflater.inflate(</span><br><span class="line">                    R.layout.fragment, container, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-测试运行"><a href="#5-测试运行" class="headerlink" title="5. 测试运行"></a>5. 测试运行</h3><p>添加相应的资源文件就可以运行了<br>打开app开始显示的页面:<br><img src="/images/android_viewpager_2.png" alt="viewpager_page_1"></p>
<p>向左滑动一次或者点击PagerTabStrip的第二个Tab:<br><img src="/images/android_viewpager_3.png" alt="viewpager_page_2"></p>
<p>再向左滑动一次或者点击PagerTabStrip的第三个Tab:<br><img src="/images/android_viewpager_4.png" alt="viewpager_page_3"></p>
<p>附上每个page的xml布局文件，随便写的用来测试:<br>swipe_fragment_1:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> <span class="attr">android:weightSum</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/imageView"</span> <span class="attr">android:src</span>=<span class="string">"@drawable/img1"</span> <span class="attr">android:layout_weight</span>=<span class="string">"0.66"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textAppearance</span>=<span class="string">"?android:attr/textAppearanceLarge"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">"This is page1"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/textView"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>swipe_fragment_2:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> <span class="attr">android:weightSum</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">RatingBar</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/ratingBar"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ProgressBar</span></span></span><br><span class="line"><span class="tag">            <span class="attr">style</span>=<span class="string">"?android:attr/progressBarStyleLarge"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/progressBar"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">SeekBar</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/seekBar"</span> <span class="attr">android:indeterminate</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Spinner</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/spinner"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>swipe_fragment_3:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> <span class="attr">android:weightSum</span>=<span class="string">"1"</span> <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:inputType</span>=<span class="string">"textEmailAddress"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:ems</span>=<span class="string">"10"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/editText"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RadioGroup</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:text</span>=<span class="string">"RadioButton1"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/radioButton"</span> <span class="attr">android:checked</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:text</span>=<span class="string">"RadioButton2"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/radioButton2"</span> <span class="attr">android:layout_gravity</span>=<span class="string">"center_horizontal"</span> <span class="attr">android:checked</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:text</span>=<span class="string">"RadioButton3"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:id</span>=<span class="string">"@+id/radioButton3"</span> <span class="attr">android:layout_gravity</span>=<span class="string">"right"</span> <span class="attr">android:checked</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">RadioGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextClock</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/textClock"</span> <span class="attr">android:layout_gravity</span>=<span class="string">"center_horizontal"</span> <span class="attr">android:layout_weight</span>=<span class="string">"0.07"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>viewpager</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链学习一</title>
    <url>/2018/03/24/blockchain01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在协助一个团队做一个和区块链相关的项目，虽然比较边缘性，和区块链联系没那么紧密，但区块链本身还是需要了解一下的。</p>
<p>花了一天阅读了一下区块链技术指南<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="[区块链技术指南](https://github.com/yeasy/blockchain_guide)
">[1]</span></a></sup><br><a id="more"></a></p>
<h2 id="1-区块链思想的诞生与概念"><a href="#1-区块链思想的诞生与概念" class="headerlink" title="1. 区块链思想的诞生与概念"></a>1. 区块链思想的诞生与概念</h2><p>这一章从数字货币入手，比较了传统纸币和数字货币之间的优劣，概述了设计数字货币时需要解决的技术难点，进而引入了区块链的概念。<br>其中一些以前不了解的细节有:</p>
<ul>
<li>严格来讲, 货币（money）不等于现金或通货（cash，currency），货币的范围更广，维基百科里的相关解释:<ul>
<li>Money: Money is any item or verifiable record that is generally accepted as payment for goods and services and repayment of debts in a particular country or socio-economic context.</li>
<li>Currency: A currency is a system of money (monetary units) in common use, especially in a nation.</li>
<li>Cash: In economics, cash is money in the physical form of currency, such as banknotes and coins. In bookkeeping and finance, cash is current assets comprising currency or currency equivalents that can be accessed immediately or near-immediately (as in the case of money market accounts).</li>
</ul>
</li>
<li>去中心化场景下，数字货币的实现存在的难点:<ul>
<li>货币的防伪:谁来负责验证货币</li>
<li>货币交易:如何确定货币从一方转移到另外一方</li>
<li>避免双重支付:如何避免出现双重支付</li>
</ul>
</li>
<li>区块链技术雏形最早出现在比特币项目中，作为比特币背后的分布式记账平台，从记账的角度来看，区块链是首个自带对账功能的数字记账技术实现。跟传统的记账技术相比，其特点应该包括:<ul>
<li>维护一条不断增长的链，只可能添加记录，而发生过的记录都不可篡改</li>
<li>去中心化，或者说多中心化，无需集中的控制而能达成共识，实现上尽量分布式</li>
<li>通过密码学的机制来确保交易无法抵赖和破坏，并尽量保护用户信息和记录的隐私性</li>
</ul>
</li>
<li>当前区块链技术的三种典型应用场景:<ul>
<li>比特币为代表的公信的数字货币</li>
<li>以太坊为代表的公信的交易处理</li>
<li>Hyperleger为代表的带权限的交易处理</li>
</ul>
</li>
<li>区块链的基本概念:<ul>
<li>交易(Transaction):一次操作，导致账本状态的一次改变，如添加一条记录</li>
<li>区块(Block):记录一段时间内发生的交易和状态结果，是对当前账本状态的一次共识</li>
<li>链(Chain):由一个个区块按照发生顺序串联而成，是整个状态变化的日志记录</li>
</ul>
</li>
<li>nonce: In cryptography, a nonce is an arbitrary number that can only be used once. It is similar in spirit to a nonce word, hence the name. It is often a random or pseudo-random number issued in an authentication protocol to ensure that old communications cannot be reused in replay attacks. They can also be useful as initialization vectors and in cryptographic hash functions.</li>
<li>分类:<ul>
<li>根据参与者的不同，可以分为公开(Public)链、联盟(Consortium)链和私有(Private)链</li>
<li>根据使用目的和场景的不同，又可以分为以数字货币为目的的货币链，以记录产权为目的的产权链，以众筹为目的的众筹链等</li>
</ul>
</li>
<li>借(Debit): 意味着债务，表示从其他方转移到本科目内; 贷(Credit): 意味着债权，代表从该科目转移出去</li>
</ul>
<h2 id="2-区块链技术的价值、挑战和展望"><a href="#2-区块链技术的价值、挑战和展望" class="headerlink" title="2. 区块链技术的价值、挑战和展望"></a>2. 区块链技术的价值、挑战和展望</h2><ul>
<li>从技术特点上，区块链一般被认为具有:<ul>
<li>分布式容错性:网络极其鲁棒，容错 1/3 左右节点的异常状态</li>
<li>不可篡改性:一致提交后的数据会一直存在，不可被销毁或修改</li>
<li>隐私保护性:密码学保证了未经授权者能访问到数据，但无法解析</li>
</ul>
</li>
<li>随之带来的业务特性将可能包括:<ul>
<li>可信任性:区块链技术可以提供天然可信的分布式账本平台，不需要额外第三方中介机构</li>
<li>降低成本:跟传统技术相比，区块链技术可能带来更短的时间、更少的人力和维护成本</li>
<li>增强安全:区块链技术将有利于安全可靠的审计管理和账目清算，减少犯罪可能性，和各种风险</li>
</ul>
</li>
<li>能否最终带来成本的降低，将是一项技术能否被深入应用的关键</li>
<li>所有跟信息、价值（包括货币、证券、专利、版权、数字商品、实际物品等）、信用等相关的交换过程，都将可能从区块链技术中得到启发或直接受益</li>
<li>涉及领域: 分布式、存储、密码学、心理学、经济学、博弈论、网络协议、系统安全等, 相关限制: 处理性能、扩展性等</li>
<li>常见的分布式系统，可以通过增加节点来扩展整个系统的处理能力。区块链并非如此。</li>
</ul>
<h2 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3. 应用场景"></a>3. 应用场景</h2><ul>
<li>有直接或间接依赖于第三方担保信任机构的活动，均可能从区块链技术中获益<ul>
<li>金融服务<ul>
<li>银行金融管理</li>
<li>证券交易</li>
</ul>
</li>
<li>征信和权属管理</li>
<li>资源共享</li>
<li>投资管理</li>
<li>物联网与供应链</li>
</ul>
</li>
<li>制约区块链技术进一步应用的因素:<ul>
<li>首先就是谁来为区块链上的合同担保？特别在金融、法律等领域，实际执行的生活往往还得是由人来做</li>
<li>另外就是物品的数字化。非数字化的物品很难放到数字世界中进行管理。</li>
</ul>
</li>
<li>一些对于上述观点的补充:<ul>
<li>做任何应用层面的东西，都要意识到这个社会中最重要的永远是人的存在，所以人性永远在考虑范围内，而区块链的应用脱离了人只考虑数字世界必然是行不通的，需要对人性有所分析，对区块链应用涉及的社会活动所影响到的人的心理都要有充分估计，否则只是空谈而已。</li>
<li>关于物品的数字化，的确是个问题，主要体现在物联网与供应链应用上，因为无法完全数字化，就必然会涉及到人，比如物流过程中从一级到另一级，一个物流人员将一个商品掉包如何确认？肯定不能够通过商品上贴的二维码来保证吧。其实就相当于得找到一个Hash算法，将实际物体映射到数字世界，或者思维转变，不考虑实际物体的数字化，而是着手与供应链过程中涉及到的人的信任保证。</li>
<li>是不是区块链、叫不叫区块链，其实都不重要，主要是利用技术解决在没有”中介”的情况下如何促成一项交易的完成，确保一件物品的归属。减少交易环节是一个实实在在的需求，能够通过一项技术去减少交易环节，最好是P2P且能够保证双方信任的，这项技术的综合成本比原先的交易流程中间过程成本低，就是有价值的，而技术本身的实现并不唯一，但是技术必然需要实现以上需求的核心要求，其中最重要的就是去中心化，反观现在很多产品是打着区块链幌子的积分制而已，根本没有去中心化。</li>
<li>以上观点都是一时的想法… 接触了更多知识有了更多思考之后应该有很多地方需要更正吧</li>
</ul>
</li>
</ul>
<h2 id="4-分布式系统的核心问题"><a href="#4-分布式系统的核心问题" class="headerlink" title="4. 分布式系统的核心问题"></a>4. 分布式系统的核心问题</h2><ul>
<li>一致性问题: <ul>
<li>概念: 在分布式系统中，一致性(Consistency，早期也叫 Agreement)是指对于系统中的多个服务节点，给定一系列操作，在协议（往往通过某种共识算法）保障下，试图使得它们对处理结果达成某种程度的一致。</li>
<li>解决分布式系统一致性问题的核心思想是: 将可能引发不一致的并行操作进行串行化</li>
<li>一致性需要满足的要求:<ul>
<li>可终止性(Termination): 一致的结果在有限时间内能完成</li>
<li>共识性(Consensus): 不同节点最终完成决策的结果应该相同</li>
<li>合法性(Validity): 决策的结果必须是其它进程提出的提案</li>
</ul>
</li>
<li>强一致性: 顺序一致性(Sequential Consistency)、线性一致性(Linearizability Consistency)</li>
<li>弱一致性</li>
<li>关于一致性问题，在学习多智能体协同控制相关知识的时候，也是重点研究的，其实本质上都是相似的，因为多智能体系统也是一个分布式系统，只是在多智能体问题中，一致性通常是更为严格地被数学模型所表达，最简单的就是多个智能体之间某一变量的一致，如位置、速度、加速度等，以方便最后理论证明提出的控制算法是否满足一致性，而计算机分布式系统中将所有进程看成一个序列，考虑序列的一致性，通常是保证序列元素的执行顺序。</li>
</ul>
</li>
<li>共识算法: 保障系统满足不同程度的一致性的解决方法。即便在网络通信可靠情况下，一个可扩展的分布式系统的共识问题的下限是无解。</li>
<li>FLP不可能原理: 在网络可靠，存在节点失效(即便只有一个)的最小化异步模型系统中，不存在一个可以解决一致性问题的确定性算法。PS: 如果套用多智能体系统里的概念，相当于，若节点间组成的网络拓扑是不连通的，则系统无法达到一致性，但是如果长时间来看，即使某一时间段某个节点down掉了，只要下一时间段可以恢复，从而保证连续时间上的连通性，系统最终还是可以达到一致的。</li>
<li>CAP原理: 分布式计算系统不可能同时确保一致性(Consistency)、可用性(Availablity)和分区容忍性(Partition)，设计中往往需要弱化对某个特性的保证。<ul>
<li>一致性(Consistency): 任何操作应该都是原子的，发生在后面的事件能看到前面事件发生导致的结果，注意这里指的是强一致性</li>
<li>可用性(Availablity): 在有限时间内，任何非失败节点都能应答请求</li>
<li>分区容忍性(Partition): 网络可能发生分区，即节点之间的通信不可保障</li>
</ul>
</li>
<li>ACID原则: 即Atomicity(原子性)、Consistency(一致性)、Isolation(隔离性)、Durability(持久性)。ACID原则描述了对分布式数据库的一致性需求，同时付出了可用性的代价。</li>
<li>BASE原则: Basic Availiability，Soft state，Eventually Consistency，牺牲掉对一致性的约束(最终一致性)，来换取一定的可用性。</li>
<li>PAXOS算法:<ul>
<li>三种节点: proposer, acceptor, learner</li>
<li>两个阶段: 准备阶段、提交阶段</li>
</ul>
</li>
<li>Raft算法: Paxos算法的一种简化实现，包括三种角色: leader、candidate和follower，其基本过程为:<ul>
<li>Leader选举: 每个candidate随机经过一定时间都会提出选举方案，最近阶段中得票最多者被选为leader</li>
<li>同步log: leader会找到系统中log最新的记录，并强制所有的follower来刷新到这个记录</li>
</ul>
</li>
<li>拜占庭问题: 讨论的是允许存在少数节点作恶(消息可能被伪造)场景下的一致性达成问题<ul>
<li>PBFT算法: 包括三个阶段来达成共识, Pre-Prepare、Prepare 和 Commit</li>
<li>PoW算法 </li>
</ul>
</li>
</ul>
<h2 id="5-密码学与安全技术"><a href="#5-密码学与安全技术" class="headerlink" title="5. 密码学与安全技术"></a>5. 密码学与安全技术</h2><ul>
<li>工程领域从来没有黑科技；密码学不是工程。目的是保证信息的机密性、完整性、认证性和不可抵赖性</li>
<li>Hash算法与数字摘要</li>
<li>加解密算法: 保证机密性</li>
<li>数字签名: 用于证实某数字内容的完整性(integrity)和来源(或不可抵赖，non-repudiation)<ul>
<li>HMAC(Hash-based Message Authentication Code): 即”基于 Hash 的消息认证码”，HMAC(K, H, Message)，其中，K为提前共享的对称密钥，H为提前商定的Hash算法，Message为要处理的消息内容。HMAC 一般用于证明身份的场景</li>
<li>盲签名: 主要是为了实现防止追踪(unlinkability)，签名者无法将签名内容和结果进行对应，且消息的内容对签名者是不可见的</li>
<li>多重签名: 想象成一份文件被n个人管理，需要m个人签名才有效，这就是多重签名。可以用于电子商务、财产分割、资金监管等场景中，实际上类似电子商务这种需要中介担保的场景都可以用到多重签名</li>
<li>群签名</li>
<li>环签名: 属于一种简化的群签名</li>
</ul>
</li>
<li>数字证书: 用来证明某个公钥是谁的，并且内容是正确的</li>
<li>PKI体系: 在非对称加密中，公钥则可以通过证书机制来进行保护，如何管理和分发证书则可以通过 PKI(Public Key Infrastructure)来保障。PKI至少包含以下组件:<ul>
<li>CA(Certification Authority): 负责证书的颁发和作废，接收来自RA的请求，是最核心的部分</li>
<li>RA(Registration Authority): 对用户身份进行验证，校验数据合法性，负责登记，审核过了就发给CA</li>
<li>证书数据库: 存放证书，一般采用LDAP目录服务，标准格式采用X.500系列</li>
</ul>
</li>
<li>Merkle树，其特点是，底层数据的任何变动，都会传递到其父亲节点，一直到树根。典型应用场景包括:<ul>
<li>快速比较大量数据</li>
<li>快速定位修改</li>
<li>零知识证明</li>
</ul>
</li>
<li>同态加密，函数加密: 相关内容可以参考<a href="http://blog.sciencenet.cn/blog-411071-707426.html" target="_blank" rel="noopener">这里</a></li>
<li>零知识证明(zero knowledge validation): 证明者在不向验证者提供任何有用的信息的前提下，使验证者相信某个论断是正确的</li>
</ul>
<h2 id="6-比特币项目"><a href="#6-比特币项目" class="headerlink" title="6. 比特币项目"></a>6. 比特币项目</h2><ul>
<li>以前以为比特币交易是没有下限的，原来是有的，交易的最小单位是”聪”，即10exp-8比特币</li>
<li>原理和设计、挖矿、工具、共识机制、闪电网络、侧链</li>
</ul>
<h2 id="7-Ethereum-以太坊项目"><a href="#7-Ethereum-以太坊项目" class="headerlink" title="7. Ethereum(以太坊项目)"></a>7. Ethereum(以太坊项目)</h2><ul>
<li>智能合约</li>
</ul>
<h2 id="8-Hyperledger-超级账本项目"><a href="#8-Hyperledger-超级账本项目" class="headerlink" title="8. Hyperledger(超级账本项目)"></a>8. Hyperledger(超级账本项目)</h2><ul>
<li>Fabric</li>
</ul>
<h2 id="9-区块链服务平台设计"><a href="#9-区块链服务平台设计" class="headerlink" title="9. 区块链服务平台设计"></a>9. 区块链服务平台设计</h2><ul>
<li>区块链即服务（Blockchain as a Service，BaaS），是部署在云计算基础设施之上，对外提供区块链网络的生命周期管理和运行时服务管理等功能的一套工具</li>
<li>IBM Bluemix云区块链服务</li>
<li>微软Azure云区块链服务</li>
<li>使用超级账本Cello搭建区块链服务</li>
<li>一个看法是，若是区块链应用都建立在少数厂商的云上，那岂不是该云厂商就是实际的中心，区块链要解决的去中心化就不复存在了，私以为还是有一定道理的</li>
</ul>
<h2 id="10-一些想法"><a href="#10-一些想法" class="headerlink" title="10. 一些想法"></a>10. 一些想法</h2><p>区块链实际需要解决的还是去中心化(多中心化)场景下的信任问题，而涉及到现实世界中时，事情总不是那么容易解决的。一方面现实世界中永远是少部分人掌握大多数资源(生产资料)，无论是号称哪种体制，进行何种革命，到头来不过是一个轮回，而区块链目前看来也不可能是革命的手段，毕竟现在控制人类社会运转的资源并不会因为区块链而进行转移和改变，所以区块链若要大规模应用，如何避免其变成实际上的中心化是个很重要的问题，而这个问题很有可能无解，需要找到一种大多数人都有且数量级相当的资源来作为惩罚或奖励，Kino能想到的是生命值，不过这是不可能的。另一方面就是现在都是靠博弈来保证利益的最大化，保证实际结果的可信，而这些独立于数字世界之外的问题会对现实生活产生的影响有多少，也没有充分论证，博弈某种程度上也许就是把人类的恶拿了出来，而整个世界的社会实验，把整个社会的恶都反映了出来，会有什么情况，也是未知的。所以对于区块链技术将会革命整个现有生产关系的说法，Kino觉得不可能，或者保守点，近几十年年不可能。区块链当前最可能的应用大概还是资源相当的企业间的相关应用，其涉及的相关方需要数量偏少且资源没有数量级上的差别，比如汽车行业供应链上的资金流转。</p>
<h2 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h2><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)"><a href="https://github.com/yeasy/blockchain_guide" target="_blank" rel="noopener">区块链技术指南</a><a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)"><a href="https://bitcoin.org/" target="_blank" rel="noopener">比特币官网</a><a href="#fnref:2" rev="footnote"> ↩</a></span></div><div id="fn:3" style="display:flex"><span style="width:20px">3.</span><span style="width:calc(100% - 20px)"><a href="https://www.ethereum.org/" target="_blank" rel="noopener">以太坊官网</a><a href="#fnref:3" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>techonology</category>
        <category>blockchain</category>
      </categories>
      <tags>
        <tag>blockchain</tag>
        <tag>cryptocurrency</tag>
        <tag>digital currency</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么大学过的比高中还累</title>
    <url>/2016/06/10/chickenSoup01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>本科毕业, 觉得碌碌无为, 又恰在知乎发现了一篇文章, 看完一阵怅然, 留存一份于此, 若是在迷茫时能再给自己一点激励, 也算是有用了。<br>原文由 小鸟 发表于知乎, 原答案<a href="https://www.zhihu.com/question/37148904/answer/82800993" target="_blank" rel="noopener">戳此</a><br><a id="more"></a></p>
<h3 id="2-原文"><a href="#2-原文" class="headerlink" title="2. 原文"></a>2. 原文</h3><p>谈三点感受：</p>
<h4 id="2-1-大多数人都只不过是在用战术上的勤奋掩盖战略上的懒惰罢了"><a href="#2-1-大多数人都只不过是在用战术上的勤奋掩盖战略上的懒惰罢了" class="headerlink" title="2.1 大多数人都只不过是在用战术上的勤奋掩盖战略上的懒惰罢了"></a>2.1 大多数人都只不过是在用战术上的勤奋掩盖战略上的懒惰罢了</h4><p>在大学，你每天能够和室友一起去上课，一边玩手机一边听老师讲几句，在那里可以坐几个小时，中午挤食堂吃一顿可口的饭菜，下午没课有时候去参加社团，学生会，班级，学校（依据个人口味不同）各种大大小小的活动和会议，晚上把作业做一下 或者刷最近大家都在看的电视剧，晚上睡觉前发条朋友圈：今天做了。。。。，很开心，很充实，明天继续加油。你觉得自己过得好累，事情好多，忙不过来。你不是忙不过来，你只是在瞎忙活，你不能为自己规划一条适合自己的道路，有时候你也会想想这个问题，但是现实的安逸让你妥协了，大多数时候你都在逃避，你让自己默认不去选择，你不愿意承担选择后会出错的后果，你明明清楚无二的知道自己该做什么，可你就是管不住自己，在遇到想要努力的领域的大牛的时候你会为自己打一针强心剂：我也要像他这样厉害。可是三天之后你还是原来的那个你<br>可是你根本就不明白，不做出选择就是你的选择，就算你得到一个很受伤的结局之后还是不悔过。这种情况不同程度的在每个人身上都发生过，打球的人可能都有过这样的经历你宁愿刻苦的重复练习一个动作而不愿意纠正这个动作做出正确的姿势；高中的时候你更愿意做那些自己有优势科目的作业，而不是那些你急需补救的弱势科目，还会美其名曰：那些有优势的科目是自己感兴趣的。大多数时候你不是感兴趣，你只是在当时的环境下选择了一种让自己更舒适的选项，乍看起来你确实也很勤奋，但是这种勤奋能不能解决问题就要另当别论了</p>
<h4 id="2-2-成就感阈值上升"><a href="#2-2-成就感阈值上升" class="headerlink" title="2.2 成就感阈值上升"></a>2.2 成就感阈值上升</h4><p>在高中你只需要学习好就够了，学习好都能有坐公交车不用投币的错觉，老师会围着你转，父母也对你呵护备至，周围的亲朋好友也会夸你，爸妈也很有面子，而且在中国人的价值观里品德这种东西居然也是跟学习成绩成正比的，评价标准是如此的单一，老师说的都是”如果不学习你的人生就完了“这样的论调，所以在这样的环境里，你要做的就只是学习，让自己在这个评价标准中得A，这样的生活虽然也累，但是你只要成绩能进步，考试考好了，家长老师都会夸你，会有很强的满足感，你也会有更强大的动力，你会逼自己更加努力去获得来自外界的下一次夸奖，下一次成就感，其他的事情有人替你安排，而且你还很心安理得，你会觉得做学习之外的任何事都是在浪费时间。<br>但是大学里的评价每个人的标准太多了，你一下子应接不暇，高中那么优秀的你，在大学里当然也要不干示弱，贪心的你想包揽对你有利的每一件事，你要做班干部，要做社团骨干，要进学生会，要入党，要拿奖学金，要巴结老师，要积累给别人吹牛逼的资本，要搞好和同学之间的关系，要有女朋友，好像你不和室友打游戏都能把你归为不合群，你要得到各种你想要的利益，你要取悦各种人群，你什么都想要。<br>你活得这么累，神仙也救不了你</p>
<blockquote>
<p>他们是希望回到高三，那种得心应手的状态，那种解出一道题就能获得满足感的状态，那种盲目地相信“熬过高三什么都会好的”状态，那种以为世界真的可以凭借一张卷子创造的状态，那种因为面前只有一条路而走得格外笃定的状态，那种做错了不过擦掉考砸了不过重来的状态，那种大学永远也没有办法给你的状态。</p>
<p>大学的可恶之处或许在于，它看似给你提供了种种可能，各色社团各类选修通识，但事实上又有一套评价体系限制着你的选择。或许更可恶之处在于，我们都变得实际而精明起来，知道结识什么样的人脉可以把未来的天堑变通途，也知道选什么样的课老师给分很水什么样的社团加入后可以有更多的资源，于是我们活得如履薄冰生怕翘掉的哪一节课会给未来抹上污点，也生怕得罪的哪一个人会让日子变得寸步难行。</p>
</blockquote>
<h4 id="2-3-大多数人都是平庸的”乌合之众”"><a href="#2-3-大多数人都是平庸的”乌合之众”" class="headerlink" title="2.3 大多数人都是平庸的”乌合之众”"></a>2.3 大多数人都是平庸的”乌合之众”</h4><p>我们被安排了18年，到了大学得到了 苦苦寻求的自由，却发现这并不是自己想要的生活，我们要的还是那种被别人安排的井井有条的生活，就像《肖申克的救赎》中的詹姆斯.惠特摩 饰演的老布已经习惯了监狱中体制化的生活，50年的服刑结束后，不能适应外面的生活只能选择自杀一样，我们也不过如此<br>大多数人在进入大学之前都没有形成独立的价值观再加上自己学识和能力上的浅薄，平庸的根本驾驭不了这突如其来的自由，你拥有的自由只能让你更空虚，更一无是处，你对任何事都失去了以前的那种归属感，再加上你平庸的能力，不能全力以赴的你在任何事情的尝试上都失去了成就感，自卑，空虚，恶性循环。所以我们就尽量让自己合群，跟随别人把体制要你做的事情做得中规中矩，不做出头鸟，用这种合群做挡箭牌掩饰自己的无能：反正周围的人都是这样做的。<br>难道那些为自己真正喜欢的事情努力的人不累吗？当然累，但是这种累和那种茫然无措的累是完全不同的 。极致的成功，极致的痛苦，有些人可以每天睡觉4小时，其他时间都用来做那一件事，但如果给你，可能两天就放弃了, 这并不可爱，那些做着不被周围人认同的事情的人可能还要承受来自外界质疑的压力，他们的生活有时也会混乱不堪，但他们很快就会让自己走上正轨，他们有清晰的方向，伟大的人都是执拗的，特立独行的，就是这样。<br>在绝大多数时候努力与否和能不能成功没有必然联系，就像有人说的: 功夫负不负有心人本该没有那么重要，”有心”的价值是不能用负与不负来衡量的。 真要比起来，有些人的起点你可能穷尽一生都够不到，成名与成功都应该是顺其自然，水到渠成的事情。我不在乎自己是否能逆袭成一个高富帅，或者得到一举成名对的机会，我相信我所涉及的这些领域能为我铺就一条独一无二的道路<br><strong>你选择为什么事情所累和被生活推着往前走所累是完全不同的</strong></p>
<h4 id="2-4-大学四年应当如何度过"><a href="#2-4-大学四年应当如何度过" class="headerlink" title="2.4 大学四年应当如何度过"></a>2.4 大学四年应当如何度过</h4><p><a href="https://www.zhihu.com/question/20161454" target="_blank" rel="noopener">这里</a>有很全面的一些解答，但就我个人来说，我觉得其实很简单，就是生活热情和自律的问题：</p>
<ol>
<li>为自己规划一个清晰的职业方向（学术，从政，商界），默默朝着那个方向努力</li>
<li>为自己培养几个关于音乐，运动，艺术的爱好，一定要保持自己对生活本身的激情，提升自己对美的欣赏水平</li>
<li>时间充裕的同学一定要健身，锻炼身体，护肤，虽不用过分着重自己的外表，但一定要精神干练，别人看到起码要舒服</li>
<li>广泛阅读，学有专攻，广泛涉猎，尝试静下心来读一些经典著作</li>
<li>远离寝室，远离寝室，远离寝室，寝室真的是时间的黑洞，意志力的坟墓，屌丝的培养皿，就算是看电影也请你离开寝室看</li>
<li>忘掉：合群，你有更重要的事情去做，如果你真的足够优秀，你肯定会有很多朋友</li>
<li>生活中兼顾当下的乐趣和对未来的功效</li>
<li>想象自己像一个追求卓越者一样去行动和约束自己</li>
<li>把生活观念从马拉松式的“长跑”变成“短跑”，冲刺，休整，冲刺，休整</li>
<li>内向的人一定要锻炼自己开口讲话，这也是我的缺陷，共勉吧</li>
</ol>
<h4 id="警告"><a href="#警告" class="headerlink" title="警告:"></a>警告:</h4><blockquote>
<p>如果你正在阅读本文，那么这个警告正是为你准备的。<br>你所读到的本文中的每个词都是你生命中又一秒钟的浪费。<br>你没有别的事情可以做吗？<br>你的生命真的如此空虚以至于你怎么都想不出另一个打发时间的方法吗？<br>或许，你只是对自己所尊敬和信任的所谓权威者们过于信服，以至于无法移开你的目光。<br>你只会习惯性地阅读别人告诉你你应该读的？<br>你只会思考那些别人告诉你应该思考的？<br>还有购买那些别人告诉你应该拥有的东西？<br>滚出你的房间，去寻找真正志趣相投的朋友，停止没有必要的购物和猥琐的自慰。<br>完成你手上的任务，开始一场战斗和搏击，证明你还是活生生的人类。<br>如果你不释放和找回你身上的人性，你将只是屏幕和数据上一个统计值。<br>你已经被警告了……<br>Tyler.</p>
</blockquote>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>struggle</tag>
      </tags>
  </entry>
  <entry>
    <title>开发工具配置</title>
    <url>/2013/01/12/developConfig/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-Tex"><a href="#1-Tex" class="headerlink" title="1. Tex"></a>1. Tex</h3><h4 id="1-1-Texlive"><a href="#1-1-Texlive" class="headerlink" title="1.1 Texlive"></a>1.1 Texlive</h4><p><a href="https://www.tug.org/texlive/" target="_blank" rel="noopener">https://www.tug.org/texlive/</a></p>
<h4 id="1-2-CTAN"><a href="#1-2-CTAN" class="headerlink" title="1.2 CTAN"></a>1.2 CTAN</h4><p><a href="https://www.ctan.org" target="_blank" rel="noopener">https://www.ctan.org</a></p>
<a id="more"></a>
<h3 id="2-Sublime"><a href="#2-Sublime" class="headerlink" title="2. Sublime"></a>2. Sublime</h3><h4 id="2-1-Install"><a href="#2-1-Install" class="headerlink" title="2.1 Install"></a>2.1 Install</h4><p><a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">https://www.sublimetext.com/3</a><br>Backup: <a href="https://drive.google.com/open?id=0B7ciOrhoI8vkOEZqOXNBWnNrbzg" target="_blank" rel="noopener">https://drive.google.com/open?id=0B7ciOrhoI8vkOEZqOXNBWnNrbzg</a></p>
<h4 id="2-2-Package-Control"><a href="#2-2-Package-Control" class="headerlink" title="2.2 Package Control"></a>2.2 Package Control</h4><p><a href="https://packagecontrol.io/installation" target="_blank" rel="noopener">https://packagecontrol.io/installation</a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request,os,hashlib; h = <span class="string">'df21e130d211cfc94d9b0905775a7c0f'</span> + <span class="string">'1e3d39e33b79698005270310898eea76'</span>; pf = <span class="string">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( <span class="string">'http://packagecontrol.io/'</span> + pf.replace(<span class="string">' '</span>, <span class="string">'%20'</span>)).read(); dh = hashlib.sha256(by).hexdigest(); print(<span class="string">'Error validating download (got %s instead of %s), please try manual install'</span> % (dh, h)) <span class="keyword">if</span> dh != h <span class="keyword">else</span> open(os.path.join( ipp, pf), <span class="string">'wb'</span> ).write(by)</span><br></pre></td></tr></table></figure></p>
<h4 id="2-3-SublimeCodeIntel"><a href="#2-3-SublimeCodeIntel" class="headerlink" title="2.3 SublimeCodeIntel"></a>2.3 SublimeCodeIntel</h4><p><a href="https://github.com/SublimeCodeIntel/SublimeCodeIntel" target="_blank" rel="noopener">https://github.com/SublimeCodeIntel/SublimeCodeIntel</a></p>
<h4 id="2-4-ConvertToUTF8"><a href="#2-4-ConvertToUTF8" class="headerlink" title="2.4 ConvertToUTF8"></a>2.4 ConvertToUTF8</h4><p><a href="https://github.com/seanliang/ConvertToUTF8" target="_blank" rel="noopener">https://github.com/seanliang/ConvertToUTF8</a></p>
<h4 id="2-5-Latexing"><a href="#2-5-Latexing" class="headerlink" title="2.5 Latexing"></a>2.5 Latexing</h4><p><a href="http://www.latexing.com" target="_blank" rel="noopener">http://www.latexing.com</a><br>Change setting:<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"license"</span>: <span class="string">""</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"log"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"quick_build"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Primary Quick Build: pdflatex"</span>,</span><br><span class="line">            <span class="attr">"primary"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"cmds"</span>: [<span class="string">"pdflatex"</span>]</span><br><span class="line">            <span class="comment">//"cmds": ["xelatex"]             // Change by hypocrisy on 2017.07.15</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Quick Build 1: pdflatex + bibtex + pdflatex (2x)"</span>,</span><br><span class="line">            <span class="attr">"cmds"</span>: [<span class="string">"pdflatex"</span>, <span class="string">"bibtex"</span>, <span class="string">"pdflatex"</span>, <span class="string">"pdflatex"</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Quick Build 2: pdflatex + biber + pdflatex (2x)"</span>,</span><br><span class="line">            <span class="attr">"cmds"</span>: [<span class="string">"pdflatex"</span>, <span class="string">"biber"</span>, <span class="string">"pdflatex"</span>, <span class="string">"pdflatex"</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;                                         <span class="comment">// Add by Hypocrisy on 2017.07.15</span></span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Quick Build 3: xelatex"</span>,</span><br><span class="line">            <span class="attr">"cmds"</span>: [<span class="string">"xelatex"</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;                                         <span class="comment">// Add by Hypocrisy on 2017.07.15</span></span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Quick Build 4: xelatex + bibtex + xelatex (2x)"</span>,</span><br><span class="line">            <span class="attr">"cmds"</span>: [<span class="string">"xelatex"</span>, <span class="string">"bibtex"</span>, <span class="string">"xelatex"</span>, <span class="string">"xelatex"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="attr">"fallback_encoding"</span>: <span class="string">"utf_8"</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Changed by Hypocrisy on 2017.07.15</span></span><br><span class="line">    <span class="attr">"path"</span>: [<span class="string">"D:\\Program Files\\Sublime Text 3"</span>,<span class="string">"D:\\Programs\\texlive\\tlpkg\\tlperl\\bin"</span>,<span class="string">"D:\\Programs\\texlive\\bin\\win32"</span>,<span class="string">"C:\\Program Files\\Microsoft\\R Client\\R_SERVER\\bin"</span>],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">"show_log_panel_on"</span>: [<span class="string">"errors"</span>, <span class="string">"warnings"</span>, <span class="string">"badboxes"</span>, <span class="string">"infos"</span>],</span><br><span class="line"></span><br><span class="line">    <span class="attr">"keep_focus"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"keep_focus_delay"</span>: <span class="number">0.2</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">"executables"</span>: &#123;</span><br><span class="line">        <span class="comment">// Required</span></span><br><span class="line">        <span class="attr">"perl"</span>: [<span class="string">"perl"</span>],</span><br><span class="line">        <span class="attr">"latexmk"</span>: [<span class="string">"latexmk"</span>],</span><br><span class="line">        <span class="comment">// Optional</span></span><br><span class="line">        <span class="attr">"pdflatex"</span>: [<span class="string">"pdflatex"</span>],</span><br><span class="line">        <span class="attr">"xelatex"</span>: [<span class="string">"xelatex"</span>],</span><br><span class="line">        <span class="attr">"lualatex"</span>: [<span class="string">"lualatex"</span>],</span><br><span class="line">        <span class="attr">"biber"</span>: [<span class="string">"biber"</span>],</span><br><span class="line">        <span class="attr">"bibtex"</span>: [<span class="string">"bibtex"</span>],</span><br><span class="line">        <span class="attr">"sublime"</span>: [<span class="string">"subl"</span>, <span class="string">"sublime_text"</span>, <span class="string">"sublime_text.exe"</span>],</span><br><span class="line">        <span class="attr">"kpsewhich"</span>: [<span class="string">"kpsewhich"</span>],</span><br><span class="line">        <span class="attr">"mthelp"</span>: [<span class="string">"mthelp"</span>],</span><br><span class="line">        <span class="attr">"texcount"</span>: [<span class="string">"texcount"</span>],</span><br><span class="line">        <span class="attr">"texdoc"</span>: [<span class="string">"texdoc"</span>],</span><br><span class="line">        <span class="attr">"rscript"</span>: [<span class="string">"Rscript"</span>, <span class="string">"Rscript.exe"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">"forward_sync"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"reverse_sync"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">"pdf_viewer_osx"</span>: &#123;</span><br><span class="line">        <span class="attr">"skim"</span>: [</span><br><span class="line">            <span class="string">"/Applications/Skim.app"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"preview"</span>: [</span><br><span class="line">            <span class="string">"/Applications/Preview.app"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"pdf_viewer_windows"</span>: &#123;</span><br><span class="line">        <span class="attr">"foxit_reader"</span>: [</span><br><span class="line">            <span class="string">"D:\\Program Files (x86)\\Foxit Software\\Foxit PhantomPDF\\FoxitPhantomPDF.exe"</span>   <span class="comment">// Changed by Hypocrisy on 2017.07.15</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"sumatra_pdf"</span>: [</span><br><span class="line">            <span class="string">"D:\\Program Files\\SumatraPDF\\SumatraPDF.exe"</span>         <span class="comment">// Changed by Hypocrisy on 2017.07.15</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"pdf_viewer_linux"</span>: &#123;</span><br><span class="line">        <span class="attr">"evince"</span>: [</span><br><span class="line">            <span class="string">"/usr/bin/evince"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"okular"</span>: [</span><br><span class="line">            <span class="string">"/usr/bin/okular"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"pdf_viewer_order"</span> : [</span><br><span class="line">        <span class="comment">// OSX</span></span><br><span class="line">        <span class="string">"skim"</span>,</span><br><span class="line">        <span class="string">"preview"</span>,</span><br><span class="line">        <span class="comment">// Windows</span></span><br><span class="line">        <span class="string">"sumatra_pdf"</span>,</span><br><span class="line">        <span class="string">"adobe_reader"</span>,</span><br><span class="line">        <span class="string">"foxit_reader"</span>,</span><br><span class="line">        <span class="string">"pdf_xchange_viewer"</span>,</span><br><span class="line">        <span class="comment">// Linux</span></span><br><span class="line">        <span class="string">"evince"</span>,</span><br><span class="line">        <span class="string">"okular"</span></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">"phrases"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"phrases_mode"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"phrases_min_count"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"phrases_min_length"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"phrases_max_length"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"phrases_bounding_words"</span>: [],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">"partial_build"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">"open_pdf_on_load"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"typeset_on_save"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"type_scrolling"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">"output_directory"</span>: <span class="literal">true</span>,           <span class="comment">// Change by Hypocrisy on 2017/07/15</span></span><br><span class="line">    <span class="attr">"output_directory_mode"</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">"default_tex_extension"</span>: <span class="string">".tex"</span>,</span><br><span class="line">    <span class="attr">"default_bib_extension"</span>: <span class="string">".bib"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"check_source"</span>: [<span class="string">"local_bibliography"</span>, <span class="string">"remote_bibliography"</span>],</span><br><span class="line"></span><br><span class="line">    <span class="attr">"tex_pattern"</span>: [<span class="string">"*.tex"</span>, <span class="string">"*.ltx"</span>, <span class="string">"*.tikz"</span>],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">"graphics_pattern"</span>: [<span class="string">"*.jpeg"</span>, <span class="string">"*.jpg"</span>, <span class="string">"*.png"</span>, <span class="string">"*.eps"</span>, <span class="string">"*.pdf"</span>],</span><br><span class="line">    <span class="attr">"currfile_graphicspath"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"auto_trigger_fill"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">"cite_panel_format"</span>: [<span class="string">"#&#123;key&#125;: &#123;title&#125;"</span>, <span class="string">"&#123;type&#125; (&#123;origin&#125;) by &#123;author&#125;"</span>],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">"label_format"</span>: <span class="string">"&#123;type&#125;:&#123;prefix&#125;:&#123;name&#125;"</span>,</span><br><span class="line">    <span class="attr">"label_type"</span>: &#123;</span><br><span class="line">        <span class="attr">"table"</span>: <span class="string">"tbl"</span>,</span><br><span class="line">        <span class="attr">"figure"</span>: <span class="string">"fig"</span>,</span><br><span class="line">        <span class="attr">"part"</span>: <span class="string">"prt"</span>,</span><br><span class="line">        <span class="attr">"chapter"</span>: <span class="string">"cha"</span>,</span><br><span class="line">        <span class="attr">"section"</span>: <span class="string">"sec"</span>,</span><br><span class="line">        <span class="attr">"subsection"</span>: <span class="string">"ssec"</span>,</span><br><span class="line">        <span class="attr">"subsubsection"</span>: <span class="string">"sssec"</span>,</span><br><span class="line">        <span class="attr">"paragraph"</span>: <span class="string">"par"</span>,</span><br><span class="line">        <span class="attr">"subparagraph"</span>: <span class="string">"spar"</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">"foldable_environments"</span>: [<span class="string">"table"</span>, <span class="string">"figure"</span>, <span class="string">"equation"</span>],</span><br><span class="line"></span><br><span class="line">    <span class="attr">"static_cwl"</span>: [<span class="string">"tex.cwl"</span>, <span class="string">"latex-209.cwl"</span>, <span class="string">"latex-dev.cwl"</span>, <span class="string">"latex-document.cwl"</span>, <span class="string">"latex-l2tabu.cwl"</span>, <span class="string">"latex-mathsymbols.cwl"</span>],</span><br><span class="line">    <span class="attr">"dynamic_cwl"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">"build_arguments"</span>: [],</span><br><span class="line"></span><br><span class="line">    <span class="attr">"symbols_in_category"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"cache"</span>: &#123;</span><br><span class="line">        <span class="attr">"pkg"</span>: <span class="number">168</span>,</span><br><span class="line">        <span class="attr">"doc"</span>: <span class="number">168</span>,</span><br><span class="line">        <span class="attr">"tex"</span>: <span class="number">24</span>,</span><br><span class="line">        <span class="attr">"bib"</span>: <span class="number">24</span>,</span><br><span class="line">        <span class="attr">"bibsonomy"</span>: <span class="number">48</span>,</span><br><span class="line">        <span class="attr">"citeulike"</span>: <span class="number">48</span>,</span><br><span class="line">        <span class="attr">"global_bib"</span>: <span class="number">48</span>,</span><br><span class="line">        <span class="attr">"mendeley"</span>: <span class="number">48</span>,</span><br><span class="line">        <span class="attr">"zotero"</span>: <span class="number">48</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"remote_bibliography_in_category"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"bibname"</span>: <span class="string">"Remote.bib"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"update_remote_bibliography"</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"cite_key_blacklist"</span>: [<span class="string">"the"</span>, <span class="string">"a"</span>, <span class="string">"an"</span>, <span class="string">"der"</span>, <span class="string">"die"</span>, <span class="string">"das"</span>],</span><br><span class="line"></span><br><span class="line">    <span class="attr">"bibsonomy"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"bibsonomy_username"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"bibsonomy_apikey"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"bibsonomy_internal_cite_key"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"bibsonomy_cite_key_pattern"</span>: <span class="string">"&#123;Author&#125;&#123;Year&#125;&#123;Title&#125;"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"citeulike"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"citeulike_username"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"citeulike_internal_cite_key"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"citeulike_cite_key_pattern"</span>: <span class="string">"&#123;Author&#125;&#123;Year&#125;&#123;Title&#125;"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"global_bib_file"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"global_bib_file_path"</span>: <span class="string">""</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"mendeley"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"mendeley_oauth_token"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"mendeley_oauth_token_secret"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"mendeley_internal_cite_key"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"mendeley_cite_key_pattern"</span>: <span class="string">"&#123;Author&#125;&#123;Year&#125;&#123;Title&#125;"</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attr">"zotero"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"zotero_user_id"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"zotero_user_key"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"zotero_cite_key_pattern"</span>: <span class="string">"&#123;Author&#125;&#123;Year&#125;&#123;Title&#125;"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"online_lookup"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"Dict.cc"</span>,</span><br><span class="line">            <span class="attr">"url"</span>: <span class="string">"http://www.dict.cc/?s=&#123;query&#125;"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"Dict.leo.org"</span>,</span><br><span class="line">            <span class="attr">"url"</span>: <span class="string">"http://dict.leo.org/ende/#/search=&#123;query&#125;"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"Dictionary.com"</span>,</span><br><span class="line">            <span class="attr">"url"</span>: <span class="string">"http://dictionary.reference.com/browse/&#123;query&#125;"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"Linguee.com EN-DE"</span>,</span><br><span class="line">            <span class="attr">"url"</span>: <span class="string">"http://www.linguee.com/english-german/search?query=&#123;query&#125;"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"Linguee.de DE-EN"</span>,</span><br><span class="line">            <span class="attr">"url"</span>: <span class="string">"http://www.linguee.de/deutsch-englisch/search?query=&#123;query&#125;"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"Pons.eu"</span>,</span><br><span class="line">            <span class="attr">"url"</span>: <span class="string">"http://en.pons.eu/dict/search/results/?q=&#123;query&#125;&amp;l=deen"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"Thesaurus.com"</span>,</span><br><span class="line">            <span class="attr">"url"</span>: <span class="string">"http://thesaurus.com/browse/&#123;query&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="attr">"knitr"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"tikz"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"tikz_create_pdf"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-6-LaTeX-cwl"><a href="#2-6-LaTeX-cwl" class="headerlink" title="2.6 LaTeX-cwl"></a>2.6 LaTeX-cwl</h4><p><a href="https://github.com/LaTeXing/LaTeX-cwl" target="_blank" rel="noopener">https://github.com/LaTeXing/LaTeX-cwl</a></p>
<h4 id="2-7-Pandoc"><a href="#2-7-Pandoc" class="headerlink" title="2.7 Pandoc"></a>2.7 Pandoc</h4><p>Pandoc: <a href="http://pandoc.org/installing.html" target="_blank" rel="noopener">http://pandoc.org/installing.html</a><br>Sublime-Pandoc: <a href="https://github.com/tbfisher/sublimetext-Pandoc" target="_blank" rel="noopener">https://github.com/tbfisher/sublimetext-Pandoc</a><br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"default"</span>: &#123;</span><br><span class="line">    <span class="attr">"pandoc-path"</span>: <span class="string">"D:/Programs/Pandoc/pandoc.exe"</span>,       <span class="comment">// Add by Hypocrisy on 2017/07/14</span></span><br><span class="line">    <span class="comment">// transformations</span></span><br><span class="line">    <span class="attr">"transformations"</span>: &#123;</span><br><span class="line">      <span class="attr">"Markdown (Pandoc)"</span>: &#123;</span><br><span class="line">        <span class="attr">"new-buffer"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"scope"</span>: &#123;</span><br><span class="line">          <span class="attr">"text.html"</span>: <span class="string">"html"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"syntax_file"</span>: <span class="string">"Packages/Markdown/Markdown.tmLanguage"</span>,</span><br><span class="line">        <span class="attr">"pandoc-arguments"</span>: [</span><br><span class="line">          <span class="string">"--to=markdown"</span>,</span><br><span class="line">          <span class="string">"--wrap=none"</span>,</span><br><span class="line">          <span class="string">"--atx-headers"</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="attr">"HTML 5"</span>: &#123;</span><br><span class="line">        <span class="attr">"new-buffer"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"scope"</span>: &#123;</span><br><span class="line">          <span class="attr">"text.html.markdown"</span>: <span class="string">"markdown"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"syntax_file"</span>: <span class="string">"Packages/HTML/HTML.tmLanguage"</span>,</span><br><span class="line">        <span class="attr">"pandoc-arguments"</span>: [</span><br><span class="line">          <span class="string">"--to=html5"</span>,</span><br><span class="line">          <span class="string">"--no-highlight"</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="attr">"PDF"</span>: &#123;</span><br><span class="line">        <span class="attr">"scope"</span>: &#123;</span><br><span class="line">          <span class="attr">"text.html"</span>: <span class="string">"html"</span>,</span><br><span class="line">          <span class="attr">"text.html.markdown"</span>: <span class="string">"markdown"</span>,</span><br><span class="line">          <span class="comment">//"text.tex.latex": "latex",          // Add by Hypocrisy on 2017/07/14</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"pandoc-arguments"</span>: [</span><br><span class="line">          <span class="string">"-t"</span>, <span class="string">"pdf"</span>,</span><br><span class="line">          <span class="comment">//"--latex-engine=D:/Programs/texlive/bin/win32/xelatex.exe"</span></span><br><span class="line">          <span class="comment">// use --latex-engine=engine where engine is</span></span><br><span class="line">          <span class="comment">// pdflatex|lualatex|xelatex. This may need to be specified with a full path</span></span><br><span class="line">          <span class="comment">// if -o or --output missing, will write to a temporary file</span></span><br><span class="line">          <span class="comment">// "--output=~/Downloads/output.pdf"</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="attr">"Microsoft Word"</span>: &#123;</span><br><span class="line">        <span class="attr">"scope"</span>: &#123;</span><br><span class="line">          <span class="attr">"text.html"</span>: <span class="string">"html"</span>,</span><br><span class="line">          <span class="attr">"text.html.markdown"</span>: <span class="string">"markdown"</span>,</span><br><span class="line">          <span class="attr">"text.tex.latex"</span>: <span class="string">"latex"</span>,          <span class="comment">// Add by Hypocrisy on 2017/07/14</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"pandoc-arguments"</span>: [</span><br><span class="line">          <span class="string">"-t"</span>, <span class="string">"docx"</span>,</span><br><span class="line">          <span class="comment">//"--latex-engine=D:/Programs/texlive/bin/win32/xelatex.exe",     // Add by Hypocrisy on 2017/07/14</span></span><br><span class="line">          <span class="string">"--output=./Output/output.docx"</span>            <span class="comment">// Add by Hypocrisy on 2017/07/14</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="attr">"PDF TOC (Narrow margins)"</span>: &#123;</span><br><span class="line">        <span class="attr">"scope"</span>: &#123;</span><br><span class="line">          <span class="attr">"text.html"</span>: <span class="string">"html"</span>,</span><br><span class="line">          <span class="attr">"text.html.markdown"</span>: <span class="string">"markdown"</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        <span class="attr">"pandoc-arguments"</span>: [</span><br><span class="line">          <span class="string">"-V"</span>, <span class="string">"geometry:margin=1.25in"</span>, </span><br><span class="line">          <span class="string">"-s"</span>, <span class="string">"--toc"</span>, <span class="string">"--number-sections"</span>, <span class="string">"--parse-raw"</span>,</span><br><span class="line">          <span class="string">"-t"</span>, <span class="string">"pdf"</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="attr">"PDF TOC"</span>: &#123;</span><br><span class="line">        <span class="attr">"scope"</span>: &#123;</span><br><span class="line">          <span class="attr">"text.html"</span>: <span class="string">"html"</span>,</span><br><span class="line">          <span class="attr">"text.html.markdown"</span>: <span class="string">"markdown"</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        <span class="attr">"pandoc-arguments"</span>: [</span><br><span class="line">          <span class="string">"-s"</span>, <span class="string">"--toc"</span>, <span class="string">"--number-sections"</span>, <span class="string">"--parse-raw"</span>,</span><br><span class="line">          <span class="string">"-t"</span>, <span class="string">"pdf"</span>,</span><br><span class="line">         ],</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="attr">"HTML TOC"</span>: &#123;</span><br><span class="line">        <span class="attr">"new-buffer"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"scope"</span>: &#123;</span><br><span class="line">          <span class="attr">"text.html.markdown"</span>: <span class="string">"markdown"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"syntax_file"</span>: <span class="string">"Packages/HTML/HTML.tmLanguage"</span>,</span><br><span class="line">        <span class="attr">"pandoc-arguments"</span>: [</span><br><span class="line">          <span class="string">"--to=html5"</span>,</span><br><span class="line">          <span class="string">"--no-highlight"</span>,</span><br><span class="line">          <span class="string">"-s"</span>, <span class="string">"--toc"</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="attr">"Beamer Slides (PDF)"</span>: &#123;</span><br><span class="line">        <span class="attr">"scope"</span>: &#123;</span><br><span class="line">          <span class="attr">"text.html"</span>: <span class="string">"html"</span>,</span><br><span class="line">          <span class="attr">"text.html.markdown"</span>: <span class="string">"markdown"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// Use the "out-ext" parameter to define a custom output file extension. Commonly used for pdf.</span></span><br><span class="line">        <span class="attr">"out-ext"</span>: <span class="string">"pdf"</span>,</span><br><span class="line">        <span class="attr">"pandoc-arguments"</span>: [</span><br><span class="line">          <span class="string">"-t"</span>, <span class="string">"beamer"</span>,</span><br><span class="line">          <span class="string">"--latex-engine=D:/Programs/texlive/bin/win32/pdflatex.exe"</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="attr">"Beamer Slides (LaTeX)"</span>: &#123;</span><br><span class="line">        <span class="attr">"scope"</span>: &#123;</span><br><span class="line">          <span class="attr">"text.html"</span>: <span class="string">"html"</span>,</span><br><span class="line">          <span class="attr">"text.html.markdown"</span>: <span class="string">"markdown"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"pandoc-arguments"</span>: [</span><br><span class="line">          <span class="string">"-t"</span>, <span class="string">"beamer"</span>,</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      </span><br><span class="line">      <span class="attr">"s5 Slides"</span>: &#123;</span><br><span class="line">        <span class="attr">"scope"</span>: &#123;</span><br><span class="line">          <span class="attr">"text.html"</span>: <span class="string">"html"</span>,</span><br><span class="line">          <span class="attr">"text.html.markdown"</span>: <span class="string">"markdown"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"pandoc-arguments"</span>: [</span><br><span class="line">          <span class="string">"-t"</span>, <span class="string">"slidy"</span>, <span class="string">"-s"</span>, <span class="string">"--self-contained"</span>,</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// these should not need to be customized</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// output formats that are written to file, using -o parameter. These we do</span></span><br><span class="line">    <span class="comment">// not output to a sublime text buffer.</span></span><br><span class="line">    <span class="attr">"pandoc-format-file"</span>: [<span class="string">"docx"</span>, <span class="string">"epub"</span>, <span class="string">"pdf"</span>, <span class="string">"odt"</span>, <span class="string">"beamer"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-Vim"><a href="#3-Vim" class="headerlink" title="3. Vim"></a>3. Vim</h3><h4 id="3-1-Install"><a href="#3-1-Install" class="headerlink" title="3.1 Install"></a>3.1 Install</h4><p>Recommend vim 8.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install python3-dev</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;vim&#x2F;vim.git</span><br><span class="line">cd vim</span><br><span class="line"># configure with python support</span><br><span class="line">.&#x2F;configure --enable-python3interp&#x3D;yes \</span><br><span class="line">            --with-python3-config-dir&#x3D;&#x2F;usr&#x2F;lib&#x2F;python3.5&#x2F;&lt;config-dir&gt;  # &lt;config-dir&gt; varies in different system, I used &#39;config-3.5m-x86_64-linux-gnu&#39;.</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p>
<h4 id="3-2-Install-plugins"><a href="#3-2-Install-plugins" class="headerlink" title="3.2 Install plugins"></a>3.2 Install plugins</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p ~&#x2F;.vim&#x2F;pack&#x2F;yuzhen-plugins&#x2F;start&#x2F;</span><br><span class="line">cd ~&#x2F;.vim&#x2F;pack&#x2F;yuzhen-plugins&#x2F;start</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;scrooloose&#x2F;nerdtree.git</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;fholgado&#x2F;minibufexpl.vim.git</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;mattn&#x2F;emmet-vim.git</span><br><span class="line">apt install exuberant-ctags</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;majutsushi&#x2F;tagbar.git</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;SirVer&#x2F;ultisnips.git     # Need python support</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;honza&#x2F;vim-snippets.git</span><br><span class="line">## YouCompleteMe</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Valloric&#x2F;YouCompleteMe.git</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"># Method 1(Recommend)</span><br><span class="line">python3 install.py</span><br><span class="line"># End of Method 1</span><br><span class="line"># Method 2</span><br><span class="line">mkdir ~&#x2F;.ycm_build</span><br><span class="line">cd ~&#x2F;.ycm_build</span><br><span class="line">apt install cmake</span><br><span class="line">cmake -G &quot;Unix Makefiles&quot; . ~&#x2F;.vim&#x2F;pack&#x2F;yuzhen-plugins&#x2F;start&#x2F;YouCompleteMe&#x2F;third_party&#x2F;ycmd&#x2F;cpp</span><br><span class="line">cmake --build . --target ycm_core --config Release</span><br><span class="line"># End of Method 2</span><br><span class="line"># Add Javascript Support</span><br><span class="line">cd ~&#x2F;.vim&#x2F;pack&#x2F;yuzhen-plugins&#x2F;start&#x2F;YouCompleteMe&#x2F;third_party&#x2F;ycmd&#x2F;third_party&#x2F;tern_runtime</span><br><span class="line">yarn install --production     # or &#39;yarn global add install --production&#39;</span><br><span class="line"># End of Javascript Support</span><br></pre></td></tr></table></figure>
<h4 id="3-3-Configuration"><a href="#3-3-Configuration" class="headerlink" title="3.3 Configuration"></a>3.3 Configuration</h4><p>Git仓库获得<code>/etc/vim/vimrc;/etc/vim/vimrc.local;/etc/vim/vimrc.tiny</code>内容</p>
<h4 id="3-4-Some-problems"><a href="#3-4-Some-problems" class="headerlink" title="3.4 Some problems"></a>3.4 Some problems</h4><p>If you have added <code>set encoding=utf-8</code>, but there is still ycm error, you can excute:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export LC_ALL&#x3D;en_US.utf-8 </span><br><span class="line">export LANG&#x3D;&quot;$LC_ALL&quot;</span><br></pre></td></tr></table></figure><br>If vim cannot find vimrc, you can excute:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export VIMINIT&#x3D;&#39;source $MYVIMRC&#39;</span><br><span class="line">export MYVIMRC&#x3D;&#39;&#x2F;etc&#x2F;vim&#x2F;vimrc&#39;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-Git"><a href="#4-Git" class="headerlink" title="4. Git"></a>4. Git</h3><p><code>git config --global core.editor &quot;vim&quot;</code></p>
<h3 id="5-Valgrind"><a href="#5-Valgrind" class="headerlink" title="5. Valgrind"></a>5. Valgrind</h3>]]></content>
      <categories>
        <category>techonology</category>
        <category>misc</category>
      </categories>
      <tags>
        <tag>development</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>日语学习三</title>
    <url>/2018/06/01/japanese04/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>————<strong>更新于2018.06.01</strong>————<br><a href="/2017/09/30/japanese03/">上一篇文章</a>介绍了词类系统和句法成分，这篇文章Kino主要来讲解极性时轴。<br>在语言学中，极性———即Polarity———表示该句是肯定还是否定、判断真还是假，具体细节可参考<a href="https://ja.wikipedia.org/wiki/極性_%28言語学%29" target="_blank" rel="noopener">極性</a><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “極性 (言語学).” Wikipedia, Wikimedia Foundation, 14 June 2018, https://ja.wikipedia.org/wiki/極性_(言語学).
">[1]</span></a></sup>、<a href="https://en.wikipedia.org/wiki/Affirmation_and_negation" target="_blank" rel="noopener">Affirmation and negation</a><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “Affirmation and Negation.” Wikipedia, Wikimedia Foundation, 19 June 2018, https://en.wikipedia.org/wiki/Affirmation_and_negation.
">[2]</span></a></sup>、<a href="https://en.wikipedia.org/wiki/Polarity_item" target="_blank" rel="noopener">Polarity item</a><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “Polarity Item.” Wikipedia, Wikimedia Foundation, 19 June 2018, https://en.wikipedia.org/wiki/Polarity_item.">[3]</span></a></sup>等，时轴在这里指时(tense)，在<a href="/2017/09/16/japanese01/#2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">第一篇文章</a>里已经介绍过，Kino为了凑够四字标题且避免使用时态这种说法，就用了时轴这个词，灵感来源于现在常用时间轴来表示过去、现在、将来，后续为方便大多还是只用“时”这个称谓了。<br>将极性和时轴放在一起且最先介绍的理由为: 这两项较为容易理解，且负极性（否定）搭配过去时的变形经常互相影响。<br>考虑极性、时、体、态、式以及敬体系统，在讨论其中一项或几项的概念规则时，其他几项应该有相应基准作为参考，按照惯例应该是正极性、现在时、一般体、主动态、陈述式、非敬体。</p>
<a id="more"></a>
<h2 id="1-极性"><a href="#1-极性" class="headerlink" title="1. 极性"></a>1. 极性</h2><p>如前所述，极性分为肯定和否定。本章将分两大节来讲解极性，一是在句尾变形表示整个句子的极性，二是在句中变形词汇表示修饰语的极性。<br>本章所述均为当前状态，也就是现在时。</p>
<h3 id="1-1-句尾"><a href="#1-1-句尾" class="headerlink" title="1.1 句尾"></a>1.1 句尾</h3><p>完整句子的句尾肯定是述语，包括名词、形容词和动词，其中句尾是名词、形容词时，表达一种状态、情感等，句尾是动词时，表达一种动作。</p>
<h4 id="1-1-1-名词"><a href="#1-1-1-名词" class="headerlink" title="1.1.1 名词"></a>1.1.1 名词</h4><p>以“我是学生”、“我不是学生”为例。</p>
<ul>
<li>肯定: 句尾名词后加「だ」表示肯定极性，「私は学生だ」</li>
<li>否定: 句尾名词后加「じゃない」，「私は学生じゃない」</li>
<li><strong>注意: 肯定极性中的「だ」可以省略。</strong></li>
</ul>
<h4 id="1-1-2-形容词"><a href="#1-1-2-形容词" class="headerlink" title="1.1.2 形容词"></a>1.1.2 形容词</h4><p>な形容词和い形容词规则不同，分开来讲。</p>
<h5 id="1-1-2-1-な形容词"><a href="#1-1-2-1-な形容词" class="headerlink" title="1.1.2.1 な形容词"></a>1.1.2.1 な形容词</h5><p>规则和名词在句尾相同，以“学校安静”、“学校不安静”为例。</p>
<ul>
<li>肯定: 句尾な形容词后加「だ」表示肯定极性，「学校が静かだ」</li>
<li>否定: 句尾な形容词后加「じゃない」，「学校が静かじゃない」</li>
<li><strong>注意: 肯定极性中的「だ」可以省略。</strong></li>
</ul>
<h5 id="1-1-2-2-い形容词"><a href="#1-1-2-2-い形容词" class="headerlink" title="1.1.2.2 い形容词"></a>1.1.2.2 い形容词</h5><p>以“她可爱”、“她不可爱”为例。</p>
<ul>
<li>肯定: 不做变化，「彼女は可愛い」</li>
<li>否定: 句尾い形容词，将「い」变为「くない」，「彼女は可愛くない」</li>
</ul>
<h4 id="1-1-3-动词"><a href="#1-1-3-动词" class="headerlink" title="1.1.3 动词"></a>1.1.3 动词</h4><p>一段动词、五段动词和特殊动词不同，分开来讲。</p>
<h5 id="1-1-3-1-一段动词（る动词）"><a href="#1-1-3-1-一段动词（る动词）" class="headerlink" title="1.1.3.1 一段动词（る动词）"></a>1.1.3.1 一段动词（る动词）</h5><p>以“我吃饭”、“我不吃饭”为例。</p>
<ul>
<li>肯定: 不做变化，「私はたべる」</li>
<li>否定: 句尾一段动词，将「る」变为「ない」，「私はたべない」</li>
</ul>
<h5 id="1-1-3-2-五段动词（う动词）"><a href="#1-1-3-2-五段动词（う动词）" class="headerlink" title="1.1.3.2 五段动词（う动词）"></a>1.1.3.2 五段动词（う动词）</h5><p>以“我玩”、“我不玩”、“我买”、“我不买”为例。</p>
<ul>
<li>肯定: 不做变化，「私は遊ぶ」、「私は買う」</li>
<li>否定: 句尾五段动词，将词尾变为同行「あ」段假名，再加上「ない」，也即将 /u/ 音变为 /anai/，但是以「う」结尾的词需要变成「わ」，「私は遊ばない」、「私は買わない」</li>
</ul>
<h5 id="1-1-3-3-特殊动词"><a href="#1-1-3-3-特殊动词" class="headerlink" title="1.1.3.3 特殊动词"></a>1.1.3.3 特殊动词</h5><p>特殊动词する、くる的的变形比较特别，此外还有ある比较特别。对于する、くる、ある，按照顺序规则分别为:</p>
<ul>
<li>肯定: 不做变化</li>
<li>否定: しない、こない、ない</li>
</ul>
<h3 id="1-2-句中"><a href="#1-2-句中" class="headerlink" title="1.2 句中"></a>1.2 句中</h3><p>用在句中，即做修饰语用。</p>
<h4 id="1-2-1-名词"><a href="#1-2-1-名词" class="headerlink" title="1.2.1 名词"></a>1.2.1 名词</h4><p>以“是学生的人”和“不是学生的人”为例。</p>
<ul>
<li>肯定: 名词肯定极性没法直接修饰名词，即*<em>不能使用</em>「学生だ人」这种表达方式。事实上，在日语里没有现在时的“是学生的人”这种形式</li>
<li>否定: 和在句尾做述语的形式相同，「学生じゃな人」</li>
<li>注意: 名词A与名词B没有修饰关系时，可以并排放置使用，如「国际教育中心」，名词A和名词B是从属关系时，即“A的B”这种关系，可以用「AのB」表达</li>
</ul>
<h4 id="1-2-2-形容词"><a href="#1-2-2-形容词" class="headerlink" title="1.2.2 形容词"></a>1.2.2 形容词</h4><h5 id="1-2-2-1-な形容词"><a href="#1-2-2-1-な形容词" class="headerlink" title="1.2.2.1 な形容词"></a>1.2.2.1 な形容词</h5><p>以“有名的人”和“不有名的人”为例。</p>
<ul>
<li>肯定: 在词尾加「な」，「有名な人」</li>
<li>否定: 和在句尾做述语的形式相同，「有名じゃない人」<h5 id="1-2-2-2-い形容词"><a href="#1-2-2-2-い形容词" class="headerlink" title="1.2.2.2 い形容词"></a>1.2.2.2 い形容词</h5>以“可爱的Kino”和“不可爱的Kino”为例。</li>
<li>肯定: 和在句尾做述语的形式相同，「可愛いキノ」</li>
<li>否定: 和在句尾做述语的形式相同，「可愛くないキノ」</li>
</ul>
<h4 id="1-2-3-动词"><a href="#1-2-3-动词" class="headerlink" title="1.2.3 动词"></a>1.2.3 动词</h4><p>和在句尾做述语完全相同，不赘述。</p>
<h2 id="2-时轴"><a href="#2-时轴" class="headerlink" title="2. 时轴"></a>2. 时轴</h2><p>关于时轴，日语里只有两种类型，过去时和现在时，上一章所有变形都是在现在时的情况下，下面结束过去时的变形方式。</p>
<h3 id="2-1-句尾"><a href="#2-1-句尾" class="headerlink" title="2.1 句尾"></a>2.1 句尾</h3><h4 id="2-1-1-名词"><a href="#2-1-1-名词" class="headerlink" title="2.1.1 名词"></a>2.1.1 名词</h4><p>以“我过去是学生”和“我过去不是学生”为例。</p>
<ul>
<li>肯定: 句尾名词后加「だった」表示过去肯定，「私は学生いだった」</li>
<li>否定: 句尾名词后加「じゃなかった」表示过去否定，「私は学生いじゃなかった」</li>
</ul>
<h4 id="2-1-2-形容词"><a href="#2-1-2-形容词" class="headerlink" title="2.1.2 形容词"></a>2.1.2 形容词</h4><h5 id="2-1-2-1-な形容词"><a href="#2-1-2-1-な形容词" class="headerlink" title="2.1.2.1 な形容词"></a>2.1.2.1 な形容词</h5><p>以“学校过去是安静的”和“学校过去是不安静的”为例。</p>
<ul>
<li>肯定: 句尾な形容词后加「だった」表示过去肯定，「学校は静かだった」</li>
<li>否定: 句尾な形容词后加「じゃなかった」表示过去否定，「学校は静かじゃなかった」</li>
</ul>
<h5 id="2-1-2-2-い形容词"><a href="#2-1-2-2-い形容词" class="headerlink" title="2.1.2.2 い形容词"></a>2.1.2.2 い形容词</h5><p>以“Kino过去是可爱的”和“Kino过去是不可爱的”为例。</p>
<ul>
<li>肯定: 句尾い形容词将「い」变为「かった」表示过去肯定，「キノは可愛かった」</li>
<li>否定: 句尾い形容词将「い」变为「くなかった」表示过去肯定，「キノは可愛くなかった」</li>
</ul>
<h4 id="2-1-3-动词"><a href="#2-1-3-动词" class="headerlink" title="2.1.3 动词"></a>2.1.3 动词</h4><p>一段动词、五段动词和特殊动词不同，分开来讲。</p>
<h5 id="2-1-3-1-一段动词"><a href="#2-1-3-1-一段动词" class="headerlink" title="2.1.3.1 一段动词"></a>2.1.3.1 一段动词</h5><p>以“我过去吃了”和“我过去没吃”为例。</p>
<ul>
<li>肯定: 句尾一段动词将「る」变为「た」，「私は食べた」</li>
<li>否定: 句尾一段动词将「る」变为「なかった」，「私は食べなかった」<h5 id="2-1-3-2-五段动词"><a href="#2-1-3-2-五段动词" class="headerlink" title="2.1.3.2 五段动词"></a>2.1.3.2 五段动词</h5>五段动词的过去时较为复杂，不举具体例子说明。</li>
<li>肯定: 句尾五段动词的过去肯定变形较为复杂，结尾词不同其形式不同，分别是「す」-&gt;「した」、「く」-&gt;「いた」、「ぐ」-&gt;「いだ」、「む/ぶ/ぬ」-&gt;「んだ」、「る/う/つ」-&gt;「った」，<strong>唯一的例外是「行く」-&gt;「行いた」-&gt;「行った」</strong>。</li>
<li>否定: 在现在时的否定基础上，将「い」变为「かった」<h5 id="2-1-3-3-特殊动词"><a href="#2-1-3-3-特殊动词" class="headerlink" title="2.1.3.3 特殊动词"></a>2.1.3.3 特殊动词</h5>特殊动词する、くる的过去时变形比较特别，按照顺序规则分别为:</li>
<li>肯定: した、きた</li>
<li>否定: しなかった、こなかった</li>
</ul>
<h3 id="2-2-句中"><a href="#2-2-句中" class="headerlink" title="2.2 句中"></a>2.2 句中</h3><p>所有词性的过去时在句中的形式和句尾是相同的，即所有过去时的名词、形容词、动词都可以直接做修饰语，修饰另一个名词。</p>
<h2 id="3-时极综合"><a href="#3-时极综合" class="headerlink" title="3. 时极综合"></a>3. 时极综合</h2><p>对于名词、な形容词、い形容词、一段动词和五段动词，综合考虑极性、时轴和在句子的位置，分别得到表1、2、3、4、5、6。</p>
<p align="center">表1 名词</p>

<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">现在肯定</th>
<th style="text-align:center">现在否定</th>
<th style="text-align:center">过去肯定</th>
<th style="text-align:center">过去否定</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">句尾</td>
<td style="text-align:center">だ</td>
<td style="text-align:center">じゃない</td>
<td style="text-align:center">だった</td>
<td style="text-align:center">じゃなかった</td>
</tr>
<tr>
<td style="text-align:center">句中</td>
<td style="text-align:center">不存在该用法</td>
<td style="text-align:center">じゃない</td>
<td style="text-align:center">だった</td>
<td style="text-align:center">じゃなかった</td>
</tr>
</tbody>
</table>
<p align="center">表2 な形容词</p>

<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">现在肯定</th>
<th style="text-align:center">现在否定</th>
<th style="text-align:center">过去肯定</th>
<th style="text-align:center">过去否定</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">句尾</td>
<td style="text-align:center">だ</td>
<td style="text-align:center">じゃない</td>
<td style="text-align:center">だった</td>
<td style="text-align:center">じゃなかった</td>
</tr>
<tr>
<td style="text-align:center">句中</td>
<td style="text-align:center">な</td>
<td style="text-align:center">じゃない</td>
<td style="text-align:center">だった</td>
<td style="text-align:center">じゃなかった</td>
</tr>
</tbody>
</table>
<p align="center">表3 い形容词</p>

<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">现在肯定</th>
<th style="text-align:center">现在否定</th>
<th style="text-align:center">过去肯定</th>
<th style="text-align:center">过去否定</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">句尾</td>
<td style="text-align:center">原形</td>
<td style="text-align:center">くない</td>
<td style="text-align:center">かった</td>
<td style="text-align:center">くなかった</td>
</tr>
<tr>
<td style="text-align:center">句中</td>
<td style="text-align:center">原形</td>
<td style="text-align:center">くない</td>
<td style="text-align:center">かった</td>
<td style="text-align:center">くなかった</td>
</tr>
</tbody>
</table>
<p align="center">表4 一段动词</p>

<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">现在肯定</th>
<th style="text-align:center">现在否定</th>
<th style="text-align:center">过去肯定</th>
<th style="text-align:center">过去否定</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">句尾</td>
<td style="text-align:center">原形</td>
<td style="text-align:center"><del>る</del>ない</td>
<td style="text-align:center"><del>る</del>た</td>
<td style="text-align:center"><del>る</del>なかった</td>
</tr>
<tr>
<td style="text-align:center">句中</td>
<td style="text-align:center">原形</td>
<td style="text-align:center"><del>る</del>ない</td>
<td style="text-align:center"><del>る</del>た</td>
<td style="text-align:center"><del>る</del>なかった</td>
</tr>
</tbody>
</table>
<p align="center">表5 五段动词</p>

<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">现在肯定</th>
<th style="text-align:center">现在否定</th>
<th style="text-align:center">过去肯定</th>
<th style="text-align:center">过去否定</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">句尾</td>
<td style="text-align:center">原形</td>
<td style="text-align:center"><del>/u/</del>/a/ない</td>
<td style="text-align:center">「す-&gt;した」「く-&gt;いた」、「ぐ-&gt;いだ」、「む/ぶ/ぬ-&gt;んだ」、「る/う/つ-&gt;った」</td>
<td style="text-align:center">否定极+过去时</td>
</tr>
<tr>
<td style="text-align:center">句中</td>
<td style="text-align:center">原形</td>
<td style="text-align:center"><del>/u/</del>/a/ない</td>
<td style="text-align:center">「す-&gt;した」「く-&gt;いた」、「ぐ-&gt;いだ」、「む/ぶ/ぬ-&gt;んだ」、「る/う/つ-&gt;った」</td>
<td style="text-align:center">否定极+过去时</td>
</tr>
</tbody>
</table>
<p align="center">表6 特殊动する、くる</p>

<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">现在肯定</th>
<th style="text-align:center">现在否定</th>
<th style="text-align:center">过去肯定</th>
<th style="text-align:center">过去否定</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">句尾</td>
<td style="text-align:center">原形</td>
<td style="text-align:center">しない、こない</td>
<td style="text-align:center">した、きた</td>
<td style="text-align:center">しなかった、こなかった</td>
</tr>
<tr>
<td style="text-align:center">句中</td>
<td style="text-align:center">原形</td>
<td style="text-align:center">しない、こない</td>
<td style="text-align:center">した、きた</td>
<td style="text-align:center">しなかった、こなかった</td>
</tr>
</tbody>
</table>
<p>可以看出，除却名词和な形容词，其余几类在作为述语和作为修饰语的情况下，规则是完全相同的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要讲解了日语中的极性和时，下一篇文章将讲解日语中的动作体貌。</p>
<h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)">Wikipedians. “極性 (言語学).” Wikipedia, Wikimedia Foundation, 14 June 2018, <a href="https://ja.wikipedia.org/wiki/極性_(言語学)" target="_blank" rel="noopener">https://ja.wikipedia.org/wiki/極性_(言語学)</a>.<a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)">Wikipedians. “Affirmation and Negation.” Wikipedia, Wikimedia Foundation, 19 June 2018, <a href="https://en.wikipedia.org/wiki/Affirmation_and_negation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Affirmation_and_negation</a>.<a href="#fnref:2" rev="footnote"> ↩</a></span></div><div id="fn:3" style="display:flex"><span style="width:20px">3.</span><span style="width:calc(100% - 20px)">Wikipedians. “Polarity Item.” Wikipedia, Wikimedia Foundation, 19 June 2018, <a href="https://en.wikipedia.org/wiki/Polarity_item" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Polarity_item</a>.<a href="#fnref:3" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>humanities</category>
        <category>languages</category>
      </categories>
      <tags>
        <tag>japanese</tag>
      </tags>
  </entry>
  <entry>
    <title>日语学习六</title>
    <url>/2018/06/18/japanese07/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇介绍了日语的语态，这一篇文章开始讲述日语的语气。语气简单来说就是说话者对某一命题的主观意见和心里态度的总称。<br>王忻在日语语气再考(上)<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="王忻. 日语语气再考(上)[J]. 日语学习与研究, 2002(2):18-24.
">[1]</span></a></sup>和日语语气再考(下)<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="王忻. 日语语气再考(下)[J]. 日语学习与研究, 2002(3):18-24.
">[2]</span></a></sup>中对日语语气进行了详细的研究，刘峰在日语语气概论<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="刘峰. 日语语气概论(モダリティ)[J]. 科教文汇(上旬刊), 2010(2):141-142.
">[3]</span></a></sup>中也对日语语气进行了简要说明，日语语法专题教程<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.
">[4]</span></a></sup>中有单独一章介绍语气。<br>本篇将结合这些资料，对语气进行相关说明。</p>
<a id="more"></a>
<h2 id="1-语气概述"><a href="#1-语气概述" class="headerlink" title="1. 语气概述"></a>1. 语气概述</h2><h3 id="1-1-命题与语气的对立"><a href="#1-1-命题与语气的对立" class="headerlink" title="1.1 命题与语气的对立"></a>1.1 命题与语气的对立</h3><p>日语的句子(话语)在语义和句法结构的关系上，大体呈现出表现客观语义的“叙述素材”和表达主观语义的“句子的叙述方式”两个层面，前者称为“命题内容”，日语为“言表事态”，下文简称为“命题”，后者称为“语气”，日语为“言表态度”，即日语的句子由“命题”与“语气”这两个性质不同的部分构成。具体来说，所谓命题，是指说话人在句中所表述的、与说话人主观思维相分离的客观事实；所谓语气，是指说话人在说话时从说话人的立场出发、主观性地对命题的把握方法和态度。通过两者的对立统一，构成句子的意义结构。</p>
<h3 id="1-2-命题与语气的界定与位置"><a href="#1-2-命题与语气的界定与位置" class="headerlink" title="1.2 命题与语气的界定与位置"></a>1.2 命题与语气的界定与位置</h3><p>虽说句子是由命题和语气两部分组成的，但并不是说句子等于命题和语气两部分的简单相加。也就是说命题与语气并不是并列关系，而是一种包容关系：{[命题]语气}<br>从作为语气载体的语法形式上来看，命题和语气还是应该能够划分并有自己的位置的。一般说来:</p>
<ul>
<li>命题部分包括主语部分和谓语部分中的体、认定方式、态、时等。</li>
<li>语气部分包括谓语活用形、系词(即“コピュラ”，在传统语法中称为助动词)及形式名词、终助词/特提助词/陈述副词/感叹词和接续词等等。另外敬语表达形式也应包括其中。</li>
</ul>
<p>语气的位置是多种多样的，它因种类和词类不同而定。语气表现形式出现在句子尾部的频率大大高于其它位置。<br>王忻在日语语气再考(上)<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="王忻. 日语语气再考(上)[J]. 日语学习与研究, 2002(2):18-24.
">[1]</span></a></sup>归纳为: 任意一个句子都应有表现语气的部分(尽管有时可能很难清楚地划分出来)，它在句中的位置不定，但句子的后部必然是语气。<br>此外，一个句子有两处以上出现语气时，就应把它们分为主要语气和次要语气等来考察。</p>
<h2 id="2-语气的分类"><a href="#2-语气的分类" class="headerlink" title="2. 语气的分类"></a>2. 语气的分类</h2><p>与语气研究有关的分类可归纳为两大类，一种是对各种不同语气的句子类型进行的分类，一种是对语气载体（表现语气的语法形式）的分类。前者是从句子语一气的类型入手，在对这些类型进行分析的过程中涉及到构成这些语气的“构件”——表现语气的语法形式。后者与前者方向相反，是从这些“构件”入手，对这些“构件”构成的语气进行归纳研究的。</p>
<h3 id="2-1-不同语气类型的分类"><a href="#2-1-不同语气类型的分类" class="headerlink" title="2.1 不同语气类型的分类"></a>2.1 不同语气类型的分类</h3><h4 id="2-1-1-经典分类"><a href="#2-1-1-经典分类" class="headerlink" title="2.1.1 经典分类"></a>2.1.1 经典分类</h4><p>日语语气再考(上)<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="王忻. 日语语气再考(上)[J]. 日语学习与研究, 2002(2):18-24.
">[1]</span></a></sup>和日语语法专题教程<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.
">[4]</span></a></sup>中列出了已有的几种较为代表性的分类，包括:</p>
<ul>
<li>高桥太郎等(2001)编著的《日本語の文法2001》中的分类</li>
<li>仁田义雄(1997)在《日本語のモダリティと人称》中的分类</li>
<li>奥田靖雄(1996)在《文のことーその分类をめぐってー》中的分类</li>
<li>寺村秀夫(1982)在《日本語のシンタクスと意味》中的分类</li>
<li>益冈隆志(2000)在《日本語の文法诸相》中的分类</li>
<li>森山卓郎(2000)在《日本語の文法3モダリテイ》中的分类</li>
<li>井上优在(2006)在《シリーズ方言学2方言の文法》中的分类</li>
</ul>
<h4 id="2-1-2-详解两种分类"><a href="#2-1-2-详解两种分类" class="headerlink" title="2.1.2 详解两种分类"></a>2.1.2 详解两种分类</h4><h5 id="2-1-2-1-第一种分类方式"><a href="#2-1-2-1-第一种分类方式" class="headerlink" title="2.1.2.1 第一种分类方式"></a>2.1.2.1 第一种分类方式</h5><p>日语语气概论<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="刘峰. 日语语气概论(モダリティ)[J]. 科教文汇(上旬刊), 2010(2):141-142.
">[3]</span></a></sup>中将语气类型分为四类:<br>1. 反映句子所表达内容的功能语气。<br>这是决定句子最基本性质的语气，其有两种类型：信息类与行为类。它们都属于表现类型的语气。<br>信息类语气就承担着向听者传达信息（叙述语气）以及从听者那里获取信息的功能（疑问语气）。</p>
<blockquote>
<p>例: 昨日上海に行った(叙述语气，礼貌语气)<br>例: 明日休むか(疑问语气，非礼貌语气)</p>
</blockquote>
<p>行为类语气承担着说话者和听话者的行为实现的机能，其中又分为说话者自身行为实现（意志型语气），说话者以自己的行为实现为前提，要求对方也实现某种行为（劝诱语气），要求对方实现某种行为（行为要求语气）。</p>
<blockquote>
<p>例: 美味しいな、やっぱり食べようか(意志形语气)<br>例: 仕事もう終わっただろう、じゃ、一緒に帰ろう(劝诱语气)<br>例: 部屋が散らかってるぞ、速く片付けろ(行为要求语气)</p>
</blockquote>
<p>2. 针对命题的把握方法的语气。<br>该语气是说话者对于命题内容的把握方式，有两种语气类型：评价语气和认知语气。<br>评价语气是对命题所表达的事象做出的必要、不必要 或者允许、不允许的评价式表达。</p>
<blockquote>
<p>例: この仕事を引き受けた以上さ、 最後までやらなくてはならない. 句中的なくてはならない是说话者对やる这个事象是必要的一种评价的表达。<br>例: ここにある飲み物は自由に取ってもいい. 句中的てもいい是表示对取る这个事象是被许可的一种评价的表达。</p>
</blockquote>
<p>认知语气在认知的把握方法上，有对命题的基本认知态度，如断 定、推量、对命题成立的可能性、必然性的认知，通过证据来对命题进行把握的表示推断、传闻等语气。</p>
<blockquote>
<p>例: 上海は今雪を降っているだろう(推量的语气)<br>例: 今晩、風が吹くかもしれない(可能性的语气)<br>例: 道は濡れているから、 昨夜雨が降っていたようだ(推定的语气)<br>例: 天気予報によると、明日も雨が降るそうだ(传闻的语气)</p>
</blockquote>
<p>3. 表示上下文之间关系的语气。<br>该语气称为说明语气，通过提示上下文之间的关系使得听话者对所叙内容更易理解。</p>
<blockquote>
<p>例: 遅くなってすみません、 いきなり社長から電話をもらったんだ(说明语气)</p>
</blockquote>
<p>4. 表示对听话者的语气。<br>由于语言交流是双方相互进行的，因此，除了说话这自身对命题主观表达外，还有向听话者表示传达的义务，像这类语气称之为对听话者语气。对听话者语气中有两种语气类型：传达态度和礼貌的语气。<br>礼貌体与普通体的选择，要根据双方的年龄、地位、场合等来决定。</p>
<blockquote>
<p>例: 昨日、スーパーへ買い物に行った(普通体语气)<br>例: 昨日、スーパーへ買い物に行きました(礼貌体语气)</p>
</blockquote>
<p>传达态度语气是向对方传达时在语气上所做的一些细微调整等,传达态度语气通常会用よ、 ね、 わ这种语气终助词来表达。</p>
<blockquote>
<p>例: 仕事はストレスがいっぱい溜まっているなあ<br>例: ね、本、ここにあるよ、何で見つからないの?</p>
</blockquote>
<p>表示传达的语气既有向对方传达的意图也有自言自语的场合，如なあ多用于自言自语的场合。</p>
<h5 id="2-1-2-2-第二种分类方式"><a href="#2-1-2-2-第二种分类方式" class="headerlink" title="2.1.2.2 第二种分类方式"></a>2.1.2.2 第二种分类方式</h5><p>日语语法专题教程<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.
">[4]</span></a></sup>采用了井上优在「シリーズ方言学2方言の文法」(岩波書店,2006)中对语气的分类。Kino在这里也j简要介绍一下。主要分为两大类: “说话者对命题内容的判断”和“对听话者的发话态度和传递态度”。<br>1. 说话者对命题内容的判断<br>即“判断性语气”、“对事性语气”、“命题指向性语气”，包括“真伪判断性语气”和“价值判断语气”。</p>
<ul>
<li>真伪判断语气主要包括断定、推量、概然性判断、证据性判断、当然性判断、传闻、说明等语气</li>
<li>价值判断语气主要有“适当适度”、“必要”、“容许认可”三类语气</li>
</ul>
<p>2. 对听话者的发话态度和传递态度<br>即“发话传递语气”、“对人性语气”、“听话者指向性语气”，包括“描述判断”、“表抒”、“号令”、“疑问、询问、确认”、“强调”等。</p>
<h3 id="2-2-不同语气载体的分类"><a href="#2-2-不同语气载体的分类" class="headerlink" title="2.2 不同语气载体的分类"></a>2.2 不同语气载体的分类</h3><p>所谓语气载体即表达各种语气的语法形式，如用言活用形、系词、形式名词、特提助词等。<br>在日语语法专题教程<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.
">[4]</span></a></sup>中，作者按照语气载体的方式将日语中语气的表达方式主要分为四类:</p>
<ul>
<li>述语的活用形及其他附着在述语上的语法形式</li>
<li>副词的使用</li>
<li>感叹词和间投助词的使用(这里间投助词的意思是“加在语句和语句、句子中间的助词”，即在句节后通过停顿提示听话者，以表达说话者感叹等语气的助词)</li>
<li>句尾语调</li>
</ul>
<p>而王忻在日语语气再考(上)<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="王忻. 日语语气再考(上)[J]. 日语学习与研究, 2002(2):18-24.
">[1]</span></a></sup>和日语语气再考(下)<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="王忻. 日语语气再考(下)[J]. 日语学习与研究, 2002(3):18-24.
">[2]</span></a></sup>中将语气载体按与命题的距离分为三个级次。下面简要说明一下。</p>
<h4 id="2-2-1-第一级语气"><a href="#2-2-1-第一级语气" class="headerlink" title="2.2.1 第一级语气"></a>2.2.1 第一级语气</h4><p>第一级语气是以活用形为手段表现的。具体活用形中的哪种形式表达何种语气基本如图1所示。</p>
<p><img src="/images/japanese07_1.png" alt="figure 1"></p>
<p align="center">图1 活用形表达的语气</p>

<p>本图除动词外还可适用于形容词，只是形容词没有劝诱形和命令形。</p>
<h4 id="2-2-2-第二级语气"><a href="#2-2-2-第二级语气" class="headerlink" title="2.2.2 第二级语气"></a>2.2.2 第二级语气</h4><p>第二级语气是接在表第一级确切语气的形式后，表明说话人对所述内容的态度的形式。在层次结构上它把命题+第一级语气作为一个整体对其进行包容。它由助动词和形式名词+だ的形式担当。<br>根据表意，本群词可分为表述推断事实的推测语气者、表述解释说明的说明语气者和表说话人心中认为“可否”、“愿否”的语气这三小类。前者主要由助动词担任，中者由“形式体言+だ”的形式担当，后者主要由形容词性短语担当。</p>
<h4 id="2-2-3-第三级语气"><a href="#2-2-3-第三级语气" class="headerlink" title="2.2.3 第三级语气"></a>2.2.3 第三级语气</h4><p>第三级语气的表现形式由特提(取リ立て)助词，陈述副词、终助词、感叹词、部分接续词和敬语等形式担当<br>其中除特提助词(把句子中某些成分特别提出加以强调来表达某种言外之意为特提)、陈述副词是表示对事性语气以外其余均表示对人性语气。<br>与第一级、第二级语气相比，第三级语气的最大特点是位置相对不稳定，第一级语气活用形处于谓语位置，第二级语气系 词又是紧随活用形之后，位置都比较固定，而第三级语气因成分复杂等原因位置也就不固定了。<br>从词类来看表现对人性语气的终助词、感叹词和接续词位置相对稳定，终助词在句尾，感叹词一 般在句首，接续词则在下句之前。但敬语和表现对事性语气的特提助助词的位置就难以如此简单地划定了。</p>
<h2 id="3-特殊用法"><a href="#3-特殊用法" class="headerlink" title="3. 特殊用法"></a>3. 特殊用法</h2><p>将一个句子全部用片假名书写，用来表示惊讶、敌意等强烈的语气。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章主要阐述了日语的语气，下一篇将讲解日语中的敬体。</p>
<h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)">王忻. 日语语气再考(上)[J]. 日语学习与研究, 2002(2):18-24.<a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)">王忻. 日语语气再考(下)[J]. 日语学习与研究, 2002(3):18-24.<a href="#fnref:2" rev="footnote"> ↩</a></span></div><div id="fn:3" style="display:flex"><span style="width:20px">3.</span><span style="width:calc(100% - 20px)">刘峰. 日语语气概论(モダリティ)[J]. 科教文汇(上旬刊), 2010(2):141-142.<a href="#fnref:3" rev="footnote"> ↩</a></span></div><div id="fn:4" style="display:flex"><span style="width:20px">4.</span><span style="width:calc(100% - 20px)">马兰英, 孙海英, 徐莲. 日语语法专题教程[M]. 浙江工商大学出版社, 2016.<a href="#fnref:4" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>humanities</category>
        <category>languages</category>
      </categories>
      <tags>
        <tag>japanese</tag>
      </tags>
  </entry>
  <entry>
    <title>日语学习七</title>
    <url>/2018/06/18/japanese08/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇文章介绍了日语的语气，这一篇Kino将要讲解日语的敬语系统。<br>日语敬语是日语中用于表达敬意的表达方式，用来表示说话者、说话对象、话中人物之间的社会阶级、亲疏等关系。出席使用日语的许多社交场合必须使用敬语，以表达适当的身份关系和礼貌。<br>现代日语敬语的分类研究<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="姚莉萍. 现代日语敬语的分类研究. 日语学习与研究 3(1996):6-10.
">[1]</span></a></sup> 中介绍了几种日语的分类方式，包括以敬意形式进行的分类和待遇表现进行的分类。而现在常用的分类方法还是按照前者进行分类的，一般可分为丁宁语（礼貌语）、尊敬语和谦逊语三大类。有时丁宁语也可以再另分出郑重语和美化语两类敬语。说话人会根据谈话内容以及对象，而使用相关的辞汇或是动词变形。<br>根据相关参考资料如日语语法指南<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Tae, and Pizza. 敬语和动词词根. 日语语法指南 | Learn Japanese, http://res.wokanxing.info/jpgramma/polite.html.
">[2]</span></a></sup>、维基百科<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. 日語敬語. Wikipedia, Wikimedia Foundation, 7 June 2018, https://zh.wikipedia.org/wiki/日語敬語.
">[3]</span></a></sup>、日语敬语<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="三吉礼子. 日语敬语. 北京大学出版社, 2006.
">[4]</span></a></sup>、试论日语敬语现象<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="桑凤平. 试论日语敬语现象. 外语与外语教学 8(2001):21-23.
">[5]</span></a></sup>、日语敬语的常见错误分析<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="杜玲莉. 日语敬语的常见错误分析. 东北亚外语研究 6(2004):7-8.
">[6]</span></a></sup>对敬体的几大类进行介绍。</p>
<a id="more"></a>
<h2 id="1-丁宁语"><a href="#1-丁宁语" class="headerlink" title="1. 丁宁语"></a>1. 丁宁语</h2><p>表示客气、礼貌、文雅、郑重的语言，叫丁宁语，丁宁语是代表说话人礼貌的敬语，代表尊重听话对象。<br>丁宁语反映在句尾，根据句尾的不同，有以下两种情况:</p>
<h3 id="1-1-句尾是动词"><a href="#1-1-句尾是动词" class="headerlink" title="1.1 句尾是动词"></a>1.1 句尾是动词</h3><p>将动词变为一类い形活用词根，之后再句尾加「ます」。<br>此外，考虑极性和时轴，「ます」形有相应变化:</p>
<ul>
<li>肯定现在: 「ます」</li>
<li>否定现在: 「ません」</li>
<li>肯定过去: 「ました」</li>
<li>否定过去: 「ませんでした」</li>
</ul>
<h3 id="1-2-句尾是名词、形容词"><a href="#1-2-句尾是名词、形容词" class="headerlink" title="1.2 句尾是名词、形容词"></a>1.2 句尾是名词、形容词</h3><p>句尾若是有「だ」，将「だ」除去，之后在句尾加「です」。<br>考虑极性和时轴，「です」形也有不同变化。</p>
<p align="center">表1 い形容词结尾</p>

<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">口语</th>
<th style="text-align:center">丁宁语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">肯定现在</td>
<td style="text-align:center">かわいい</td>
<td style="text-align:center">かわいいです</td>
</tr>
<tr>
<td style="text-align:center">否定现在</td>
<td style="text-align:center">かわいくない</td>
<td style="text-align:center">かわいくないです</td>
</tr>
<tr>
<td style="text-align:center">肯定过去</td>
<td style="text-align:center">かわいかった</td>
<td style="text-align:center">かわいかったです</td>
</tr>
<tr>
<td style="text-align:center">否定过去</td>
<td style="text-align:center">かわいくなかった</td>
<td style="text-align:center">かわいくなかったです</td>
</tr>
</tbody>
</table>
<p align="center">表2 な形容词或名词结尾</p>

<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">口语</th>
<th style="text-align:center">丁宁语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">肯定现在</td>
<td style="text-align:center">静か（だ）</td>
<td style="text-align:center">静かです</td>
</tr>
<tr>
<td style="text-align:center">否定现在</td>
<td style="text-align:center">静かじゃない</td>
<td style="text-align:center">静かじゃないです</td>
</tr>
<tr>
<td style="text-align:center">肯定过去</td>
<td style="text-align:center">静かだった</td>
<td style="text-align:center"><strong>静かでした</strong></td>
</tr>
<tr>
<td style="text-align:center">否定过去</td>
<td style="text-align:center">静かじゃなかった</td>
<td style="text-align:center">静かじゃなかったです</td>
</tr>
</tbody>
</table>
<h3 id="1-3-否定情况下的另一种表达"><a href="#1-3-否定情况下的另一种表达" class="headerlink" title="1.3 否定情况下的另一种表达"></a>1.3 否定情况下的另一种表达</h3><p>上述否定形的丁宁语不是「官方」的正确活用。更加「正确」的活用形应该是把「ないです」部分改为「ありません」，理由是动词「ある」的丁宁未然形不是「ないです」而是「ありません」。所以，「かわいくない」应该写作「かわいくありません」，「静かじゃない」则应该是「静かじゃありません」。<br>实际上，这种所谓的「官方」用法听起来太过呆板和正式。在日常对话中，大家基本用的都是上述介绍的形式，虽然在用丁宁语写作时应该用更加正式的活用形，但日常说话几乎用不到。</p>
<h3 id="1-4-特殊词"><a href="#1-4-特殊词" class="headerlink" title="1.4 特殊词"></a>1.4 特殊词</h3><p>有一些词汇的丁宁语版本完全是另外一个词汇，主要有:</p>
<ul>
<li>「ある」: 「ござる」，「ござる」总是以「ます」形出现，即「ございます」</li>
<li>「です」: 「でございます」，其实就是「でござる」的「ます」形活用，从「である」而来，字面意思是「以…的形式存在」</li>
<li>「いい」: 「よろしい」是更正式的表达方式</li>
<li>「さん」: 「様」，这个后缀在口语里面不常用到，即使在说尊敬语或谦逊语。不过，写信的时候一般会用到它，即使对方是熟人也一样。还有服务行业例如收银员或服务员通常会称呼客户为「お客様」。当然了，皇族和神灵一定是会用「様」的，例如「神様」</li>
</ul>
<h2 id="2-尊敬语"><a href="#2-尊敬语" class="headerlink" title="2. 尊敬语"></a>2. 尊敬语</h2><p>对他人的行为、状态及有关事物等表示敬意的语言，尊敬语代表尊敬话题里施行行为的人。<br>话题提及社会阶级较高的人，例如长辈、师长、上司、客户等，便会使用尊敬语。提及说话人自身的时候，不用尊敬语。</p>
<h3 id="2-1-动词的尊敬语形式"><a href="#2-1-动词的尊敬语形式" class="headerlink" title="2.1 动词的尊敬语形式"></a>2.1 动词的尊敬语形式</h3><p>对动作主体表示尊敬有四个方法。</p>
<h4 id="2-1-1-用特殊尊敬语动词"><a href="#2-1-1-用特殊尊敬语动词" class="headerlink" title="2.1.1 用特殊尊敬语动词"></a>2.1.1 用特殊尊敬语动词</h4><p>和一般用语完全不一样。例如动词「する」，尊敬语动词则为「なさる」。动词「話す」，尊敬语动词则为「おっしゃる」。</p>
<h4 id="2-1-2-使用「お……になる」句型"><a href="#2-1-2-使用「お……になる」句型" class="headerlink" title="2.1.2 使用「お……になる」句型"></a>2.1.2 使用「お……になる」句型</h4><p>一般没有相应尊敬语的动词，也可以换成「一类い形活用词根」，前加「お」、后加「になる」，使之成为尊敬语。例如「読む」，尊敬语可以用「お読みになる」。<br>也可以用「下さい」替代「になる」。当你想用尊敬语动词请别人做什么的时候，这种表达很有用。</p>
<h4 id="2-1-3-使用「お……です」句型"><a href="#2-1-3-使用「お……です」句型" class="headerlink" title="2.1.3 使用「お……です」句型"></a>2.1.3 使用「お……です」句型</h4><p>将一般动词换成「一类い形活用词根」，前加「お」、后加「です」，也成为尊敬语。例如「読む」，尊敬语可以用「お読みです」。</p>
<h4 id="2-1-4-动词被动形也可以当尊敬语使用"><a href="#2-1-4-动词被动形也可以当尊敬语使用" class="headerlink" title="2.1.4 动词被动形也可以当尊敬语使用"></a>2.1.4 动词被动形也可以当尊敬语使用</h4><p>「読みましたか」，尊敬语亦可说成「読まれましたか」</p>
<h3 id="2-2-名词形容词的尊敬语形式"><a href="#2-2-名词形容词的尊敬语形式" class="headerlink" title="2.2 名词形容词的尊敬语形式"></a>2.2 名词形容词的尊敬语形式</h3><p>除了动词外，部分名词也有尊敬语。例如「その人」，尊敬语是「その方」。一般情况下，大部分名词前可以加上词头表示尊敬。<br>日语固有词即訓読み单词通常加「お」，例如「お顔」、「お話」，汉字词即音読み单词通常加「ご」，例如「ご冗談」、「ご両親」。如写成汉字，两者均作「御」。<br>部分形容词也加上「お」、「ご」做成尊敬语，规则与名词类似。例如「お忙しい」、「お元気」、「ご満足」。</p>
<h2 id="3-谦逊语"><a href="#3-谦逊语" class="headerlink" title="3. 谦逊语"></a>3. 谦逊语</h2><p>谦逊语又称谦让语，说话人通过谦虚地讲述、甚至是贬低话题中行为主体的动作，用来对接受行为的人表示尊敬。行为主体是说话人自身的时候，也可以用谦让语。</p>
<h2 id="3-1-用特殊谦逊语动词"><a href="#3-1-用特殊谦逊语动词" class="headerlink" title="3.1 用特殊谦逊语动词"></a>3.1 用特殊谦逊语动词</h2><p>谦逊语可以用特殊词汇来表示，例如自有一套动词。一般例如动词「する」，谦让语动词则为「いたす」。一般动词「話す」，谦让语动词则为「申す」。</p>
<h2 id="3-2-使用「お-ご……する-いたす-申し上げる」句型"><a href="#3-2-使用「お-ご……する-いたす-申し上げる」句型" class="headerlink" title="3.2 使用「お/ご……する/いたす/申し上げる」句型"></a>3.2 使用「お/ご……する/いたす/申し上げる」句型</h2><p>另外，如果没有相对的谦逊动词，可以使用「お/ご……する/いたす/申し上げる」句型。一般动词换成「一类い形活用词根」，前加「お」或「ご」、后加「する」或「いたす」，便可成为谦让语，「いたす」实际上又是「する」的谦逊语。例如「持つ」，谦让语可以说成「お持ちする」，「案内する」谦让语可以说成「ご案内する」。</p>
<h2 id="3-3-注意事项"><a href="#3-3-注意事项" class="headerlink" title="3.3 注意事项"></a>3.3 注意事项</h2><p>部分谦逊语已经成为固有短语，例如「いただく」本为「もらう」的谦逊语，但这个动词的丁宁语体「いただきます」则是吃喝之前所说的寒暄话。</p>
<h2 id="4-特殊动词"><a href="#4-特殊动词" class="headerlink" title="4. 特殊动词"></a>4. 特殊动词</h2><h3 id="4-1-特殊尊敬语和特殊谦逊语"><a href="#4-1-特殊尊敬语和特殊谦逊语" class="headerlink" title="4.1 特殊尊敬语和特殊谦逊语"></a>4.1 特殊尊敬语和特殊谦逊语</h3><p>这里列出一些尊敬语和谦逊语与一般用语完全不一样的动词。</p>
<p align="center">表3 尊敬语和谦逊语</p>

<table>
<thead>
<tr>
<th style="text-align:center">字典形</th>
<th style="text-align:center">尊敬语</th>
<th style="text-align:center">谦逊语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">する</td>
<td style="text-align:center">なさる</td>
<td style="text-align:center">致す</td>
</tr>
<tr>
<td style="text-align:center">行く</td>
<td style="text-align:center">いらっしゃる／おいでになる</td>
<td style="text-align:center">参る</td>
</tr>
<tr>
<td style="text-align:center">来る</td>
<td style="text-align:center">いらっしゃる／おいでになる</td>
<td style="text-align:center">参る</td>
</tr>
<tr>
<td style="text-align:center">いる</td>
<td style="text-align:center">いらっしゃる／おいでになる</td>
<td style="text-align:center">おる</td>
</tr>
<tr>
<td style="text-align:center">見る</td>
<td style="text-align:center">ご覧になる</td>
<td style="text-align:center">拝見する</td>
</tr>
<tr>
<td style="text-align:center">聞く</td>
<td style="text-align:center">－</td>
<td style="text-align:center">伺う</td>
</tr>
<tr>
<td style="text-align:center">言う</td>
<td style="text-align:center">おっしゃる</td>
<td style="text-align:center">申す／申し上げる</td>
</tr>
<tr>
<td style="text-align:center">あげる</td>
<td style="text-align:center">－</td>
<td style="text-align:center">差し上げる</td>
</tr>
<tr>
<td style="text-align:center">くれる</td>
<td style="text-align:center">下さる</td>
<td style="text-align:center">－</td>
</tr>
<tr>
<td style="text-align:center">もらう</td>
<td style="text-align:center">－</td>
<td style="text-align:center">いただく</td>
</tr>
<tr>
<td style="text-align:center">食べる</td>
<td style="text-align:center">召し上がる</td>
<td style="text-align:center">いただく</td>
</tr>
<tr>
<td style="text-align:center">飲む</td>
<td style="text-align:center">召し上がる</td>
<td style="text-align:center">いただく</td>
</tr>
<tr>
<td style="text-align:center">知っている</td>
<td style="text-align:center">ご存知（です）</td>
<td style="text-align:center">存じる</td>
</tr>
</tbody>
</table>
<h3 id="4-2-特殊尊敬语和特殊谦逊语的活用规则"><a href="#4-2-特殊尊敬语和特殊谦逊语的活用规则" class="headerlink" title="4.2 特殊尊敬语和特殊谦逊语的活用规则"></a>4.2 特殊尊敬语和特殊谦逊语的活用规则</h3><p>在使用特殊尊敬语和特殊谦逊语基础之上，还可以对这些动词使用丁宁语的规则。<br>但这些动词很多并不遵循普通的ます活用规则，包括「なさる」、「いらっしゃる」、「おっしゃる」、「下さる」和「ござる」。对这些东西要改写为ます形的话，不是像う动词那样把「る」变为「り」，而是要变为「い」。除了ます形，它们的其他活用规则跟普通う动词一样。</p>
<p align="center">表4 尊敬语和谦逊语的特殊活用规则</p>

<table>
<thead>
<tr>
<th style="text-align:center">字典形</th>
<th style="text-align:center">ます形</th>
<th style="text-align:center">过去ます形</th>
<th style="text-align:center">未然ます形</th>
<th style="text-align:center">过去未然ます形</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">なさる</td>
<td style="text-align:center">なさいます</td>
<td style="text-align:center">なさいました</td>
<td style="text-align:center">なさいません</td>
<td style="text-align:center">なさいませんでした</td>
</tr>
<tr>
<td style="text-align:center">いらっしゃる</td>
<td style="text-align:center">いらっしゃいます</td>
<td style="text-align:center">いらっしゃいました</td>
<td style="text-align:center">いらっしゃいません</td>
<td style="text-align:center">いらっしゃいませんでした</td>
</tr>
<tr>
<td style="text-align:center">おっしゃる</td>
<td style="text-align:center">おっしゃいます</td>
<td style="text-align:center">おっしゃいました</td>
<td style="text-align:center">おっしゃいません</td>
<td style="text-align:center">おっしゃいませんでした</td>
</tr>
<tr>
<td style="text-align:center">下さる</td>
<td style="text-align:center">下さいます</td>
<td style="text-align:center">下さいました</td>
<td style="text-align:center">下さいません</td>
<td style="text-align:center">下さいませんでした</td>
</tr>
<tr>
<td style="text-align:center">ござる</td>
<td style="text-align:center">ございます</td>
<td style="text-align:center">ございました</td>
<td style="text-align:center">ございません</td>
<td style="text-align:center">ございませんでした</td>
</tr>
</tbody>
</table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇主要讲解了日语的敬语系统，下一篇将讲解日语中的复合句。</p>
<h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)">姚莉萍. 现代日语敬语的分类研究. 日语学习与研究 3(1996):6-10.<a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)">Tae, and Pizza. 敬语和动词词根. 日语语法指南 | Learn Japanese, <a href="http://res.wokanxing.info/jpgramma/polite.html" target="_blank" rel="noopener">http://res.wokanxing.info/jpgramma/polite.html</a>.<a href="#fnref:2" rev="footnote"> ↩</a></span></div><div id="fn:3" style="display:flex"><span style="width:20px">3.</span><span style="width:calc(100% - 20px)">Wikipedians. 日語敬語. Wikipedia, Wikimedia Foundation, 7 June 2018, <a href="https://zh.wikipedia.org/wiki/日語敬語" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/日語敬語</a>.<a href="#fnref:3" rev="footnote"> ↩</a></span></div><div id="fn:4" style="display:flex"><span style="width:20px">4.</span><span style="width:calc(100% - 20px)">三吉礼子. 日语敬语. 北京大学出版社, 2006.<a href="#fnref:4" rev="footnote"> ↩</a></span></div><div id="fn:5" style="display:flex"><span style="width:20px">5.</span><span style="width:calc(100% - 20px)">桑凤平. 试论日语敬语现象. 外语与外语教学 8(2001):21-23.<a href="#fnref:5" rev="footnote"> ↩</a></span></div><div id="fn:6" style="display:flex"><span style="width:20px">6.</span><span style="width:calc(100% - 20px)">杜玲莉. 日语敬语的常见错误分析. 东北亚外语研究 6(2004):7-8.<a href="#fnref:6" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>humanities</category>
        <category>languages</category>
      </categories>
      <tags>
        <tag>japanese</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode Summary 01 — Cycle Detection</title>
    <url>/2018/10/29/leetcode01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前段时间忙于找工作，因而有正大光明的托词和导师说，11月之后再去做课题相关的事情，也就有了一段较为自由的时间。<br>其中诸多准备，免不了在Leetcode上刷题，虽然对于最终的结果来说没有帮助，但刷题过程中遇到了一些解决思路相似的问题，就依次将这些共性问题阐述一遍罢了。<br>本系列的第一篇介绍的是环检测问题，对应的维基百科页面有<a href="https://en.wikipedia.org/wiki/Cycle_detection" target="_blank" rel="noopener">Cycle detection</a>。这类问题最常见的求解算法是Floyd Cycle Algorithm/Floyd’s Tortoise and Hare，中文名通常为Floyd判圈算法/龟兔赛跑算法。</p>
<a id="more"></a>
<h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>在计算机科学中，有一类问题称之为<strong>环检测问题</strong>，即对于一个由迭代函数(iterated function)值组成的序列，判断该序列是否有环及环出现的位置。<br>关于什么是迭代函数(iterated function)，严格定义可以查看<a href="https://en.wikipedia.org/wiki/Iterated_function" target="_blank" rel="noopener">这里</a>，简单来说就是一个函数\(f\)，其定义域和值域都是集合\(X\)，那么对于某个自变量/输入\(a\)，其因变量/输出\(b\)也可以作为函数\(f\)的自变量/输入，如此给定一个初始值\(x\)，将\(f\)的每一次输出作为下一次的输入，如此重复\(n\)次，就称作函数\(f\)的第\(n\)次迭代。</p>
<p>对于上述函数\(f\)，如果其集合\(X\)是有限的，那么对于序列:<br>$$<br>S = \{x_0, x_1 = f(x_0), x_2 = f(x_1), \cdots, x_i = f(x_{i-1}), \cdots\}<br>$$<br>那么必然会有两个位置\(i\)和\(j\)，且\(i &lt; j\)，其\(x_i = x_j\)，一旦出现这种状况，显然在\(j\)位置之后，会重复从\(x_i\)到\(x_{j-1}\)的序列。所谓环检测问题，就是给定\(f\)和\(x_0\)，要求找到\(i\)和\(j\)。<br>当然对于无限集合\(X\)，是有可能不存在环的，这取决于\(f\)和\(x_0\)的共同作用。例如\(f=x^2\)，如果\(X\)的范围是复数域，那么\(x_0=0,1,-1,e^{\frac{2\pi{}mi}{n}}\)，则有环，否则没有。这里\(m\)的取值范围是整数，\(n\)的取值范围是\({1,2,3,4,6,7,8,12,14,15,16,24,28,30,31,32,\cdots}\)，就不仔细推导了，有兴趣的可以自行推导。</p>
<h3 id="2-求解算法"><a href="#2-求解算法" class="headerlink" title="2. 求解算法"></a>2. 求解算法</h3><p>对于上述问题，最常见的算法是Floyd’s Tortoise and Hare，其次还有Brent’s algorithm和Gosper’s algorithm等。<br>最直接的想法是记录每次迭代的值，建立一个hash表，这样可以在重复出现时直接定位，但是这种方法空间复杂度太高，故弃。</p>
<h4 id="2-1-Floyd’s-Tortoise-and-Hare"><a href="#2-1-Floyd’s-Tortoise-and-Hare" class="headerlink" title="2.1 Floyd’s Tortoise and Hare"></a>2.1 Floyd’s Tortoise and Hare</h4><p>对于问题描述中迭代函数组成的序列，如果存在环，那么对于\(i\ge{}\mu\)，则\(x_i = x_{i+k\lambda}\)，其中\(\lambda\)是环的长度，\(\mu\)是环的第一个元素出现的位置。<br>基于此，可以推出，\(\exists{}i = k\lambda\ge\mu\Longrightarrow{}x_i = x_{2i}\)<br>因此，只要设定两个指针\(P1\)和\(P2\)，其中\(P2\)的步长是2，\(P1\)的步长是1，那么就可以找到两个指针指向值相等的位置，反过来说，即只要存在相等值，就存在环，此时可以得出\(\nu = P2 - P1 = P1 = k\lambda\).<br>显然\(x_{\mu{}+\nu} = x_{\mu}\)，即\(x_{\nu{}+\mu} = x_{\mu}\)，故找到上述位置之后，\(P1\)仍保持原来位置，而\(P2\)放回序列最初位置，此时两个指针的推进步长都设置为1，两指针指向的值再次相等时，就是环开始的位置。找到环开始的位置后，向后迭代找到下一次重复位置，就可以得到环的长度\(\lambda\)了。<br><img src="/images/leetcode01_1.png" alt="img01"></p>
<h4 id="2-2-Brent’s-algorithm"><a href="#2-2-Brent’s-algorithm" class="headerlink" title="2.2 Brent’s algorithm"></a>2.2 Brent’s algorithm</h4><p>Floyd’s Tortoise and Hare算法很精巧，但是判断环存在、找到环开始位置和确定环长度需要分为三步，Brent’s algorithm效率更高，且只需要两步。<br>Brent’s algorithm也是利用了快慢两个指针的想法，但是它的想法是动态增加步长，加快搜索速度。<br>其基本意图是设立两个指针，尽快让第一个指针到达环内，然后第二个指针以步长1前进，再次相等时走过的步数正好是环的长度\(\lambda\)，具体做法如下。<br>首先，设定两个指针\(P1\)和\(P2\)，\(P2\)第一次先前进\(2^0=1\)步，在前进的过程中若始终\(x_{P2}\ne{}x_{P1}\)，则令\(P1 = P2\)，然后\(P2\)再前进\(2^1=2\)，在前进的过程中若始终\(x_{P2}\ne{}x_{P1}\)，则令\(P1 = P2\)，然后\(P2\)再前进\(2^2=4\)……<br>如此，直到出现相等的位置，在出现相等位置之前，最后一次\(P2\)前进的步数就是环的长度\(\lambda\)。<br>此时，将\(P1\)放于序列开始位置0，\(P2\)放于\(\lambda\)位置，由于\(x_{\mu} = x_{\lambda{}+\mu}\)，故只要让\(P1\)和\(P2\)依次向前前进，等到两者指向值相同时，\(P1\)的位置正好就是环的开始位置。<br><img src="/images/leetcode01_2.png" alt="img02"></p>
<p>Brent’s algorithm的效率比Floyd’s Tortoise and Hare要高，最差情况是Floyd’s Tortoise and Hare算法。其主要原因是，步长动态增加，速度提高，以及首次找到相同值时，记录了环的长度，而Floyd’s Tortoise and Hare算法首次找到相同值时，并不知道环的长度，只能知道环长度的整数倍。</p>
<h4 id="2-3-Gosper’s-algorithm"><a href="#2-3-Gosper’s-algorithm" class="headerlink" title="2.3 Gosper’s algorithm"></a>2.3 Gosper’s algorithm</h4><p>Gosper算法可以参考<a href="http://www.inwap.com/pdp10/hbaker/hakmem/flows.html" target="_blank" rel="noopener">此处</a>，Kino还没有细看，就不细说了。</p>
<h3 id="3-相关练习"><a href="#3-相关练习" class="headerlink" title="3. 相关练习"></a>3. 相关练习</h3><p>Leetcode上有以下数题与此相关。</p>
<h4 id="3-1-Leetcode-141-Linked-List-Cycle"><a href="#3-1-Leetcode-141-Linked-List-Cycle" class="headerlink" title="3.1 Leetcode 141. Linked List Cycle"></a>3.1 Leetcode 141. Linked List Cycle</h4><p><a href="https://leetcode.com/problems/linked-list-cycle" target="_blank" rel="noopener">Link</a></p>
<blockquote>
<p>Description: Given a linked list, determine if it has a cycle in it.</p>
</blockquote>
<p>Floyd’s Tortoise and Hare<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !(head-&gt;next)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* tortoise = head-&gt;next;</span><br><span class="line">    ListNode* hare = head-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(hare &amp;&amp; hare-&gt;next) &#123;</span><br><span class="line">      <span class="keyword">if</span>(tortoise == hare) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      tortoise = tortoise-&gt;next;</span><br><span class="line">      hare = hare-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Brent’s algorithm<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !(head-&gt;next)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> current_step = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> limited_step = <span class="number">1</span>;</span><br><span class="line">    ListNode* tortoise = head-&gt;next;</span><br><span class="line">    ListNode* hare = head-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(hare &amp;&amp; hare-&gt;next) &#123;</span><br><span class="line">      <span class="keyword">if</span>(tortoise == hare) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(current_step == limited_step) &#123;</span><br><span class="line">        current_step = <span class="number">0</span>;</span><br><span class="line">        limited_step *= <span class="number">2</span>;</span><br><span class="line">        tortoise = hare;</span><br><span class="line">      &#125;</span><br><span class="line">      hare = hare-&gt;next;</span><br><span class="line">      current_step++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-2-Leetcode-142-Linked-List-Cycle-II"><a href="#3-2-Leetcode-142-Linked-List-Cycle-II" class="headerlink" title="3.2 Leetcode 142. Linked List Cycle II"></a>3.2 Leetcode 142. Linked List Cycle II</h4><p><a href="https://leetcode.com/problems/linked-list-cycle-ii" target="_blank" rel="noopener">Link</a></p>
<blockquote>
<p>Description: Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
</blockquote>
<p>Floyd’s Tortoise and Hare<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !(head-&gt;next)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* tortoise = head-&gt;next;</span><br><span class="line">    ListNode* hare = head-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(tortoise != hare) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!hare || !(hare-&gt;next)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      tortoise = tortoise-&gt;next;</span><br><span class="line">      hare = hare-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tortoise = head;</span><br><span class="line">    <span class="keyword">while</span>(tortoise != hare) &#123;</span><br><span class="line">      tortoise = tortoise-&gt;next;</span><br><span class="line">      hare = hare-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tortoise;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Brent’s algorithm<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !(head-&gt;next)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> current_step = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> limited_step = <span class="number">1</span>;</span><br><span class="line">    ListNode* tortoise = head-&gt;next;</span><br><span class="line">    ListNode* hare = head-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(tortoise != hare) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!hare || !(hare-&gt;next)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(current_step == limited_step) &#123;</span><br><span class="line">        current_step = <span class="number">0</span>;</span><br><span class="line">        limited_step *= <span class="number">2</span>;</span><br><span class="line">        tortoise = hare;</span><br><span class="line">      &#125;</span><br><span class="line">      hare = hare-&gt;next;</span><br><span class="line">      current_step++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tortoise = head;</span><br><span class="line">    hare = head;</span><br><span class="line">    <span class="keyword">while</span>(current_step--) &#123;</span><br><span class="line">      tortoise = tortoise-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(tortoise != hare) &#123;</span><br><span class="line">      tortoise = tortoise-&gt;next;</span><br><span class="line">      hare = hare-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tortoise;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-Leetcode-202-Happy-Number"><a href="#3-3-Leetcode-202-Happy-Number" class="headerlink" title="3.3 Leetcode 202. Happy Number"></a>3.3 Leetcode 202. Happy Number</h4><p><a href="https://leetcode.com/problems/happy-number/" target="_blank" rel="noopener">Link</a></p>
<blockquote>
<p>Description: Write an algorithm to determine if a number is “happy”.<br>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
</blockquote>
<p>Floyd’s Tortoise and Hare<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tortoise = nextNum(n);</span><br><span class="line">    <span class="keyword">int</span> hare = nextNum(nextNum(n));</span><br><span class="line">    <span class="keyword">while</span>(tortoise != hare) &#123;</span><br><span class="line">      tortoise = nextNum(tortoise);</span><br><span class="line">      hare = nextNum(nextNum(hare));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tortoise == <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">nextNum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nxt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">      <span class="keyword">int</span> digit = n%<span class="number">10</span>;</span><br><span class="line">      nxt += digit*digit;</span><br><span class="line">      n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nxt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Brent’s algorithm<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> current_step = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> limited_step = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tortoise = nextNum(n);</span><br><span class="line">    <span class="keyword">int</span> hare = nextNum(nextNum(n));</span><br><span class="line">    <span class="keyword">while</span>(tortoise != hare) &#123;</span><br><span class="line">      <span class="keyword">if</span>(current_step == limited_step) &#123;</span><br><span class="line">        current_step = <span class="number">0</span>;</span><br><span class="line">        limited_step *= <span class="number">2</span>;</span><br><span class="line">        tortoise = hare;</span><br><span class="line">      &#125;</span><br><span class="line">      hare = nextNum(hare);</span><br><span class="line">      current_step++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tortoise == <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">nextNum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nxt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">      <span class="keyword">int</span> digit = n%<span class="number">10</span>;</span><br><span class="line">      nxt += digit*digit;</span><br><span class="line">      n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nxt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-4-Leetcode-287-Find-the-Duplicate-Number"><a href="#3-4-Leetcode-287-Find-the-Duplicate-Number" class="headerlink" title="3.4 Leetcode 287. Find the Duplicate Number"></a>3.4 Leetcode 287. Find the Duplicate Number</h4><p><a href="https://leetcode.com/problems/find-the-duplicate-number" target="_blank" rel="noopener">Link</a></p>
<blockquote>
<p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
</blockquote>
<p>Floyd’s Tortoise and Hare<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.empty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;nums = nums;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> tortoise = f(nums[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> hare = f(f(nums[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">while</span>(tortoise != hare) &#123;</span><br><span class="line">      tortoise = f(tortoise);</span><br><span class="line">      hare = f(f(hare));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tortoise = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(tortoise != hare) &#123;</span><br><span class="line">      tortoise = f(tortoise);</span><br><span class="line">      hare = f(hare);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tortoise;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nums[n];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Brent’s algorithm<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.empty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;nums = nums;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> current_step = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> limited_step = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tortoise = f(nums[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> hare = f(f(nums[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">while</span>(tortoise != hare) &#123;</span><br><span class="line">      <span class="keyword">if</span>(current_step == limited_step) &#123;</span><br><span class="line">        current_step = <span class="number">0</span>;</span><br><span class="line">        limited_step *= <span class="number">2</span>;</span><br><span class="line">        tortoise = hare;</span><br><span class="line">      &#125;</span><br><span class="line">      hare = f(hare);</span><br><span class="line">      current_step++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tortoise = nums[<span class="number">0</span>];</span><br><span class="line">    hare = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(current_step--) &#123;</span><br><span class="line">      tortoise = f(tortoise);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(tortoise != hare) &#123;</span><br><span class="line">      tortoise = f(tortoise);</span><br><span class="line">      hare = f(hare);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tortoise;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nums[n];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-实际应用"><a href="#4-实际应用" class="headerlink" title="4. 实际应用"></a>4. 实际应用</h3><p>环检测(cycle detection)问题的实际应用有 <em>伪随机数生成器(pseudorandom number generators)强度的度量</em>，比如 <em>线性同余生成器(linear congruential generator)</em>，<em>加密哈希函数的冲突检测</em>，<em>细胞自动机(cellular automaton)的振荡周期配置</em>等</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>Cycle Detection</tag>
        <tag>Floyd Cycle Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>日语学习十</title>
    <url>/2020/05/03/japanese11/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇总结了日语句子的分析和改造，这一章主要介绍一些实用表达。<br>实用表达，实际上也就是一些常用助词和动词的学习，包括他们常用的变形形式. 其实也可以说就是惯用语啦. 这一篇很多都是来源于Tae Kim的教程，Tae Kim的教程中语法系统和惯用表达揉在了一起，这里将其讲解惯用表达摘了出来.</p>
<a id="more"></a>
<h2 id="1-授受表达"><a href="#1-授受表达" class="headerlink" title="1. 授受表达"></a>1. 授受表达</h2><p>参考了这两篇文章: 文章一<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="“日语语法：授受动词.” 日语语法：授受动词 - 日语入门 - 丫丫日语, 4 Jan. 2015, http://www.yayajp.com/index.php?a=shows&catid=4&id=136.
">[1]</span></a></sup>、文章二<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="KIM, TAE. “授受动词.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/favors.html.
">[2]</span></a></sup><br>所谓授受表达，即授予和接受，由于在日语文化中，长幼尊卑是非常重要的元素，因此授予的主体不同时，表达也各不相同。</p>
<h3 id="1-1-やる、あげる、さしあげる"><a href="#1-1-やる、あげる、さしあげる" class="headerlink" title="1.1 やる、あげる、さしあげる"></a>1.1 やる、あげる、さしあげる</h3><p>表示说话者一方给另一方东西时，常用到这三个词.<br>其中:</p>
<ul>
<li>「やる」用于上对下或关系密切的同辈之间或者为动植物做某事</li>
<li>「あげる」用于对等关系</li>
<li>「さしあげる」是敬语动词，用于下对上，是一种自谦表达。</li>
</ul>
<p>例句:</p>
<ul>
<li>犬に餌をやった？</li>
<li>花に水をやる</li>
<li>あなたは時には妹さんにおこづかいをあげますか</li>
<li>彼の誕生日に贈り物をあげたいんnです</li>
<li>恩師に記念品をさしあげます</li>
</ul>
<h3 id="1-2-もらう、いただく"><a href="#1-2-もらう、いただく" class="headerlink" title="1.2 もらう、いただく"></a>1.2 もらう、いただく</h3><h4 id="1-2-1-独立使用"><a href="#1-2-1-独立使用" class="headerlink" title="1.2.1 独立使用"></a>1.2.1 独立使用</h4><p>作为一个独立的动词使用时，表示从别人那里接受或得到某东西。「いただく」表示从上司或者长辈处领受某物品时。</p>
<ul>
<li>手紙をもらう</li>
<li>この時計は田中さんからもらったのです</li>
<li>結構な品物をいただきます</li>
</ul>
<h4 id="1-2-2-助词使用"><a href="#1-2-2-助词使用" class="headerlink" title="1.2.2 助词使用"></a>1.2.2 助词使用</h4><p>接在动词连用形之后，以「～てもらう」、「～ていただく」的形式作为补助动词来使用。「～ていただく」是「～てもらう」的谦逊表达。</p>
<ul>
<li>私は日本の友達に日本料理を教えてもらった</li>
</ul>
<h3 id="1-3-くれる、くださる"><a href="#1-3-くれる、くださる" class="headerlink" title="1.3 くれる、くださる"></a>1.3 くれる、くださる</h3><h4 id="1-3-1-独立使用"><a href="#1-3-1-独立使用" class="headerlink" title="1.3.1 独立使用"></a>1.3.1 独立使用</h4><p>作为一个独立的动词使用时，表示别人给自己或给属于自己一方的人予东西。「くださる」是「くれる」的敬语形式。</p>
<ul>
<li>これは友達が妹にくれた本です。</li>
<li>先生は私に日本の地図をくださいました。</li>
</ul>
<h4 id="1-3-2-助词使用"><a href="#1-3-2-助词使用" class="headerlink" title="1.3.2 助词使用"></a>1.3.2 助词使用</h4><p>接在动词连用形之后，以「～てくれる」、「～てくださる」的形式作为补助动词来使用。</p>
<ul>
<li>課長がこの地図を貸してくださいました。</li>
</ul>
<h3 id="1-4-表达请求"><a href="#1-4-表达请求" class="headerlink" title="1.4 表达请求"></a>1.4 表达请求</h3><h4 id="1-4-1-请求对方帮忙做什么"><a href="#1-4-1-请求对方帮忙做什么" class="headerlink" title="1.4.1 请求对方帮忙做什么"></a>1.4.1 请求对方帮忙做什么</h4><p>用くれる、もらえる表示想请人帮忙，其中「もらえる」是「もらう」的可能型</p>
<ul>
<li>千円を貸してくれる？</li>
<li>千円を貸してもらえる？</li>
</ul>
<h4 id="1-4-2-请对方不要作什么"><a href="#1-4-2-请对方不要作什么" class="headerlink" title="1.4.2 请对方不要作什么"></a>1.4.2 请对方不要作什么</h4><p>只要把「で」加到用言否定式后面就可以了。</p>
<ul>
<li>全部食べないでくれますか</li>
<li>高い物を買わないでくれる</li>
</ul>
<h3 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h3><p>Tae Kim<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="KIM, TAE. “授受动词.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/favors.html.
">[2]</span></a></sup>总结得很好: “从说话者的角度来看，所有给出的东西都是「向上」的，而别人给自己的东西则是「向下」的”，你也可以理解为对方总是高高在上的，说话者一方总是需要尽量表达谦卑，以表示尊敬对方，除非对方足够亲密或者非人等.<br>特别需要说明的是”说话人”，说话者在说出一句话时，总是代表了某一方，无论是他自己还是他人，他意指何方，那么那一方就是谦卑的一方.<br>最后再给个用了多种表达的一个例句:</p>
<ul>
<li>突然にかような奇怪な手紙を差し上げる非礼をお許し下さい。</li>
</ul>
<h2 id="2-比较表达"><a href="#2-比较表达" class="headerlink" title="2. 比较表达"></a>2. 比较表达</h2><p>又是Tae Kim<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Kim, Tae. “运用「方」和「よる」.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/comparison.html.
">[3]</span></a></sup>，这个系列的教程写的确实太好，就拿来主义了，当然还有Wasabi的这个系列<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Admin, Wasabi. “Japanese Comparison: より, ...の方が, and ...で一番.” Wasabi, 24 Sept. 2016, https://www.wasabi-jpn.com/japanese-grammar/japanese-comparison/.
">[4]</span></a></sup>，也非常棒.<br>表达比较首先需要有比较的对象: A和B. 当我们想对这两个对象进行比较时，从汉语的角度，我们会说:</p>
<ul>
<li>“A比B更…「述語」”</li>
<li>“和B相比, A更…「述語」”</li>
<li>“A这样/A这一方/A这种情况 比 B更…「述語」”</li>
<li>“和B相比, A这样/A这一方/A这种情况 更…「述語」”</li>
</ul>
<p>我们会发现这些句子中，无论怎么表达，A才是主语，B是作为被比较的一方存在的.<br>考虑到日语和汉语一样基本什么语法成分也都能省略，其实A、B两方也都有可能在表达中被省略. 基于此，我们来看下面的语法。</p>
<h3 id="2-1-「方」"><a href="#2-1-「方」" class="headerlink" title="2.1 「方」"></a>2.1 「方」</h3><p>「方」就是用来表达 “A这样/A这一方/A这种情况” 的 “这样/这一方/这种情况”，通常在句子中都是用「Aの方」，假设上下文明确的情况下，我们省略了B，给出一些例句.</p>
<ul>
<li>ボブの方が年上です</li>
<li>学生じゃない方がいいよ</li>
</ul>
<h3 id="2-2-「より」"><a href="#2-2-「より」" class="headerlink" title="2.2 「より」"></a>2.2 「より」</h3><p>相对的，「より」就是用来表达 “与B相比” 中的 “与…相比” 的意思. 同样的，假设可以省略A，给出一些例句.</p>
<ul>
<li>仕事がないよりましだよ</li>
</ul>
<p>如果把双方都用上，当然也可.</p>
<ul>
<li>辛からい方ほうが甘あまいのより好すき</li>
</ul>
<p>注:</p>
<blockquote>
<p>1) <strong>被「より」粘黏的单词不需要任何时态。</strong><br>2) 可以将「より」与疑问词例如「誰」、「何」或「どこ」合用来表示与其他人或其他东西相比最高的意思</p>
<ul>
<li>この仕事は誰よりも早くできます</li>
</ul>
</blockquote>
<h3 id="2-3-「と同じくらい」"><a href="#2-3-「と同じくらい」" class="headerlink" title="2.3 「と同じくらい」"></a>2.3 「と同じくらい」</h3><p>这个短语可以用来表达 “A就像和B一样” 这种意思</p>
<ul>
<li>小野さんは森さんと同じくらい林檎が好すきです</li>
</ul>
<h3 id="2-4-「一番」-「最も」"><a href="#2-4-「一番」-「最も」" class="headerlink" title="2.4 「一番」/「最も」"></a>2.4 「一番」/「最も」</h3><p>这个词用来表达最高级的意思，后者比前者更正式.</p>
<ul>
<li>中国は世界で一番人口が多いです</li>
<li>中国は世界で最も人口が多いです</li>
</ul>
<h3 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h3><p>比较的表达并不难，明确比较双方，使用关键的两个词: 「方」和「よる」，就很容易表达</p>
<h2 id="3-引用表达"><a href="#3-引用表达" class="headerlink" title="3. 引用表达"></a>3. 引用表达</h2><p>这其实是复合句的一种形式，但是引用他人的话这种复合句比较特殊，在之前的复合句中也没有提及，在此补充。<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Kim, Tae. “将关系从句作为宾语.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/actionclause.html.
">[5]</span></a></sup></p>
<h3 id="3-1-直接引用"><a href="#3-1-直接引用" class="headerlink" title="3.1 直接引用"></a>3.1 直接引用</h3><p>直接引用别人的话，最特殊的点在于，虽然是复合的句子，但是被引用的话，其语法表达、时体态，全都保持原封不动就行了，在英语中，直接给引用的句子加个引号就行，中文多了个冒号，共同点就是都是靠标点符号来区分的，而在日语中，额外多了个助词「と」来表达这种情况.</p>
<ul>
<li>「今日は授業がない」と先生から聞いたんだけど</li>
</ul>
<h3 id="3-2-转述引用"><a href="#3-2-转述引用" class="headerlink" title="3.2 转述引用"></a>3.2 转述引用</h3><p>转述不是逐字逐句的引用，所以不用加引号。和动词「思う」一起用还能用来表达想法，意为”你认为…”，或者和动词「考える」一起用表达你在考虑某事。</p>
<ul>
<li>先生から今日は授業がないと聞いたんだけど</li>
<li>私は、アリスと言います</li>
<li>レーを食べようと思ったけど、食べる時間がなかった。</li>
</ul>
<p>注:</p>
<blockquote>
<p><strong>转述引用中，如果所引用的关系从句是名词或者な形容词形成的状态表示的话，必须显式加上表陈述的「だ」</strong></p>
<ul>
<li>これは何だと言いましたか。  //（他）说这是什么?</li>
<li>何と言いましたか。          //（他）说什么？</li>
</ul>
</blockquote>
<h3 id="3-3-口语版本"><a href="#3-3-口语版本" class="headerlink" title="3.3 口语版本"></a>3.3 口语版本</h3><p>「と」在口语中经常换成「って」来表达，用这种口语版本，可以省略句子的其他部分，靠上下文让对方理解.</p>
<ul>
<li>もうお金がないって。</li>
</ul>
<p>注: <strong>日常对话中，「って」 还可以用来谈论其他任何事情，大多数时候它是用来代替「は」以提出一个新的话题。</strong></p>
<ul>
<li>明日って、雨が降るんだって。</li>
</ul>
<h2 id="4-相似性表达"><a href="#4-相似性表达" class="headerlink" title="4. 相似性表达"></a>4. 相似性表达</h2><p>这个Tae Kim已经写得很好了，参考这篇文章<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Kim, Tae. “相似性或传闻.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/similarity.html.
">[6]</span></a></sup>即可.<br>介绍了「よう（様）」、「みたい」、「～そう」、「～そうだ」、「～らしい」、「っぽい」六种表达方式，经常看动画其实读起来就有很熟悉的感觉，重点关注其中的活用变化，不赘述.</p>
<h2 id="5-被覆盖表达"><a href="#5-被覆盖表达" class="headerlink" title="5. 被覆盖表达"></a>5. 被覆盖表达</h2><p>参考Tae Kim的这一节<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Kim, Tae. “被某物所覆盖.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/covered.html.
">[7]</span></a></sup>，主要介绍了「だらけ」、「まみれ」、「ずくめ」</p>
<h2 id="6-意向表达"><a href="#6-意向表达" class="headerlink" title="6. 意向表达"></a>6. 意向表达</h2><p>参考Tae Kim的这一节<sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Kim, Tae. “希望和建议.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/desire.html.
">[8]</span></a></sup>和这一节<sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Kim, Tae. “高级意向形.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, http://res.wokanxing.info/jpgramma/volitional2.html.">[9]</span></a></sup>，主要介绍了「たい」、「欲しい」、意向形，以及一些高级用法</p>
<h2 id="7-常用句型"><a href="#7-常用句型" class="headerlink" title="7. 常用句型"></a>7. 常用句型</h2><p>还有一些其他常用句型，在此列举一些.</p>
<blockquote>
<ul>
<li>～以外の何ものでもない</li>
<li>～か[否(いな)]か</li>
<li>～限りだ</li>
<li>～かたがた</li>
<li>～ずじまいだ</li>
</ul>
</blockquote>
<h2 id="8-常用短语"><a href="#8-常用短语" class="headerlink" title="8. 常用短语"></a>8. 常用短语</h2><p>有一些常用短语，如果去分析它们的词源或者语法结构的话，会觉得很别扭，像背单词一样把它们背下来，能够做到熟练到张口就来就好了~</p>
<blockquote>
<ul>
<li>こちらこそ</li>
<li>よろしくお願いします</li>
<li>いらっしゃいませ</li>
<li>いただきます</li>
</ul>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章主要介绍了日语中的一些实用表达，下一篇简单说几句语篇的内容，整个系列也就结束了。</p>
<h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)">“日语语法：授受动词.” 日语语法：授受动词 - 日语入门 - 丫丫日语, 4 Jan. 2015, <a href="http://www.yayajp.com/index.php?a=shows&amp;catid=4&amp;id=136" target="_blank" rel="noopener">http://www.yayajp.com/index.php?a=shows&amp;catid=4&amp;id=136</a>.<a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)">KIM, TAE. “授受动词.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, <a href="http://res.wokanxing.info/jpgramma/favors.html" target="_blank" rel="noopener">http://res.wokanxing.info/jpgramma/favors.html</a>.<a href="#fnref:2" rev="footnote"> ↩</a></span></div><div id="fn:3" style="display:flex"><span style="width:20px">3.</span><span style="width:calc(100% - 20px)">Kim, Tae. “运用「方」和「よる」.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, <a href="http://res.wokanxing.info/jpgramma/comparison.html" target="_blank" rel="noopener">http://res.wokanxing.info/jpgramma/comparison.html</a>.<a href="#fnref:3" rev="footnote"> ↩</a></span></div><div id="fn:4" style="display:flex"><span style="width:20px">4.</span><span style="width:calc(100% - 20px)">Admin, Wasabi. “Japanese Comparison: より, …の方が, and …で一番.” Wasabi, 24 Sept. 2016, <a href="https://www.wasabi-jpn.com/japanese-grammar/japanese-comparison/" target="_blank" rel="noopener">https://www.wasabi-jpn.com/japanese-grammar/japanese-comparison/</a>.<a href="#fnref:4" rev="footnote"> ↩</a></span></div><div id="fn:5" style="display:flex"><span style="width:20px">5.</span><span style="width:calc(100% - 20px)">Kim, Tae. “将关系从句作为宾语.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, <a href="http://res.wokanxing.info/jpgramma/actionclause.html" target="_blank" rel="noopener">http://res.wokanxing.info/jpgramma/actionclause.html</a>.<a href="#fnref:5" rev="footnote"> ↩</a></span></div><div id="fn:6" style="display:flex"><span style="width:20px">6.</span><span style="width:calc(100% - 20px)">Kim, Tae. “相似性或传闻.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, <a href="http://res.wokanxing.info/jpgramma/similarity.html" target="_blank" rel="noopener">http://res.wokanxing.info/jpgramma/similarity.html</a>.<a href="#fnref:6" rev="footnote"> ↩</a></span></div><div id="fn:7" style="display:flex"><span style="width:20px">7.</span><span style="width:calc(100% - 20px)">Kim, Tae. “被某物所覆盖.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, <a href="http://res.wokanxing.info/jpgramma/covered.html" target="_blank" rel="noopener">http://res.wokanxing.info/jpgramma/covered.html</a>.<a href="#fnref:7" rev="footnote"> ↩</a></span></div><div id="fn:8" style="display:flex"><span style="width:20px">8.</span><span style="width:calc(100% - 20px)">Kim, Tae. “希望和建议.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, <a href="http://res.wokanxing.info/jpgramma/desire.html" target="_blank" rel="noopener">http://res.wokanxing.info/jpgramma/desire.html</a>.<a href="#fnref:8" rev="footnote"> ↩</a></span></div><div id="fn:9" style="display:flex"><span style="width:20px">9.</span><span style="width:calc(100% - 20px)">Kim, Tae. “高级意向形.” 日语语法指南 | Learn Japanese, 16 Oct. 2017, <a href="http://res.wokanxing.info/jpgramma/volitional2.html" target="_blank" rel="noopener">http://res.wokanxing.info/jpgramma/volitional2.html</a>.<a href="#fnref:9" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>humanities</category>
        <category>languages</category>
      </categories>
      <tags>
        <tag>japanese</tag>
      </tags>
  </entry>
  <entry>
    <title>用音乐逃离尘世</title>
    <url>/2017/11/19/listening03/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="/2016/04/10/listening01">以前的文章</a>写到了最爱的十张专辑, 但十张是远不能记录自己的喜好滴. 就把自己硬盘里躺着的歌手、专辑列出来, 顺便按照喜爱程度评个分…</p>
<a id="more"></a>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><ul>
<li>Adele  ★★★★★★★★★★<br>高三毕业之后听了Adele…<br>有一次和好友A聊天,A突然说到:”我们当初是怎么熟悉的啊?” 我回答说我也忘了… 其实是假装的,因为莫名感觉有点不好意思哈哈哈<br>毕业那个假期大抵有点寂寞,高中才接触网络,却汲汲于学业和种种琐事,于是毕业就成了一个网瘾少年,每天就玩游戏、聊天,在学校的时候对A很好奇却无机会接触,毕业不知哪来的勇气找人聊天了。最开始聊天的内容基本全忘了,只记得A推荐了Adele的Someone like you,果然音乐才是永恒… 此后Adele一直躺在我的歌单里,也就让我记得了这件小事…<br>然而对Adele的评价却无关这些小事,一切只是因为Adele的声音太好了,前两张专辑太对我胃口了.<ul>
<li>19   ★★★★★★★★★★</li>
<li>21   ★★★★★★★★★★</li>
</ul>
</li>
<li>Amy Winehouse  ★★★★★★★★☆☆<br>死亡升华了毒后. 她的生平曾经加重了我对这个世界的绝望、不过对于爵士乐,我好像一直兴趣平平,曾经Norah Jones火遍全球时,也是无法欣赏,小野丽莎是为数不多我能听下去的爵士歌手<ul>
<li>Back to Black  ★★★★★★★★☆☆</li>
</ul>
</li>
<li>Angelic Foe<ul>
<li>Oppressed By The Heavens</li>
</ul>
</li>
<li>Ankhagram<ul>
<li>Where Are You Now</li>
</ul>
</li>
<li>Anne-Sophie Mutter<ul>
<li>Carmen Fantasy</li>
</ul>
</li>
<li>Anúna<ul>
<li>Omnis (1997)</li>
</ul>
</li>
<li>Bach<br>非专业古典爱好者,若要说一首巴赫的名曲出来,我能记得起来名字的就只有<em>地狱中的奥菲欧</em>了<ul>
<li>100 Best Bach (6CD)</li>
<li>Glenn Gould - The Complete Bach Collection (38CD)</li>
</ul>
</li>
<li>Bang Gang<ul>
<li>Ghosts from the Past</li>
</ul>
</li>
<li>Beethoven<ul>
<li>[DG 453 700-2]Complete Beethoven Edition (20VOL)</li>
</ul>
</li>
<li>Bette Midler<ul>
<li>Experience The Divine Greatest Hits</li>
</ul>
</li>
<li>Birdy<br>96年的小姐姐、啊不对,是小妹妹…<ul>
<li>Birdy</li>
</ul>
</li>
<li>Björk<ul>
<li>Vespertine</li>
</ul>
</li>
<li>Black Box Recorder<ul>
<li>England Made Me</li>
<li>Passionoia</li>
<li>The Worst Of Black Box Recorder</li>
</ul>
</li>
<li>Black Sabbath<ul>
<li>Paranoid</li>
</ul>
</li>
<li>Bright eyes<ul>
<li>I’M Wide Awake It’S Morning</li>
</ul>
</li>
<li>Buckethead<br>发专辑成瘾的桶头、然而我完整听过的只有一张专辑<ul>
<li>1998 - Colma</li>
</ul>
</li>
<li>Cat Power<ul>
<li>Dark End of The Street</li>
<li>Moon Pix</li>
<li>Myra Lee</li>
<li>Sun</li>
<li>The Greatest</li>
<li>The Greatest(JP Edition)</li>
<li>What Would The Community Think</li>
</ul>
</li>
<li>Chopin<ul>
<li>Chopin. Complete Edition (DG 2009)</li>
</ul>
</li>
<li>Chris De Burgh<ul>
<li>Footsteps (2008)</li>
</ul>
</li>
<li>Cigarettes after Sex<ul>
<li>Cigarettes After Sex</li>
</ul>
</li>
<li>Cinderella<ul>
<li>Heartbreak Station</li>
</ul>
</li>
<li>Club 8<ul>
<li>Best Wishes - Best Of Club 8</li>
<li>Pleasure</li>
</ul>
</li>
<li>Cocteau Twins<ul>
<li>Treasure</li>
</ul>
</li>
<li>Corde Oblique<ul>
<li>A Hail Of Bitter Almonds</li>
<li>Respiri</li>
<li>Volonta D’Arte</li>
</ul>
</li>
<li>Dark Lunacy<ul>
<li>Devoid</li>
<li>Forget Me Not</li>
</ul>
</li>
<li>Dark the Suns<ul>
<li>The Dead End</li>
</ul>
</li>
<li>Devil Doll<br>记不清从哪得知这个歌手了,也许是落网推荐的?只记得是和Estatic Fear放一起说的<ul>
<li>1989 - The Girl Who Was… Death<br>最早的时候无法欣赏,某天耐着性子听完了,自那以后就不定时拿出来重听一遍.</li>
<li>1990 - Eliogabalus</li>
<li>1992 - Sacrilegium</li>
<li>1993 - The Sacrilege Of Fatal Arms</li>
<li>1996 - Dies Irae</li>
</ul>
</li>
<li>Diana Boncheva<ul>
<li>Beethoven Virus</li>
</ul>
</li>
<li>Dido<ul>
<li>Greatest Hits (Deluxe Edition)</li>
</ul>
</li>
<li>Dishwalla<ul>
<li>Opaline</li>
</ul>
</li>
<li>Dreamtale<ul>
<li>Beyond Reality (2002)<br>序曲是魔兽玩家的记忆、</li>
</ul>
</li>
<li>Duffy<ul>
<li>Rockferry(Deluxe Edition)</li>
</ul>
</li>
<li>Dvar<ul>
<li>Deii</li>
<li>El Mariil</li>
</ul>
</li>
<li>Dvořák<ul>
<li>Dvořák _ The Masterworks, CD40</li>
</ul>
</li>
<li>Eric Clapton<ul>
<li>Basel, Switzerland (Baloise Session)</li>
<li>Layla And Other Assorted Love Songs</li>
</ul>
</li>
<li>Estatic Fear<ul>
<li>A Sombre Dance</li>
</ul>
</li>
<li>Gin Wigmore<ul>
<li>Gravel &amp; Wine</li>
</ul>
</li>
<li>Guns N’ Roses<ul>
<li>Appetite for Destruction 1987</li>
<li>Chinese democracy 2008</li>
<li>Greatest Hits 2004</li>
<li>Lies 1989 (Remastered MFSL)</li>
<li>Live Era 1999</li>
<li>The Spaghetti Incident 1993</li>
<li>Use Your Illusion I 1991</li>
<li>Use Your Illusion II 1991</li>
</ul>
</li>
<li>Gwen Stefani<ul>
<li>Love.Angel.Music.Baby</li>
</ul>
</li>
<li>Gérard Darmon<ul>
<li>On S’aime</li>
</ul>
</li>
<li>H.I.M<ul>
<li>Razorblade Romance</li>
</ul>
</li>
<li>Haggard<ul>
<li>Eppur Si Muove [Limited Edition]</li>
<li>Tales of Ithiria</li>
</ul>
</li>
<li>ICY<ul>
<li>Wanderlust流浪癖</li>
<li>住在春天</li>
<li>南澜掌</li>
<li>哼一首歌等日落</li>
<li>比天空还远</li>
<li>浅彩虹</li>
<li>遇见我</li>
<li>黑色香水</li>
</ul>
</li>
<li>Iggy Pop<ul>
<li>Préliminaires</li>
</ul>
</li>
<li>Imperium Dekadenz<ul>
<li>Dämmerung der Szenarien</li>
</ul>
</li>
<li>James Blake<ul>
<li>Overgrown</li>
</ul>
</li>
<li>Jennifer Warnes<ul>
<li>Famous Blue Raincoat</li>
</ul>
</li>
<li>Joan Jett<ul>
<li>The Hit List</li>
</ul>
</li>
<li>Joe Satriani<ul>
<li>Is There Love in Space</li>
<li>Super Colossal</li>
<li>The Complete Studio Albums Collection(Additional Creations and Bonus Tracks)</li>
<li>The Essential</li>
</ul>
</li>
<li>John Lennon<ul>
<li>Imagine</li>
</ul>
</li>
<li>Josh Vietti<ul>
<li>Best Of Both Worlds</li>
</ul>
</li>
<li>Joy Division<ul>
<li>Closer</li>
<li>Substance(1977-1980)</li>
<li>Unknown Pleasures</li>
</ul>
</li>
<li>Kalmah<ul>
<li>2010 - 12 Gauge</li>
</ul>
</li>
<li>Kate Bush<ul>
<li>Hounds of Love</li>
<li>Never for Ever</li>
<li>The Kick Inside</li>
<li>The Whole Story</li>
</ul>
</li>
<li>Lana Del Rey<ul>
<li>Born to die</li>
</ul>
</li>
<li>Leonard Cohen<ul>
<li>Ten New Songs</li>
<li>The Essential Leonard Cohen</li>
</ul>
</li>
<li>Lisa Ekdhal<ul>
<li>Give me that slow knowing smile</li>
</ul>
</li>
<li>Lou Reed<ul>
<li>Transformer</li>
</ul>
</li>
<li>Lush<ul>
<li>Hypocrite</li>
<li>Lovelife</li>
</ul>
</li>
<li>Lynyrd Skynyrd<ul>
<li>(Pronounced.Leh-Nerd.Skin-Nerd)</li>
<li>Second Helping</li>
</ul>
</li>
<li>Mac DeMarco<ul>
<li>Some Other Ones</li>
</ul>
</li>
<li>Mazzy Star<ul>
<li>Among my swan</li>
<li>Seasons of Your Day</li>
<li>She Hangs Brightly</li>
<li>So Tonight That I Might See</li>
</ul>
</li>
<li>Michael Jackson<ul>
<li>The Ultimate Collection (Japanese)</li>
</ul>
</li>
<li>Mono Inc<ul>
<li>After The War</li>
<li>Viva Hades</li>
<li>Voices Of Doom</li>
</ul>
</li>
<li>Monta<ul>
<li>Always Altamont</li>
<li>Good Morning Stranger</li>
<li>The Brilliant Masses</li>
<li>Where Circles Begin</li>
</ul>
</li>
<li>Mozart<ul>
<li>Mozart_225 (200CD)</li>
</ul>
</li>
<li>Mr. Big<ul>
<li>Bump Ahead</li>
<li>Lean Into It</li>
</ul>
</li>
<li>Muse<ul>
<li>Showbiz(1999)</li>
</ul>
</li>
<li>Mylène Farmer<ul>
<li>Innamoramento</li>
</ul>
</li>
<li>Nick Colionne<ul>
<li>Best Of Both Worlds</li>
</ul>
</li>
<li>Oasis<ul>
<li>Don’t Look Back in Anger</li>
<li>Let There Be Love</li>
<li>Wonderwall</li>
</ul>
</li>
<li>Ozzy Osbourne<ul>
<li>Blizzard Of Ozz</li>
<li>Blizzard Of Ozz (Expanded Edition)</li>
</ul>
</li>
<li>Paloma Faith<ul>
<li>Do You Want the Truth or Something Beautiful</li>
</ul>
</li>
<li>Paramore<ul>
<li>Riot (Deluxe Version)</li>
</ul>
</li>
<li>Pat Metheny Group<ul>
<li>1987 - Still Life (Talking)</li>
<li>1989 - Letter From Home</li>
<li>Upojenie</li>
</ul>
</li>
<li>Pink Floyd<ul>
<li>Animals</li>
<li>The Dark Side Of The Moon</li>
<li>The Dark Side Of The Moon (Immersion Box Set)</li>
<li>The Wall</li>
<li>Wish You Were Here</li>
</ul>
</li>
<li>Portishhead<ul>
<li>Dummy (1994)</li>
</ul>
</li>
<li>Priscilla Ahn<ul>
<li>A Good Day</li>
<li>Where You Grow Up</li>
</ul>
</li>
<li>Rachmaninoff<ul>
<li>Rachmaninov - The Complete Works (2014) <a href="32CD">FLAC</a></li>
</ul>
</li>
<li>Radiohead<ul>
<li>A Moon Shaped Pool</li>
</ul>
</li>
<li>Shostakovich<ul>
<li>Shostakovich Edition _ Symphonies - Concertos - Suites - String Quartets - Chamber Music (27CD)</li>
</ul>
</li>
<li>SOAK<ul>
<li>Before We Forgot How To Dream</li>
</ul>
</li>
<li>Standfast<ul>
<li>Standfast</li>
</ul>
</li>
<li>Steelheart<ul>
<li>Tangled in Reins</li>
</ul>
</li>
<li>Suede<ul>
<li>Coming Up</li>
</ul>
</li>
<li>SymphonyOrchestra<ul>
<li>Marco Beasley, Accordone - Morini - Solve et Coagula (2014)</li>
</ul>
</li>
<li>Tchaikovsky<ul>
<li>(60CD)</li>
</ul>
</li>
<li>The Cranberries<ul>
<li>Bury The Hatchet (The Complete Sessions 2002)</li>
<li>Everybody Else is Doing It, So Why Can’t We</li>
<li>Gold</li>
<li>Wake Up And Smell The Coffee</li>
</ul>
</li>
<li>The Hampdens<ul>
<li>The Last Party</li>
</ul>
</li>
<li>The Velvet Underground<ul>
<li>Loaded</li>
<li>The Velvet Underground(1969)</li>
</ul>
</li>
<li>The Verve<ul>
<li>Urban Hymns</li>
</ul>
</li>
<li>The Weepies<ul>
<li>(2006)Say I Am You</li>
</ul>
</li>
<li>The Who<ul>
<li>Who’s Next</li>
</ul>
</li>
<li>This Mortal Coil<ul>
<li>1983-1991 (1993)</li>
<li>Bloody</li>
<li>Dust &amp; Guitars</li>
<li>Filigree &amp; Shadow</li>
<li>It’ll End In Tears</li>
</ul>
</li>
<li>Tiamat<ul>
<li>Amanethes</li>
</ul>
</li>
<li>Tori Amos<ul>
<li>Little Earthquake</li>
</ul>
</li>
<li>Tracy Chapman<ul>
<li>Crossroads</li>
<li>Let It Rain</li>
<li>Matters of the Heart</li>
<li>New Beginning</li>
<li>Our Bright Future</li>
<li>Telling Stories</li>
<li>Tracy Chapman</li>
<li>Where You Live</li>
</ul>
</li>
<li>Vangelis<ul>
<li>The Best of Instrumental Works</li>
</ul>
</li>
<li>Various Artists<ul>
<li>Beautiful Field[2007]</li>
<li>とある科学の超電磁砲</li>
<li>クレヨンしんちゃん TV?映画 主題歌集だゾ</li>
<li>デュラララ!!</li>
</ul>
</li>
<li>Vivaldi<ul>
<li>Antonio.Vivaldi.-.[Vivaldi.masterworks(40CD)]</li>
</ul>
</li>
<li>WANDS<ul>
<li>『SLAM DUNK』 ED 02「世界が終わるまでは」</li>
</ul>
</li>
<li>Xandria<ul>
<li>Now&amp;Forever</li>
</ul>
</li>
<li>Yellow Magic Orchestra<ul>
<li>Solid State Survivor[1979]</li>
</ul>
</li>
<li>Yuhki Kuramoto<ul>
<li>Winter Holidays</li>
</ul>
</li>
<li>вечность.слушать.ветер<ul>
<li>вечность.слушать.ветер</li>
</ul>
</li>
<li>万能青年旅店<ul>
<li>万能青年旅店</li>
</ul>
</li>
<li>何韵诗<ul>
<li>First（EP）</li>
<li>诗与胡说（EP）</li>
<li>无名·诗（国语）</li>
<li>Awakening</li>
<li>Coexistence</li>
</ul>
</li>
<li>刘忻</li>
<li>发光曲线 (Glow Curve)<ul>
<li>迷航 (Dedicate To Mind) (2013)</li>
</ul>
</li>
<li>吉森信<ul>
<li>DuRaRaRa!!x2 Shou Original Soundtrack[320K]</li>
<li>DuRaRaRa!!x2 Ten Soundtrack CD[320K]</li>
<li>OST ベストヒット池袋 サイケデリミックス<br>对デュラララ!!爱得太深,也是它的歌曲让我坚持看了下去,没有最开始就放弃… 相辅相成</li>
</ul>
</li>
<li>周杰伦<ul>
<li>JAY</li>
<li>范特西</li>
<li>范特西 PLUS-EP</li>
<li>八度空间</li>
<li>叶惠美</li>
<li>七里香</li>
<li>十一月的肖邦</li>
<li>依然范特西</li>
<li>霍元甲</li>
<li>我很忙</li>
<li>魔杰座</li>
<li>跨时代</li>
<li>惊叹号</li>
<li>十二新作</li>
<li>哎呦，不错哦</li>
</ul>
</li>
<li>声音碎片乐队<ul>
<li>优美的低于生活</li>
<li>把光芒洒向更开阔的地方</li>
</ul>
</li>
<li>小野リサ<ul>
<li>2005-Romance Latino Vol.3</li>
</ul>
</li>
<li>张国荣<ul>
<li>I Am What I Am</li>
<li>宠爱</li>
</ul>
</li>
<li>张悬<ul>
<li>(2009)城市</li>
</ul>
</li>
<li>戸川純<ul>
<li>TOGAWA LEGEND SELF SELECT BEST &amp; RARE 1979-2008</li>
</ul>
</li>
<li>李志<ul>
<li>你好,郑州</li>
<li>梵高先生</li>
<li>这个世界会好吗</li>
</ul>
</li>
<li>杨乃文<ul>
<li>应该</li>
</ul>
</li>
<li>林宥嘉<ul>
<li>神秘嘉宾</li>
</ul>
</li>
<li>林忆莲<ul>
<li>回忆莲莲</li>
</ul>
</li>
<li>海がきこえるSoundtrack</li>
<li>海龟先生<ul>
<li>海龟先生</li>
</ul>
</li>
<li>燕池<ul>
<li>燕歌行</li>
</ul>
</li>
<li>王若琳<ul>
<li>Start From Here (Stereo SACD)</li>
<li>The Things We Do For Love</li>
</ul>
</li>
<li>王菲<ul>
<li>敷衍</li>
<li>浮躁</li>
</ul>
</li>
<li>田馥甄<ul>
<li>My Love</li>
<li>To Hebe</li>
<li>渺小</li>
</ul>
</li>
<li>細野晴臣<ul>
<li>Flying Saucer 1947</li>
<li>Heavenly Music</li>
<li>ハリー細野 &amp; TIN PAN ALLEY IN CHINATOWN</li>
<li>ホソノバ</li>
<li>細野晴臣 STRANGE SONG BOOK</li>
</ul>
</li>
<li>范晓萱<ul>
<li>国语真经典</li>
</ul>
</li>
<li>蔡健雅<ul>
<li>呼吸</li>
<li>记念</li>
<li>陌生人</li>
<li>若你碰到他</li>
<li>说到爱</li>
<li>天使与魔鬼的对话</li>
</ul>
</li>
<li>袁泉<ul>
<li>孤独的花朵</li>
<li>孤独的花朵 EP</li>
</ul>
</li>
<li>郝蕾<ul>
<li>关于TA的伤心事</li>
</ul>
</li>
<li>陈粒<ul>
<li>如也</li>
</ul>
</li>
<li>陈绮贞<ul>
<li>华丽的冒险</li>
</ul>
</li>
<li>響け！ユーフォニアム<ul>
<li>オリジナルサウンドトラック「おもいでミュージック」</li>
</ul>
</li>
<li>黄耀明<ul>
<li>CROSS OVER(EP)</li>
<li>拂了一身还满</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>life</category>
        <category>listening</category>
      </categories>
      <tags>
        <tag>music</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习三</title>
    <url>/2015/08/19/machineLearning03/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-朴素贝叶斯"><a href="#1-朴素贝叶斯" class="headerlink" title="1. 朴素贝叶斯"></a>1. 朴素贝叶斯</h3><p>朴素贝叶斯的两个假设：</p>
<ul>
<li>特征之间相互独立，即一个单词出现的可能性与它和其他单词相邻没有关系</li>
<li>每个特征同等重要</li>
</ul>
<a id="more"></a>
<h3 id="2-文本分类"><a href="#2-文本分类" class="headerlink" title="2. 文本分类"></a>2. 文本分类</h3><h4 id="2-1-准备数据"><a href="#2-1-准备数据" class="headerlink" title="2.1 准备数据"></a>2.1 准备数据</h4><p>从文本中构建词向量, 将文本看成单词向量或词条向量(也就是说将句子转换为向量)<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    postingList=[[<span class="string">'my'</span>, <span class="string">'dog'</span>, <span class="string">'has'</span>, <span class="string">'flea'</span>, <span class="string">'problems'</span>, <span class="string">'help'</span>, <span class="string">'please'</span>],</span><br><span class="line">                 [<span class="string">'maybe'</span>, <span class="string">'not'</span>, <span class="string">'take'</span>, <span class="string">'him'</span>, <span class="string">'to'</span>, <span class="string">'dog'</span>, <span class="string">'park'</span>, <span class="string">'stupid'</span>],</span><br><span class="line">                 [<span class="string">'my'</span>, <span class="string">'dalmation'</span>, <span class="string">'is'</span>, <span class="string">'so'</span>, <span class="string">'cute'</span>, <span class="string">'I'</span>, <span class="string">'love'</span>, <span class="string">'him'</span>],</span><br><span class="line">                 [<span class="string">'stop'</span>, <span class="string">'posting'</span>, <span class="string">'stupid'</span>, <span class="string">'worthless'</span>, <span class="string">'garbage'</span>],</span><br><span class="line">                 [<span class="string">'mr'</span>, <span class="string">'licks'</span>, <span class="string">'ate'</span>, <span class="string">'my'</span>, <span class="string">'steak'</span>, <span class="string">'how'</span>, <span class="string">'to'</span>, <span class="string">'stop'</span>, <span class="string">'him'</span>],</span><br><span class="line">                 [<span class="string">'quit'</span>, <span class="string">'buying'</span>, <span class="string">'worthless'</span>, <span class="string">'dog'</span>, <span class="string">'food'</span>, <span class="string">'stupid'</span>]]</span><br><span class="line">    classVec = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]    <span class="comment">#1 is abusive, 0 not</span></span><br><span class="line">    <span class="keyword">return</span> postingList,classVec</span><br><span class="line">                 </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createVocabList</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    vocabSet = set([])  <span class="comment">#create empty set</span></span><br><span class="line">    <span class="keyword">for</span> document <span class="keyword">in</span> dataSet:</span><br><span class="line">        vocabSet = vocabSet | set(document) <span class="comment">#union of the two sets</span></span><br><span class="line">    <span class="keyword">return</span> list(vocabSet)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setOfWords2Vec</span><span class="params">(vocabList, inputSet)</span>:</span></span><br><span class="line">    returnVec = [<span class="number">0</span>]*len(vocabList)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">            returnVec[vocabList.index(word)] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">print</span> <span class="string">"the word: %s is not in my Vocabulary!"</span> % word</span><br><span class="line">    <span class="keyword">return</span> returnVec</span><br></pre></td></tr></table></figure><br>loadDataSet()创建了一些实验样本<br>createVocabList()会创建一个包含在所有文档中出现的不重复词的列表<br>获取词汇表后，使用setOfWords2Vec()函数，该函数的输入参数为词汇表及某个文档，输出的是文档向量，向量的每一元素为1或0，分别表示在词汇表中的单词在输入文档中是否出现</p>
<h4 id="2-2-训练算法"><a href="#2-2-训练算法" class="headerlink" title="2.2 训练算法"></a>2.2 训练算法</h4><p>从词向量计算概率<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trainNB0</span><span class="params">(trainMatrix,trainCategory)</span>:</span></span><br><span class="line">    numTrainDocs = len(trainMatrix)</span><br><span class="line">    numWords = len(trainMatrix[<span class="number">0</span>])</span><br><span class="line">    pAbusive = sum(trainCategory)/float(numTrainDocs)</span><br><span class="line">    p0Num = ones(numWords); p1Num = ones(numWords)      <span class="comment">#change to ones() </span></span><br><span class="line">    p0Denom = <span class="number">2.0</span>; p1Denom = <span class="number">2.0</span>                        <span class="comment">#change to 2.0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numTrainDocs):</span><br><span class="line">        <span class="keyword">if</span> trainCategory[i] == <span class="number">1</span>:</span><br><span class="line">            p1Num += trainMatrix[i]</span><br><span class="line">            p1Denom += sum(trainMatrix[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p0Num += trainMatrix[i]</span><br><span class="line">            p0Denom += sum(trainMatrix[i])</span><br><span class="line">    p1Vect = log(p1Num/p1Denom)          <span class="comment">#change to log()</span></span><br><span class="line">    p0Vect = log(p0Num/p0Denom)          <span class="comment">#change to log()</span></span><br><span class="line">    <span class="keyword">return</span> p0Vect,p1Vect,pAbusive</span><br></pre></td></tr></table></figure><br>上述训练算法原本应该为：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p0Num = zeros(numWords); p1Num = zeros(numWords)</span><br><span class="line">p0Denom = <span class="number">0</span>; p1Denom = <span class="number">0</span></span><br><span class="line">......</span><br><span class="line">p1Vect = p1Num/p1Denom</span><br><span class="line">p0Vect = p0Num/p0Denom</span><br></pre></td></tr></table></figure><br>原来初始化为0，使用zeros()，然而若其中一个概率值为0，则最终也为0，故改用ones()，并且同时修改p0(1)Denom为2<br>原来也没有对数，为了防止乘积数字太小下溢出为0，改用对数</p>
<p>代码函数中的输入参数为文档矩阵trainMatrix，以及由每篇文档类别标签所构成的向量trainCategory。首先计算文档属于侮辱性文档(class=1)的概率，即P(1)，因为这是一个二分类问题较为简单，多于两类的分类问题要对代码稍作修改；之后计算条件概率；最后对每个元素除以该类别中的总词数</p>
<h4 id="2-3-测试算法"><a href="#2-3-测试算法" class="headerlink" title="2.3 测试算法"></a>2.3 测试算法</h4><p>根据现实情况修改分类器<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classifyNB</span><span class="params">(vec2Classify, p0Vec, p1Vec, pClass1)</span>:</span></span><br><span class="line">    p1 = sum(vec2Classify * p1Vec) + log(pClass1)    <span class="comment">#element-wise mult</span></span><br><span class="line">    p0 = sum(vec2Classify * p0Vec) + log(<span class="number">1.0</span> - pClass1)</span><br><span class="line">    <span class="keyword">if</span> p1 &gt; p0:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testingNB</span><span class="params">()</span>:</span></span><br><span class="line">    listOPosts,listClasses = loadDataSet()</span><br><span class="line">    myVocabList = createVocabList(listOPosts)</span><br><span class="line">    trainMat=[]</span><br><span class="line">    <span class="keyword">for</span> postinDoc <span class="keyword">in</span> listOPosts:</span><br><span class="line">        trainMat.append(setOfWords2Vec(myVocabList, postinDoc))</span><br><span class="line">    p0V,p1V,pAb = trainNB0(array(trainMat),array(listClasses))</span><br><span class="line">    testEntry = [<span class="string">'love'</span>, <span class="string">'my'</span>, <span class="string">'dalmation'</span>]</span><br><span class="line">    thisDoc = array(setOfWords2Vec(myVocabList, testEntry))</span><br><span class="line">    <span class="keyword">print</span> testEntry,<span class="string">'classified as: '</span>,classifyNB(thisDoc,p0V,p1V,pAb)</span><br><span class="line">    testEntry = [<span class="string">'stupid'</span>, <span class="string">'garbage'</span>]</span><br><span class="line">    thisDoc = array(setOfWords2Vec(myVocabList, testEntry))</span><br><span class="line">    <span class="keyword">print</span> testEntry,<span class="string">'classified as: '</span>,classifyNB(thisDoc,p0V,p1V,pAb)</span><br></pre></td></tr></table></figure><br>使用bayes.testingNB()测试算法。</p>
<h4 id="2-4-准备数据"><a href="#2-4-准备数据" class="headerlink" title="2.4 准备数据"></a>2.4 准备数据</h4><p>文档词袋模型: 我们将每个词的出现与否作为一个特征，这可以被描述为词集模型(set-of-words model)，如果一个词在文档中出现不止一次，这可能意味着包含该词是否出现在文档中所不能表达的某种信息，这种方法被称为词袋模型(bag-of-words model)。在词袋中，每个单词可出现多次，而词集中每个词只能出现一次，为适应词袋模型，将setOfWords2Vec()函数稍作修改为bagOfWords2VecMN()<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bagOfWords2VecMN</span><span class="params">(vocabList, inputSet)</span>:</span></span><br><span class="line">    returnVec = [<span class="number">0</span>]*len(vocabList)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">            returnVec[vocabList.index(word)] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> returnVec</span><br></pre></td></tr></table></figure></p>
<h3 id="3-过滤垃圾邮件"><a href="#3-过滤垃圾邮件" class="headerlink" title="3. 过滤垃圾邮件"></a>3. 过滤垃圾邮件</h3><h4 id="3-1-准备数据"><a href="#3-1-准备数据" class="headerlink" title="3.1 准备数据"></a>3.1 准备数据</h4><p>切分文本: 利用正则表达式切分文本<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">emailText = open(<span class="string">'email/ham/6.txt'</span>).read()</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">regExpress = re.compile(<span class="string">'\\w*'</span>)</span><br><span class="line">listOfTokens = regExpress.split(emailText)</span><br><span class="line">[tok.lower() <span class="keyword">for</span> tok <span class="keyword">in</span> listOfTokens <span class="keyword">if</span> len(tok) &gt; <span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<h4 id="3-2-测试算法"><a href="#3-2-测试算法" class="headerlink" title="3.2 测试算法"></a>3.2 测试算法</h4><p>使用朴素贝叶斯进行交叉验证<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">textParse</span><span class="params">(bigString)</span>:</span>    <span class="comment">#input is big string, #output is word list</span></span><br><span class="line">    <span class="keyword">import</span> re</span><br><span class="line">    listOfTokens = re.split(<span class="string">r'\W*'</span>, bigString)</span><br><span class="line">    <span class="keyword">return</span> [tok.lower() <span class="keyword">for</span> tok <span class="keyword">in</span> listOfTokens <span class="keyword">if</span> len(tok) &gt; <span class="number">2</span>] </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spamTest</span><span class="params">()</span>:</span></span><br><span class="line">    docList=[]; classList = []; fullText =[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">26</span>):</span><br><span class="line">        wordList = textParse(open(<span class="string">'email/spam/%d.txt'</span> % i).read())</span><br><span class="line">        docList.append(wordList)</span><br><span class="line">        fullText.extend(wordList)</span><br><span class="line">        classList.append(<span class="number">1</span>)</span><br><span class="line">        wordList = textParse(open(<span class="string">'email/ham/%d.txt'</span> % i).read())</span><br><span class="line">        docList.append(wordList)</span><br><span class="line">        fullText.extend(wordList)</span><br><span class="line">        classList.append(<span class="number">0</span>)</span><br><span class="line">    vocabList = createVocabList(docList)<span class="comment">#create vocabulary</span></span><br><span class="line">    trainingSet = range(<span class="number">50</span>); testSet=[]           <span class="comment">#create test set</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        randIndex = int(random.uniform(<span class="number">0</span>,len(trainingSet)))</span><br><span class="line">        testSet.append(trainingSet[randIndex])</span><br><span class="line">        <span class="keyword">del</span>(trainingSet[randIndex])  </span><br><span class="line">    trainMat=[]; trainClasses = []</span><br><span class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> trainingSet:<span class="comment">#train the classifier (get probs) trainNB0</span></span><br><span class="line">        trainMat.append(bagOfWords2VecMN(vocabList, docList[docIndex]))</span><br><span class="line">        trainClasses.append(classList[docIndex])</span><br><span class="line">    p0V,p1V,pSpam = trainNB0(array(trainMat),array(trainClasses))</span><br><span class="line">    errorCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> testSet:        <span class="comment">#classify the remaining items</span></span><br><span class="line">        wordVector = bagOfWords2VecMN(vocabList, docList[docIndex])</span><br><span class="line">        <span class="keyword">if</span> classifyNB(array(wordVector),p0V,p1V,pSpam) != classList[docIndex]:</span><br><span class="line">            errorCount += <span class="number">1</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"classification error"</span>,docList[docIndex]</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'the error rate is: '</span>,float(errorCount)/len(testSet)</span><br><span class="line">    <span class="comment">#return vocabList,fullText</span></span><br></pre></td></tr></table></figure><br>spamTest()对贝叶斯垃圾邮件分类器进行自动化处理，导入文件夹spam和ham下的文本文件，并将它们解析为词列表，接下来构建一个测试集和训练集，两个集合中的元素是被随机选出的。随机选取数据的一部分为训练集，而剩余部分作为测试集的过程称为<em>留存交叉验证(hold-out cross validation)</em>。重复多次求平均值可以更好的估计错误率</p>
<h3 id="4-示例"><a href="#4-示例" class="headerlink" title="4. 示例"></a>4. 示例</h3><p>使用朴素贝叶斯分类器从个人广告中获取区域倾向</p>
<h4 id="4-1-收集数据"><a href="#4-1-收集数据" class="headerlink" title="4.1 收集数据"></a>4.1 收集数据</h4><p>导入RSS源, 安装feedparser库<code>pip install feedparser</code>, 使用方法如下:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> feedparser</span><br><span class="line">ny = feedparser.parse(<span class="string">'http://newyork.craigslist.org/stp/index.rss'</span>)</span><br><span class="line"><span class="keyword">print</span> ny[<span class="string">'entries'</span>]</span><br></pre></td></tr></table></figure><br>RSS源分类器及高频词去除函数<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcMostFreq</span><span class="params">(vocabList,fullText)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> operator</span><br><span class="line">    freqDict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> vocabList:</span><br><span class="line">        freqDict[token]=fullText.count(token)</span><br><span class="line">    sortedFreq = sorted(freqDict.iteritems(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>) </span><br><span class="line">    <span class="keyword">return</span> sortedFreq[:<span class="number">30</span>]       </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">localWords</span><span class="params">(feed1,feed0)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> feedparser</span><br><span class="line">    docList=[]; classList = []; fullText =[]</span><br><span class="line">    minLen = min(len(feed1[<span class="string">'entries'</span>]),len(feed0[<span class="string">'entries'</span>]))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(minLen):</span><br><span class="line">        wordList = textParse(feed1[<span class="string">'entries'</span>][i][<span class="string">'summary'</span>])</span><br><span class="line">        docList.append(wordList)</span><br><span class="line">        fullText.extend(wordList)</span><br><span class="line">        classList.append(<span class="number">1</span>) <span class="comment">#NY is class 1</span></span><br><span class="line">        wordList = textParse(feed0[<span class="string">'entries'</span>][i][<span class="string">'summary'</span>])</span><br><span class="line">        docList.append(wordList)</span><br><span class="line">        fullText.extend(wordList)</span><br><span class="line">        classList.append(<span class="number">0</span>)</span><br><span class="line">    vocabList = createVocabList(docList)<span class="comment">#create vocabulary</span></span><br><span class="line">    top30Words = calcMostFreq(vocabList,fullText)   <span class="comment">#remove top 30 words</span></span><br><span class="line">    <span class="keyword">for</span> pairW <span class="keyword">in</span> top30Words:</span><br><span class="line">        <span class="keyword">if</span> pairW[<span class="number">0</span>] <span class="keyword">in</span> vocabList: vocabList.remove(pairW[<span class="number">0</span>])</span><br><span class="line">    trainingSet = range(<span class="number">2</span>*minLen); testSet=[]           <span class="comment">#create test set</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">        randIndex = int(random.uniform(<span class="number">0</span>,len(trainingSet)))</span><br><span class="line">        testSet.append(trainingSet[randIndex])</span><br><span class="line">        <span class="keyword">del</span>(trainingSet[randIndex])  </span><br><span class="line">    trainMat=[]; trainClasses = []</span><br><span class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> trainingSet:<span class="comment">#train the classifier (get probs) trainNB0</span></span><br><span class="line">        trainMat.append(bagOfWords2VecMN(vocabList, docList[docIndex]))</span><br><span class="line">        trainClasses.append(classList[docIndex])</span><br><span class="line">    p0V,p1V,pSpam = trainNB0(array(trainMat),array(trainClasses))</span><br><span class="line">    errorCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> docIndex <span class="keyword">in</span> testSet:        <span class="comment">#classify the remaining items</span></span><br><span class="line">        wordVector = bagOfWords2VecMN(vocabList, docList[docIndex])</span><br><span class="line">        <span class="keyword">if</span> classifyNB(array(wordVector),p0V,p1V,pSpam) != classList[docIndex]:</span><br><span class="line">            errorCount += <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'the error rate is: '</span>,float(errorCount)/len(testSet)</span><br><span class="line">    <span class="keyword">return</span> vocabList,p0V,p1V</span><br></pre></td></tr></table></figure><br>移除高频词是由于词汇表中的一小部分单词却占据了所有文本用词的一大部分，产生这种现象的原因是语言中大部分都是冗余和结构辅助性内容。另一个常用方法是不仅移除高频词，同时从某个预定词表中移除结构上的辅助词，该词表称为停用词表(stop word list)，可以在网上找到(例如 <a href="http://www.ranks.nl/resources/stopwords.html" target="_blank" rel="noopener">http://www.ranks.nl/resources/stopwords.html</a>)<br>通过以下命令测试上述代码：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ny = feedparser.parse(<span class="string">'http://newyork.craigslist.org/stp/index.rss'</span>)</span><br><span class="line">sf = feedparser.parse(<span class="string">'http://sfbay.craigslist.org/stp/index.rss'</span>)</span><br><span class="line">vocabList, pSF, pNY = bayes.localWords(ny,sf)</span><br><span class="line">vocabList, pSF, pNY = bayes.localWords(ny,sf)</span><br></pre></td></tr></table></figure><br>为了得到错误率的精确估计，应该多次进行上述实验取平均值</p>
<h4 id="4-2-分析数据"><a href="#4-2-分析数据" class="headerlink" title="4.2 分析数据"></a>4.2 分析数据</h4><p>显示地域相关的用词, 可以先对向量pSF和pNY进行排序, 然后按照顺序将词打印出来。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTopWords</span><span class="params">(ny,sf)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> operator</span><br><span class="line">    vocabList,p0V,p1V=localWords(ny,sf)</span><br><span class="line">    topNY=[]; topSF=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(p0V)):</span><br><span class="line">        <span class="keyword">if</span> p0V[i] &gt; <span class="number">-6.0</span> : topSF.append((vocabList[i],p0V[i]))</span><br><span class="line">        <span class="keyword">if</span> p1V[i] &gt; <span class="number">-6.0</span> : topNY.append((vocabList[i],p1V[i]))</span><br><span class="line">    sortedSF = sorted(topSF, key=<span class="keyword">lambda</span> pair: pair[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**"</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> sortedSF:</span><br><span class="line">        <span class="keyword">print</span> item[<span class="number">0</span>]</span><br><span class="line">    sortedNY = sorted(topNY, key=<span class="keyword">lambda</span> pair: pair[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**"</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> sortedNY:</span><br><span class="line">        <span class="keyword">print</span> item[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><br>getTopWords()使用两个RSS源作为输入，然后训练并测试朴素贝叶斯分类器，返回使用的概率值。<br><code>bayes.getTopWords(ny,sf)</code>可查看运行结果</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>ai</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
        <tag>bayes decision</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习四</title>
    <url>/2015/08/25/machineLearning04/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-Logistic回归"><a href="#1-Logistic回归" class="headerlink" title="1. Logistic回归"></a>1. Logistic回归</h3><p>利用Logistic回归进行分类的主要思想是: 根据现有数据对分类边界线建立回归公式,以此进行分类</p>
<h3 id="2-基于Logistic回归和Sigmoid函数的分类"><a href="#2-基于Logistic回归和Sigmoid函数的分类" class="headerlink" title="2. 基于Logistic回归和Sigmoid函数的分类"></a>2. 基于Logistic回归和Sigmoid函数的分类</h3><p>我们想要的函数是能接受所有的输入然后预测出类别。例如,在两个类的情况下,上述函数输出0或1,我们接触过的函数 Heaviside step function(单位阶跃函数)即是。然而此函数在跳跃点上从0瞬间跳跃到1，这个瞬间跳跃过程有时很难处理。Sigmoid函数有类似的性质但是更容易处理，其具体计算公式为：\(\sigma(z)=\frac{1}{1+e^{-z}}\)<br>为了实现Logistic回归分类器，我们可以在每个特征上都乘以一个回归系数，然后把所有的结果值相加，将这个总和代入Sigmoid函数中，进而得到一个范围在0~1之间的数值。任何大于0.5的数据被分入1类，小于0.5即被归为0类。所以，Logistic回归也可以看成是一种概率估计<br>确定了分类器的函数形式后，问题变为求最佳回归系数。<br><a id="more"></a></p>
<h3 id="3-基于最优化方法的最佳回归系数确定"><a href="#3-基于最优化方法的最佳回归系数确定" class="headerlink" title="3. 基于最优化方法的最佳回归系数确定"></a>3. 基于最优化方法的最佳回归系数确定</h3><p>Sigmoid函数的输入记为z，由下公式得出:<br>\(z=w_0x_0+w_1x_1+\cdots+w_nx_n=w^Tx\)<br>其中向量x是分类器的输入数据，向量w就是我们要找到的最佳参数(系数)，从而使分类器尽可能精确。</p>
<h4 id="3-1-最优化方法：梯度上升法"><a href="#3-1-最优化方法：梯度上升法" class="headerlink" title="3.1 最优化方法：梯度上升法"></a>3.1 最优化方法：梯度上升法</h4><p>梯度上升法基于的思想是:<br>要找到某函数的最大值最好的方法是沿着该函数的梯度方向做探寻，如果梯度记为\(\nabla\)，则函数\(f(x,y)\)的梯度由下式表示：\(\nabla f(x,y)=\begin{bmatrix}<br>\frac{\partial f(x,y)}{\partial x} \\<br>\frac{\partial f(x,y)}{\partial y}<br>\end{bmatrix}\)<br>其中，函数f(x,y)必须在待计算的点上有定义并可微。具体函数示例图如下:<br><img src="/images/machineLearning04_4.png" alt="fourth"></p>
<p>梯度上升算法到达每个点后都会重新估计移动的方向。从P0开始，计算完该点的梯度，函数就根据梯度移动到下一点P1，在P1点梯度再次被重新计算，并沿新的梯度方向移动到P2，如此循环迭代直到满足停止条件。迭代过程中，梯度算子总是保证我们能选取到最佳的移动方向。<br>可以看到，梯度算子总是指向函数值增长最快的方向，这里所说的是移动方向，而未提到移动量的大小，该变量称为步长，记作\(\alpha\)，用向量表示的话，梯度上升算法的迭代公式如下：\(w:=w+\alpha \nabla_wf(w)\)<br>该公式将一直被迭代执行，直到达到某个停止条件为止<br>Addition: 梯度下降算法只需要将上式的+改为－。梯度上升算法用来求函数的最大值，梯度下降算法用来求函数的最小值</p>
<ul>
<li>训练算法<br>下图中有100个样本点，每个点包含两个数值型特征：X1和X2。在此数据集上，通过梯度上升算法找到最佳回归系数，也就是拟合出Logistic回归模型的最佳参数<br><img src="/images/machineLearning04_6.png" alt="sixth"><br>梯度上升伪代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每个回归系数初始化为1</span><br><span class="line">重复R次：</span><br><span class="line">    计算整个数据集的梯度</span><br><span class="line">    使用alpha × gradient更新回归系数的向量</span><br><span class="line">    返回回归系数</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-2-分析数据-画出决策边界"><a href="#3-2-分析数据-画出决策边界" class="headerlink" title="3.2 分析数据: 画出决策边界"></a>3.2 分析数据: 画出决策边界</h4><p>上面已经解出了一组回归系数，它确定了不同类别数据间的分割线，以下函数画出分割线:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotBestFit</span><span class="params">(wei)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">    weights = wei.getA()</span><br><span class="line">    dataMat,labelMat=loadDataSet()</span><br><span class="line">    dataArr = array(dataMat)</span><br><span class="line">    n = shape(dataArr)[<span class="number">0</span>] </span><br><span class="line">    xcord1 = []; ycord1 = []</span><br><span class="line">    xcord2 = []; ycord2 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> int(labelMat[i])== <span class="number">1</span>:</span><br><span class="line">            xcord1.append(dataArr[i,<span class="number">1</span>]); ycord1.append(dataArr[i,<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            xcord2.append(dataArr[i,<span class="number">1</span>]); ycord2.append(dataArr[i,<span class="number">2</span>])</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    ax.scatter(xcord1, ycord1, s=<span class="number">30</span>, c=<span class="string">'red'</span>, marker=<span class="string">'s'</span>)</span><br><span class="line">    ax.scatter(xcord2, ycord2, s=<span class="number">30</span>, c=<span class="string">'green'</span>)</span><br><span class="line">    x = arange(<span class="number">-3.0</span>, <span class="number">3.0</span>, <span class="number">0.1</span>)</span><br><span class="line">    y = (-weights[<span class="number">0</span>]-weights[<span class="number">1</span>]*x)/weights[<span class="number">2</span>]           </span><br><span class="line">    ax.plot(x, y)</span><br><span class="line">    plt.xlabel(<span class="string">'X1'</span>); plt.ylabel(<span class="string">'X2'</span>);</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-训练算法：随机梯度上升"><a href="#3-3-训练算法：随机梯度上升" class="headerlink" title="3.3 训练算法：随机梯度上升"></a>3.3 训练算法：随机梯度上升</h4><p>梯度上升算法在每次更新回归系数时都需要遍历整个数据集，该方法处理100个左右的数据集时尚可，若数据集过大则计算复杂度太高，改进方法之一是一次仅用一个样本点来更新回归系数，该方法称为随机梯度上升算法。由于可以在新样本到来时对分类器进行增量式更新，因而随机梯度上升算法是一个在线学习算法，与”在线学习”相对应，一次处理所有系数称为”批处理”<br>伪代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每个回归系数初始化为1</span><br><span class="line">对数据集中每个样本：</span><br><span class="line">    计算该样本的梯度</span><br><span class="line">    使用alpha × gradient更新回归系数值</span><br><span class="line">返回回归系数值</span><br></pre></td></tr></table></figure><br>实际代码：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stocGradAscent0</span><span class="params">(dataMatrix, classLabels)</span>:</span></span><br><span class="line">    m,n = shape(dataMatrix)</span><br><span class="line">    alpha = <span class="number">0.01</span></span><br><span class="line">    weights = ones(n)   </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        h = sigmoid(sum(dataMatrix[i]*weights))</span><br><span class="line">        error = classLabels[i] - h</span><br><span class="line">        weights = weights + alpha * error * dataMatrix[i]</span><br><span class="line">    <span class="keyword">return</span> weights</span><br></pre></td></tr></table></figure><br>运行一次并不能看出最终效果，修改代码使其在数据集上运行200(or other)次。而对于不同的系数，迭代达到稳定的次数不同，有的也许只要50次，而有的则会来回波动，为了避免来回波动，从而收敛到某个值，以及加快收敛速度，代码改进：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stocGradAscent1</span><span class="params">(dataMatrix, classLabels, numIter=<span class="number">150</span>)</span>:</span></span><br><span class="line">    m,n = shape(dataMatrix)</span><br><span class="line">    weights = ones(n)   </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(numIter):        dataIndex = range(m)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            alpha = <span class="number">4</span>/(<span class="number">1.0</span>+j+i)+<span class="number">0.01</span>               </span><br><span class="line">            randIndex = int(random.uniform(<span class="number">0</span>,len(dataIndex)))        </span><br><span class="line">            h = sigmoid(sum(dataMatrix[randIndex]*weights))</span><br><span class="line">            error = classLabels[randIndex] - h</span><br><span class="line">            weights = weights + alpha * error * dataMatrix[randIndex]</span><br><span class="line">            <span class="keyword">del</span>(dataIndex[randIndex])</span><br><span class="line">    <span class="keyword">return</span> weights</span><br></pre></td></tr></table></figure></p>
<pre><code>- 一方面，alpha在每次迭代时都会调整，这会缓解数据波动或高频波动，另外虽然alpha随着迭代次数不断减小，但不会减为0，这样做是为了保证多次迭代后新数据仍有一定影响。如果要处理的问题是动态变化的，可以适当加大上述常数项，以确保新值获得更大的回归系数。在降低alpha函数中，每次减少1/(j+i)，其中j是迭代次数，i是样本点的下标，这样j&amp;lt;&amp;lt;max(i)时，alpha就不是严格下降的，避免严格下降也常用于模拟退火等优化算法中
- 另一方面，通过随机选取样本来更新回归系数，这将减少周期性的波动
- 此外，改进算法增加了一个参数确定迭代次数
</code></pre><h3 id="4-示例：预测病马的死亡率"><a href="#4-示例：预测病马的死亡率" class="headerlink" title="4. 示例：预测病马的死亡率"></a>4. 示例：预测病马的死亡率</h3><p>数据来源于<a href="http://archive.ics.uci.edu/ml/
datasets/Horse+Colic">UCI机器学习数据库</a>，数据包含368个样本和28个特征。该数据集部分指标主观难以测量，且数据集中有30%的值是缺失的</p>
<h4 id="4-1-准备数据"><a href="#4-1-准备数据" class="headerlink" title="4.1 准备数据"></a>4.1 准备数据</h4><p>处理数据中的缺失值, 可选做法有：</p>
<ul>
<li>使用可用特征的均值来填补缺失值</li>
<li>使用特殊值来填补缺失值，如-1</li>
<li>忽略有缺失的样本</li>
<li>使用相似样本的均值填补缺失值</li>
<li>使用另外的机器学习算法预测缺失值</li>
</ul>
<p>这里我们将所有的缺失值用0替代，因为其恰好能用于Logistic回归，在回归系数更新公式中:<br><code>weights = weights + alpha * error * dataMatrix[randIndex]</code><br>如果dataMatrix的某特征对应0，则该特征将不做更新。另外由于sigmoid(0)=0.5，它对结果的预测不具有任何倾向性<br>如果在测试数据集中发现一条数据的类别标签已经缺失，最简单的做法是将该数据丢弃</p>
<h4 id="4-2-测试算法"><a href="#4-2-测试算法" class="headerlink" title="4.2 测试算法"></a>4.2 测试算法</h4><p>用Logistic回归进行分类, Logistic回归分类函数：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classifyVector</span><span class="params">(inX, weights)</span>:</span></span><br><span class="line">    prob = sigmoid(sum(inX*weights))</span><br><span class="line">    <span class="keyword">if</span> prob &gt; <span class="number">0.5</span>: <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">colicTest</span><span class="params">()</span>:</span></span><br><span class="line">    frTrain = open(<span class="string">'horseColicTraining.txt'</span>) </span><br><span class="line">    frTest = open(<span class="string">'horseColicTest.txt'</span>)</span><br><span class="line">    trainingSet = []; trainingLabels = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> frTrain.readlines():</span><br><span class="line">        currLine = line.strip().split(<span class="string">'\t'</span>)</span><br><span class="line">        lineArr =[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">21</span>):</span><br><span class="line">            lineArr.append(float(currLine[i]))</span><br><span class="line">        trainingSet.append(lineArr)</span><br><span class="line">        trainingLabels.append(float(currLine[<span class="number">21</span>]))</span><br><span class="line">    trainWeights = stocGradAscent1(array(trainingSet), trainingLabels, <span class="number">500</span>)</span><br><span class="line">    errorCount = <span class="number">0</span>; numTestVec = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> frTest.readlines():</span><br><span class="line">        numTestVec += <span class="number">1.0</span></span><br><span class="line">        currLine = line.strip().split(<span class="string">'\t'</span>)</span><br><span class="line">        lineArr =[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">21</span>):</span><br><span class="line">            lineArr.append(float(currLine[i]))</span><br><span class="line">        <span class="keyword">if</span> int(classifyVector(array(lineArr), trainWeights))!= </span><br><span class="line">            int(currLine[<span class="number">21</span>]):</span><br><span class="line">            errorCount += <span class="number">1</span></span><br><span class="line">    errorRate = (float(errorCount)/numTestVec)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"the error rate of this test is: %f"</span> % errorRate</span><br><span class="line">    <span class="keyword">return</span> errorRate</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiTest</span><span class="params">()</span>:</span></span><br><span class="line">    numTests = <span class="number">10</span>; errorSum=<span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(numTests):</span><br><span class="line">        errorSum += colicTest()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"after %d iterations the average error rate is:</span></span><br><span class="line"><span class="string">        %f"</span> % (numTests, errorSum/float(numTests))</span><br></pre></td></tr></table></figure><br>classifyVector()，它以回归系数和特征向量作为输入来计算对应的Sigmoid值<br>colicTest()是用于打开测试集和训练集，并对数据进行格式化处理的函数<br>multiTest()，其功能是调用colicTest()10次并求结果的平均值</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>ai</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
        <tag>logistic</tag>
      </tags>
  </entry>
  <entry>
    <title>Metaheuristic algorithm —— Concept</title>
    <url>/2018/11/19/metaheuristicAlgorithm01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Kino的课题常需要用到元启发式算法，就在此稍稍总结。<br>元启发式(metaheuristic)，很多时候也被称为智能优化(intelligent optimization)、现代启发式(Modern Heuristic)、智能计算(Intelligent Computation)、自然计算(Natural Computation)等，细分到具体算法有<em>遗传算法</em>、<em>粒子群算法</em>、<em>差分进化算法</em>、<em>蚁群算法</em>等。<br><strong>元启发式(metaheuristic)</strong>这个词本身可以拆成两部分来看，<em>元(meta)</em>和<em>启发式(heuristic)</em>，本文主要从这两方面来阐述元启发式的概念，后续文章再介绍各算法的原理、步骤、代码等。</p>
<a id="more"></a>
<h3 id="1-Meta"><a href="#1-Meta" class="headerlink" title="1. Meta"></a>1. Meta</h3><p>首先来解释<em>元(meta)</em>，程序员对这个词并不陌生，学习编程语言到某个阶段总会出来一个<em>元编程(metaprogramming)</em>技术，还会经常见到<em>元数据(metadata)</em>等。与顾名思义的一些概念相比，<em>元</em>的概念就有点晦涩了，初次遇见总是一脸诧异，难以理解。<br>感性上来看，<strong>metaXXX</strong>就是相比XXX来说更高级的一种概念/理论，是研究超越XXX的存在，玄之又玄，不能理解不是你的错，就像形而上学(metaphysics)一样难以理解。<br>而不去探讨<strong>meta</strong>哲学性质的意义，只考虑其作为前缀(prefix)的情况，根据<em>meta</em>在Wikipedia的相应词条<a href="https://en.wikipedia.org/wiki/Meta" target="_blank" rel="noopener">Meta</a><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. (2018, November 12). Meta. Retrieved from https://en.wikipedia.org/wiki/Meta
">[1]</span></a></sup>，<strong>meta</strong>大多数时候可以理解为<strong>X about X</strong>，大致翻译为<strong>关于X的X</strong>，这里的<strong>关于</strong>在中文语境里通常用<strong>实现、描述、编写</strong>等动词代替。例如<strong>metadata</strong>就是<strong>data about data</strong>，即描述数据的数据，<strong>metaprogramming</strong>就是<strong>programming about programming</strong>，即<strong>编写程序的程序</strong>，诸如此类。如果有需要，这种概念还可以递归，即添加任意多的<strong>meta</strong>前缀，变身成为<strong>metametameta…</strong>。<br>在此基础上再去看<strong>meta</strong>的中文翻译<strong>元</strong>，就会发现这个翻译其实很巧妙。“元”汉语里有 起源/开始(如元旦/元始天尊)、基本/根本(如元素/元气/元件) 的意思，完美地涵盖了meta想要表达的意思。然而<strong>元</strong>这个字很少单用，已经融合在最常见的一些词语中，所以当看到用<strong>元</strong>的前缀生造出的词语时，大多数人还是会难以理解。</p>
<p>这样说完感觉可能还是一片迷茫，就拿上面所说的<em>metadata</em>和<em>metaprogramming</em>作为示例来具体说明。</p>
<h4 id="1-1-Metadata"><a href="#1-1-Metadata" class="headerlink" title="1.1 Metadata"></a>1.1 Metadata</h4><p>关于Metadata，循序渐进地来举几个栗子。</p>
<ul>
<li>填写各类登记表时，通常需要填写姓名、性别、爱好等信息，那么我们填写的信息<strong>Kino、女、睡觉</strong>就是具体需要的data，而<strong>姓名、性别、爱好</strong>这种描述属性的文字，就属于metadata</li>
<li>对上面的内容稍加扩展，可以认为在进行关系型数据库设计时，我们建立的表结构就可以看作是metadata，而最终记录到表中的内容就是data，而对于K-V数据库来说，也不妨理解为Key是metadata，Value是data，JSON数据自然也可如此理解。</li>
<li>XML数据格式，XML(Extensible Markup Language)作为一种标记语言(Markup Language)，本就是Metadata一种表现形式。可以把XML的tag和property的key作为metadata，而把content和property的value作为data。HTML作为XML的亲戚，也可以如此理解，而至于HTML中的meta标签，又是将整个HTML文件看作data，这个meta标签里的内容就是用来描述这整个HTML的data也就是metadata了，比如<code>&lt;meta name=&quot;google-site-verification&quot; content=&quot;......&quot; /&gt;</code></li>
</ul>
<h4 id="1-2-Metaprogramming"><a href="#1-2-Metaprogramming" class="headerlink" title="1.2 Metaprogramming"></a>1.2 Metaprogramming</h4><p>按照上面的逻辑继续下去，变量声明就是描述变量的类型，难道就是metaprogramming了吗? 显然不会是这么简单的事情。<br>metaprogramming本身还是一个比较宏观的定义，对应到不同编程语言的具体实现上，又各有不同。下面简单叙述几种语言的metaprogramming机制，只要实际使用过其中一种，就不难理解了。</p>
<ul>
<li>C++：在C++中，可以利用模板实现元编程，在Effective C++中就有关于模板元编程的讨论</li>
<li>Java：在Java中，最为人熟知的反射，就可以用来实现元编程</li>
<li>Python：在Python中，如果一个类继承的不是object而是type，那么它就被成为<strong>元类(metaclass)</strong>，可以用元类来验证、注册子类，这也可以称为元编程</li>
</ul>
<p>从上面的例子中总结一下，元编程的实现手段各异，但大多是想解决这几个问题：</p>
<ul>
<li>设计中出现的相似内容太多，而这些重复内容存在于类层面，已经不能通过类的抽象来解决了，或者解决起来更为复杂(比如引入过于复杂的设计模式等)，这个时候需要更高一层的抽象来处理问题，解决这个问题的过程就可以称为元编程，Python中的metaclass就是典型的应用</li>
<li>面向对象程序的设计中，类的定义是在编译期就确定的，运行时动态生成的是实例，如果想要更高一层，在运行时动态生成类，那么这个实现过程就可以称为元编程，Java中的反射是典型的应用</li>
<li>…</li>
</ul>
<p>这也提醒了我们，在使用元编程前需要思考这个问题是否必须使用元编程、使用元编程能否简化实现过程，如果可以再尝试使用，否则就需要谨慎对待。<br><strong>元编程更大程度上是一个概念和思想，而不是一个具体方法和手段</strong></p>
<h4 id="1-3-Off-topic"><a href="#1-3-Off-topic" class="headerlink" title="1.3 Off topic"></a>1.3 Off topic</h4><p>思维一发散，意识就止不住到处游走，虽然离题万里，但且记录在此吧。</p>
<blockquote>
<p>突然想到导师最喜欢提的问题：“你这个效能评估的参数选取标准是什么呢？你怎么证明你这个效能评估的结果是可信的呢？毁伤评估的结果是怎么得来的呢？”似也有点元的意味，而且还可以无限递归，最终变成“评估评估…评估的结果”。如果该项工作有客观的评估标准，评估起来就相对简单可信，如果没有客观标准，靠专家标准或者自己选取的参数标准评估，可信性就大打折扣了，这个时候就可以再追问一句：“你怎么评价你选取的参数是可靠的呢？”。<br>今天刚好看到<a href="https://en.wikipedia.org/wiki/2019_redefinition_of_SI_base_units" target="_blank" rel="noopener">新闻</a>，国际单位制的七个基本单位重新进行了定义，都改以宇宙的基本常数为基础定义<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. (2018, November 19). 2019 redefinition of SI base units. Retrieved from https://en.wikipedia.org/wiki/2019_redefinition_of_SI_base_units
">[2]</span></a></sup>，于是突然想到，所谓度量系统<strong>Metric System</strong>里的单词<strong>metric</strong>，在词源上是不是和<strong>meta</strong>同源的，毕竟metric是用来衡量一切的标准，有种meta的意味在里面，不过事实到底如何，毫无词源学基础的Kino是无法确定了。<br>似乎更能理解那句不是爱因斯坦的名言“越简单越好，但不要过于简单”，过犹不及，繁简之间如何取舍是个永恒的问题，奥卡姆剃刀并不是万能的，更何况繁简也是相互转化的，就像有时想为了简洁不停地添加meta，最终却导致设计模式的臃肿，反而更复杂了。所谓大道至简，是对还是错，还未可知。但是爱因斯坦真的说过这句：“不应否认任何理论的终极目标都是尽可能让不可削减的基本元素变得更加简单且更少，但也不能放弃对任何一个单一经验数据的充分阐释。”这似乎是个比较恰当的说法。</p>
</blockquote>
<h3 id="2-Heuristic"><a href="#2-Heuristic" class="headerlink" title="2. Heuristic"></a>2. Heuristic</h3><p>维基百科也有启发式(Heuristic)的词条<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. (2014, May 25). Heuristic (computer science). Retrieved from https://en.wikipedia.org/wiki/Heuristic_(computer_science)
">[3]</span></a></sup>，但实际的定义很简单。<br>启发式算法(Heuristic)算法和精确(Exact)算法相对应，它们的求解对象都是运筹优化类问题。区别在于，对于组合优化等非凸优化问题，用精确算法虽可求出其全局最优解，但计算效率低，有时还是NP问题，规模变大则无法在有限时间内求解，而利用启发式算法，可以提高计算效率，但求得的解可能只是较好的次优解，而不能达到全局最优解。<br>针对一个具体的优化问题，提出一个在计算效率和求解质量间取得均衡的具体算法，这个算法就叫做启发式算法。<br>例如需要求解\(y=f(x)\)的最小值，用精确求解可以得到准确值为\(\min{y}=22\)，耗时\(t=10s\)，而使用启发式算法求得的结果是\(\min{y}=22.22\)，但耗时只有\(t=3s\)。<br>对于精确求解法，具体包括穷举法、分支定界法、割平面法、动态规划法等，而对于传统的启发式算法，包括构造型方法、局部搜索算法、松弛方法、解空间缩减法等。</p>
<h3 id="3-Metaheuristic"><a href="#3-Metaheuristic" class="headerlink" title="3. Metaheuristic"></a>3. Metaheuristic</h3><p>综合以上概念，将meta和heuristic结合得到的所谓元启发(metaheuristic)，理论定义上应该是<strong>heuristic about heuristic</strong>，但是这种<strong>实现启发式的启发式</strong>，还是很难直观理解。<br>先回到刚刚说的启发式算法，严格意义上的启发式，是针对某个特定优化问题的，只要是能够取得较好值的算法都可以叫做启发式算法，而元启发，就是给定一套流程/方法论，对不同的问题，只要按照该流程设计，就能实现一个针对具体问题的启发式算法，因此把这个抽象的流程称之为元启发。换句话说，启发式是面向问题的(Problem Oriented)，而元启发是面向方法的(Method Oriented)。最常见的比如遗传算法，它只给定了一个标准流程：编码-&gt;初始化-&gt;选择-&gt;交叉-&gt;变异-&gt;…，而针对一个具体的优化问题，需要设计特定的编码方式、选择特定的适应度函数…，如此设计完成的具体算法才是启发式算法。<br><strong>但是、然而、不过</strong>，现在的论文中，大多数时候把元启发和启发式也混着用，在整篇文章中，通常只使用元启发式或启发式其中一个词，所以界限并没有那么分明了，元启发经常被称为启发式、启发式也经常被叫做元启发。<br>元启发也有维基百科页面，<a href="https://en.wikipedia.org/wiki/Metaheuristic" target="_blank" rel="noopener">戳这里</a></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>传统的任务分配、组合优化类等运筹学问题，大多都可以抽象成非凸优化的模型，也是NP问题，无法用传统方法求解，同时这些问题大多缺少或不能统计历史数据，因此也无法使用有监督机器学习等算法，这种情况下使用智能优化算法就非常合适。<br>针对这些运筹学问题，只要能够利用元启发算法的思想设计出合理的启发式算法，从而解决问题，其实就是一个很好的工作，但是现在的研究导向是发论文至上，研究智能优化算法的实验室也不例外，一切以发论文为导向，设计全新的元启发式算法实在困难，于是现在的论文大多还是Problem Oriented，通过说动听的故事阐述问题意义，再找出和之前的问题区别，比如多了一个小小的约束条件，这时就可以命名这个问题为XXXXX，以此说明自己定义了一个新问题，再抽象出该问题的数学模型(大多数时候只是在目标函数或约束条件上做些许修改，太简单没有做的意义，太复杂元启发也难以求解)，然后根据元启发算法的流程设计出完整的算法(在流程中的任一处加一点修改即可称之为改进)，编程实现算法做比较，得出结论;当然Method Oriented也还是有的，刚刚提到的一些小的改动、针对经典的TSP等做算法改进、超多目标优化问题的求解方法等。<br>总之一切为了论文，至于这些论文里的问题是否真的有意义、方法是否真的有创新，谁在乎呢。</p>
<h3 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h3><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)">Wikipedians. (2018, November 12). Meta. Retrieved from <a href="https://en.wikipedia.org/wiki/Meta" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Meta</a><a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)">Wikipedians. (2018, November 19). 2019 redefinition of SI base units. Retrieved from <a href="https://en.wikipedia.org/wiki/2019_redefinition_of_SI_base_units" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/2019_redefinition_of_SI_base_units</a><a href="#fnref:2" rev="footnote"> ↩</a></span></div><div id="fn:3" style="display:flex"><span style="width:20px">3.</span><span style="width:calc(100% - 20px)">Wikipedians. (2014, May 25). Heuristic (computer science). Retrieved from <a href="https://en.wikipedia.org/wiki/Heuristic_(computer_science)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Heuristic_(computer_science)</a><a href="#fnref:3" rev="footnote"> ↩</a></span></div><div id="fn:4" style="display:flex"><span style="width:20px">4.</span><span style="width:calc(100% - 20px)">Wikipedians. (2018, November 16). Metaheuristic. Retrieved from <a href="https://en.wikipedia.org/wiki/Metaheuristic" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Metaheuristic</a><a href="#fnref:4" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>techonology</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>metaheuristic</tag>
      </tags>
  </entry>
  <entry>
    <title>模式识别二</title>
    <url>/2015/08/17/patternRecognition02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="贝叶斯决策"><a href="#贝叶斯决策" class="headerlink" title="贝叶斯决策"></a>贝叶斯决策</h1><h3 id="1-基本规则"><a href="#1-基本规则" class="headerlink" title="1. 基本规则"></a>1. 基本规则</h3><p>贝叶斯决策理论就是用统计概率的方法研究随机模式的决策问题。用贝叶斯决策理论方法进行分类时要求满足以下两个条件：</p>
<ul>
<li>1)各类别总体的概率分布是已知的</li>
<li>2)要决策的类别数是一定的</li>
</ul>
<p>在统计模式识别中，模式分类问题实际上就是把特征空间分割成若干个区域，每一个区域对应一个模式类别。对于确定性模式，由于模式样本的观测值是确定的，所以样本都会被正确地区分到相应的类型区域中。然而对大多数情况而言，这是非常理想的概率分布，许多实际情况下，即使在类型A的条件下，模式样本x位于区域A的概率也小于1，而位于B的概率大于0，这种交错分布的样本使分类发生错误，这是模式随机性的一种体现。如何使分类错误率尽可能小是研究各种分类方法的中心议题。</p>
<a id="more"></a>
<h3 id="2-相关概念"><a href="#2-相关概念" class="headerlink" title="2. 相关概念"></a>2. 相关概念</h3><ul>
<li>1)先验概率：预先已知的或者可以估计的模式识别系统位于某种类型的概率</li>
<li>2)类条件概率密度函数：系统位于某种类型条件下模式样本X出现的概率密度分布函数。为了强调是同一事物内部，因此这种分布密度函数往往表示成条件概率的形式，即\(P(X|Y)\)</li>
<li>3)后验概率：系统在某个具体的模式样本X条件下位于某种类型的概率。一个具体事物属于某种类别的概率，比如一个学生用特征向量X表示，他/她是男性或女性的概率表示成\(P(Male|X)\)和\(P(Female|X)\)，这就是后验概率，而一个具体事物必然有所属，故有\(P(Male|X)+P(Female|X)=1\)的约束，这与类分布密度函数是不同的。后验概率与先验概率也不同，后验概率涉及一个具体事物，而先验概率是泛指一类事物，因此\(P(Male|X)\)和\(P(Male)\)是不同的概念。后验概率可以根据贝叶斯公式计算，它直接用作分类判别的依据。</li>
<li>4)贝叶斯公式：两个事物X与w联合出现的概率称为联合概率，可写成\(P(X,w)\)，而它们又可与条件概率联系起来，即\(P(X,w)=P(X|w)P(w)=P(w|X)P(X)\)，这就是贝叶斯公式。如果将上式中各个项与先验概率、类条件概率密度函数以及后验概率联合起来，可以找到利用先验概率和类条件概率密度函数来计算后验概率的方法</li>
</ul>
<h3 id="3-几种常用的决策规则"><a href="#3-几种常用的决策规则" class="headerlink" title="3. 几种常用的决策规则"></a>3. 几种常用的决策规则</h3><h4 id="3-1-最小错误率的贝叶斯决策"><a href="#3-1-最小错误率的贝叶斯决策" class="headerlink" title="3.1 最小错误率的贝叶斯决策"></a>3.1 最小错误率的贝叶斯决策</h4><p>基于最小错误概率的贝叶斯决策理论就是按照后验概率的大小作判决的，其决策规则为：<br>如果\(P(w_1|x)&gt;P(w_2|x)\)，则\(x\in w_1\)，否则\(x\in w_2\)<br>而上式中：<br>$$<br>\begin{equation}<br>\begin{cases}<br>P(w_i|x)=\frac{P(x|w_i)}{P(x)}P(w_i) \\<br>P(x)=\sum_{j=1}^2P(x|w_j)P(w_j)<br>\end{cases}<br>\nonumber<br>\end{equation}<br>$$<br>因为分母P(x)在决策时不起作用，最小错误率的决策规则的其他表达形式：</p>
<ul>
<li>1) 如果\(P(x|w_1)P(w_1)&gt;P(x|w_2)P(w_2)\)，则\(x\in w_1\)，否则\(x\in w_2\)</li>
<li>2) 对于1还可以用比值方式表示，得到相应决策规则为：<br>如果\(l(x)=\frac{P(x|w_1)}{P(x|w_2)}&gt;\frac{P(w_2)}{P(w_1)}\)，则\(x\in w_1\)，否则\(x\in w_2\)<br>我们称\(P(x|w_i)\)关于x的似然函数或似然，式中\(l(x)\)称为似然比，\(\frac{P(w_2)}{P(w_1)}\)为似然比的阈值。<br>因此贝叶斯决策法则也可以表达为：<br>如果似然比超过某个阈值\(\frac{P(w_2)}{P(w_1)}\)（它与x无关），则做决策\(x\in w_1\)，否则\(x\in w_2\)</li>
<li>3) 对于2中的\(l(x)\)取自然对数的负值，决策规则可写为：<br>如果\(h(x)=-\ln[l(x)]=-\ln P(x|w_1)+\ln P(x|w_2)&lt;\ln\frac{P(w_1)}{P(w_2)}\)，则\(x\in w_1\)，否则就判定\(x\in w_2\)</li>
</ul>
<p>以上为两个类别且模式只有一个特征的情况，考虑多个类别并且模式具有多个特征情况下的最小错误率贝叶斯决策规则：<br>设\(\Omega=\{w_1,w_2,\ldots,w_c\}\)是c个类别状态的有限集合，特征向量X是d维随机向量，\(P(X|w_i)\)是模式向量X在\(w_i\)状态下的类条件概率密度，\(P(w_i)\)为\(w_i\)类的先验概率，则根据贝叶斯公式，后验概率\(P(w_i|X)=\frac{P(X|w_i)}{P(X)}P(w_i)\)，其中：\(P(X)=\sum_{j=1}^cP(X|w_j)P(w_j)\)。这时最小错误率的贝叶斯决策法为：如果存在\(P(w_i|X)&gt;P(w_j|X)\)对于一切\(i\neq j\)成立，则决策为\(w_i\)<br>需要注意的是：<br>当我们考虑一个特征时，只用一个标量x表示；而对于多个特征，则要用向量X代替标量x。另外需要指出的是，如果两种类别的决策概率几近相等，而不做出决定又不太重要时，可以选择拒绝决策。</p>
<h4 id="3-2-最小风险的贝叶斯决策"><a href="#3-2-最小风险的贝叶斯决策" class="headerlink" title="3.2 最小风险的贝叶斯决策"></a>3.2 最小风险的贝叶斯决策</h4><p>从不同性质的错误会引起不同程度的损失这一考虑出发，我们宁可扩大一些总的错误率，也要使总的损失减小，因此引进一个与损失有关联的、更为广泛的概念—风险。在作出决策时，要考虑所承担的风险，最小风险的贝叶斯决策规则正是为了体现这一点而产生的，把各种分类错误引起的损失考虑进去的贝叶斯决策法则。<br>在最小错误概率的贝叶斯决策方法中，分类时的决策单纯取决于观测值X对各类的后验概率中之最大值，因而也就无法估计做出错误决策所带来的损失，为此不妨将做出判决的依据从单纯考虑后验概率最大值，改为对该观测值X条件下各状态后验概率求加权和的方式：<br>\(R_i(X)=\sum_{j=1}^c\lambda_j^{(i)}P(w_j|X)\)，式中\(\lambda_j^{(i)}\)表示观测样本X实属类别j，而被判定为状态i时所造成的损失；\(R_i(X)\)则表示了观测值X被判为i类时损失的均值。因此加权和\(R_i(X)\)衡量了观测样本X被判为状态\(w_i\)所需承担的风险。<br>下面我们给出一些确切的定义，然后讨论最小风险的贝叶斯决策规则。</p>
<ul>
<li>1)自然状态与状态空间。自然状态是指待识别对象的类别，而状态空间是由所有自然状态所组成的空间，\(\Omega=\{w_1,w_2,\cdots,w_c\}\)</li>
<li>2)决策与决策空间。在决策论中，对分类问题所做的判决，称之为决策，由所有决策组成的空间称为决策空间。决策不仅包括根据观测值将样本划归哪一类别(状态)，还可以包括其他决策，如”拒绝”等，因此决策空间内决策总数可以不等于类别数c，表示成如下形式：<br>\(A=\{\alpha_1,\alpha_2,\cdots,\alpha_a\}\)</li>
<li>3)损失函数\(\lambda(\alpha_i|w_j)\)，也记为\(\lambda(\alpha_i,w_j)\)，这就是我们前面引用的\(\lambda_j^{(i)}\)，它明确表示对自然状态\(w_j\)做出决策\(\alpha_i\)时所造成的损失</li>
<li>4)观测值X条件下的期望损失。\(R(\alpha_i|X)=\sum_{j=1}^c\lambda(\alpha_i|w_j)P(w_j|x),i=1,2,3,\ldots,\alpha\) 也称为条件风险</li>
</ul>
<p>每一个决策都会带来损失，通常它是决策和自然状态的函数，可以用决策表来表示其关系<br>对于实际问题，最小风险的贝叶斯决策可按下列步骤进行：</p>
<ul>
<li>1)根据贝叶斯公式计算后验概率</li>
<li>2)根据后验概率和决策表，计算出各个决策的条件风险</li>
<li>3)找出使条件风险最小的决策，就是最小风险贝叶斯决策<br>对于二类问题：<br>$$<br>\begin{equation}<br>\begin{cases}<br>R(\alpha_1|X)=\lambda_{11}P(w_1|X)+\lambda_{12}P(w_2|X) \\<br>R(\alpha_2|X)=\lambda_{21}P(w_1|X)+\lambda_{22}P(w_2|X)<br>\end{cases}<br>\nonumber<br>\end{equation}<br>$$<br>其中\(\lambda_{ij}=\lambda(\alpha_i,w_j)\)，若\(R(\alpha_1|X)&lt;R(\alpha_2|X)\)，则判定\(w_1\)为真正状态，否则为\(w_2\)<br>也可以用先验概率和类条件概率密度之积替代后验概率,得到其他形式</li>
</ul>
<h4 id="3-3-限定错误率的两类判别决策"><a href="#3-3-限定错误率的两类判别决策" class="headerlink" title="3.3 限定错误率的两类判别决策"></a>3.3 限定错误率的两类判别决策</h4><p>在两类判别决策问题中，有两种错误分类的可能。实际中，有时要求限制其中一类错误率为某个常数，而另一类错误率尽可能小，这就是所谓Neyman-Pearson决策要解决的问题。</p>
<h4 id="3-4-最大最小决策"><a href="#3-4-最大最小决策" class="headerlink" title="3.4 最大最小决策"></a>3.4 最大最小决策</h4><p>最小错误率和最小风险贝叶斯决策的决策都是与先验概率有关的，对给定的x，其P(wi)不变。如果P(wi)可变或者先验概率未知，再按照某个固定的P(wi)条件下的决策规则进行决策就往往得不到最小的错误率或风险。最大最小决策就是希望考虑在P(wi)变化的情况下，使最大可能的风险最小，即在最差条件下争取最好的结果</p>
<h3 id="4-分类器设计"><a href="#4-分类器设计" class="headerlink" title="4. 分类器设计"></a>4. 分类器设计</h3><p>分类器设计实质上是在描述待识别对象的d维特征所组成的特征空间内，将其划分为c个决策域。决策域的边界面称为决策面，在数学上用解析形式表示成决策面方程，用于表达决策规则的某些函数称为判别函数。显然判别函数与决策面方程式密切相关的，并且都由相关决策规则确定的。<br>判别函数：对于d维特征空间中的c个模式类别，各给出一个由d个特征组成的单值函数，称为判别函数。在c类的情况下，我们共有c个判别函数，分别对应c个模式类</p>
<h3 id="5-正态分布时的统计决策"><a href="#5-正态分布时的统计决策" class="headerlink" title="5. 正态分布时的统计决策"></a>5. 正态分布时的统计决策</h3><p>正太分布假设是对各种随机变量使用得最普遍的假设。</p>
<h4 id="5-1-单变量正态分布概率密度函数"><a href="#5-1-单变量正态分布概率密度函数" class="headerlink" title="5.1 单变量正态分布概率密度函数"></a>5.1 单变量正态分布概率密度函数</h4><p>\(p(x)=\frac{1}{\sqrt{2\pi}\sigma}\exp\left[-\frac{1}{2}(\frac{x-\mu}{\sigma})^2\right]\)</p>
<h4 id="5-2-多元正太分布概率密度函数"><a href="#5-2-多元正太分布概率密度函数" class="headerlink" title="5.2 多元正太分布概率密度函数"></a>5.2 多元正太分布概率密度函数</h4><p>\(p(x)=\frac{1}{(2\pi)^{\frac{d}{2}}|\Sigma|^{\frac{1}{2}}}\exp\left[-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)\right]\)<br>其中\(\Sigma\)是\(d\times d\)维协方差矩阵，是个半正定的对称矩阵：<br>\(\Sigma=\begin{bmatrix}<br>\sigma_{11}^2 &amp; \sigma_{12}^2 &amp; \cdots &amp; \sigma_{1d}^2 \\<br>\sigma_{21}^2 &amp; \sigma_{22}^2 &amp; \cdots &amp; \sigma_{2d}^2 \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>\sigma_{d1}^2 &amp; \sigma_{d2}^2 &amp; \cdots &amp; \sigma_{dd}^2<br>\end{bmatrix}\)<br>通常将上式简记为：\(p(x)\sim N(\mu,\sigma)\)，其中\(\mu=E[x]=(\mu_1,\mu_2,\ldots,\mu_d)^T\)</p>
<h4 id="5-3-多元正太分布下最小错误率贝叶斯决策"><a href="#5-3-多元正太分布下最小错误率贝叶斯决策" class="headerlink" title="5.3 多元正太分布下最小错误率贝叶斯决策"></a>5.3 多元正太分布下最小错误率贝叶斯决策</h4><ul>
<li>第一种情况：\(\Sigma_i=\sigma^2I\)</li>
<li>第二种情况：\(\Sigma_i=\Sigma\)</li>
<li>第三种情况：\(\Sigma_i\)任意</li>
</ul>
<h3 id="6-离散情况的贝叶斯决策"><a href="#6-离散情况的贝叶斯决策" class="headerlink" title="6. 离散情况的贝叶斯决策"></a>6. 离散情况的贝叶斯决策</h3><h3 id="7-概率密度函数估计"><a href="#7-概率密度函数估计" class="headerlink" title="7. 概率密度函数估计"></a>7. 概率密度函数估计</h3><p>在前面我们都假设类条件概率密度函数是已知的，然后去设计贝叶斯分类器，但在很多情况下，类条件概率密度函数往往必须首先利用统计推断理论中的估计方法从可用的样本集数据中估计出来。从样本集推断总体概率分布主要包括以下两种方法：</p>
<h4 id="7-1-参数估计"><a href="#7-1-参数估计" class="headerlink" title="7.1 参数估计"></a>7.1 参数估计</h4><p>如果已知概率密度函数的类型(如正态分布)，而表征概率密度函数的某些参数未知(如均值和方差)，则可以利用参数估计方法</p>
<ul>
<li>最大似然估计</li>
<li>贝叶斯估计和贝叶斯学习</li>
</ul>
<h4 id="7-2-非参数估计"><a href="#7-2-非参数估计" class="headerlink" title="7.2 非参数估计"></a>7.2 非参数估计</h4><p>如果不知道概率密度函数的形式，但能估计出一些参数(如均值和方差)，则采用非参数估计方法</p>
<ul>
<li>Parzen窗法</li>
<li>Kn近邻估计法</li>
</ul>
<h3 id="8-分类错误率的计算"><a href="#8-分类错误率的计算" class="headerlink" title="8. 分类错误率的计算"></a>8. 分类错误率的计算</h3><p>对于类条件概率密度及先验概率已知的问题，当我们用指定的决策规则来进行分类时，它的错误率应是固定的。但实际中，经常遇到类条件概率密度函数的形式或其参数，甚至是类型的先验概率等都预先未知的情况，再加上训练样本的数据也具有随机性，就使得训练和判决问题变得十分复杂。这种复杂性反映在错误率上，使错误率也具有随机性。因此可以认为，错误率反应了分类问题的固有复杂性，它是分类问题复杂性的一种量度。<br>对错误率的计算或估计方法可分为以下三个方面：</p>
<ul>
<li>按理论公式计算(特殊情况才可)<ul>
<li>正态分布且协方差阵相等的情况下</li>
<li>各维为独立随机变量情况下</li>
</ul>
</li>
<li>计算错误率上界<ul>
<li>Chernoff界限</li>
<li>用Bhattacharyya系数确定的错误率上界</li>
</ul>
</li>
<li>实验估计</li>
</ul>
]]></content>
      <categories>
        <category>science</category>
        <category>ai</category>
      </categories>
      <tags>
        <tag>pattern recognition</tag>
        <tag>bayes decision</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记八</title>
    <url>/2015/10/02/reading08/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>图书馆再读舒婷</p>
<h3 id="2-致橡树"><a href="#2-致橡树" class="headerlink" title="2. 致橡树"></a>2. 致橡树</h3><blockquote>
<p>我如果爱你——<br>绝不像攀援的凌霄花，<br>借你的高枝炫耀自己：<br>我如果爱你——<br>绝不学痴情的鸟儿，<br>为绿荫重复单调的歌曲；<br>也不止像泉源，<br>常年送来清凉的慰籍；<br>也不止像险峰，增加你的高度，衬托你的威仪。<br>甚至日光。<br>甚至春雨。<br>不，这些都还不够！<br>我必须是你近旁的一株木棉，<br>做为树的形象和你站在一起。<br>根，紧握在地下，<br>叶，相触在云里。<br>每一阵风过，<br>我们都互相致意，<br>但没有人<br>听懂我们的言语。<br>你有你的铜枝铁干，<br>像刀，像剑，<br>也像戟，<br>我有我的红硕花朵，<br>像沉重的叹息，<br>又像英勇的火炬，<br>我们分担寒潮、风雷、霹雳；<br>我们共享雾霭、流岚、虹霓，<br>仿佛永远分离，<br>却又终身相依，<br>这才是伟大的爱情，<br>坚贞就在这里：<br>爱——<br>不仅爱你伟岸的身躯，<br>也爱你坚持的位置，足下的土地。</p>
</blockquote>
<a id="more"></a>
<h3 id="3-这也是一切"><a href="#3-这也是一切" class="headerlink" title="3. 这也是一切"></a>3. 这也是一切</h3><p>以前读过北岛的《一切》，内涵如何自然是见仁见智了，我只觉得太过悲凉，不过当时正是喜欢那种情绪的年纪，可是人的思想总是在不断变化的，渴望积极-&gt;享受消极-&gt;向往奋斗-&gt;安于现状-&gt;… 谁又能料到下一刻的自己处于何种状态呢。今天又看到了舒婷的《这也是一切》，虽气势上没有《一切》来得汹涌，却是更加给人以鼓舞。单纯从诗歌形式上来说，为了表达自己的观点自然需要使用一些绝对化的表述来增强感染力，所以有了北岛的《一切》，大概是因为觉得这“一切”不完美，舒婷又作此诗来补充吧，至少不是批判，舒婷在散文《生活、书籍与诗》中写到：“我非常喜欢他的诗，尤其是《一切》。”总之，这两首诗结合起来看，让我感受到一切的消极与绝望，而又给我以勇气渴望冲破这绝望，大抵如此。</p>
<blockquote><br>不是一切大树<br>    都被暴风折断，<br>不是一切种子，<br>    都找不到生根的土壤；<br>不是一切真情<br>    都流失在人心的沙漠里；<br>不是一切梦想<br>    都甘愿被折掉翅膀。<br><br>不，不是一切<br>    都像你说的那样！<br>不是一切火焰，<br>    都只燃烧自己<br>    而不把别人照亮；<br>不是一切星星，<br>    都仅指示黑夜<br>    而不报告曙光；<br>不是一切歌声，<br>    都只掠过耳旁<br>    而不留在心上。<br><br>不，不是一切<br>    都像你说的那样！<br><br>不是一切呼吁都没有回响；<br>不是一切损失都无法补偿；<br>不是一切深渊都是灭亡；<br>不是一切灭亡都覆盖在弱者头上；<br>不是一切心灵<br>    都可以踩在脚下，烂在泥里；<br>不是一切后果<br>    都是眼泪血印，而不展现欢容。<br><br>一切的现在都孕育着未来，<br>未来的一切都生长于它的昨天。<br>希望，而且为它斗争，<br>请把这一切放在你的肩上。<br></blockquote>


<h3 id="4-中秋夜"><a href="#4-中秋夜" class="headerlink" title="4. 中秋夜"></a>4. 中秋夜</h3><p>前几天刚过完中秋，此时看到舒婷的这首《中秋夜》倒也还算应景。</p>
<blockquote><br>海岛八月中秋<br>芭蕉摇摇<br>龙眼熟坠<br>不知有“花朝月夕”<br>只因年来风雨见多<br>当激情招来十级风暴<br>心，不知在哪里停泊<br><br>道路已经选择<br>没有蔷薇花<br>并不曾后悔过<br>人在月光里容易梦游<br>渴望得到也懂得温柔<br>要使血不这样奔流<br>凭二十四岁的骄傲显然不够<br><br>要有坚实的肩膀<br>能靠上疲惫的头<br>需要有一双手<br>来支持最沉重的时刻<br>尽管明白<br>生命应当完全献出去<br>留多少给自己<br>就有多少忧愁<br></blockquote>


<h3 id="5-会唱歌的鸢尾花"><a href="#5-会唱歌的鸢尾花" class="headerlink" title="5. 会唱歌的鸢尾花"></a>5. 会唱歌的鸢尾花</h3><p>这个诗名会让我联想到十年前元若蓝的一首歌“绿袖子”</p>
<blockquote><br>我的忧伤因为你的照耀<br>升起一圈淡淡的光轮<br>　　　　　　　　　　　　　　 ——题记<br><br>​一<br>　　　　在你的胸前<br>　　　　我已变成会唱歌的鸢尾花<br>　　　　你呼吸的轻风吹动我<br>　　　　在一片丁当响的月光下<br>　　　　用你宽宽的手掌<br>　　　　暂时<br>　　　　覆盖我吧<br>　　　　<br>二<br>　　　　现在我可以做梦了吗<br>　　　　雪地。大森林<br>　　　　古老的风铃和斜塔<br>　　　　我可以要一株真正的圣诞树吗<br>　　　　上面挂满<br>　　　　溜冰鞋、神笛和童话<br>　　　　焰火、喷泉般炫耀欢乐<br>　　　　我可以大笑着在街上奔跑吗<br>　　　　<br>三<br>　　　　我那小篮子呢<br>　　　　我的丰产田里长草的秋收啊<br>　　　　我那旧水壶呢<br>　　　　我的脚手架下干渴的午休啊<br>　　　　我的从未打过的蝴蝶结<br>　　　　我的英语练习：I love you，love you<br>　　　　我的街灯下折叠而又拉长的身影啊<br>　　　　我那无数次<br>　　　　流出来又咽进去的泪水啊<br>　　　　还有<br>　　　　还有<br>　　　　不要问我<br>　　　　为什么在梦中微微转侧<br>　　　　往事，像躲在墙角的蛐蛐<br>　　　　小声而固执地呜咽着<br>　　　　<br>四<br>　　　　让我做个宁静的梦吧<br>　　　　不要离开我<br>　　　　那条很短很短的街<br>　　　　我们已经走了很长很长的岁月<br>　　　　让我做个安详的梦吧<br>　　　　不要惊动我<br>　　　　别理睬那盘旋不去的鸦群<br>　　　　只要你眼中没有一丝阴云<br>　　　　让我做个荒唐的梦吧<br>　　　　不要笑话我<br>　　　　我要葱绿地每天走进你的诗行<br>　　　　又绯红地每晚回到你的身旁<br>　　　　让我做个狂悖的梦吧<br>　　　　原谅并且容忍我的专制<br>　　　　当我说：你是我的！你是我的<br>　　　　亲爱的，不要责备我……<br>　　　　我甚至渴望<br>　　　　涌起热情的千万层浪头<br>　　　　千万次把你淹没<br>　　　　<br>五<br>　　　　当我们头挨着头<br>　　　　像乘着向月球去的高速列车<br>　　　　世界发出尖锐的啸声向后倒去<br>　　　　时间疯狂地旋转<br>　　　　雪崩似地纷纷摔落<br>　　　　当我们悄悄对视<br>　　　　灵魂像一片画展中的田野<br>　　　　一涡儿一涡儿阳光<br>　　　　吸引我们向更深处走去<br>　　　　寂静、充实、和谐<br>　　　　<br>六<br>　　　　就这样<br>　　　　握着手坐在黑暗里<br>　　　　听任那古老而又年轻的声音<br>　　　　在我们心中穿来穿去<br>　　　　即使有个帝王前来敲门<br>　　　　你也不必搭理<br>　　　　但是……<br>　　　　<br>七<br>　　　　等等？那是什么？什么声响<br>　　　　唤醒我血管里猩红的节拍<br>　　　　当我晕眩的时候<br>　　　　永远清醒的大海啊<br>　　　　那是什么？谁的意志<br>　　　　使我肉体和灵魂的眼睛一齐睁开<br>　　　　你要每天背起十字架<br>　　　　跟我来<br>　　　　<br>八<br>　　　　伞状的梦<br>　　　　蒲公英一般飞逝<br>　　　　四周一片环形山<br>　　　　<br>九<br>　　　　我情感的三角梅啊<br>　　　　你宁可生生灭灭<br>　　　　回到你风风雨雨的山坡<br>　　　　不要在花瓶上摇曳<br>　　　　我天性中的野天鹅啊<br>　　　　你即使负着枪伤<br>　　　　也要横越无遮拦的冬天<br>　　　　不要留恋带栏杆的春色<br>　　　　然而，我的名字和我的信念<br>　　　　已同时进入跑道<br>　　　　代表民族的某个单项纪录<br>　　　　我没有权利休息<br>　　　　生命的冲刺<br>　　　　没有终点，只有速度<br>　　　　<br>十<br>　　　　向<br>　　　　将要做出最高裁决的天空<br>　　　　我扬起脸<br>　　　　风啊，你可以把我带去<br>　　　　但我还有为自己的心<br>　　　　承认不当幸福者的权利<br>　　　　<br>十一<br>　　　　亲爱的，举起你的灯<br>　　　　照我上路<br>　　　　让我同我的诗行一起远播吧<br>　　　　理想之钟在沼地后面敲响，夜那么柔和<br>　　　　灯光和城市簇在我的臂弯里，灯光拱动着<br>　　　　让我的诗行随我继续跋涉吧<br>　　　　大道扭动触手高声叫嚷：不能通过<br>　　　　泉水纵横的土地却把路标交给了花朵<br>　　　　<br>十二<br>　　　　我走过钢齿交错的市街，走向广场<br>　　　　我走进南瓜棚、走出青稞地、深入荒原<br>　　　　生活不断铸造我<br>　　　　一边是重轭、一边是花冠<br>　　　　却没有人知道<br>　　　　我还是你的不会做算术的笨姑娘<br>　　　　无论时代的交响怎样立刻卷去我的呼应<br>　　　　你仍然能认出我那独一无二的声音<br>　　　　<br>十三<br>　　　　我站得笔直<br>　　　　无畏、骄傲，分外年轻<br>　　　　痛苦的风暴在心底<br>　　　　太阳在额前<br>　　　　我的黄皮肤光亮透明<br>　　　　我的黑头发丰洁茂盛<br>　　　　中国母亲啊<br>　　　　给你应声而来的儿女<br>　　　　重新命名<br>　　　　<br>十四<br>　　　　把我叫做你的桦树苗儿<br>　　　　你的蔚蓝的小星星吧，妈妈<br>　　　　如果子弹飞来<br>　　　　就先把我打中<br>　　　　我微笑着，眼睛分外清明地<br>　　　　从母亲的肩头慢慢滑下<br>　　　　不要哭泣了，红花草<br>　　　　血，在你的浪尖上燃烧<br>　　　　……<br>　　　　<br>十五<br>　　　　到那时候，心爱的人<br>　　　　你不要悲伤<br>　　　　虽然再没有人<br>　　　　扬起浅色衣裙<br>　　　　穿过蝉声如雨的小巷<br>　　　　来敲你的彩色玻璃窗<br>　　　　虽然再没有淘气的手<br>　　　　把闹钟拨响<br>　　　　着恼地说：现在各就各位<br>　　　　去，回到你的航线上<br>　　　　你不要在玉石的底座上<br>　　　　塑造我朴素的形象<br>　　　　更不要陪孤独的吉他<br>　　　　把日历一页一页往回翻<br>　　　　<br>十六<br>　　　　你的位置<br>　　　　在那旗帜下<br>　　　　理想使痛苦光辉<br>　　　　这是我嘱托橄榄树<br>　　　　留给你的<br>　　　　最后一句话<br>　　　　和鸽子一起来找我吧<br>　　　　在早晨来找我<br>　　　　你会从人们的爱情里<br>　　　　找到我<br>　　　　找到你的<br>　　　　会唱歌的鸢尾花<br></blockquote>]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>poetry</tag>
        <tag>舒婷</tag>
      </tags>
  </entry>
  <entry>
    <title>书单</title>
    <url>/2012/11/22/books/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="涉猎书目列表-不加筛选-供以后参考"><a href="#涉猎书目列表-不加筛选-供以后参考" class="headerlink" title="涉猎书目列表(不加筛选,供以后参考)"></a>涉猎书目列表(不加筛选,供以后参考)</h3><blockquote><br>《扫起落叶好过冬》                         林达<br>《白玉雕龙》                               古龙<br>《欢乐英雄》                               古龙<br>《萧十一郎》                               古龙<br>《多情剑客无情剑》                         古龙<br>《楚留香传奇》                             古龙<br>《大旗英雄传》                             古龙<br>《游侠录》                                 古龙<br>《月异星邪》                               古龙<br>《笑傲江湖》                               金庸<br>《天龙八部》                               金庸<br>《神雕侠侣》                               金庸<br>《流星之绊》                               东野圭吾(著),徐建雄(译)                                                南海出版社<br>《搜索方法论——优化与决策支持技术入门教程》 Edmund K.Burke,Graham Kendall(著),许莹,郭斯羽,李仁发(译)               清华大学出版社<br>《分布式实时系统》                         张凤登                                                                 科学出版社<br>《Java RESTful Web Service实战》           韩陆                                                                   机械工业出版社<br>《运筹学》                                 寇玮华                                                                 西安交通大学出版社<br>《堂吉诃德》                               Miguel de Cervantes Saavedra(著),刘京胜(译)                            中央编译出版社<br>《荷马史诗·伊利亚特》                      Homer(著),罗念生,王焕生(译)<br>《编程之魂》                               Federico Biancuzzi,Shane Warden(著) 闫怀志(译)                         电子工业出版社<br>《编译原理》                               蒋宗礼,姜守旭                                                          高等教育出版社<br>《孤独漫步者的遐想》                       Jean-Jacques Rousseau(著),钱培鑫(译)                                   译林出版社<br>《普林斯顿数学指南(共三卷)》               Timothy Gowers(著),齐民友(译)                                          科学出版社<br>《数学经验(学习版)》                       Philip J.Davis,Reuben Hersh,Elena Anne Marchisotto(著),王前(译)        大连理工大学出版社<br>《数学方法论稿(修订版)》                   张奠宙,过伯祥,方均斌,龙开奋                                            上海教育出版社<br>《超越普里瓦洛夫》                         刘培杰数学工作室(编)                                                   哈尔滨工业大学出版社<br>《黎曼博士的零点》                         Karl Sabbagh(著),汪晓勤(译)                                            上海教育出版社<a id="more"></a><br>《精通AngularJS》                          Pawel Kozlowski,Peter Bacon Darwin(著),李路(译)                        华中科技大学出版社<br>《Rails高级编程》                          Brad Ediger(著),FreeWbeel UI Team(译)                                  机械工业出版社<br>《Ruby基础教程(第4版)》                    高桥征义(著),何文斯(译)                                                人民邮电出版社<br>《最优化方法应用基础》                     卢险峰                                                                 同济大学出版社<br>《数学之美(第二版)》                       吴军                                                                   人民邮电出版社<br>《用AngularJS开发下一代Web应用》           Brad Green,Shyam Seshadri(著),大漠穷秋(译)                             电子工业出版社<br>《Effective C++(第三版)》                  Scott Meyers(著),侯捷(译)                                              电子工业出版社<br>《Pattern Recognition and Machine Learning》  Bishop                                                              Springer<br>《Introduction to Algorithms(3rd edition)》   Thomas H.Cormen                                                     The MIT Press<br>《雷达系统设计MATLAB仿真》                 Bassem R. Mahafza,Atef Z. Elsherbeni(著),朱国富,黄晓涛(译)             电子工业出版社<br>《拓扑学》                                 江辉有                                                                 机械工业出版社<br>《深入浅出MFC(第二版)》                    侯俊杰                                                                 华中科技大学出版社<br>《徒然草·方丈记》                          吉田兼好,鸭长明(著),王新禧(译)<br>《枕草子》                                 清少纳言(著),周作人(译)                                                上海人民出版社<br>《徒然草》                                 吉田兼好(著),田伟华(译)                                                湖南人民出版社<br>《舒婷精选集》                             舒婷                                                                   北京燕山出版社<br>《数学先锋:数学前沿(1950-现在)》           Michael·J.Bradley(著),蒲实(译)                                         上海科学技术文献出版社<br>《数学先锋:数学的奠基(1800-1900年)》       Michael·J.Bradley(著),杨延涛(译)                                       上海科学技术文献出版社<br>《泛函分析–理论和应用》                   Haim Brezis(著),叶东,周风(译)                                          清华大学出版社<br>《英美诗歌名篇研读》                       刘文荣                                                                 上海教育出版社<br>《泛函分析》                               Peter D.Lax(著),侯成军,王利广(译)                                      人民邮电出版社<br>《计算机操作系统实验与实践(基于Windows与Linux)》  秦明,李波                                                       清华大学出版社<br>《浮生六记》                               沈复(著),马一夫(译评)                                                  吉林文史出版社<br>《博弈论:日常生活中的博弈策略》            刘庆财                                                                 中国华侨出版社<br>《操作系统实验教程(Linux版)》              潘景昌,刘杰                                                            清华大学出版社<br>《计算机操作系统(第二版)》                 庞丽萍,阳富民                                                          人民邮电出版社<br>《模式识别》                               钟珞,潘昊,封筠,何平                                                    武汉大学出版社<br>《短码之美》                               Ozy(著),李秀银,赛丽娜(译)                                              人民邮电出版社<br>《数学思想10讲》                           张广祥                                                                 科学出版社<br>《康托的无穷的数学和哲学》                 周·道本(著),郑毓信,刘晓力(编译)                                        大连理工大学出版社<br>《隐写分析原理与应用》                     葛秀慧,田浩                                                            清华大学出版社<br>《Linux内核技术手册》                      Greg Kroab-Hartman<br>《啊哈，灵机一动》                         Martin Gardner<br>《Kali 渗透测试技术实战》                  James Board, Andrew Bindner<br>《Linux Shell脚本编程入门》                金泰龙<br>《构建嵌入式Linux系统》                    Karim Yagbmour<br>《500个世界著名数学征解问题》              冯贝叶<br>《e的密码》                                陈仁政<br>《大自然的常数》                           约翰•巴罗<br>《内核漏洞的利用与防范》                   Enrico Perla，Massimiliano Oldani<br>《音乐爱好者》                             2015年3月号<br>《无线电》                                 2014年11月<br>《只差一个谎言》                           东野圭吾<br>《纪伯伦经典诗集》                         卡里.纪伯伦<br>《C++语言的设计与演化》                    Bjarne Stroustrup<br>《MySQL实用教程(第二版)》                  郑阿奇<br>《JavaScript启示录》                       Cody Lindley<br>《复杂性思考》                             Allen B. Downey<br>《东京岛》                                 桐野夏生<br>《编程珠玑(续)》                           Jon Bentley<br>《Python编程实战》                         Mark Summerfield<br>《元明清散曲选》                           王起<br>《纯数学教程:纪念版:centenary edition》    G. H. Hardy<br>《量子力学概论:翻译版》                    David J. Griffiths<br>《理论力学》                               邵兴<br>《高等数学》                               刘光旭, 张效成, 赖学坚<br>《工程制图》                               朱廷祥, 龚斌, 苏明<br>《顾城的诗》                               顾城<br>《二十世纪中国经典散文诗》                 王光明, 孙玉石<br>《陪安东尼度过漫长岁月》                   安东尼<br>《四级标准阅读100篇》                      许淑清<br>《革命根据地史话》                         马洪武, 王明生<br>《线性代数题型综合解析与方法指导》         梁晓毅, 白云霄<br>《中国共产党史稿:1921-1949》               沙健孙<br>《陈赓大将》                               尹家民<br>《英语专业四八级词汇认知速记一本通》       王天翼<br>《全新大学英语1-6级词汇多彩联想》          黎小说<br>《大学物理学》                             黄亦斌<br>《后来……》                             纪尧姆·米索<br>《高等数学:物理类.修订版》                 文丽, 吴良<br>《门》                                     夏目漱石<br>《我是猫》                                 夏目漱石<br>《爱与生的苦恼》                           叔本华<br>《英语专业4级考试复习思路及全真模拟》      王厚平<br>《查泰莱夫人的情人》                       劳伦斯<br>《C/C++程序设计》                          郝兴伟<br>《叔本华文集.作为意志和表象的世界卷》      叔本华(Schopenhauer,A.)<br>《Photoshop CS 5平面广告设计经典108例》    麓山文化编著<br>《网页设计与制作》                         孙振业<br>《计算机网络安全》                         邓亚平<br>《动漫秀场.31,超级漫画男性角色素描技法》   黎贯宇<br>《单片机C语言和汇编语言实用开发技术》      陈洪财<br>《那些洒满阳光的日子》                     达子<br>《1978-2008哈尔滨工业大学理论力学本科期末考试题汇编》  程燕平, 王春香<br>《大学物理典型题解题思路与技巧》           王小力, 张孝林, 徐忠锋<br>《七个谎言》                               詹姆士·莱思登<br>《C和指针.第2版》                          Kenneth A. Reek<br>《年轻人最爱读的55则英文散文》             高山, 姜宗彦<br>《C语言通用范例开发金典》                  柳盛, 王国全, 沈永林<br>《大学物理学习题分析与解答》               李存志, 郑建邦, 徐忠锋<br>《标准C语言基础教程》                      Gary J. Bronson<br>《电路分析:基础理论与实用技术.第2版》      张永瑞, 周永金, 张双琦<br>《Programming in ANSI C》                  Balagurusamy, E.<br>《数据结构与STL》                          徐雅静,肖波 北京邮电大学出版社<br>《数据结构:C语言描述》                     王爱民，李杰<br>《世上另一个我》                           萨拉·帕坎南<br>《C++应用程序设计》                        Richard Johnsonbaugh, Martin Kalin<br>《Access数据库技术及应用》                 陈继锋, 苏云凤<br>《Visual Basic 2010入门经典》              Thearon Willis, Bryan Newsome<br>《Access 2007中文版从入门到精通:普及版》   颜金传, 陈德全, 黄平山<br>《Visual C++.NET程序设计例学与实践》       魏亮, 王艳玲<br>《C++面向对象程序设计》                    谭浩强<br>《考点、考题、精练一本全:会计》            注册会计师全国统一考试研究专家组编<br>《C++大学教程》                            P. J. Deitel, H. M. Deitel<br>《Visual C++ 2005入门经典》                Ivor Horton<br>《51单片机C语言应用开发技术大全.第2版》    刘坤, 赵红波, 张宪栋<br>《Dreamweaver CS 5中文版标准教程》         牛红惠, 王超英, 孙膺<br>《网页设计与网站建设完全实用手册》         孙东梅<br>《完美应用Ubuntu.第2版》                   何晓龙, 李明<br>《网页设计与网站建设完全实用手册》         孙东梅<br>《离散数学及其应用》                       Kenneth H. Rosen<br>《Linux操作系统.第2版》                    邵国金<br>《新世纪日本语教程自学指南》               李遇玫<br>《新日本语》                               斎藤里美, 李思纯<br>《ACM国际大学生程序设计竞赛:题目与解读》   俞勇<br>《电路分析基础》                           刘景夏<br>《复变函数与积分变换》                     刘西民, 卢玉峰, 李崇君<br>《MATLAB 2009从入门到精通》                崔智全<br>《复变函数与积分变换》                     刘明华, 周晖杰<br>《Android应用开发入门》                    Wallace Jackson<br>《新编综合日语》                           陈俊英<br>《嵌入式Linux操作系统原理与应用》          文全刚<br>《基于PROTEUS的电路及单片机设计与仿真》    张涵<br>《PHP编程基础与实例教程》                  孔祥盛<br>《PHP与MySQL程序设计》                     W. Jason Gilmore<br>《MySQL高效编程》                          王志刚, 江友华<br>《Android进阶实践》                        蔺华, 时允田<br>《Java 7程序设计》                         Budi Kurniawan<br>《JavaScript基础教程》                     Tom Negrino, Dori Smith<br>《4周攻克雅思词汇周计划》                  詹圣麒<br>《JavaScript设计与开发新思维:develop &amp; design》  Larry Ullman<br>《深入理解Java Web开发技术:探索基于主流框架的最佳组合》  谭贞军<br>《单片机原理、应用与PROTEUS仿真.第2版》    张靖武, 周灵彬, 方曙光<br>《Photoshop CS 5完全学习手册》             前沿文化编著<br>《轻松玩转jQuery》                         蓝健<br>《HTML5开发手册》                          Chuck Hudson, Tom Leadbetter<br>《新参者》                                 东野圭吾<br>《加密与解密实战攻略》                     郭栋, 孙锋, 唐植明<br>《十日谈》                                 Giovanni Boccaccio(著),方平,王科一(译)                                 上海译文出版社<br>《Android应用开发深入学习实录》            关立勋<br>《JavaScript基础教程》                     Tom Negrino, Dori Smith<br>《模拟电子技术》                           陈永强, 魏金成, 吴昌东<br>《精通MATLAB GUI设计》                     陈垚光<br>《MATLAB小波分析.第2版》                   张德丰<br>《论美国的民主》                           托克维尔<br>《古典音乐初烧必读》                       许丽雯<br>《自动控制原理》                           卢京潮<br>《失踪者》                                 折原一<br>《自动控制元件》                           葛伟亮<br>《黑客反汇编揭秘》                         Kris Kaspersky<br>《Web安全测试》                            Paco Hope, Ben Waltber<br>《追忆似水年华.第一卷,在斯万家这边》       M. 普鲁斯特<br>《SolidWorks 2012中文版入门与提高》        张云杰, 李玉庆<br>《自动控制原理》                           张爱民<br>《电机学学习指导》                         孙旭东, 王善铭<br>《易学Python》                             Anthony Briggs<br>《深入HTML 5应用开发》                     Anthony T. Holdener, Mario Andres Pagella<br>《Python灰帽子:黑客与逆向工程师的Python编程之道:python programming for hackers and reverse engineers》  Justin Seitz<br>《IDA Pro权威指南:the unofficial guide to the world’s most popular disassembler》  Chris Eagle<br>《ARM嵌入式系统基础教程》                  周立功<br>《数据结构:Java语言描述》                  刘小晶, 杜选<br>《数据结构实例解析与实验指导:Java语言描述》  刘小晶<br>《程序员面试攻略.第2版》                   John Mongan, Noah Suojanen, Eric Giguere<br>《数据结构:C++版》                         吴小平, 马桂媛<br></blockquote>
]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>favorite</tag>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title>日语学习一</title>
    <url>/2017/09/16/japanese01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>————<strong>更新于2017.09.16</strong>————<br>种种原因（其实是一时冲动），报了12月份的JLPT N2，明知时间很紧，难以通过，但这正是我需要的吧，有个短期内想要完成的目标，为此花上所有胡思乱想的时间，それでいい…<br>语法和单词是并行着学的，虽然有标准日本语的书籍，但是没有使用，语法主要是参考<a href="http://res.wokanxing.info/jpgramma/hiragana.html" target="_blank" rel="noopener">日语语法指南</a><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Tae. “平假名.” 日语语法指南 | Learn Japanese, http://res.wokanxing.info/jpgramma/hiragana.html.
">[1]</span></a></sup>学习的，单词目前使用的是<a href="https://cichang.hujiang.com/home/" target="_blank" rel="noopener">沪江开心词场</a>。<br>学日语当然得听日语歌啦，于是将以前收藏的歌汇总做了个<a href="http://www.xiami.com/collect/354265681" target="_blank" rel="noopener">歌单</a>。</p>

    <div id="aplayer-DZEoWUAB" class="aplayer aplayer-tag-marker meting-tag-marker"
         data-id="354265681" data-server="xiami" data-type="playlist" data-mode="circulation" data-autoplay="true" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"
    ></div>
<p>本文主要整理了九月上半月的语法学习知识。</p>
<p>————<strong>更新于2018.05.20</strong>————<br>对于日语的学习，有了新的思考和认识，就推倒原来的结构重新写了一遍。<br>首先介绍下语言学，语言学是一门一直在不断发展的学科，在现代语言学诞生之前，语法研究的方法和观念通常被概括为传统语法，或者也可以说只有语法学而没有系统的语言学，据Wiki所述，现代的语言学建立于18世纪初期，是随着历史比较语言学的出现的，Kino觉得自此之后，语言学就开始逐渐成为一项成体系、跨学科的科学研究了。<br>现代语言学的发展过程种又先后出现了各种学派，其对语法的研究方式、分类方式也各有不同，例如有新语法学派、结构主义学派、生成与法学派和功能主义学派等。(画外音: 作为一名码农, 应该多少也会听过乔姆斯基的大名, 其提出的转换生成语法开创了生成语法学派, 虽然在语言学界饱受争议, 在程序语言中倒是应用广泛…)<br>当然语言学也并不只是包括语法内容，如音韵、词法、句法等，当然这根据不同的分类方法有不同的结果，广义的语法也可以把词法、句法包含在内。<br>彻底系统地学习这些内容太过繁杂，Kino也并不是语言理论专业的，故建立的日语学习体系肯定没那么严谨，可能跨越了多个学派的方法，杂糅了多学派间的内容，涉及了不同学派的术语，后续的文章中，因为当时的写作状态、相应信息的查询难易度等影响，不是每一章的内容都考察了其学派出处，若有知情者可以给Kino提出建议，Kino会尽快修改。<br><a id="more"></a></p>
<p>Kino的整个日语学习系统划分如下图所示：<br><img src="/images/japanese01_0.png" alt="japanese_system"></p>
<h2 id="1-学习工具"><a href="#1-学习工具" class="headerlink" title="1. 学习工具"></a>1. 学习工具</h2><p>本章主要介绍一些日语学习中可能用到的工具。</p>
<h3 id="1-1-日语单词"><a href="#1-1-日语单词" class="headerlink" title="1.1 日语单词"></a>1.1 日语单词</h3><p>专门学习日语的app大多数都不提供记忆曲线功能，不提供记忆曲线但有自己独特优势的app有<a href="http://www.xuewujing.com/" target="_blank" rel="noopener">最最日语</a>、<a href="https://play.google.com/store/apps/details?id=com.PEP.biaori&amp;hl=en" target="_blank" rel="noopener">标准日本语</a>、<a href="https://play.google.com/store/apps/details?id=io.github.nekotachi.easynews" target="_blank" rel="noopener">NHK日本語</a>，可以辅助用。<br>提供记忆曲线的日语单词记忆app有<a href="https://soukaapp.com/" target="_blank" rel="noopener">souka</a>、<a href="http://app.mi.com/details?id=com.kakajapan.word" target="_blank" rel="noopener">卡卡日语</a>，但是总觉得设计不太合理，Kino用的不是特别习惯。<br>不专门针对日语学习的记忆卡片类应用<a href="https://apps.ankiweb.net/" target="_blank" rel="noopener">anki</a>，用来自己随手制作卡片很好，但是想拿到直接使用需要找到合适的词库。<br>词典类的app有<a href="https://play.google.com/store/apps/details?id=com.renzo.japanese" target="_blank" rel="noopener">Japanese</a>、<a href="https://play.google.com/store/apps/details?id=com.mojitec.mojidict&amp;hl=en" target="_blank" rel="noopener">MOJi辞書</a>、<a href="https://www.eudic.net/v4/en/app/eudic" target="_blank" rel="noopener">欧路词典</a><br>此外，还可以下载一些日语母语者常用的app玩耍，如新闻类的SmartNews，可以设置只看日语新闻，菜谱类的Delish Kitchen(Google play上不经意间看到的)等。<br>————<strong>更新于2020.05.02</strong>————<br>最近发现”最最日语”把”最最剧场”拆分成了一个新的APP, 强烈推荐！最最日语本身完全可以不用, 但是用”最最剧场”练习口语非常棒！</p>
<h3 id="1-2-语法"><a href="#1-2-语法" class="headerlink" title="1.2 语法"></a>1.2 语法</h3><p>还是有参考之前的<a href="http://res.wokanxing.info/jpgramma/hiragana.html" target="_blank" rel="noopener">日语语法指南</a><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Tae. “平假名.” 日语语法指南 | Learn Japanese, http://res.wokanxing.info/jpgramma/hiragana.html.
">[1]</span></a></sup>，随手查阅和复习还是很实用的，进一步的语法学习参考了维基百科相关内容和参考书<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="马兰英, 孙海英, and 徐莲. 日语语法专题教程. 浙江工商大学出版社, 2016.
">[2]</span></a></sup>。</p>
<h2 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h2><p>这一章Kino挑选了一些重点概念进行介绍，主要是为了方便对后续文章的理解。</p>
<h3 id="2-1-语法范畴"><a href="#2-1-语法范畴" class="headerlink" title="2.1 语法范畴"></a>2.1 语法范畴</h3><p>这一节介绍了维基中文上的<a href="https://zh.wikipedia.org/wiki/%E8%AF%AD%E6%B3%95%E8%8C%83%E7%95%B4" target="_blank" rel="noopener">语法范畴</a><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “语法范畴.” Wikipedia, Wikimedia Foundation, 29 Apr. 2018, https://zh.wikipedia.org/wiki/语法范畴.
">[3]</span></a></sup>词条的内容，当然从参考文献看该内容的最原始出处该是<em>Features: Perspectives on a key notion in linguistics</em>。<br>语法范畴的常见归类有:</p>
<ul>
<li>性(genus): 是指一个名词或代词的类别，以及形容词、冠词或动词在与名词或代词搭配时发生的屈折变化。<a href="https://en.wikipedia.org/wiki/Grammatical_gender" target="_blank" rel="noopener">英文对照参考</a></li>
<li>数(number): 在语言学中，名词、代词、形容词、动词都有数的区别。一般分为单数和众数（复数），但是部分的语言亦具有双数（例如阿拉伯语），更有少数的语言具有三数（例如多罗马科语）、微数（Paucal，代表“少数的”）等。<a href="https://en.wikipedia.org/wiki/Grammatical_number" target="_blank" rel="noopener">英文对照参考</a></li>
<li>格(casus): 也叫语义格，是名词或代名词因语义角色不同而变化。<a href="https://en.wikipedia.org/wiki/Grammatical_case" target="_blank" rel="noopener">英文对照参考</a></li>
<li>时(tempus): 是表示行为发生的时间和说话时的关系。一般分为过去时、现在时、将来时，通常也有与表示动作进行或终止的进行式和完成式等体貌一起相连用的情况。注意时态和句式是两个概念，过去时、现在时、将来时不能写为“过去式”、“现在式”、“将来式”。<a href="https://en.wikipedia.org/wiki/Grammatical_tense" target="_blank" rel="noopener">英文对照参考</a></li>
<li>体(aspect): 也叫体貌/动貌，表示事件的内部时间结构，例如关于该动作的开始、持续、完成或重复等方面的情况，但不涉及该动作发生的时间。注意区分, Grammatical aspect 是指”貌”，而 Lexical aspect 是指”体”。<a href="https://en.wikipedia.org/wiki/Grammatical_aspect" target="_blank" rel="noopener">英文对照参考</a></li>
<li>式(modus): 也叫语气/语式，指通过一定的语法形式，说明动作或过程的进行方式，也就是说话者对行为或动作的态度。<a href="https://en.wikipedia.org/wiki/Grammatical_mood" target="_blank" rel="noopener">英文对照参考</a></li>
<li>态(genus verbi): 也叫语态，在语法学中描述句子中动词和参与此动作之主语之间关系的一个术语。<a href="https://en.wikipedia.org/wiki/Voice_(grammar" target="_blank" rel="noopener">英文对照参考</a>)</li>
<li>身(person): 也叫人称，是与语言中的行为动作相关的话语角色。<a href="https://en.wikipedia.org/wiki/Grammatical_person" target="_blank" rel="noopener">英文对照参考</a></li>
<li>级(comparison): 是关于形容词和副词的性质、状态在用于比较时的不同程度的语法范畴，属于比较常见的一类语法范畴。<a href="https://en.wikipedia.org/wiki/Comparison%5f%28grammar%29" target="_blank" rel="noopener">英文对照参考</a></li>
</ul>
<p>如果想了解更丰富的相关语法特性的分类，可以参考<a href="https://en.wikipedia.org/wiki/Grammatical_category" target="_blank" rel="noopener">Grammatical category</a><sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “Grammatical Category.” Wikipedia, Wikimedia Foundation, 19 June 2018, https://en.wikipedia.org/wiki/Grammatical_category.
">[4]</span></a></sup></p>
<h3 id="2-2-相关易混淆概念"><a href="#2-2-相关易混淆概念" class="headerlink" title="2.2 相关易混淆概念"></a>2.2 相关易混淆概念</h3><ul>
<li>时态: 在英语学习时，国内英语教材一般并不会对这些概念进行介绍和区分，然而英语语法学习过程中又经常提到时态，这里所说的时态其实是时(tense)和体(aspect)的综合，不是单纯的表示时(tense)，也不是时(tense)和态(voice)的综合，但是tense又常被翻译为时态，所以需要在细分这些语法概念时，区分清楚这些概念，否则就容易在学习过程中混淆。</li>
</ul>
<h3 id="2-3-Kino的碎碎念"><a href="#2-3-Kino的碎碎念" class="headerlink" title="2.3 Kino的碎碎念"></a>2.3 Kino的碎碎念</h3><p>Kino看过的大多日语语法介绍，总觉得都不够成体系，从词形变化入手，以词形变化驱动语法概念的讲解，有种学习语法就是为了方便记忆词汇变形、常用句型等的错觉，对于Kino来说这种方式容易抓不住重点，不能形成自己的理解，记忆深度也不够。<br>在Kino的理解中，语言诞生之初自然是无所谓语法概念的，在语言的发展进化过程中，渐渐出现了一些规则，提炼出这些规则就形成了语法体系，从这个角度上说，主张学习语言不需要先学习语法的说法也有其道理，语言学到了一定程度自然会对语法有所理解。但是既然语言规则已经被提炼出来，形成了系统化的语法，Kino认为，在一门第二语言的学习过程中，尽早地掌握其语法体系，可以起到事半功倍的效果，也正因如此才有了这一系列的文章。<br>Kino尝试着根据自己已经掌握的内容，和自己当前对日语的理解，构建自己的日语学习系统，对日语学习进行了系统化的划分，当然主要内容还是语法部分，希望实现以语法概念驱动词形变化等细节，使得各种变化规则是自然而然出现的。</p>
<h2 id="3-发音系统"><a href="#3-发音系统" class="headerlink" title="3. 发音系统"></a>3. 发音系统</h2><p>本章介绍了日语的发音系统，Kino根据自己当下的理解，将发音系统主要分为基本音、变化音、词调、语调四部分内容。</p>
<h3 id="3-1-基本音"><a href="#3-1-基本音" class="headerlink" title="3.1 基本音"></a>3.1 基本音</h3><p>基本音是构成日语发音的最基本单位，分为元音、拨音和辅音，其中辅音可以细分为几类。</p>
<h4 id="3-1-1-元音"><a href="#3-1-1-元音" class="headerlink" title="3.1.1 元音"></a>3.1.1 元音</h4><p>a、i、u、e、o</p>
<h4 id="3-1-2-拨音"><a href="#3-1-2-拨音" class="headerlink" title="3.1.2 拨音"></a>3.1.2 拨音</h4><p>n（ん）</p>
<h4 id="3-1-3-清辅音"><a href="#3-1-3-清辅音" class="headerlink" title="3.1.3 清辅音"></a>3.1.3 清辅音</h4><p>k、s、t、n、h、m、y、r、w</p>
<h4 id="3-1-4-浊辅音"><a href="#3-1-4-浊辅音" class="headerlink" title="3.1.4 浊辅音"></a>3.1.4 浊辅音</h4><p>g、z、d、b, 分别由k、s、t、h浊化形成</p>
<h4 id="3-1-5-半浊辅音"><a href="#3-1-5-半浊辅音" class="headerlink" title="3.1.5 半浊辅音"></a>3.1.5 半浊辅音</h4><p>p, 由h半浊化形成</p>
<h3 id="3-2-五十音图及其扩展"><a href="#3-2-五十音图及其扩展" class="headerlink" title="3.2 五十音图及其扩展"></a>3.2 五十音图及其扩展</h3><p>基本音中的元音、拨音和清辅音构成了五十音图，五十音图有两种书写方式，分别是平假名和片假名。</p>
<h4 id="3-2-1-五十音图的平假名-Hiragana-表示"><a href="#3-2-1-五十音图的平假名-Hiragana-表示" class="headerlink" title="3.2.1 五十音图的平假名(Hiragana)表示"></a>3.2.1 五十音图的平假名(Hiragana)表示</h4><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">w</th>
<th style="text-align:center">r</th>
<th style="text-align:center">y</th>
<th style="text-align:center">m</th>
<th style="text-align:center">h</th>
<th style="text-align:center">n</th>
<th style="text-align:center">t</th>
<th style="text-align:center">s</th>
<th style="text-align:center">k</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ん</td>
<td style="text-align:center">わ</td>
<td style="text-align:center">ら</td>
<td style="text-align:center">や</td>
<td style="text-align:center">ま</td>
<td style="text-align:center">は</td>
<td style="text-align:center">な</td>
<td style="text-align:center">た</td>
<td style="text-align:center">さ</td>
<td style="text-align:center">か</td>
<td style="text-align:center">あ</td>
<td style="text-align:center">a</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">ゐ*</td>
<td style="text-align:center">り</td>
<td style="text-align:center"></td>
<td style="text-align:center">み</td>
<td style="text-align:center">ひ</td>
<td style="text-align:center">に</td>
<td style="text-align:center">ち</td>
<td style="text-align:center">し</td>
<td style="text-align:center">き</td>
<td style="text-align:center">い</td>
<td style="text-align:center">i</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">る</td>
<td style="text-align:center">ゆ</td>
<td style="text-align:center">む</td>
<td style="text-align:center">ふ</td>
<td style="text-align:center">ぬ</td>
<td style="text-align:center">つ</td>
<td style="text-align:center">す</td>
<td style="text-align:center">く</td>
<td style="text-align:center">う</td>
<td style="text-align:center">u</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">ゑ*</td>
<td style="text-align:center">れ</td>
<td style="text-align:center"></td>
<td style="text-align:center">め</td>
<td style="text-align:center">へ</td>
<td style="text-align:center">ね</td>
<td style="text-align:center">て</td>
<td style="text-align:center">せ</td>
<td style="text-align:center">け</td>
<td style="text-align:center">え</td>
<td style="text-align:center">e</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">を</td>
<td style="text-align:center">ろ</td>
<td style="text-align:center">よ</td>
<td style="text-align:center">も</td>
<td style="text-align:center">ほ</td>
<td style="text-align:center">の</td>
<td style="text-align:center">と</td>
<td style="text-align:center">そ</td>
<td style="text-align:center">こ</td>
<td style="text-align:center">お</td>
<td style="text-align:center">o</td>
</tr>
</tbody>
</table>
<h4 id="3-2-2-五十音图的片假名-Katakana-表示"><a href="#3-2-2-五十音图的片假名-Katakana-表示" class="headerlink" title="3.2.2 五十音图的片假名(Katakana)表示"></a>3.2.2 五十音图的片假名(Katakana)表示</h4><table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">w</th>
<th style="text-align:center">r</th>
<th style="text-align:center">y</th>
<th style="text-align:center">m</th>
<th style="text-align:center">h</th>
<th style="text-align:center">n</th>
<th style="text-align:center">t</th>
<th style="text-align:center">s</th>
<th style="text-align:center">k</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ン</td>
<td style="text-align:center">ワ</td>
<td style="text-align:center">ラ</td>
<td style="text-align:center">ヤ</td>
<td style="text-align:center">マ</td>
<td style="text-align:center">ハ</td>
<td style="text-align:center">ナ</td>
<td style="text-align:center">タ</td>
<td style="text-align:center">サ</td>
<td style="text-align:center">カ</td>
<td style="text-align:center">ア</td>
<td style="text-align:center">a</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">ヰ*</td>
<td style="text-align:center">リ</td>
<td style="text-align:center"></td>
<td style="text-align:center">ミ</td>
<td style="text-align:center">ヒ</td>
<td style="text-align:center">ニ</td>
<td style="text-align:center">チ</td>
<td style="text-align:center">シ</td>
<td style="text-align:center">キ</td>
<td style="text-align:center">イ</td>
<td style="text-align:center">i</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">ル</td>
<td style="text-align:center">ユ</td>
<td style="text-align:center">ム</td>
<td style="text-align:center">フ</td>
<td style="text-align:center">ヌ</td>
<td style="text-align:center">ツ</td>
<td style="text-align:center">ス</td>
<td style="text-align:center">ク</td>
<td style="text-align:center">ウ</td>
<td style="text-align:center">u</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">ヱ*</td>
<td style="text-align:center">レ</td>
<td style="text-align:center"></td>
<td style="text-align:center">メ</td>
<td style="text-align:center">ヘ</td>
<td style="text-align:center">ネ</td>
<td style="text-align:center">テ</td>
<td style="text-align:center">セ</td>
<td style="text-align:center">ケ</td>
<td style="text-align:center">エ</td>
<td style="text-align:center">e</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">ヲ*</td>
<td style="text-align:center">ロ</td>
<td style="text-align:center">ヨ</td>
<td style="text-align:center">モ</td>
<td style="text-align:center">ホ</td>
<td style="text-align:center">ノ</td>
<td style="text-align:center">ト</td>
<td style="text-align:center">ソ</td>
<td style="text-align:center">コ</td>
<td style="text-align:center">オ</td>
<td style="text-align:center">o</td>
</tr>
</tbody>
</table>
<h4 id="3-2-3-浊-半浊辅音和元音-拨音构成的扩展音图"><a href="#3-2-3-浊-半浊辅音和元音-拨音构成的扩展音图" class="headerlink" title="3.2.3 浊/半浊辅音和元音/拨音构成的扩展音图"></a>3.2.3 浊/半浊辅音和元音/拨音构成的扩展音图</h4><p>考虑基本音中的浊辅音、半浊辅音和元音、拨音的结合，可以够成一个扩展音图。<br>既然已经了解了平假名和片假名，这里就将两者综合在一起书写了。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">p</th>
<th style="text-align:center">b</th>
<th style="text-align:center">d</th>
<th style="text-align:center">z</th>
<th style="text-align:center">g</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ん ン</td>
<td style="text-align:center">ぱ パ</td>
<td style="text-align:center">ば バ</td>
<td style="text-align:center">だ ダ</td>
<td style="text-align:center">ざ ザ</td>
<td style="text-align:center">が ガ</td>
<td style="text-align:center">あ ア</td>
<td style="text-align:center">a</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">ぴ ピ</td>
<td style="text-align:center">び ビ</td>
<td style="text-align:center">ぢ ヂ</td>
<td style="text-align:center">じ ジ</td>
<td style="text-align:center">ぎ ギ</td>
<td style="text-align:center">い イ</td>
<td style="text-align:center">i</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">ぷ プ</td>
<td style="text-align:center">ぶ ブ</td>
<td style="text-align:center">づ ヅ</td>
<td style="text-align:center">ず ズ</td>
<td style="text-align:center">ぐ グ</td>
<td style="text-align:center">う ウ</td>
<td style="text-align:center">u</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">ぺ ぺ</td>
<td style="text-align:center">べ ベ</td>
<td style="text-align:center">で デ</td>
<td style="text-align:center">ぜ ゼ</td>
<td style="text-align:center">げ ゲ</td>
<td style="text-align:center">え エ</td>
<td style="text-align:center">e</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">ぽ ポ</td>
<td style="text-align:center">ぼ ボ</td>
<td style="text-align:center">ど ド</td>
<td style="text-align:center">ぞ ゾ</td>
<td style="text-align:center">ご ゴ</td>
<td style="text-align:center">お オ</td>
<td style="text-align:center">o</td>
</tr>
</tbody>
</table>
<h3 id="3-3-变化音"><a href="#3-3-变化音" class="headerlink" title="3.3 变化音"></a>3.3 变化音</h3><h4 id="3-3-1-长音"><a href="#3-3-1-长音" class="headerlink" title="3.3.1 长音"></a>3.3.1 长音</h4><p>长音是将假名发音延长一拍的音，基本构成规则为:</p>
<ul>
<li>Hiragana规则: / a /后加あ，/ i / e /后加い，/ u / o /后加う</li>
<li>Katagana规则: 都加 ー</li>
</ul>
<h4 id="3-3-2-促音"><a href="#3-3-2-促音" class="headerlink" title="3.3.2 促音"></a>3.3.2 促音</h4><p>促音っ为小写的つ，在单词中不发音，但是占一拍时间，发音到此时作一拍停顿，然后接后面的假名。<br>促音っ一般只出现在か行、さ行、た行、ぱ行前面</p>
<h4 id="3-3-3-拗音"><a href="#3-3-3-拗音" class="headerlink" title="3.3.3 拗音"></a>3.3.3 拗音</h4><p>拗音是将「い」段假名（い除外）和复元音「や」、「ゆ」、「よ」三个音相拼而成，在「い」段假名后面右下角加小写的「や」、「ゆ」、「よ」表示，每个拗音合起来只占一拍</p>
<h4 id="3-3-4-外来音"><a href="#3-3-4-外来音" class="headerlink" title="3.3.4 外来音"></a>3.3.4 外来音</h4><p>为了解决日语里本不存在的外来词带来的音，发明了一些新的组合。</p>
<table>
<thead>
<tr>
<th style="text-align:center">v</th>
<th style="text-align:center">w</th>
<th style="text-align:center">f</th>
<th style="text-align:center">ch</th>
<th style="text-align:center">d</th>
<th style="text-align:center">t</th>
<th style="text-align:center">j</th>
<th style="text-align:center">sh</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ヴァ</td>
<td style="text-align:center">ワ</td>
<td style="text-align:center">ファ</td>
<td style="text-align:center">チャ</td>
<td style="text-align:center">ダ</td>
<td style="text-align:center">タ</td>
<td style="text-align:center">ジャ</td>
<td style="text-align:center">シャ</td>
</tr>
<tr>
<td style="text-align:center">ヴィ</td>
<td style="text-align:center">ウィ</td>
<td style="text-align:center">フィ</td>
<td style="text-align:center">チ</td>
<td style="text-align:center">ディ</td>
<td style="text-align:center">ティ</td>
<td style="text-align:center">ジ</td>
<td style="text-align:center">シ</td>
</tr>
<tr>
<td style="text-align:center">ヴ</td>
<td style="text-align:center">ウ</td>
<td style="text-align:center">フ</td>
<td style="text-align:center">チュ</td>
<td style="text-align:center">ドゥ</td>
<td style="text-align:center">トゥ</td>
<td style="text-align:center">ジュ</td>
<td style="text-align:center">シュ</td>
</tr>
<tr>
<td style="text-align:center">ヴェ</td>
<td style="text-align:center">ウェ</td>
<td style="text-align:center">フェ</td>
<td style="text-align:center">チェ</td>
<td style="text-align:center">デ</td>
<td style="text-align:center">テ</td>
<td style="text-align:center">ジェ</td>
<td style="text-align:center">シェ</td>
</tr>
<tr>
<td style="text-align:center">ヴォ</td>
<td style="text-align:center">ウォ</td>
<td style="text-align:center">フォ</td>
<td style="text-align:center">チョ</td>
<td style="text-align:center">ド</td>
<td style="text-align:center">ト</td>
<td style="text-align:center">ジョ</td>
<td style="text-align:center">ショ</td>
</tr>
</tbody>
</table>
<h3 id="3-4-词调"><a href="#3-4-词调" class="headerlink" title="3.4 词调"></a>3.4 词调</h3><p>和汉语类似，日语中的发音也有调性，不过汉语是每个字有自己的声调，而日语的声调主要体现在词语上，当然句子上也有体现，故Kino在此将调性分为词调和句调的两大部分，这样更顾名思义。本节介绍词调，句调在下一节讲解。<br>日语用⓪、①、②、③、④、⑤等带圈数字标注词调的调型，调型的具体解释和相关注意点如下:</p>
<ul>
<li>⓪型，即平板式，全部平读，表示只有第一拍低，其他各拍都高，无下降处。后续的助词也高</li>
<li>①型，也叫头高型。表示只有第一拍高，以下各拍都低。</li>
<li>②型，表示只有第二拍高，第一拍和第三拍以下各拍都低。后续的助词也低。</li>
<li>③型，表示第二拍，第三拍高，第一拍和第四拍以下各拍都低。后续的助词也低。</li>
<li>……</li>
<li>其中②型及其之后的调型，若尾拍是高音，称之为尾高型,否则为中高型。</li>
<li>可以看出尾高型和平板型在单个词时的音调变化是相同的，区别在于其后续接助词时，尾高型需要把单词的最后一拍重读，助词降调，而平板型后的助词不需要降调。</li>
<li>当两个单词组成一个合成词时，第二个单词的第一个假名常常用重读。</li>
</ul>
<p>即词调圈中的数字是N，就表示[0,1]拍为低音，[2,N]拍为高音，[N+1,~]为低音。其中N=0和N=1比较特殊。</p>
<p>实际发音可以参考<a href="http://www.gavo.t.u-tokyo.ac.jp/ojad/" target="_blank" rel="noopener">OJAD辞書</a><sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="“Online Japanese Accent Dictionary.” Keikichi Hirose & Nobuaki Minematsu Laboratory, the University of Tokyo, http://www.gavo.t.u-tokyo.ac.jp/ojad/.
">[5]</span></a></sup></p>
<p>更多细节和注意事项可参考<a href="https://ja.wikipedia.org/wiki/%E3%82%A2%E3%82%AF%E3%82%BB%E3%83%B3%E3%83%88#%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%81%AE%E3%82%A2%E3%82%AF%E3%82%BB%E3%83%B3%E3%83%88" target="_blank" rel="noopener">日本語のアクセント</a><sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “日本語のアクセント.” Wikipedia, Wikimedia Foundation, https://ja.wikipedia.org/wiki/アクセント#日本語のアクセント.
">[6]</span></a></sup>、<a href="https://zh.wikipedia.org/wiki/%E6%97%A5%E8%AF%AD#%E5%A3%B0%E8%B0%83" target="_blank" rel="noopener">日语声调</a><sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “日语.” Wikipedia, Wikimedia Foundation, zh.wikipedia.org/wiki/日语#声调.
">[7]</span></a></sup>和<a href="https://www.zhihu.com/question/26810278" target="_blank" rel="noopener">日语声调应该如何掌握</a><sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Zhihuer. “日语声调应该如何掌握？.” 知乎, 27 Nov. 2014, https://www.zhihu.com/question/26810278.
">[8]</span></a></sup></p>
<h3 id="3-5-句调"><a href="#3-5-句调" class="headerlink" title="3.5 句调"></a>3.5 句调</h3><p>对每个句子来说，也有特定的调性，一般叫做语调，这里称之为句调。日语中的句子通常都是开始高，往后整体音高有逐渐降低的倾向。</p>
<ul>
<li>短语和陈述句的语调<br>按照开始高后面逐渐下降的原则变化，但是其中单词的词调还需要保持。此外，对于想要强调的地方，需要提高语调。</li>
<li>疑问句的语调<br>疑问句的句尾读升调。</li>
</ul>
<h2 id="4-书写系统"><a href="#4-书写系统" class="headerlink" title="4. 书写系统"></a>4. 书写系统</h2><p>本章主要介绍日语书面语常用的书写方式，主要包括汉字、假名和标点符号三部分。若想了解更多详细内容可以参考<a href="https://ja.wikipedia.org/wiki/Wikipedia:表記ガイド" target="_blank" rel="noopener">表記ガイド</a><sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “表記ガイド.” Wikipedia, Wikimedia Foundation, 1 June 2018, https://ja.wikipedia.org/wiki/Wikipedia:表記ガイド.
">[9]</span></a></sup></p>
<h3 id="4-1-汉字"><a href="#4-1-汉字" class="headerlink" title="4.1 汉字"></a>4.1 汉字</h3><p>日语里，名词、形容词词干、动词和副词基本都是用汉字写的。<br>联系到上一章，汉字在发音上，通常对应两种读法:音読み（おんよみ）和訓読み（くんよみ）</p>
<ul>
<li>音読み: 音読み是根据汉字的中国发音演变的读法。组合出现的汉字（熟語）通常用音読み发音。参考<a href="https://ja.wikipedia.org/wiki/%E9%9F%B3%E8%AA%AD%E3%81%BF" target="_blank" rel="noopener">音読み</a><sup id="fnref:10"><a href="#fn:10" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “音読み.” Wikipedia, Wikimedia Foundation, 21 Oct. 2017, ja.wikipedia.org/wiki/音読み.
">[10]</span></a></sup></li>
<li>訓読み: 訓読み是利用日本固有的音来读的方法（另一种说法是訓読み为日本自创的读法，这种说法其实是错误的，就好像日本人学了汉字之后再创造了一个对应的音，但实际上日语与汉语完全是两种语言，日本出现日语之后没有文字，于是将直接将汉字引入，汉字只是日语的一种表达方式而已）。单独的汉字一般用訓読み发音，此外形容词和动词也会用訓読み发音，但后面一般都会跟着一些假名（称为「送假名」）。参考<a href="https://ja.wikipedia.org/wiki/%E8%A8%93%E8%AA%AD%E3%81%BF" target="_blank" rel="noopener">訓読み</a><sup id="fnref:11"><a href="#fn:11" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “訓読み.” Wikipedia, Wikimedia Foundation, 1 June 2018, ja.wikipedia.org/wiki/訓読み.
">[11]</span></a></sup></li>
</ul>
<h3 id="4-2-假名"><a href="#4-2-假名" class="headerlink" title="4.2 假名"></a>4.2 假名</h3><p>第三章所有用于注音的假名同时也都可以作为书面文字使用，平假名通常用于体现语法功能，片假名通常用于外来词。<br>但是片假名还有一些特殊用法，将一句话全部用片假名书写还有<strong>加强语气（如强烈的敌意等）、表示人物大叫、强调</strong>等功能。</p>
<h3 id="4-3-标点符号（約物コード）"><a href="#4-3-标点符号（約物コード）" class="headerlink" title="4.3 标点符号（約物コード）"></a>4.3 标点符号（約物コード）</h3><p>全面的日语标点符号在<a href="https://ja.wikipedia.org/wiki/約物" target="_blank" rel="noopener">約物</a><sup id="fnref:12"><a href="#fn:12" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “約物.” Wikipedia, Wikimedia Foundation, 24 June 2018, ja.wikipedia.org/wiki/約物.
">[12]</span></a></sup>中可以查阅，该小节主要讲解常用的标点符号的常见用法。</p>
<h4 id="4-3-1-句読点（くとうてん）"><a href="#4-3-1-句読点（くとうてん）" class="headerlink" title="4.3.1 句読点（くとうてん）"></a>4.3.1 句読点（くとうてん）</h4><ul>
<li>句点。: 标在句末。会话文中的半截话（后半部省略），也标句号。需要注意的是，会话文中的句子如果在引号内，最后的句号通常不标，以及在引用简单语句时不用句号。</li>
<li>読点、: 现在日语横写时也常写作”，”（コンマ）。用于清楚地表示出词语、短语、句节间的关系，以及连接两个句子时。</li>
</ul>
<h4 id="4-3-2-中黒-・"><a href="#4-3-2-中黒-・" class="headerlink" title="4.3.2 中黒 ・"></a>4.3.2 中黒 ・</h4><ul>
<li>用来表示并列的体言</li>
<li>用来隔开两个单词构成的外来语、西洋人的名和姓</li>
<li>竖写时表示数字的小数点</li>
</ul>
<h4 id="4-3-3-疑問符・感嘆符"><a href="#4-3-3-疑問符・感嘆符" class="headerlink" title="4.3.3 疑問符・感嘆符"></a>4.3.3 疑問符・感嘆符</h4><p>这两个符号都属于外来符号。</p>
<ul>
<li>疑問符？: 用于表示疑问、发问、质问和反问等句子的句末。但在普通的文章中，原则上基本不用问号，而是用句号代替。</li>
<li>感嘆符！: 用于语调强烈的句子中表示感叹。</li>
</ul>
<h4 id="4-3-4-括弧類"><a href="#4-3-4-括弧類" class="headerlink" title="4.3.4 括弧類"></a>4.3.4 括弧類</h4><ul>
<li>鉤括弧「」: 用于表示引用部分或要求特别注意的词语。</li>
<li>丸括弧（）: 对语句加注解。</li>
<li>二重鉤括弧『』: 用于表示书名或报纸、杂志等的标题；在单引号内需要用引号表示的部分用双引号表示。<strong>即日语是鉤括弧套二重鉤括弧，「『』」，不要想当然地受双引号套单引号影响</strong></li>
</ul>
<h4 id="4-3-5-3点リーダー-…"><a href="#4-3-5-3点リーダー-…" class="headerlink" title="4.3.5 3点リーダー …"></a>4.3.5 3点リーダー …</h4><p>一般两个连用构成二倍三点リーダー ……</p>
<ul>
<li>表示会话过程中的无声状态。如: 「なるほど。……そうなのか。」</li>
<li>在行文结尾留有余韵，表达相应情感。如: そして、山へ向かった……</li>
<li>表示省略</li>
<li>……</li>
</ul>
<h4 id="4-3-6-長音符号-ー"><a href="#4-3-6-長音符号-ー" class="headerlink" title="4.3.6 長音符号 ー"></a>4.3.6 長音符号 ー</h4><p>在片假名表示长音</p>
<h4 id="4-3-7-波ダッシュ-～"><a href="#4-3-7-波ダッシュ-～" class="headerlink" title="4.3.7 波ダッシュ　～"></a>4.3.7 波ダッシュ　～</h4><p>表示地点、时间、数量等的区间范围。</p>
<h4 id="4-3-8-踊り字"><a href="#4-3-8-踊り字" class="headerlink" title="4.3.8 踊り字"></a>4.3.8 踊り字</h4><p>这是一类特殊的符号，表示代替相同文字，简化书写，具体可以参考<a href="https://ja.wikipedia.org/wiki/%E8%B8%8A%E3%82%8A%E5%AD%97" target="_blank" rel="noopener">踊り字</a><sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “踊り字.” Wikipedia, Wikimedia Foundation, 14 June 2018, ja.wikipedia.org/wiki/踊り字.">[13]</span></a></sup>。</p>
<ul>
<li>々（同の字点）: 用于代替前面的一个汉字，也是用的最多的。</li>
<li>ゝ（一の字点）: 用于代替前面的一个假名</li>
<li>〻（二の字点）: 不是用来重复前一个汉字，而是前一个汉字是训读的情况下用此强调或消歧，用于竖写排版中，写于前一个字的右下方而非正中。其实这到底是什么意思, Kino查阅有限的文献后还是难以理解, 而且现在用到的场合极少, 也可以用々代替, 就放弃研究了, 如有专业人士了解可以评论说明。Wiki上举的例子是<ul>
<li>各（おのおの）-&gt; 各〻</li>
<li>屡（しばしば）-&gt; 屡〻</li>
</ul>
</li>
<li>〱（くの字点）: 重复两个字以上的情况，用于竖写排版的情况下，如”見る見る”的重复等</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇主要对日语语法进行了总结，系统讲解了发音系统和书写系统。<a href="/2017/09/30/japanese03/">下一篇文章</a>里Kino将会介绍词类系统和句法成分的内容。</p>
<h2 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h2><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)">Tae. “平假名.” 日语语法指南 | Learn Japanese, <a href="http://res.wokanxing.info/jpgramma/hiragana.html" target="_blank" rel="noopener">http://res.wokanxing.info/jpgramma/hiragana.html</a>.<a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)">马兰英, 孙海英, and 徐莲. 日语语法专题教程. 浙江工商大学出版社, 2016.<a href="#fnref:2" rev="footnote"> ↩</a></span></div><div id="fn:3" style="display:flex"><span style="width:20px">3.</span><span style="width:calc(100% - 20px)">Wikipedians. “语法范畴.” Wikipedia, Wikimedia Foundation, 29 Apr. 2018, <a href="https://zh.wikipedia.org/wiki/语法范畴" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/语法范畴</a>.<a href="#fnref:3" rev="footnote"> ↩</a></span></div><div id="fn:4" style="display:flex"><span style="width:20px">4.</span><span style="width:calc(100% - 20px)">Wikipedians. “Grammatical Category.” Wikipedia, Wikimedia Foundation, 19 June 2018, <a href="https://en.wikipedia.org/wiki/Grammatical_category" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Grammatical_category</a>.<a href="#fnref:4" rev="footnote"> ↩</a></span></div><div id="fn:5" style="display:flex"><span style="width:20px">5.</span><span style="width:calc(100% - 20px)">“Online Japanese Accent Dictionary.” Keikichi Hirose &amp; Nobuaki Minematsu Laboratory, the University of Tokyo, <a href="http://www.gavo.t.u-tokyo.ac.jp/ojad/" target="_blank" rel="noopener">http://www.gavo.t.u-tokyo.ac.jp/ojad/</a>.<a href="#fnref:5" rev="footnote"> ↩</a></span></div><div id="fn:6" style="display:flex"><span style="width:20px">6.</span><span style="width:calc(100% - 20px)">Wikipedians. “日本語のアクセント.” Wikipedia, Wikimedia Foundation, <a href="https://ja.wikipedia.org/wiki/アクセント#日本語のアクセント" target="_blank" rel="noopener">https://ja.wikipedia.org/wiki/アクセント#日本語のアクセント</a>.<a href="#fnref:6" rev="footnote"> ↩</a></span></div><div id="fn:7" style="display:flex"><span style="width:20px">7.</span><span style="width:calc(100% - 20px)">Wikipedians. “日语.” Wikipedia, Wikimedia Foundation, zh.wikipedia.org/wiki/日语#声调.<a href="#fnref:7" rev="footnote"> ↩</a></span></div><div id="fn:8" style="display:flex"><span style="width:20px">8.</span><span style="width:calc(100% - 20px)">Zhihuer. “日语声调应该如何掌握？.” 知乎, 27 Nov. 2014, <a href="https://www.zhihu.com/question/26810278" target="_blank" rel="noopener">https://www.zhihu.com/question/26810278</a>.<a href="#fnref:8" rev="footnote"> ↩</a></span></div><div id="fn:9" style="display:flex"><span style="width:20px">9.</span><span style="width:calc(100% - 20px)">Wikipedians. “表記ガイド.” Wikipedia, Wikimedia Foundation, 1 June 2018, <a href="https://ja.wikipedia.org/wiki/Wikipedia:表記ガイド" target="_blank" rel="noopener">https://ja.wikipedia.org/wiki/Wikipedia:表記ガイド</a>.<a href="#fnref:9" rev="footnote"> ↩</a></span></div><div id="fn:10" style="display:flex"><span style="width:20px">10.</span><span style="width:calc(100% - 20px)">Wikipedians. “音読み.” Wikipedia, Wikimedia Foundation, 21 Oct. 2017, ja.wikipedia.org/wiki/音読み.<a href="#fnref:10" rev="footnote"> ↩</a></span></div><div id="fn:11" style="display:flex"><span style="width:20px">11.</span><span style="width:calc(100% - 20px)">Wikipedians. “訓読み.” Wikipedia, Wikimedia Foundation, 1 June 2018, ja.wikipedia.org/wiki/訓読み.<a href="#fnref:11" rev="footnote"> ↩</a></span></div><div id="fn:12" style="display:flex"><span style="width:20px">12.</span><span style="width:calc(100% - 20px)">Wikipedians. “約物.” Wikipedia, Wikimedia Foundation, 24 June 2018, ja.wikipedia.org/wiki/約物.<a href="#fnref:12" rev="footnote"> ↩</a></span></div><div id="fn:13" style="display:flex"><span style="width:20px">13.</span><span style="width:calc(100% - 20px)">Wikipedians. “踊り字.” Wikipedia, Wikimedia Foundation, 14 June 2018, ja.wikipedia.org/wiki/踊り字.<a href="#fnref:13" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>humanities</category>
        <category>languages</category>
      </categories>
      <tags>
        <tag>japanese</tag>
      </tags>
  </entry>
  <entry>
    <title>日语学习八</title>
    <url>/2018/06/29/japanese09/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇介绍了敬语系统，这一章主要介绍日语中的复合句。日语中复句的相关概念在维基百科上有複文<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. 複文. Wikipedia, Wikimedia Foundation, 16 Apr. 2018, ja.wikipedia.org/wiki/複文.
">[1]</span></a></sup>和節<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. 節 (文法). Wikipedia, Wikimedia Foundation, 18 Apr. 2018, ja.wikipedia.org/wiki/節_(文法).
">[2]</span></a></sup>等。<br>区别简单句和复合句的主要标志是看它主谓关系的次数，主谓关系在语法上仅成立一次的句子叫做单句。反之，句中有两层或两层以上主谓关系的就可成为复合句。简单句与复合句的区别决不是以句子长短、单词多少而定。常常是句子很长的是简单句；句子很短，但具有两层以上主谓关系的都是复合句。</p>
<a id="more"></a>
<h2 id="1-分类和结构"><a href="#1-分类和结构" class="headerlink" title="1. 分类和结构"></a>1. 分类和结构</h2><p>根据日语复句<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="henry19931224. 日语复句. 百度文库, 16 Nov. 2011, wenku.baidu.com/view/bfe202d0b14e852458fb5731.html.
">[3]</span></a></sup>、试论日语的复合句<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="谢秀忱. 试论日语的复合句. 现代外语 3(1982):33-38.
">[4]</span></a></sup>和试论日语复句中从属句节的多层立体结构<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="吴春竹. 试论日语复句中从属句节的多层立体结构. 外语学刊 6(2008):49-52.
">[5]</span></a></sup>等文献，可以对日语的分类和结构做出相应总结。<br>日语中存在着大量的复合句，其联系手段都是不相同的。根据联系手段的不同，大致可把日语复合句分为三大类。</p>
<h3 id="1-1-包孕句"><a href="#1-1-包孕句" class="headerlink" title="1.1 包孕句"></a>1.1 包孕句</h3><p>句子中的主谓宾补定状的某一个成份或者某几个成份是用主谓结构形成的，这样的句子叫包孕句。每一个顶替句子成份的主谓结构，称为从句，所以有“主语从句”“谓语从句”“宾语从句”“定语从句”“补语从句”等。其中“主语从句”“宾语从句”“补语从句”等常是主谓结构＋形式体言の构成。<br>形式体言“こと”“もの”“の”虽然本身没有固定的词意，但可充当句中各种成份，可把它们分别放在主语、宾语、补语等位置上，用来充当句中相应的各种不同的成分，不过必须在形式体言前面有其说明内容的句子或词组，相当于汉语的包孕句的结构。下面是不同的从句类型及相关示例，{}为各种从句内容。</p>
<h4 id="1-1-1-主语从句"><a href="#1-1-1-主语从句" class="headerlink" title="1.1.1 主语从句"></a>1.1.1 主语从句</h4><p>{魚が泳いでいるのが}見えます。<br>{向こうから来るのが}李さんです。<br>{この問題をどうやって解「と」くか}、分かりますか。<br>{私が買いたいのは}これです。</p>
<h4 id="1-1-2-谓语从句"><a href="#1-1-2-谓语从句" class="headerlink" title="1.1.2 谓语从句"></a>1.1.2 谓语从句</h4><p>即在句子中做述語成分<br>わが国は{土地が広いです}。<br>山田さんは{中国語が上手です}。<br>私は{息子「むすこ」が二人います}。</p>
<h4 id="1-1-3-宾语从句"><a href="#1-1-3-宾语从句" class="headerlink" title="1.1.3 宾语从句"></a>1.1.3 宾语从句</h4><p>即在句子中做对象语和目的语成分<br>電車が来たらまず{人が降りるのを}待ちます。<br>教師は{学生が一人一人本を読むのを}聞いています。<br>私は{王さんがどこへ行ったか}知りません。</p>
<h4 id="1-1-4-状语从句"><a href="#1-1-4-状语从句" class="headerlink" title="1.1.4 状语从句"></a>1.1.4 状语从句</h4><p>即在句子中做连用修饰语成分<br>今回の試験は{頭が痛くなるほど}難しいです。<br>私は{王さんが言ったとおり}やりましたが、成功しませんでした。<br>私たちの生活は{国が発展するにしたがって}良くなっていく。</p>
<h4 id="1-1-5-定语从句"><a href="#1-1-5-定语从句" class="headerlink" title="1.1.5 定语从句"></a>1.1.5 定语从句</h4><p>即在句子中做连体修饰语成分<br>{私が買いたい}辞書はこの日中辞典です。<br>ここは{私が勉強している}大学です。<br>{私が大学を卒業した}時、姉は25歳でした。</p>
<h4 id="1-1-6-补语从句"><a href="#1-1-6-补语从句" class="headerlink" title="1.1.6 补语从句"></a>1.1.6 补语从句</h4><p>私はその時まで{日本の映画館は全部指定席だと}思っていたのです。<br>私は{子供たちは立派な将来があると}考える。</p>
<h3 id="1-2-主从句"><a href="#1-2-主从句" class="headerlink" title="1.2 主从句"></a>1.2 主从句</h3><p>在这类复合句中，分句与分句之间的关系不是平等并列的，而是有主有从的。一般从句在前，独立于主句之外，主句在后，形成两层或两层以上的主谓关系，以各种接续助词、助动词、形式体言或用言的各种活用形、惯用形等作为联系手段，把前后两个不同的分句连结起来。根据不同意义的连接手段，可把主从句分为原因、结果、条件等从句。<br>主句和从句可以各有自己的主语，也可以通用一个主语；不同的主语时一般情况下，从句主语用が，主句主语用は（有违反此规则的时候）；通用主语的情况下，主语用は，其位置在句子的最前面。另外，接续助词与从句连接时，不同的接续助词有不同的活用形要求，请注意。</p>
<h4 id="1-2-1-状态从句"><a href="#1-2-1-状态从句" class="headerlink" title="1.2.1 状态从句"></a>1.2.1 状态从句</h4><p>表示同时发生的状态，“一边…一边…”<br>私は{テレビを見ながら}食事をする。<br>政府「せいふ」は{都市の発展を促進「そくしん」しつつ}、環境「かんきょう」も改善「かいぜん」していく。</p>
<h4 id="1-2-2-让步从句"><a href="#1-2-2-让步从句" class="headerlink" title="1.2.2 让步从句"></a>1.2.2 让步从句</h4><p>表示“虽然、即使、要是…就好了”等<br>{雨が降っているが}、訓練は中止しない。<br>{雨が降っても}、訓練は中止しない。<br>{君がもう少し早く来たらよかったのに}、バスはもう出てしまった。<br>{自分がいくらできるとも}、油断は大敵「たいてき」だ。<br>彼は{知っているくせに}、知らない振りをしている。</p>
<h4 id="1-2-3-条件从句"><a href="#1-2-3-条件从句" class="headerlink" title="1.2.3 条件从句"></a>1.2.3 条件从句</h4><p>日语中存在着一些用各种活用形加上不同的助词、助动词连接起来的条件从句。这种句子的意义，相当于汉语的“只要/一旦/如果/假如…就…”。 归纳起来有四种表现方法。</p>
<h5 id="1-2-3-1-「と」"><a href="#1-2-3-1-「と」" class="headerlink" title="1.2.3.1 「と」"></a>1.2.3.1 「と」</h5><p>主要表示客观上的事实，客观性较强，表示两种动作相继发生。<br>使用条件语「と」的规则:</p>
<ul>
<li>把「と」加到条件后面，再跟上满足了条件会发生的结果: [ 条件 ] + と + [ 结果 ]</li>
<li>状态表示必须显式声明: [ 状态 ] + だと + [ 结果 ]</li>
</ul>
<p>例句:</p>
<ul>
<li>学校に行かないと友達と会えないよ</li>
<li>たくさん食べると太るよ</li>
</ul>
<h5 id="1-2-3-2「なら-ば-」"><a href="#1-2-3-2「なら-ば-」" class="headerlink" title="1.2.3.2「なら(ば)」"></a>1.2.3.2「なら(ば)」</h5><p>使用前提条件语「なら」的规则:</p>
<ul>
<li>把「なら」加在前提条件后面: [ 假设会发生的前提条件 ] + なら + [ 结果 ]</li>
<li>不能加表陈述的「だ」</li>
</ul>
<p>也可以用「ならば」替代「なら」，两者意思完全一样，但前者让人感觉更正式。<br>例句:</p>
<ul>
<li>みんなが行くなら私も行く</li>
<li>アリスさんが言うなら問題ないよ</li>
</ul>
<h5 id="1-2-3-3「ば」"><a href="#1-2-3-3「ば」" class="headerlink" title="1.2.3.3「ば」"></a>1.2.3.3「ば」</h5><p>这种条件语是通用的，它不预设条件，也没有蕴含的意思。<br>「ば」条件语的活用规则如下，注意名词和な形容词的活用规则其实是在活用「である」里面的动词「ある」<br>「ば」的活用规则:</p>
<ul>
<li>对动词: [ 一类え形活用词根 ] + 「ば」，即把动词最后假名从 /u/ 段改为同行 /e/ 段，再加上「ば」</li>
<li>对い形容词以及「ない」结尾的未然形: 把最后的「い」换成「ければ」</li>
<li>对名词和な形容词: 加「であれば」</li>
</ul>
<p>例句:</p>
<ul>
<li>友達に会えれば、買い物に行きます</li>
<li>お金があればいいね</li>
<li>楽しければ、私も行く</li>
<li>楽しくなければ、私も行かない</li>
<li>食べなければ病気になるよ</li>
</ul>
<h5 id="1-2-3-4-「たら-ば-」完成时条件语"><a href="#1-2-3-4-「たら-ば-」完成时条件语" class="headerlink" title="1.2.3.4 「たら(ば)」完成时条件语"></a>1.2.3.4 「たら(ば)」完成时条件语</h5><p>「たら」的重点在于满足条件后发生的事，主要用来表示对事物完了的假定。<br>「たら」的活用规则:</p>
<ul>
<li>首先把名词、形容词或动词活用为过去形，再加上「ら」</li>
</ul>
<p>也可以用「たらば」替代「たら」，类似「ならば」，二者意思完全相同，只是前者感觉更正式。<br>例句:</p>
<ul>
<li>暇だったら、遊びに行くよ</li>
<li>学生だったら、学生割引で買えます</li>
</ul>
<h5 id="1-2-3-5-「もし」"><a href="#1-2-3-5-「もし」" class="headerlink" title="1.2.3.5 「もし」"></a>1.2.3.5 「もし」</h5><p>「もし」是条件句中常用的一个副词，用来增加一种对假设条件不确定的语气，可以翻译为“要是，如果”。但是必须搭配上述四种条件句的形式使用，「もし」本身是不能构成条件句的语法形式的。<br>例句:</p>
<ul>
<li>もしよかったら、映画を観に行きますか？</li>
<li>もし時間がないなら、明日でもいいよ。</li>
</ul>
<h4 id="1-2-4-原因从句"><a href="#1-2-4-原因从句" class="headerlink" title="1.2.4 原因从句"></a>1.2.4 原因从句</h4><p>表示“因为、由于”等原因，一般有以下联系手段。</p>
<h5 id="1-2-4-1-から"><a href="#1-2-4-1-から" class="headerlink" title="1.2.4.1 から"></a>1.2.4.1 から</h5><p>[ 原因 ] + から + [ 结果 ]<br>如果原因是字典形名词或な形容词，后面必须加「だ」来显式的表示它是原因，即「( 名词 / な形容词 ) だから」。如果忘了在「から」前面加表陈述的「だ」的话，听起来「から」就是「从…」的意思了。<br>如果是在用丁宁语的话，应该把「から」当成普通名词，在后面加「です」。<br>有上下文的时候，原因和结果都可以省略掉。省略原因的时候，必须加上表陈述的「だ」或「です」，所以经常会听到「だから」<br>例句:</p>
<ul>
<li>時間がなかったからです</li>
<li>うん、時間がなかったから</li>
<li>だからパーティーに行かなかったの？</li>
<li>天気が悪いから、山へ行くのは止めましょう。</li>
</ul>
<h5 id="1-2-4-2-ので"><a href="#1-2-4-2-ので" class="headerlink" title="1.2.4.2 ので"></a>1.2.4.2 ので</h5><p>「ので」基本上跟「から」可以互换使用，除了一些微妙的区别。「から」显式的表明了前面的句子是原因，而「ので」这仅仅是把两个句子连了起来，然后把前一个句子变味了解释的口吻。<br>「ので」听起来口气更柔和，也更礼貌，所以在解释做了失礼之事的原因的时候，人们更倾向于用它而非「から」。<br>总体上来看，在说话者的意志和能动性更强时，使用「から」；如果需要较恭敬的表达，或者是表达判断的理由时，用「ので」较多。<br><strong>「の」前面如果是字典形名词或者な形容词的话，一定要加「な」</strong><br>解释口气的「の」可以简写成「ん」，说话的时候「ので」也可以改成「んで」，因为这样可以省略音节 / o / 的发音，形成连读。<br>例句:</p>
<ul>
<li>時間がなかったのでパーティーに行かなかった</li>
<li>ちょっと忙しいので、そろそろ失礼します</li>
<li>私は学生なので、お金がないんです</li>
<li>なので、友達に会う時間がない</li>
<li>天気が悪いので、山へ行くのは止めました。</li>
</ul>
<h5 id="1-2-4-3-ため"><a href="#1-2-4-3-ため" class="headerlink" title="1.2.4.3 ため"></a>1.2.4.3 ため</h5><p>写成汉字应该是「為」。与「から」和「ので」相比，「ため」是一个能够与对方拉开距离的词语。<br>「から」和「ので」都是传达说话者的意志和判断的表达方式，与此相比，「ため」多用于描述发生的事情。<br>正因为此，「ため」多在新闻和论文中被使用，它能给对方一种严肃感，让人觉得情报的来源很可靠。<br>例句:</p>
<ul>
<li>大雨のため一時通行止めとなった</li>
<li>王さんは風邪を引いたために、会社を休みました。</li>
</ul>
<h5 id="1-2-4-4-によって"><a href="#1-2-4-4-によって" class="headerlink" title="1.2.4.4 によって"></a>1.2.4.4 によって</h5><p>「に」在表示对象、方向时通常接的是名词，但在表示目的、目标时既可接名词也可接动词简体。<br>「よって」原形为「よる」，可写做「寄る」、「拠る」、「因る」等，「～によって」這個句型在日文中是常见的，用法很多，主要有以下几种:</p>
<ul>
<li>名词 + によって(により/によりまして/による) + 名词。依据前者的条件及选项取舍的不同，結果、情況、作法也会随之改变的句型表现。「AによってB」A只能置入名詞，作为条件依据，而随着A不同B也會改变，中文意思为「依A的不同而B」。</li>
<li>名词 + によって(により/による) + 名词。表示事物、情況成立或发生的理由以及原因之句型表现。「AによってB」A只能置入名词，表理由、原因，因为A而造成B的场面</li>
<li>名词 + によって(により/による) + 名词。表示方法、手段之句型表现。「AによってB」A只能置入名词，表方法、手段，意即透过或运用A作为手段而来做B，有些人会将它与「～によると」的传闻来源表现搞混，需要注意。</li>
<li>名词 + によって(により/による) + 名词。表示消息、传闻的来源或出处的句型表现。「Aによると～」A只能置入名词，表示消息、传闻的来源，「によると」的結尾常与「～そうだ」、「～ということだ」一起使用。</li>
</ul>
<p>例句:</p>
<ul>
<li>日本人との付き合いによって日本語の会話を練習している</li>
</ul>
<h5 id="1-2-4-5-おかげで"><a href="#1-2-4-5-おかげで" class="headerlink" title="1.2.4.5 おかげで"></a>1.2.4.5 おかげで</h5><p>可以译为“托…的福”。<br>规则:</p>
<ul>
<li>名词 + 「の」 + 「おかげで」</li>
<li>形容词基本形 + 「おかげで」</li>
<li>形容动词 + 「な」 + 「おかげで」</li>
<li>动词基本形 + 「おかげで」</li>
</ul>
<p>例句:</p>
<ul>
<li>あなたのおかげで助かりました</li>
</ul>
<h5 id="1-2-4-6-せいで"><a href="#1-2-4-6-せいで" class="headerlink" title="1.2.4.6 せいで"></a>1.2.4.6 せいで</h5><p>名词「せい」的汉字是「所为」，「で」是「です」的中顿形式，可以翻译成“是…的所为”，一般是带来不好的结果。<br>规则:</p>
<ul>
<li>名词 + 「の」 + 「せいで」</li>
<li>形容词基本形 + 「せいで」</li>
<li>形容动词 + 「な」 + 「せいで」</li>
<li>动词基本形 + 「せいで」</li>
</ul>
<p>例句:</p>
<ul>
<li>わがままな母親のせいで、彼女は結婚が遅れた</li>
</ul>
<h4 id="1-2-5-结果从句"><a href="#1-2-5-结果从句" class="headerlink" title="1.2.5 结果从句"></a>1.2.5 结果从句</h4><p>日语中存在着这样一种句子结构: “…は…が…からです(だ、である)”。相当于汉语的“事情之所以这样，是由于…的缘故”。表示一种因果关系。<br>结果从句的“から”是作为副助词和“だ、です、である”结合起来，接在动词的连体形后面做谓语，先强调其结果，后叙述原因。<br>也可以用另一种惯用型“…のは…が…ためです”来表示</p>
<p>例句:</p>
<ul>
<li>任务を完成するてとができなかったのは计画が十分ではなかったからだ </li>
</ul>
<h4 id="1-2-6-目的从句"><a href="#1-2-6-目的从句" class="headerlink" title="1.2.6 目的从句"></a>1.2.6 目的从句</h4><p>表示行为的目的。<br>一般常用惯用形”…ために”、”…には”，是表示达到某种目的的句子。但这种类型的句子，一般做目的状语较多，因为前后两个事项都属于一个主体——主语，如有两层主谓关系者，可看作目的从句。</p>
<p>例句:</p>
<ul>
<li>私たちは{健康「けんこう」を保つために}、毎日運動をします。</li>
<li>{友人が早く快復「かいふく」するように}心から祈「いの」ります。</li>
<li>私は{朝起きるのに}目覚「めざ」ましが必要です。</li>
</ul>
<h4 id="1-2-6-方式从句"><a href="#1-2-6-方式从句" class="headerlink" title="1.2.6 方式从句"></a>1.2.6 方式从句</h4><p>日语中有这样一种惯用型: “…ように”、”…とおりに”，而这两者的前后都是一个句子形式，又具有两层主谓关系，我们可以把它统称为方式从句。</p>
<p>例句:</p>
<ul>
<li>レーニンが教えたように、共产党はプロレタリアートの前卫である</li>
</ul>
<p>除了表示方式以外，也可以利用 “…ように” 这一形式表示祈使目的。<br>例句:</p>
<ul>
<li>みなが気持よく休めるように、私にちが部屋をきれいに掃除している</li>
</ul>
<h4 id="1-2-7-时间从句"><a href="#1-2-7-时间从句" class="headerlink" title="1.2.7 时间从句"></a>1.2.7 时间从句</h4><p>在日常生活的语言中，经常会遇到这类惯用型: “…たびに”、”…ときに”、”…あとで(に)”、”…てから”、”…うちに” 。这一类型句子的共同点是都表示时间的含义，相当于汉语的“每逢…声”、“在…时候”、“在…之后” 、“在…之中”的意义。试论日语的复合句[4]中认为，如果在这一类惯用型前后有两个句子，又具有两层主谓关系，和前述其他副句一样，把它作为复合句看待，将其归属为时间从句。 </p>
<p>例句:</p>
<ul>
<li>吴先生の家に行くたびに、彼はいろいろなおもしろい話を聞かせてくれます</li>
<li>父からはじめ手紙が届いた時、私はとてもうれしかった</li>
<li>私が外出しためとで(に)、陈君があそびに来た</li>
<li>彼らは大学に入学してから、まだ日があさい</li>
</ul>
<h3 id="1-3-并列句"><a href="#1-3-并列句" class="headerlink" title="1.3 并列句"></a>1.3 并列句</h3><p>句中有2层以上的主谓结构，虽然这些主谓结构有某种语法形式上的联系，但是在意义上是并列的，互不依赖的。并列句中的各自的句子称作分句，前面的分句是以中顿形式，或者用接续助词て、し、が等，以及某些惯用形与后面的分句连接。<br>例句：<br>①“河水很清澈，河底看得很清楚。”<br>川の水が綺麗で、川の底「そこ」がよく見えます。（用形容动词的中顿）<br>②“客人来了，就在那里喝茶；孩子回来了，那个房间就变成了学习室。”<br>人が来ればそこでお茶を飲んで、子供が学校から帰ってくると、その部屋は勉強部屋になる。（用接续助词て）<br>③“有的人显得高兴，有的人显得伤心。”<br>嬉しそうな顔をする人もいるし、悲「かな」しそうな顔をする人もいます。（用接续助词し）<br>④ “即有山，又有海。”<br>山もあれば、海もある。（用惯用形……も……ば、……も）<br>⑤“冬天过去，春天来了”<br>冬が過ぎ、春が来た</p>
<h3 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h3><p>日语的复合句按照基本结构可以分为三大类，包孕句、主从句和并列句，这三者的从属度是逐渐递减的。在实际中，还可以将三者混合起来，构成更为复杂的句式结构。</p>
<h2 id="2-复句中的时体"><a href="#2-复句中的时体" class="headerlink" title="2. 复句中的时体"></a>2. 复句中的时体</h2><p>日语复句中的时体和英语不同，没有十分标准的研究，相应文章也较少，论日语从句的时态变化<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="林泽清, and 耿铁珍. 论日语从句的时态变化. 日语学习与研究 2(2000):16-21.
">[6]</span></a></sup>和浅析日语复句中的“时”和“体”<sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="辛宇峰. 浅析日语复句中的“时”和“体”. 外语与翻译 4(2014):54-55.
">[7]</span></a></sup>有一些介绍。<br>一般来说，日语复句的时体的基本原则是，主句的时体，以说话者的视角为基准，从句的时体以主句的时间为基准，但也会考虑到说话者的视角。<br>一般来说:</p>
<ul>
<li>如果从句的动作、状态发生在主句之前，那么通常从句都是过去时，有时也反映在体上例如完成体等</li>
<li>如果从句的动作、状态和主句同时发生，那么通常从句的时和主句相同</li>
<li>如果从句的动作、状态发生在主句之后，此时考虑主句的时间和整个句子在说话者中的视角，若主句是现在时，那从句也就用现在时即可，若主句是过去时，需要考虑从句的动作、状态在说话者视角中是否仍处于过去时，是则也用过去时，否则现在时。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章主要介绍了日语复合句的内容，下一篇将尝试综合考虑已有内容归纳日语句子的改造顺序。</p>
<h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)">Wikipedians. 複文. Wikipedia, Wikimedia Foundation, 16 Apr. 2018, ja.wikipedia.org/wiki/複文.<a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)">Wikipedians. 節 (文法). Wikipedia, Wikimedia Foundation, 18 Apr. 2018, ja.wikipedia.org/wiki/節_(文法).<a href="#fnref:2" rev="footnote"> ↩</a></span></div><div id="fn:3" style="display:flex"><span style="width:20px">3.</span><span style="width:calc(100% - 20px)">henry19931224. 日语复句. 百度文库, 16 Nov. 2011, wenku.baidu.com/view/bfe202d0b14e852458fb5731.html.<a href="#fnref:3" rev="footnote"> ↩</a></span></div><div id="fn:4" style="display:flex"><span style="width:20px">4.</span><span style="width:calc(100% - 20px)">谢秀忱. 试论日语的复合句. 现代外语 3(1982):33-38.<a href="#fnref:4" rev="footnote"> ↩</a></span></div><div id="fn:5" style="display:flex"><span style="width:20px">5.</span><span style="width:calc(100% - 20px)">吴春竹. 试论日语复句中从属句节的多层立体结构. 外语学刊 6(2008):49-52.<a href="#fnref:5" rev="footnote"> ↩</a></span></div><div id="fn:6" style="display:flex"><span style="width:20px">6.</span><span style="width:calc(100% - 20px)">林泽清, and 耿铁珍. 论日语从句的时态变化. 日语学习与研究 2(2000):16-21.<a href="#fnref:6" rev="footnote"> ↩</a></span></div><div id="fn:7" style="display:flex"><span style="width:20px">7.</span><span style="width:calc(100% - 20px)">辛宇峰. 浅析日语复句中的“时”和“体”. 外语与翻译 4(2014):54-55.<a href="#fnref:7" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>humanities</category>
        <category>languages</category>
      </categories>
      <tags>
        <tag>japanese</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统二——资源分配与调度</title>
    <url>/2015/09/16/operatingSystem02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-资源管理概述"><a href="#1-资源管理概述" class="headerlink" title="1. 资源管理概述"></a>1. 资源管理概述</h3><h4 id="1-1-资源管理的目的和任务"><a href="#1-1-资源管理的目的和任务" class="headerlink" title="1.1 资源管理的目的和任务"></a>1.1 资源管理的目的和任务</h4><ul>
<li><p>资源的静态分配和动态分配</p>
<ul>
<li>资源的静态分配<ul>
<li>系统对作业一级采用资源静态分配方法。</li>
<li>系统在调度作业时，根据作业所需资源进行分配；并在作业运行完毕时，收回所分配的全部资源。称为资源的静态分配。</li>
</ul>
</li>
<li>资源的动态分配<ul>
<li>系统对进程一级采用资源动态分配方法。</li>
<li>系统在进程运行中，根据进程提出的资源需求，进行资源的动态分配和回收。称为资源的动态分配。</li>
</ul>
</li>
</ul>
</li>
<li><p>资源管理的目的</p>
<ul>
<li>目的：为用户提供一种简单而有效地使用资源的方法，充分发挥各资源的作用。</li>
<li>应达到的目标：<ul>
<li>保证资源的高利用率</li>
<li>在”合理”时间内使所有顾客有获得所需资源的机会</li>
<li>对不可共享的资源实施互斥使用</li>
<li>防止由资源分配不当而引起死锁</li>
</ul>
</li>
</ul>
</li>
<li>资源管理的任务<ul>
<li>任务：解决资源分配问题，防止死锁；解决对资源的存取、使用方法问题</li>
<li>资源管理的功能<ul>
<li>资源数据结构的描述</li>
<li>确定资源的分配原则和调度原则</li>
<li>执行资源分配</li>
<li>存取控制和安全保护<a id="more"></a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-2-资源的分类方法"><a href="#1-2-资源的分类方法" class="headerlink" title="1.2 资源的分类方法"></a>1.2 资源的分类方法</h4><ul>
<li>物理资源和程序资源(处理器、外设等；消息或文件等)</li>
<li>单一访问入口资源(不可重入，只能为一个进程使用)和多访问入口资源(可以为多个进程共享使用)</li>
<li>等同资源(多个完全相同的设备)</li>
<li>虚拟资源(cpu、一定容量的主存、数量有限的外设)，如虚拟存储器</li>
</ul>
<h4 id="1-3-虚拟资源"><a href="#1-3-虚拟资源" class="headerlink" title="1.3 虚拟资源"></a>1.3 虚拟资源</h4><p>虚拟资源是用户使用的逻辑资源，是经过操作系统改造的、使用方便的虚拟资源，而不是那些物理的实际的资源，这样做的目的，一是要提高资源利用率，二是为了方便用户的使用</p>
<h3 id="2-资源管理的机制和策略"><a href="#2-资源管理的机制和策略" class="headerlink" title="2. 资源管理的机制和策略"></a>2. 资源管理的机制和策略</h3><p>机制：进行资源分配的必需的基本设施和部件，它包括描述资源状态的数据结构、保证资源互斥的同步机构及资源请求排队的手段。<br>策略：这些机构所使用的方法，资源分配的原则</p>
<h4 id="2-1-资源分配机制"><a href="#2-1-资源分配机制" class="headerlink" title="2.1 资源分配机制"></a>2.1 资源分配机制</h4><ul>
<li>资源描述器<ul>
<li>什么是资源描述器<br>描述各类资源的最小分配单位的数据结构称为资源描述器 RD (resource descriptor)。如：<ul>
<li>主存最小分配单位：在分区分配中—主存分区</li>
<li>磁盘最小分配单位：磁盘面中的一个扇区</li>
</ul>
</li>
<li>描述器的组织方式取决于资源分配单位的数量和这一数量是固定不变的、还是可以变化的这一特征。</li>
<li>资源描述器的内容<ul>
<li>资源名</li>
<li>资源类型</li>
<li>最小分配单位的大小</li>
<li>最小分配单位的地址</li>
<li>分配标志</li>
<li>描述器链接信息</li>
<li>存取权限</li>
<li>密级</li>
<li>最后一次存取时间</li>
<li>记账信息<br><img src="/images/operatingSystem02_1.png" alt="first"></li>
<li>资源信息块<ul>
<li>什么是资源信息块(rib)<br>描述某类资源的请求者、可用资源和该类资源分配程序等必要信息的数据结构。<ul>
<li>对于每一类可利用的资源，可将其组织成可利用资源队列。在资源信息块中有指向这两个队列的队列指针，另外还有一项为该类资源分配程序的入口地址 。</li>
</ul>
</li>
<li>资源分配程序是接收分配命令把资源分配给请求者的例程。<ul>
<li>资源分配程序包括：分配程序和回收程序。</li>
</ul>
</li>
<li>资源信息块的内容<br><img src="/images/operatingSystem02_2.png" alt="second"></li>
<li>资源分配的方式取决于设计者所选择的目标，以及与应用每一类资源相联系的特定限制。目的是使吞吐率尽可能地高，响应时间尽可能地短，即既要充分地利用系统各种资源，又要尽可能地满足用户要求。 </li>
<li>一个资源进行分配的问题，在一般情况下，是由这样两个方面组成的：管理请求的排队站（分配策略）与在等同资源间选择资源。</li>
<li>分配程序可以用不同的策略选择进程请求<ul>
<li>按照请求来到的次序进行查看</li>
<li>将进程请求者的优先权结合到每一个请求中</li>
<li>满足能更合理地应用这一资源的那个请求</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-2-资源分配策略"><a href="#2-2-资源分配策略" class="headerlink" title="2.2 资源分配策略"></a>2.2 资源分配策略</h4><ul>
<li>1)先请求先服务(FIFO(First In First Out))<ul>
<li>排序原则：按请求的先后次序排序。</li>
<li>每一个新产生的请求均排在队尾，而当资源可用时，资源分配程序则从队列中选取第一个请求，并满足其需要。</li>
<li>这种策略可用于对进程或作业的调度，或外设、主存分配<br><img src="/images/operatingSystem02_3.png" alt="third"></li>
</ul>
</li>
<li>2)优先调度<ul>
<li>在优先调度策略下，对于每一个进程要指定一个优先级，优先级反映了进程要求处理的紧迫程度。</li>
<li>排序原则：按优先级的高低排序。</li>
<li>每一个新产生的请求，按其优先级的高低插到相应的位置上。而当资源可用时，选取队列中第一个请求，并满足其需要。<br><img src="/images/operatingSystem02_4.png" alt="fourth"></li>
</ul>
</li>
<li>3)针对设备特性的调度<br>对具有高速度、大容量的存储设备(如磁盘)而言，在繁重的输入输出负载下，会有大量的I/O请求在等待。操作系统应该采取有效的调度策略从众多的请求中按最佳的排序原则去选择。确定最佳排序的目标是降低为完成这些I/O请求服务的总时间，从而提高系统效率。<ul>
<li>移臂调度<br>所谓移臂调度是指在满足某一个磁盘请求时，总是选取与当前移动臂前进方向上最近的那个请求，使移臂距离最短。<br>针对设备特性的调度是I/O调度。I/O调度程序是在磁盘硬件层实施的，磁盘硬件看到的是磁盘面、磁道、块号(对磁盘组为: 柱面号、盘面号、块号)。如下例所示，若磁盘组同时有5个访问请求，它们按请求的先后次序排序，要求访问的盘区位置如<strong>表1</strong>所示：<br>如果当前移动臂处于1号柱面上，若按上述次序访问磁盘，移动臂将从1号柱面移动到6号柱面，再移至48号柱面，然后回到3号柱面。显然这样移臂很不合理。<br>若按<strong>表2</strong>次序访问则可节省移动臂时间(注：当前移动臂方向是由外向里，即柱面号由小到大)</li>
<li>旋转调度<br>所谓旋转调度是指在满足一个磁盘请求时，总是选取与当前读写头旋转方向上最近的那个请求，使旋转圈数最少。<br>对于上述示例，使用<strong>表3</strong>排序则旋转次数更少：</li>
</ul>
</li>
<li>4)几种移臂调度算法<ul>
<li>最短寻道时间优先算法</li>
<li>扫描算法</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">柱面号</th>
<th style="text-align:center">盘面号</th>
<th style="text-align:center">块号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">5</td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">5</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">48</td>
<td style="text-align:center">8</td>
<td style="text-align:center">16</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">9</td>
<td style="text-align:center">28</td>
</tr>
</tbody>
</table>
<p align="center">表1</p>

<table>
<thead>
<tr>
<th style="text-align:center">柱面号</th>
<th style="text-align:center">盘面号</th>
<th style="text-align:center">块号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">9</td>
<td style="text-align:center">28</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">5</td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">5</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">48</td>
<td style="text-align:center">8</td>
<td style="text-align:center">16</td>
</tr>
</tbody>
</table>
<p align="center">表2</p>

<table>
<thead>
<tr>
<th style="text-align:center">柱面号</th>
<th style="text-align:center">盘面号</th>
<th style="text-align:center">块号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">9</td>
<td style="text-align:center">28</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">5</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">5</td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td style="text-align:center">48</td>
<td style="text-align:center">8</td>
<td style="text-align:center">16</td>
</tr>
</tbody>
</table>
<p align="center">表3</p>

<h3 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3. 死锁"></a>3. 死锁</h3><h4 id="3-1-死锁的定义与例子"><a href="#3-1-死锁的定义与例子" class="headerlink" title="3.1 死锁的定义与例子"></a>3.1 死锁的定义与例子</h4><p>操作系统的基本特征是并发与共享。系统允许多个进程并发执行，并且共享系统的软、硬件资源。为了最大限度地利用计算机系统的资源，操作系统应用动态分配系统各资源的策略。然而，采用这种策略时，若分配不当，一旦出现对某类资源的申请数目超过了这类资源的入口数目时，就是造成进程相互封锁的危险。事实上，不同进程对资源的申请可能按某种先后次序得到部分满足，这就可能造成其中的两个或几个进程彼此间相互封锁的情况。即每个进程“抓住”一些为其它进程所等待的资源不放，其结果谁也得不到它所申请的全部资源，所有这些进程都无法继续运行。</p>
<ul>
<li>例子：<ul>
<li>OS系统中的死锁例子<br><img src="/images/operatingSystem02_5.png" alt="fifth"></li>
<li>I/O设备共享时的死锁情况<br><img src="/images/operatingSystem02_6.png" alt="sixth"><br>此图可描述I/O设备共享时的死锁情况。<br>方框代表资源，圆圈表示进程；从资源到进程的箭头(有向边)，表示该资源分配给进程，过程资源分配边；而从进程到资源的箭头表示进程请求边。<br>由图可见，进程P1、P2的资源分配边和资源请求边形成一个环路。</li>
<li>存储器共享时的死锁情况<br><img src="/images/operatingSystem02_7.png" alt="seventh"><br>我们可以这样说，如系统中由一个包含有m个分配单位的存贮器，它为n个进程所共享，且每个进程都要求I个分配单位，当m&lt;=n(I-1)时，可能发生死锁。<br>上图绘出了一个大大简化了的存贮器共享的情况，其中m=5,n=3,I=3。当P1、P2分别获得2个单元、P3获得1个单元时，内存被分配完毕。此时，系统进入一个不安全状态，因为在它们要求下一个所需要的单元资源时，便发生死锁(此时，它们都指望其它进程释放出内存空间，但谁都也不能再向前推进一步)。</li>
</ul>
</li>
<li>死锁的定义：<ul>
<li>若一个进程集合中的每一个进程都在等候只能由本集合中的另一进程才能引发的时事件则这种情况被视为死锁。</li>
<li>死锁是并发进程彼此互相等待对方拥有的资源，且这些并发进程在得到对方的资源之前不会释放自己所拥有得资源，这就造成了各并发进程想得到不可能得到的资源，从而不能继续向前推进进程的状态。</li>
</ul>
</li>
</ul>
<h4 id="3-2-产生死锁的原因和必要条件"><a href="#3-2-产生死锁的原因和必要条件" class="headerlink" title="3.2 产生死锁的原因和必要条件"></a>3.2 产生死锁的原因和必要条件</h4><ul>
<li>死锁产生的原因<br>并发进程共享系统资源，在竞争资源时可能会产生称为死锁的附带后果。产生死锁的根本原因是系统能够提供的资源个数比要求该资源的进程数要少。所以，当系统中两个或多个进程没能力进一步执行时，系统就发生死锁。<br>资源竞争现象是具有活力的、是需要的，虽然它存在着发生死锁的危险，但是，竞争并不等于死锁。在并发进程的活动中，存在着一种合理的联合推进路线，这种推进路线可使每个进程都运行完毕。但如果进程推进不合理则会出现死锁。<br>由此可知，产生死锁的原因是：<ul>
<li>a. 系统资源不足</li>
<li>b. 进程推进顺序非法。</li>
</ul>
</li>
<li>死锁发生的必要条件<ul>
<li>a. 互斥条件，每一资源或者被分配给一个进程，或者空闲。</li>
<li>b. 部分分配条件，已分配到了一些资源的进程可以申请新的资源。</li>
<li>c. 非剥夺条件，已分配给一进程的资源不可剥夺，只能被占有它的进程显式地释放。</li>
<li>d. 循环等待条件，存在一种进程的循环链，链中的每一个进程以获得的资源同时被链中下一个进程所请求。</li>
</ul>
</li>
</ul>
<h4 id="3-3-死锁模型"><a href="#3-3-死锁模型" class="headerlink" title="3.3 死锁模型"></a>3.3 死锁模型</h4><p>资源分配图的成分：<br><img src="/images/operatingSystem02_8.png" alt="eighth"><br>用资源分配图分析死锁例：<br><img src="/images/operatingSystem02_9.png" alt="nineth"><br>用资源分配图分析无死锁例：<br><img src="/images/operatingSystem02_10.png" alt="tenth"></p>
<h4 id="3-4-解决死锁的策略"><a href="#3-4-解决死锁的策略" class="headerlink" title="3.4 解决死锁的策略"></a>3.4 解决死锁的策略</h4><p>并发进程共享系统资源时如处理不当可能发生死锁。死锁不仅会在两个进程之间发生，也可能在多个进程之间、甚至在系统全部进程之间发生。此外，死锁不仅在动态使用外设时发生，也可能在动态使用存贮器和数据库时发生，或在进程通信过程中以及在利用信号灯作同步工具时由于p操作顺序不当而产生。在早期的操作系统中，系统规模较小，结构简单，而且资源的分配常常采用静态方法，使得操作系统尚未暴露死锁问题的严重性。但是，随着系统规模的增大，软件系统变得异常庞大而复杂，系统资源的种类亦日益增多，因而，死锁的可能性将大大增加。由于死锁的发生会给系统带来严重的后果，因此，处理系统死锁问题引起了人们的普遍注意，并对它进行了深入的研究。<br>但某些类别的死锁问题的发生概率极小，这时大多数用户宁可承受在极偶然情况下发生的死锁，也不愿使其工作不便或系统性能受损–因解决这类死锁要花费很大的代价。所以，在设计上，我们不得不在方便性与正确性之间作出折衷，即象驼鸟一样对此类死锁视而不见,这就是驼鸟算法。<br>    为了使系统不发生死锁，必须设法破坏产生死锁的四个必要条件之一。可以采用下列策略之一来解决死锁问题：</p>
<ul>
<li>1)采用静态分配方法来预防死锁</li>
<li>2)采用有控分配方法来避免死锁</li>
<li>3)当死锁发生时检测出死锁，并设法修复</li>
</ul>
<h4 id="3-5-死锁的预防"><a href="#3-5-死锁的预防" class="headerlink" title="3.5 死锁的预防"></a>3.5 死锁的预防</h4><p>基本思想：静态防止发生死锁的方法。<br>预先分配所有共享资源是预防死锁的一种安全而由简单的方法。这种方法的基本思想是：每个用户向系统提交作业时，需一次说明它所需要的资源；并且作业调度程序只能在满足该作业所需的全部资源的前提下才能将它投入运行。当资源一旦分配给该作业后，在其整个运行期间这些资源为它独占。这样就摒弃”部分分配”了条件,摒弃”不剥夺”了条件 ,摒弃”环路等待”了条件 。<br>死锁预防的缺点：</p>
<ul>
<li>a.一个用户在作业运行之前可能提不出他的作业时间、将要使用的全部设备。</li>
<li>b.用户作业必须等待，直到所有资源满足时才能投入运行。</li>
<li>c.一个作业运行期间，对某些设备的使用时间很少，甚至不会用到。故这种分配技术对系统来说是浪费的。</li>
</ul>
<h4 id="3-6-死锁的避免"><a href="#3-6-死锁的避免" class="headerlink" title="3.6 死锁的避免"></a>3.6 死锁的避免</h4><p>基本思想：动态防止发生死锁的方法<br>预防死锁和避免死锁的不同在于，前者所采用的分配策略本身就否定了必要条件之一，这样来保证死锁不可能发生；而后者是在动态分配资源的策略下采用某种算法来预防可能发生的死锁，从而拒绝可能引起死锁的某个资源请求。</p>
<ul>
<li><p>有序资源分配法<br>系统若采用有序资源分配法，则需要为系统中的每一类资源分配唯一的号码，且系统要求每个进程：</p>
<ul>
<li>对它所必须使用的而且属于某一类的所有资源，必须一次性申请完</li>
<li>在申请不同类的资源时，必须按照各类的编号依次申请。<br>优缺点：</li>
<li>缺点：进程实际需要资源的顺序不一定与资源的编号相一致，因而仍然会造成资源的浪费。</li>
<li>优点：对资源进行合理的排序，这种方法是有一定实用价值的。</li>
</ul>
</li>
<li><p>银行家算法：<br>存在一种算法总能作出正确的选择从而避免死锁单种资源的银行家算法(Dijkstra,1965)</p>
<ul>
<li>问题描叙：<br>一个领域的银行家，他向一群客户分别承若了一定的货款额度，具体而言，假设有4个客户，每个客户都有一个货款额度，银行家知道不可能所有客户同时都需要最大贷款额，所以他只能保留10个单位的资金来为客户服务，而不是22个单位。这里的背景是，将客户比作进程，货款比作设备，银行家比作OS。</li>
<li>问题图示<br><img src="/images/operatingSystem02_10.png" alt="eleventh"></li>
<li>算法：<br>对每一个请求进行检查，检查如果满足它是否会导致不安全状态，若是，则不满足该请求；否则便满足。检查状态是否安全的方法是看他是否有足够的资源满足一个跟最大需求最近的客户，如果可以，则这笔投资认为是能够收回的，然后接着检查下一个跟最大需求最接近的客户，如此反复下去。如果所有投资最终都被收回，则该状态是安全的，最初的请求可以批准。</li>
</ul>
</li>
</ul>
<h4 id="3-7-死锁的检测与忽略"><a href="#3-7-死锁的检测与忽略" class="headerlink" title="3.7 死锁的检测与忽略"></a>3.7 死锁的检测与忽略</h4><ul>
<li><p>检测死锁并恢复</p>
<ul>
<li>a.基本思想：<br>检测系统是否发生死锁,检测出死锁之后,寻找排除死锁的方法，使系统恢复正常的工作状态。<br>本策略的指导原则是允许死锁产生，且当死锁发生时能检测出死锁，并有能力实现恢复。本策略的价值取决于死锁发生的频率和能够修复的程度。<br>发现死锁的原理是考查某一时刻系统状态是否合理，即是否存在一组可以实现的系统状态，能使所有进程都得到它们所申请的资源而运行结束。</li>
<li>b.检测死锁算法的基本思想：<br>得到某时刻t时，系统中各类可利用资源得数目向量w(t)对于系统中的一组进程｛P1,P2,…Pi,…,Pn｝,找出那些对各类资源请求数目均小于系统现在所拥有的各类资源数目的进程。并认为这样的进程可以获得它们所需要的全部资源 并运行结束。当它们运行结束后释放所占有的全部资源，从而使可用资源数目增加，这样的进程加入到可运行结束的进程序列之中，然后对剩下的进程再作上述考查，如果一组进程｛P1,P2,…,Pn｝中有几个进程不属于序列L中，则它们会被死锁。</li>
<li>c.排除死锁的实用办法 ：<ul>
<li>将那些陷于死锁的全部进程一律撤消。</li>
<li>逐个作废死锁进程，直至不再存在死锁为止。</li>
<li>从死锁进程中逐个地强迫强占一些资源,直至死锁不再存在。</li>
</ul>
</li>
</ul>
</li>
<li><p>死锁的忽略<br>如果系统可能发生死锁，且不提供进行死锁的预防的方法、死锁的检测与恢复的机制，那么可能会出现这种情况：系统已经出现死锁，而又不知道发生了什么。这种情况下，死锁的发生会导致系统性能的下降，因为资源被不能运行的进程锁占有，而越来越多的进程会因为申请资源而进入死锁状态。最后整个系统停止工作需要人工重新启动。<br>由于检测死锁的算法太复杂，系统开销大，所以使用很少。实际中对死锁的检测常常由计算机操作员来处理。而不是由系统本身来完成。通常修复方法是人工抽去一些作业，释放它们占的资源，再重新启动系统。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>science</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>operating system</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习五</title>
    <url>/2015/08/29/machineLearning05/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-支持向量机-Support-Vector-Machines"><a href="#1-支持向量机-Support-Vector-Machines" class="headerlink" title="1. 支持向量机(Support Vector Machines)"></a>1. 支持向量机(Support Vector Machines)</h3><p>SVM有很多实现，最流行的一种实现是序列最小优化(Sequential Minimal Optimization)算法<br>可以使用核函数(kernel)的方式将SVM扩展到更多数据集上<br>SVM的优缺点:</p>
<ul>
<li>优点：泛化错误率低，计算开销不大，结果易解释</li>
<li>缺点：对参数调节和核函数的选择敏感，原始分类器不加修改仅适用于处理二类问题</li>
</ul>
<a id="more"></a>
<h3 id="2-基于最大间隔分隔数据"><a href="#2-基于最大间隔分隔数据" class="headerlink" title="2. 基于最大间隔分隔数据"></a>2. 基于最大间隔分隔数据</h3><p>可以用一条线将两类数据点分开，则这组数据线性可分，否则线性不可分<br>线性可分数据集中的分隔界限称为分隔超平面(separating hyperplane)，也就是分类的决策边界，分布在超平面一侧的数据都属于某个类别，而另一侧的数据属于另一类别<br>我们希望找到离分隔超平面最近的点，确保它们离分隔面的距离尽可能的远，这里，点到分隔面的距离称之为间隔(margin)<br>支持向量(support vector)就是离分隔超平面最近的那些点</p>
<h3 id="3-寻找最大间隔"><a href="#3-寻找最大间隔" class="headerlink" title="3. 寻找最大间隔"></a>3. 寻找最大间隔</h3><p>分割超平面的形式可以写成\(w^Tx+b\)，要计算A点到分割超平面的距离，必须给出点到分隔面的法线长度，该值为\(|w^TA+b|/||w||\)</p>
<h4 id="3-1-分类器求解的优化问题"><a href="#3-1-分类器求解的优化问题" class="headerlink" title="3.1 分类器求解的优化问题"></a>3.1 分类器求解的优化问题</h4><p>输入数据给分类器会输出一个类别标签，使用类似Heaviside的函数，u&lt;0时，f(u)输出-1，u&gt;0为+1，即类别标签是-1和+1<br>当计算数据点到分隔面的距离并确定分隔面的放置位置时，间隔通过label \(w^Tx+b\)计算。现在的目标是找出分类器定义的w和b，为此需要找到具有最小间隔的数据点，而这些数据点就是前面提到的支持向量，一旦找到具有最小间隔的数据点，我们就需要对该间隔最大化，这可以写作：\(<br>\arg \max\limits_{w,b} \{ \min\limits_{n} (label\cdot (w^Tx+b)) \cdot \frac{1}{||w||}<br>\}\)<br>直接求解上式太难，需要转换形式。在上述优化问题中，给定了一些约束条件求最优值，约束条件就是label \(w^Tx+b\)，因此该问题是一个带约束条件的优化问题，可以考虑拉格朗日乘子法。引入拉格朗日乘子，就可以基于约束条件来表示原问题，由于此处约束条件都是基于数据点的，可以将超平面写成数据点的形式：<br>$$ \max\limits_a \left[ \sum_{i=1}^m a-\frac{1}{2}\sum_{i,j=1}^m label^{(i)}\cdot label^{(i)}\cdot \alpha_{i} \cdot \alpha_{j}\langle x^{(i)},x^{(j)}\rangle<br>\right]$$<br>其约束条件为：\(\alpha \geq 0\)和\(\sum_{i=1}^m \alpha_i \cdot label^{(i)}=0\)<br>以上基于假设：数据必须100%线性可分，但实际并不是，这时引入”松弛变量(slack variable)”，来允许有些数据点可以处于分隔面的错误一侧，这样我们的优化目标就能保持不变，但是此时新约束规则为：<br>\(C\geq \alpha \geq 0,\)和\(\sum_{i=1}^m \alpha_i \cdot label^{(i)}=0\)<br>这里常数C用于控制”最大化间隔”和”保证大部分点的函数间隔小于1.0”这两个目标的权重，在优化算法的实现代码中将C作为一个参数，则可以通过调节这个参数得到不同的结果，一旦求出了所有的alpha，就可以用这些alpha里表示分隔超平面，SVM的主要工作就是求这些alpha</p>
<h4 id="3-2-SVM应用的一般框架"><a href="#3-2-SVM应用的一般框架" class="headerlink" title="3.2 SVM应用的一般框架"></a>3.2 SVM应用的一般框架</h4><ul>
<li>收集数据：可以使用任何方法</li>
<li>准备数据：需要数值型数据</li>
<li>分析数据：有助于可视化分隔超平面</li>
<li>训练算法：SVM的大部分时间都源自训练，该过程主要实现两个参数的调优</li>
<li>测试算法：十分简单的计算过程就可以实现</li>
<li>使用算法：几乎所有的分类问题都可以使用SVM，值得一提的是，SVM本身是一个二类分类器，对多累问题应用SVM需要地代码做些修改</li>
</ul>
<h3 id="4-SMO高效优化算法"><a href="#4-SMO高效优化算法" class="headerlink" title="4. SMO高效优化算法"></a>4. SMO高效优化算法</h3><p>我们对上述最后的式子进行优化，其中一个是最小化的目标函数，一个是在优化过程中必须遵循的约束条件。以前，人们还在使用二次规划求解工具(quadratic solver)来求解上述优化问题，这种工具是一种用于在线性约束下优化具有多个变量的二次目标函数的软件。而这些二次规划求解工具则需要强大的计算能力的支撑，另外在实现上也十分复杂。所有需要做的围绕优化的事情就是训练分类器，一旦得到alpha最优值，我们就得到了分隔超平面并能够将其用于数据分类</p>
<h4 id="4-1-Platt的SMO算法"><a href="#4-1-Platt的SMO算法" class="headerlink" title="4.1 Platt的SMO算法"></a>4.1 Platt的SMO算法</h4><p>SMO表示序列最小优化(Sequential Minimal Optimization)。Platt的SMO算法将大优化问题分解为多个小优化问题，这些小优化问题往往很容易求解，并且将它们进行顺序求解的结果与作为整体求解的结果是一致的，在结果完全相同的同时，SMO算法的求解问题短很多<br>SMO算法的目标是求出一系列alpha和b，一旦求出了这些alpha，就很容易计算出权重向量w并得到分隔超平面<br>SMO算法的工作原理是：每次循环中选择两个alpha进行优化处理，一旦找到一对合适的alpha，那么久增大其中一个同时减小另外一个，这里所谓的”合适”就是指两个alpha必须要符合一定的条件，条件之一就是这两个alpha必须在间隔边界之外，而第二则是这两个alpha还没有进行过区间化处理或者不在边界上</p>
<h4 id="4-2-应用简化版SMO算法处理小规模数据集"><a href="#4-2-应用简化版SMO算法处理小规模数据集" class="headerlink" title="4.2 应用简化版SMO算法处理小规模数据集"></a>4.2 应用简化版SMO算法处理小规模数据集</h4><p>Platt SMO算法的完整实现需要大量代码，于是从简化到完整逐渐递增<br>Platt SMO算法中的外循环确定要优化的最佳alpha对，而简化版却会跳过这一部分，首先在数据集上遍历每一个alpha，然后在剩下的alpha集合中随机选择另一个alpha，从而构建alpha对。这里有一点很重要，就是我们要同时改变两个alpha，之所以这样做是因为我们有一个约束条件：\(\sum \alpha_i \cdot label^{(i)}=0\)<br>由于改变一个alpha可能导致该约束条件失效，因此我们总是同时改变两个alpha<br>为此将构建一个辅助函数，用于在某个区间范围内随机选择一个整数。同时，我们也需要另一个辅助函数，用于在数值太大时对其进行调整，实现代码：<br>辅助函数：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">(fileName)</span>:</span></span><br><span class="line">    dataMat = []; labelMat = []</span><br><span class="line">    fr = open(fileName)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">        lineArr = line.strip().split(<span class="string">'\t'</span>)</span><br><span class="line">        dataMat.append([float(lineArr[<span class="number">0</span>]), float(lineArr[<span class="number">1</span>])])</span><br><span class="line">        labelMat.append(float(lineArr[<span class="number">2</span>]))</span><br><span class="line">    <span class="keyword">return</span> dataMat,labelMat</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectJrand</span><span class="params">(i,m)</span>:</span></span><br><span class="line">    j=i <span class="comment">#we want to select any J not equal to i</span></span><br><span class="line">    <span class="keyword">while</span> (j==i):</span><br><span class="line">        j = int(random.uniform(<span class="number">0</span>,m))</span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clipAlpha</span><span class="params">(aj,H,L)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> aj &gt; H: </span><br><span class="line">        aj = H</span><br><span class="line">    <span class="keyword">if</span> L &gt; aj:</span><br><span class="line">        aj = L</span><br><span class="line">    <span class="keyword">return</span> aj</span><br></pre></td></tr></table></figure><br>简化的SMO函数伪代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建一个alpha向量并将其初始化为0向量</span><br><span class="line">当迭代次数小于最大迭代次数时(外循环)</span><br><span class="line">    对数据集中的每个数据向量(内循环):</span><br><span class="line">        如果该数据向量可以被优化:</span><br><span class="line">            随机选择另外一个数据向量</span><br><span class="line">            同时优化这两个向量</span><br><span class="line">            如果两个向量都不能被优化,退出内循环</span><br><span class="line">    如果所有向量都没被优化,增加迭代数目,继续下一次循环</span><br></pre></td></tr></table></figure><br>简化版SMO算法：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smoSimple</span><span class="params">(dataMatIn, classLabels, C, toler, maxIter)</span>:</span></span><br><span class="line">    dataMatrix = mat(dataMatIn); labelMat = mat(classLabels).transpose()</span><br><span class="line">    b = <span class="number">0</span>; m,n = shape(dataMatrix)</span><br><span class="line">    alphas = mat(zeros((m,<span class="number">1</span>)))</span><br><span class="line">    iter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (iter &lt; maxIter):</span><br><span class="line">        alphaPairsChanged = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            fXi = float(multiply(alphas,labelMat).T*(dataMatrix*dataMatrix[i,:].T)) + b</span><br><span class="line">            Ei = fXi - float(labelMat[i])<span class="comment">#if checks if an example violates KKT conditions</span></span><br><span class="line">            <span class="keyword">if</span> ((labelMat[i]*Ei &lt; -toler) <span class="keyword">and</span> (alphas[i] &lt; C)) <span class="keyword">or</span> ((labelMat[i]*Ei &gt; toler) <span class="keyword">and</span> (alphas[i] &gt; <span class="number">0</span>)):</span><br><span class="line">                j = selectJrand(i,m)</span><br><span class="line">                fXj = float(multiply(alphas,labelMat).T*(dataMatrix*dataMatrix[j,:].T)) + b</span><br><span class="line">                Ej = fXj - float(labelMat[j])</span><br><span class="line">                alphaIold = alphas[i].copy(); alphaJold = alphas[j].copy();</span><br><span class="line">                <span class="keyword">if</span> (labelMat[i] != labelMat[j]):</span><br><span class="line">                    L = max(<span class="number">0</span>, alphas[j] - alphas[i])</span><br><span class="line">                    H = min(C, C + alphas[j] - alphas[i])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    L = max(<span class="number">0</span>, alphas[j] + alphas[i] - C)</span><br><span class="line">                    H = min(C, alphas[j] + alphas[i])</span><br><span class="line">                <span class="keyword">if</span> L==H: <span class="keyword">print</span> <span class="string">"L==H"</span>; <span class="keyword">continue</span></span><br><span class="line">                eta = <span class="number">2.0</span> * dataMatrix[i,:]*dataMatrix[j,:].T - dataMatrix[i,:]*dataMatrix[i,:].T - dataMatrix[j,:]*dataMatrix[j,:].T</span><br><span class="line">                <span class="keyword">if</span> eta &gt;= <span class="number">0</span>: <span class="keyword">print</span> <span class="string">"eta&gt;=0"</span>; <span class="keyword">continue</span></span><br><span class="line">                alphas[j] -= labelMat[j]*(Ei - Ej)/eta</span><br><span class="line">                alphas[j] = clipAlpha(alphas[j],H,L)</span><br><span class="line">                <span class="keyword">if</span> (abs(alphas[j] - alphaJold) &lt; <span class="number">0.00001</span>): <span class="keyword">print</span> <span class="string">"j not moving enough"</span>; <span class="keyword">continue</span></span><br><span class="line">                alphas[i] += labelMat[j]*labelMat[i]*(alphaJold - alphas[j])<span class="comment">#update i by the same amount as j</span></span><br><span class="line">                                                                        <span class="comment">#the update is in the oppostie direction</span></span><br><span class="line">                b1 = b - Ei- labelMat[i]*(alphas[i]-alphaIold)*dataMatrix[i,:]*dataMatrix[i,:].T - labelMat[j]*(alphas[j]-alphaJold)*dataMatrix[i,:]*dataMatrix[j,:].T</span><br><span class="line">                b2 = b - Ej- labelMat[i]*(alphas[i]-alphaIold)*dataMatrix[i,:]*dataMatrix[j,:].T - labelMat[j]*(alphas[j]-alphaJold)*dataMatrix[j,:]*dataMatrix[j,:].T</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt; alphas[i]) <span class="keyword">and</span> (C &gt; alphas[i]): b = b1</span><br><span class="line">                <span class="keyword">elif</span> (<span class="number">0</span> &lt; alphas[j]) <span class="keyword">and</span> (C &gt; alphas[j]): b = b2</span><br><span class="line">                <span class="keyword">else</span>: b = (b1 + b2)/<span class="number">2.0</span></span><br><span class="line">                alphaPairsChanged += <span class="number">1</span></span><br><span class="line">                <span class="keyword">print</span> <span class="string">"iter: %d i:%d, pairs changed %d"</span> % (iter,i,alphaPairsChanged)</span><br><span class="line">        <span class="keyword">if</span> (alphaPairsChanged == <span class="number">0</span>): iter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: iter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"iteration number: %d"</span> % iter</span><br><span class="line">    <span class="keyword">return</span> b,alphas</span><br></pre></td></tr></table></figure></p>
<h4 id="4-3-利用完整Platt-SMO算法加速优化"><a href="#4-3-利用完整Platt-SMO算法加速优化" class="headerlink" title="4.3 利用完整Platt SMO算法加速优化"></a>4.3 利用完整Platt SMO算法加速优化</h4><p>完整版Platt SMO的支持函数：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">optStruct</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,dataMatIn, classLabels, C, toler)</span>:</span>  <span class="comment"># Initialize the structure with the parameters </span></span><br><span class="line">        self.X = dataMatIn</span><br><span class="line">        self.labelMat = classLabels</span><br><span class="line">        self.C = C</span><br><span class="line">        self.tol = toler</span><br><span class="line">        self.m = shape(dataMatIn)[<span class="number">0</span>]</span><br><span class="line">        self.alphas = mat(zeros((self.m,<span class="number">1</span>)))</span><br><span class="line">        self.b = <span class="number">0</span></span><br><span class="line">        self.eCache = mat(zeros((self.m,<span class="number">2</span>))) <span class="comment">#first column is valid flag</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcEk</span><span class="params">(oS, k)</span>:</span></span><br><span class="line">    fXk = float(multiply(oS.alphas,oS.labelMat).T*(oS.X*oS.X[k,:].T)) + oS.b</span><br><span class="line">    Ek = fXk - float(oS.labelMat[k])</span><br><span class="line">    <span class="keyword">return</span> Ek</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectJ</span><span class="params">(i, oS, Ei)</span>:</span>         <span class="comment">#this is the second choice -heurstic, and calcs Ej</span></span><br><span class="line">    maxK = <span class="number">-1</span>; maxDeltaE = <span class="number">0</span>; Ej = <span class="number">0</span></span><br><span class="line">    oS.eCache[i] = [<span class="number">1</span>,Ei]  <span class="comment">#set valid #choose the alpha that gives the maximum delta E</span></span><br><span class="line">    validEcacheList = nonzero(oS.eCache[:,<span class="number">0</span>].A)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> (len(validEcacheList)) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> validEcacheList:   <span class="comment">#loop through valid Ecache values and find the one that maximizes delta E</span></span><br><span class="line">            <span class="keyword">if</span> k == i: <span class="keyword">continue</span> <span class="comment">#don't calc for i, waste of time</span></span><br><span class="line">            Ek = calcEk(oS, k)</span><br><span class="line">            deltaE = abs(Ei - Ek)</span><br><span class="line">            <span class="keyword">if</span> (deltaE &gt; maxDeltaE):</span><br><span class="line">                maxK = k; maxDeltaE = deltaE; Ej = Ek</span><br><span class="line">        <span class="keyword">return</span> maxK, Ej</span><br><span class="line">    <span class="keyword">else</span>:   <span class="comment">#in this case (first time around) we don't have any valid eCache values</span></span><br><span class="line">        j = selectJrand(i, oS.m)</span><br><span class="line">        Ej = calcEk(oS, j)</span><br><span class="line">    <span class="keyword">return</span> j, Ej</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateEk</span><span class="params">(oS, k)</span>:</span><span class="comment">#after any alpha has changed update the new value in the cache</span></span><br><span class="line">    Ek = calcEk(oS, k)</span><br><span class="line">    oS.eCache[k] = [<span class="number">1</span>,Ek]</span><br></pre></td></tr></table></figure><br>完整Platt SMO算法中的优化例程<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">innerL</span><span class="params">(i, oS)</span>:</span></span><br><span class="line">    Ei = calcEk(oS, i)</span><br><span class="line">    <span class="keyword">if</span> ((oS.labelMat[i]*Ei &lt; -oS.tol) <span class="keyword">and</span> (oS.alphas[i] &lt; oS.C)) <span class="keyword">or</span>\</span><br><span class="line">       ((oS.labelMat[i]*Ei &gt; oS.tol) <span class="keyword">and</span> (oS.alphas[i] &gt; <span class="number">0</span>)):</span><br><span class="line">        j,Ej = selectJ(i, oS, Ei)                                   </span><br><span class="line">        alphaIold = oS.alphas[i].copy(); alphaJold = oS.alphas[j].copy();</span><br><span class="line">        <span class="keyword">if</span> (oS.labelMat[i] != oS.labelMat[j]):</span><br><span class="line">            L = max(<span class="number">0</span>, oS.alphas[j] - oS.alphas[i])</span><br><span class="line">            H = min(oS.C, oS.C + oS.alphas[j] - oS.alphas[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            L = max(<span class="number">0</span>, oS.alphas[j] + oS.alphas[i] - oS.C)</span><br><span class="line">            H = min(oS.C, oS.alphas[j] + oS.alphas[i])</span><br><span class="line">        <span class="keyword">if</span> L==H: <span class="keyword">print</span> <span class="string">"L==H"</span>; <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        eta = <span class="number">2.0</span> * oS.X[i,:]*oS.X[j,:].T - oS.X[i,:]*oS.X[i,:].T - \</span><br><span class="line">              oS.X[j,:]*oS.X[j,:].T</span><br><span class="line">        <span class="keyword">if</span> eta &gt;= <span class="number">0</span>: <span class="keyword">print</span> <span class="string">"eta&gt;=0"</span>; <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        oS.alphas[j] -= oS.labelMat[j]*(Ei - Ej)/eta</span><br><span class="line">        oS.alphas[j] = clipAlpha(oS.alphas[j],H,L)</span><br><span class="line">        updateEk(oS, j)</span><br><span class="line">        <span class="keyword">if</span> (abs(oS.alphas[j] - alphaJold) &lt; <span class="number">0.00001</span>): </span><br><span class="line">             <span class="keyword">print</span> <span class="string">"j not moving enough"</span>; <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        oS.alphas[i] += oS.labelMat[j]*oS.labelMat[i]*\</span><br><span class="line">                      (alphaJold - oS.alphas[j])</span><br><span class="line">        updateEk(oS, i)                                      </span><br><span class="line">        b1 = oS.b - Ei- oS.labelMat[i]*(oS.alphas[i]-alphaIold)*\</span><br><span class="line">             oS.X[i,:]*oS.X[i,:].T - oS.labelMat[j]*\</span><br><span class="line">             (oS.alphas[j]-alphaJold)*oS.X[i,:]*oS.X[j,:].T</span><br><span class="line">        b2 = oS.b - Ej- oS.labelMat[i]*(oS.alphas[i]-alphaIold)*\</span><br><span class="line">             oS.X[i,:]*oS.X[j,:].T - oS.labelMat[j]*\</span><br><span class="line">             (oS.alphas[j]-alphaJold)*oS.X[j,:]*oS.X[j,:].T</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt; oS.alphas[i]) <span class="keyword">and</span> (oS.C &gt; oS.alphas[i]): oS.b = b1</span><br><span class="line">        <span class="keyword">elif</span> (<span class="number">0</span> &lt; oS.alphas[j]) <span class="keyword">and</span> (oS.C &gt; oS.alphas[j]): oS.b = b2</span><br><span class="line">        <span class="keyword">else</span>: oS.b = (b1 + b2)/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><br>完整版Platt SMO的外循环代码：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smoP</span><span class="params">(dataMatIn, classLabels, C, toler, maxIter,kTup=<span class="params">(<span class="string">'lin'</span>, <span class="number">0</span>)</span>)</span>:</span>    <span class="comment">#full Platt SMO</span></span><br><span class="line">    oS = optStruct(mat(dataMatIn),mat(classLabels).transpose(),C,toler, kTup)</span><br><span class="line">    iter = <span class="number">0</span></span><br><span class="line">    entireSet = <span class="literal">True</span>; alphaPairsChanged = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (iter &lt; maxIter) <span class="keyword">and</span> ((alphaPairsChanged &gt; <span class="number">0</span>) <span class="keyword">or</span> (entireSet)):</span><br><span class="line">        alphaPairsChanged = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> entireSet:   <span class="comment">#go over all</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(oS.m):        </span><br><span class="line">                alphaPairsChanged += innerL(i,oS)</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"fullSet, iter: %d i:%d, pairs changed %d"</span> % (iter,i,alphaPairsChanged)</span><br><span class="line">            iter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:<span class="comment">#go over non-bound (railed) alphas</span></span><br><span class="line">            nonBoundIs = nonzero((oS.alphas.A &gt; <span class="number">0</span>) * (oS.alphas.A &lt; C))[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nonBoundIs:</span><br><span class="line">                alphaPairsChanged += innerL(i,oS)</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"non-bound, iter: %d i:%d, pairs changed %d"</span> % (iter,i,alphaPairsChanged)</span><br><span class="line">            iter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> entireSet: entireSet = <span class="literal">False</span> <span class="comment">#toggle entire set loop</span></span><br><span class="line">        <span class="keyword">elif</span> (alphaPairsChanged == <span class="number">0</span>): entireSet = <span class="literal">True</span>  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"iteration number: %d"</span> % iter</span><br><span class="line">    <span class="keyword">return</span> oS.b,oS.alphas</span><br></pre></td></tr></table></figure></p>
<h3 id="5-在复杂数据上应用核函数"><a href="#5-在复杂数据上应用核函数" class="headerlink" title="5. 在复杂数据上应用核函数"></a>5. 在复杂数据上应用核函数</h3><p>核函数(kernel)将数据转换成易于分类器理解的形式</p>
<h4 id="5-1-利用核函数将数据映射到高维空间"><a href="#5-1-利用核函数将数据映射到高维空间" class="headerlink" title="5.1 利用核函数将数据映射到高维空间"></a>5.1 利用核函数将数据映射到高维空间</h4><p><img src="/images/machineLearning05_7.png" alt="seventh"><br>Figure 6-6中，数据点位于一个圆中，人类能够意识到这点，但对于分类器而言，他只能识别分类器的结果是大于0还是小于0，如果只在x、y轴构成的坐标系中插入直线进行分类的话，我们得不到理想结果。或许可以对圆中的数据进行某种形式的转换，从而得到新变量来表示数据。在此例中，我们将数据从一个特征空间转换到另一个特征空间，在新空间下我们很容易利用已有的工具对数据进行处理，数学家们喜欢将这个过程称为<em>从一个特征空间到另一个特征空间的映射</em>。通常情况下，这种映射会将低维特征空间映射到高维特征空间。<br>这种从某个特征空间到另一个特征空间的映射是通过核函数来实现的，读者可以把核函数想象成一个包装器(wrapper)或接口(interface)，它能把数据从一个很难处理的形式转换成另一个较容易处理的形式。换种简单但不确切的方式来理解，可以把它想象成另一种距离计算的方法，距离计算的方法有很多种，核函数一样具有多种类型。经过空间转换后，我们可以在高维空间中解决线性问题，也就等价于在低维空间中解决非线性问题。<br>SVM优化中的一个有点就是所有运算都可以写成内积(inner product)的形式，我们可以把内积运算转换为核函数，而不必简化处理。将内积替换为核函数的方式称为核技巧(kernel substation)</p>
<h4 id="5-2-径向基核函数-radial-basis-function"><a href="#5-2-径向基核函数-radial-basis-function" class="headerlink" title="5.2 径向基核函数(radial basis function)"></a>5.2 径向基核函数(radial basis function)</h4><p>核函数不仅应用于SVM，还有其他很多机器学习算法也需要用到，下面来介绍一个流行的核函数：径向基核函数<br>径向基函数是一个采用向量作为自变量的函数，能够基于向量距离运算输出一个标量。这个距离可以是从&lt;0,0&gt;向量或其他向量开始计算的距离。径向基函数的高斯版本公式为：\(k(x,y)=\exp\left(\frac{-||x-y||^2}{2\sigma^2}\right)\)<br>\(\sigma\)是用户定义的用于确定到达率(reach)或者说函数值跌落到0的速度参数<br>上述高斯核函数将数据从特征空间映射到更高维空间，具体说是映射到一个无穷维空间，使用高斯核函数会得到一个理想的结果。对于Figure 6-6中例子，可以发现直接度量数据点到原点距离即可，然而碰到一个非此类的数据集，我们便会陷入困境。在该数据集中，使用高斯核函数可以得到很好的结果，当然，该函数也可以用于许多其他的数据集，并得到较低的错误率。<br>添加函数kernelTrans()，对optStruct类进行修改：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kernelTrans</span><span class="params">(X, A, kTup)</span>:</span> <span class="comment">#calc the kernel or transform data to a higher dimensional space</span></span><br><span class="line">    m,n = shape(X)</span><br><span class="line">    K = mat(zeros((m,<span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">if</span> kTup[<span class="number">0</span>]==<span class="string">'lin'</span>: K = X * A.T   <span class="comment">#linear kernel</span></span><br><span class="line">    <span class="keyword">elif</span> kTup[<span class="number">0</span>]==<span class="string">'rbf'</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            deltaRow = X[j,:] - A</span><br><span class="line">            K[j] = deltaRow*deltaRow.T</span><br><span class="line">        K = exp(K/(<span class="number">-1</span>*kTup[<span class="number">1</span>]**<span class="number">2</span>)) <span class="comment">#divide in NumPy is element-wise not matrix like Matlab</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">raise</span> NameError(<span class="string">'Houston We Have a Problem -- \</span></span><br><span class="line"><span class="string">    That Kernel is not recognized'</span>)</span><br><span class="line">    <span class="keyword">return</span> K</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">optStruct</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,dataMatIn, classLabels, C, toler, kTup)</span>:</span>  <span class="comment"># Initialize the structure with the parameters </span></span><br><span class="line">        self.X = dataMatIn</span><br><span class="line">        self.labelMat = classLabels</span><br><span class="line">        self.C = C</span><br><span class="line">        self.tol = toler</span><br><span class="line">        self.m = shape(dataMatIn)[<span class="number">0</span>]</span><br><span class="line">        self.alphas = mat(zeros((self.m,<span class="number">1</span>)))</span><br><span class="line">        self.b = <span class="number">0</span></span><br><span class="line">        self.eCache = mat(zeros((self.m,<span class="number">2</span>))) <span class="comment">#first column is valid flag</span></span><br><span class="line">        self.K = mat(zeros((self.m,self.m)))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.m):</span><br><span class="line">            self.K[:,i] = kernelTrans(self.X, self.X[i,:], kTup)</span><br></pre></td></tr></table></figure><br>在线性核函数的情况下，内积计算在”所有数据集”和”数据集中的一行”这两个输入之间展开。在径向基核函数情况下，在for循环里对矩阵的每个元素计算高斯核函数的值，而在for循环结束后，我们将计算过程应用到整个向量中去。<br>为了使用该函数，前述innerL()和calcEk()需要做些修改，修改之后：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">innerL</span><span class="params">(i, oS)</span>:</span></span><br><span class="line">    Ei = calcEk(oS, i)</span><br><span class="line">    <span class="keyword">if</span> ((oS.labelMat[i]*Ei &lt; -oS.tol) <span class="keyword">and</span> (oS.alphas[i] &lt; oS.C)) <span class="keyword">or</span> ((oS.labelMat[i]*Ei &gt; oS.tol) <span class="keyword">and</span> (oS.alphas[i] &gt; <span class="number">0</span>)):</span><br><span class="line">        j,Ej = selectJ(i, oS, Ei) <span class="comment">#this has been changed from selectJrand</span></span><br><span class="line">        alphaIold = oS.alphas[i].copy(); alphaJold = oS.alphas[j].copy();</span><br><span class="line">        <span class="keyword">if</span> (oS.labelMat[i] != oS.labelMat[j]):</span><br><span class="line">            L = max(<span class="number">0</span>, oS.alphas[j] - oS.alphas[i])</span><br><span class="line">            H = min(oS.C, oS.C + oS.alphas[j] - oS.alphas[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            L = max(<span class="number">0</span>, oS.alphas[j] + oS.alphas[i] - oS.C)</span><br><span class="line">            H = min(oS.C, oS.alphas[j] + oS.alphas[i])</span><br><span class="line">        <span class="keyword">if</span> L==H: <span class="keyword">print</span> <span class="string">"L==H"</span>; <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        eta = <span class="number">2.0</span> * oS.K[i,j] - oS.K[i,i] - oS.K[j,j] <span class="comment">#changed for kernel</span></span><br><span class="line">        <span class="keyword">if</span> eta &gt;= <span class="number">0</span>: <span class="keyword">print</span> <span class="string">"eta&gt;=0"</span>; <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        oS.alphas[j] -= oS.labelMat[j]*(Ei - Ej)/eta</span><br><span class="line">        oS.alphas[j] = clipAlpha(oS.alphas[j],H,L)</span><br><span class="line">        updateEk(oS, j) <span class="comment">#added this for the Ecache</span></span><br><span class="line">        <span class="keyword">if</span> (abs(oS.alphas[j] - alphaJold) &lt; <span class="number">0.00001</span>): <span class="keyword">print</span> <span class="string">"j not moving enough"</span>; <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        oS.alphas[i] += oS.labelMat[j]*oS.labelMat[i]*(alphaJold - oS.alphas[j])<span class="comment">#update i by the same amount as j</span></span><br><span class="line">        updateEk(oS, i) <span class="comment">#added this for the Ecache                    #the update is in the oppostie direction</span></span><br><span class="line">        b1 = oS.b - Ei- oS.labelMat[i]*(oS.alphas[i]-alphaIold)*oS.K[i,i] - oS.labelMat[j]*(oS.alphas[j]-alphaJold)*oS.K[i,j]</span><br><span class="line">        b2 = oS.b - Ej- oS.labelMat[i]*(oS.alphas[i]-alphaIold)*oS.K[i,j]- oS.labelMat[j]*(oS.alphas[j]-alphaJold)*oS.K[j,j]</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt; oS.alphas[i]) <span class="keyword">and</span> (oS.C &gt; oS.alphas[i]): oS.b = b1</span><br><span class="line">        <span class="keyword">elif</span> (<span class="number">0</span> &lt; oS.alphas[j]) <span class="keyword">and</span> (oS.C &gt; oS.alphas[j]): oS.b = b2</span><br><span class="line">        <span class="keyword">else</span>: oS.b = (b1 + b2)/<span class="number">2.0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcEk</span><span class="params">(oS, k)</span>:</span></span><br><span class="line">    fXk = float(multiply(oS.alphas,oS.labelMat).T*oS.K[:,k] + oS.b)</span><br><span class="line">    Ek = fXk - float(oS.labelMat[k])</span><br><span class="line">    <span class="keyword">return</span> Ek</span><br></pre></td></tr></table></figure></p>
<h4 id="5-3-在测试中使用核函数"><a href="#5-3-在测试中使用核函数" class="headerlink" title="5.3 在测试中使用核函数"></a>5.3 在测试中使用核函数</h4><p>接下来我们构造一个对Figure 6-6中数据点进行有效分类的分类器，该分类器使用了径向基核函数。前面提到的径向基函数有一个用户定义的输入\(\sigma\)，首先得确定它的大小，然后利用核函数构建分类器，整个函数如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testRbf</span><span class="params">(k1=<span class="number">1.3</span>)</span>:</span></span><br><span class="line">    dataArr,labelArr = loadDataSet(<span class="string">'testSetRBF.txt'</span>)</span><br><span class="line">    b,alphas = smoP(dataArr, labelArr, <span class="number">200</span>, <span class="number">0.0001</span>, <span class="number">10000</span>, (<span class="string">'rbf'</span>, k1)) </span><br><span class="line">    datMat=mat(dataArr); labelMat = mat(labelArr).transpose()</span><br><span class="line">    svInd=nonzero(alphas.A&gt;<span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">    sVs=datMat[svInd]                                    </span><br><span class="line">    labelSV = labelMat[svInd];</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"there are %d Support Vectors"</span> % shape(sVs)[<span class="number">0</span>]</span><br><span class="line">    m,n = shape(datMat)</span><br><span class="line">    errorCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        kernelEval = kernelTrans(sVs,datMat[i,:],(<span class="string">'rbf'</span>, k1))</span><br><span class="line">        predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b</span><br><span class="line">        <span class="keyword">if</span> sign(predict)!=sign(labelArr[i]): errorCount += <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"the training error rate is: %f"</span> % (float(errorCount)/m)</span><br><span class="line">    dataArr,labelArr = loadDataSet(<span class="string">'testSetRBF2.txt'</span>)</span><br><span class="line">    errorCount = <span class="number">0</span></span><br><span class="line">    datMat=mat(dataArr); labelMat = mat(labelArr).transpose()</span><br><span class="line">    m,n = shape(datMat)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        kernelEval = kernelTrans(sVs,datMat[i,:],(<span class="string">'rbf'</span>, k1))</span><br><span class="line">        predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b</span><br><span class="line">        <span class="keyword">if</span> sign(predict)!=sign(labelArr[i]): errorCount += <span class="number">1</span>    </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"the test error rate is: %f"</span> % (float(errorCount)/m)</span><br></pre></td></tr></table></figure><br>上述函数的可选输入参数即\(\sigma\)<br>可以尝试更换不同的k1参数以观察测试错误率、训练错误率、支持向量个数随k1的变化情况<br>支持向量的数目存在一个最优值，SVM的优点在于它能对数据进行高校分类。如果支持向量太少，就可能会得到一个很差的决策边界，如果支持向量太多，就相当于每次都利用整个数据集进行分类，这种分类方法称为k近邻<br>我们可以对SMO算法中的其他设置进行随意地修改或者建立新的核函数</p>
<h3 id="6-示例"><a href="#6-示例" class="headerlink" title="6. 示例"></a>6. 示例</h3><p>手写识别问题, 使用SMO算法, 构建一个系统去测试手写数字上的分类器：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img2vector</span><span class="params">(filename)</span>:</span></span><br><span class="line">    returnVect = zeros((<span class="number">1</span>,<span class="number">1024</span>))</span><br><span class="line">    fr = open(filename)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">        lineStr = fr.readline()</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            returnVect[<span class="number">0</span>,<span class="number">32</span>*i+j] = int(lineStr[j])</span><br><span class="line">    <span class="keyword">return</span> returnVect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadImages</span><span class="params">(dirName)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> os <span class="keyword">import</span> listdir</span><br><span class="line">    hwLabels = []</span><br><span class="line">    trainingFileList = listdir(dirName)           <span class="comment">#load the training set</span></span><br><span class="line">    m = len(trainingFileList)</span><br><span class="line">    trainingMat = zeros((m,<span class="number">1024</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        fileNameStr = trainingFileList[i]</span><br><span class="line">        fileStr = fileNameStr.split(<span class="string">'.'</span>)[<span class="number">0</span>]     <span class="comment">#take off .txt</span></span><br><span class="line">        classNumStr = int(fileStr.split(<span class="string">'_'</span>)[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> classNumStr == <span class="number">9</span>: hwLabels.append(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">else</span>: hwLabels.append(<span class="number">1</span>)</span><br><span class="line">        trainingMat[i,:] = img2vector(<span class="string">'%s/%s'</span> % (dirName, fileNameStr))</span><br><span class="line">    <span class="keyword">return</span> trainingMat, hwLabels    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testDigits</span><span class="params">(kTup=<span class="params">(<span class="string">'rbf'</span>, <span class="number">10</span>)</span>)</span>:</span></span><br><span class="line">    dataArr,labelArr = loadImages(<span class="string">'trainingDigits'</span>)</span><br><span class="line">    b,alphas = smoP(dataArr, labelArr, <span class="number">200</span>, <span class="number">0.0001</span>, <span class="number">10000</span>, kTup)</span><br><span class="line">    datMat=mat(dataArr); labelMat = mat(labelArr).transpose()</span><br><span class="line">    svInd=nonzero(alphas.A&gt;<span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">    sVs=datMat[svInd] </span><br><span class="line">    labelSV = labelMat[svInd];</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"there are %d Support Vectors"</span> % shape(sVs)[<span class="number">0</span>]</span><br><span class="line">    m,n = shape(datMat)</span><br><span class="line">    errorCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        kernelEval = kernelTrans(sVs,datMat[i,:],kTup)</span><br><span class="line">        predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b</span><br><span class="line">        <span class="keyword">if</span> sign(predict)!=sign(labelArr[i]): errorCount += <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"the training error rate is: %f"</span> % (float(errorCount)/m)</span><br><span class="line">    dataArr,labelArr = loadImages(<span class="string">'testDigits'</span>)</span><br><span class="line">    errorCount = <span class="number">0</span></span><br><span class="line">    datMat=mat(dataArr); labelMat = mat(labelArr).transpose()</span><br><span class="line">    m,n = shape(datMat)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        kernelEval = kernelTrans(sVs,datMat[i,:],kTup)</span><br><span class="line">        predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b</span><br><span class="line">        <span class="keyword">if</span> sign(predict)!=sign(labelArr[i]): errorCount += <span class="number">1</span>    </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"the test error rate is: %f"</span> % (float(errorCount)/m)</span><br></pre></td></tr></table></figure><br>基于SVM构建多类分类器已有很多研究和对比了，感兴趣可以查看C.W.Huset等人发表的一篇论文”A Comparison of Methods for Multiclass Support Vector Machines”</p>
<p>《机器学习实战》一书中，作者使用不同的σ值，并尝试了线性核函数，得到的结果是：<br><img src="/images/machineLearning05_9.png" alt="nineth"><br>表中结果表明，径向基函数中的参数\(\sigma=10\)左右时，可以得到最小测试错误率，该参数值比前面例子中的取值1.3大得多，这些差距是由于数据不同造成的，手写识别的数据中有1024个特征，而这些特征的值可能高达1.0，而前面的例子中只有2个特征。如何取值呢?多次尝试可以得到比较好的结果，C的设置也会影响到分类的结果。<br>当然存在另外的SVM形式，把C同时考虑进了优化过程中，例如v-SVM，这里可以参考Sergios Theodoridis和Konstantinos Koutroumbas撰写的Pattern Recognition。<br>我们还会发现，最小的训练错误率并不对应于最小的支持向量数目，另一个值得注意的点是：线性核函数的效果并不是特别差，可以牺牲线性核函数的错误率来提高分类速度，</p>
]]></content>
      <categories>
        <category>techonology</category>
        <category>ai</category>
      </categories>
      <tags>
        <tag>machine learning</tag>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记七</title>
    <url>/2015/05/08/reading07/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-Preface"><a href="#1-Preface" class="headerlink" title="1. Preface"></a>1. Preface</h3><p>From <em>Sand and Foam (excerpt)</em> by Kahlil Gibran</p>
<h3 id="2-Content"><a href="#2-Content" class="headerlink" title="2. Content"></a>2. Content</h3><blockquote><br>Seven times I have despised my soul:<br>The first time when I saw her being meek that she might attain height.<br>The second time when I saw her limping before the crippled.<br>The third time when she was given to choose between the hard and the easy, and she chose the easy.<br>The fourth time when she committed a wrong, and comforted herself that others also commit wrong.<br>The fifth time when she forbore for weakness, and attributed her patience to strength.<br>The sixth time when she despised the ugliness of a face, and knew not that it was one of her own masks.<br>And the seventh time when she sang a song of praise, and deemed it a virtue<br><br>纪伯伦 《沙与沫》 （节选）<br>曾有七次我鄙视我的灵魂：<br>第一次，当我看到她可以升迁却退让时<br>第二次，当我看到她在瘸者面前跛足前行时<br>第三次，当她处在难易之间而选择了易时<br>第四次，当她犯了错，却安慰自己说别人也会犯错时<br>第五次，当她因为懦弱而忍耐，却自认为坚忍时<br>第六次，当她鄙视一张人面的丑陋，却不知道那正是自己面具的一张时<br>第七次，当她唱着颂歌并自以为是一种美德时<br></blockquote><br><a id="more"></a><br><br><blockquote><br>All(全文):<br>I AM FOREVER walking upon these shores,<br>Betwixt the sand and the foam,<br>The high tide will erase my foot-prints,<br>And the wind will blow away the foam.<br>But the sea and the shore will remain<br>Forever.<br><br>Once I filled my hand with mist.<br>Then I opened it and lo, the mist was a worm.<br>And I closed and opened my hand again, and behold there was a bird.<br>And again I closed and opened my hand, and in its hollow stood a man with a sad face, turned upward.<br>And again I closed my hand, and when I opened it there was naught but mist.<br>But I heard a song of exceeding sweetness.<br><br>It was but yesterday I thought myself a fragment quivering without rhythm in the sphere of life.<br>Now I know that I am the sphere, and all life in rhythmic fragments moves within me.<br><br>They say to me in their awakening, “You and the world you live in are but a grain of sand upon the infinite shore of an infinite sea.”<br>And in my dream I say to them, “I am the infinite sea, and all worlds are but grains of sand upon my shore.”<br><br>Only once have I been made mute. It was when a man asked me, “Who are you?”<br><br>The first thought of God was an angel.<br>The first word of God was a man.<br><br>We were fluttering, wandering, longing creatures a thousand thousand years before the sea and the wind in the forest gave us words.<br>Now how can we express the ancient of days in us with only the sounds of our yesterdays?<br><br>The Sphinx spoke only once, and the Sphinx said, “A grain of sand is a desert, and a desert is a grain of sand; and now let us all be silent again.”<br>I heard the Sphinx, but I did not understand.<br><br>Long did I lie in the dust of Egypt, silent and unaware of the seasons.<br>Then the sun gave me birth, and I rose and walked upon the banks of the Nile,<br>Singing with the days and dreaming with the nights.<br>And now the sun threads upon me with a thousand feet that I may lie again in the dust of Egypt.<br>But behold a marvel and a riddle!<br>The very sun that gathered me cannot scatter me.<br>Still erect am I, and sure of foot do I walk upon the banks of the Nile.<br><br>Remembrance is a form of meeting.<br><br>Forgetfulness is a form of freedom.<br><br>We measure time according to the movement of countless suns; and they measure time by little machines in their little pockets.<br>Now tell me, how could we ever meet at the same place and the same time?<br><br>Space is not space between the earth and the sun to one who looks down from the windows of the Milky Way.<br><br>Humanity is a river of light running from the ex-eternity to eternity.<br><br>Do not the spirits who dwell in the ether envy man his pain?<br><br>On my way to the Holy City I met another pilgrim and I asked him, “Is this indeed the way to the Holy City?”<br>And he said, “Follow me, and you will reach the Holy City in a day and a night.”<br>And I followed him. And we walked many days and many nights, yet we did not reach the Holy City.<br>And what was to my surprise he became angry with me because he had misled me.<br><br>Make me, oh God, the prey of the lion, ere You make the rabbit my prey.<br><br>One may not reach the dawn save by the path of the night.<br><br>My house says to me, “Do not leave me, for here dwells your past.”<br>And the road says to me, “Come and follow me, for I am your future.”<br>And I say to both my house and the road, “I have no past, nor have I a future. If I stay here, there is a going in my staying; and if I go there is a staying in my going. Only love and death will change all things.”<br><br>How can I lose faith in the justice of life, when the dreams of those who sleep upon feathers are not more beautiful than the dreams of those who sleep upon the earth? Strange, the desire for certain pleasures is a part of my pain.<br><br>Seven times have I despised my soul:<br>The first time when I saw her being meek that she might attain height.<br>The second time when I saw her limping before the crippled.<br>The third time when she was given to choose between the hard and the easy, and she chose the easy.<br>The fourth time when she committed a wrong, and comforted herself that others also commit wrong.<br>The fifth time when she forbore for weakness, and attributed her patience to strength.<br>The sixth time when she despised the ugliness of a face, and knew not that it was one of her own masks.<br>And the seventh time when she sang a song of praise, and deemed it a virtue.<br><br>I AM IGNORANT of absolute truth. But I am humble before my ignorance and therein lies my honor and my reward.<br><br>There is a space between man’s imagination and man’s attainment that may only be traversed by his longing.<br><br>Paradise is there, behind that door, in the next room; but I have lost the key.<br>Perhaps I have only mislaid it.<br><br>You are blind and I am deaf and dumb, so let us touch hands and understand.<br><br>The significance of man is not in what he attains, but rather in what he longs to attain.<br><br>Some of us are like ink and some like paper.<br>And if it were not for the blackness of some of us, some of us would be dumb;<br>And if it were not for the whiteness of some of us, some of us would be blind.<br><br>Give me an ear and I will give you a voice.<br><br>Our mind is a sponge; our heart is a stream.<br>Is it not strange that most of us choose sucking rather than running?<br><br>When you long for blessings that you may not name, and when you grieve knowing not the cause, then indeed you are growing with all things that grow, and rising toward your greater self.<br><br>When one is drunk with a vision, he deems his faint expression of it the very wine.<br><br>You drink wine that you may be intoxicated; and I drink that it may sober me from that other wine.<br><br>When my cup is empty I resign myself to its emptiness; but when it is half full I resent its half-fulness.<br><br>The reality of the other person is not in what he reveals to you, but in what he cannot reveal to you.<br>Therefore, if you would understand him, listen not to what he says but rather to what he does not say.<br><br>Half of what I say is meaningless; but I say it so that the other half may reach you.<br><br>A sense of humour is a sense of proportion.<br><br>My loneliness was born when men praised my talkative faults and blamed my silent virtues.<br><br>When Life does not find a singer to sing her heart she produces a philosopher to speak her mind.<br><br>A truth is to be known always, to be uttered sometimes.<br><br>The real in us is silent; the acquired is talkative.<br><br>The voice of life in me cannot reach the ear of life in you; but let us talk that we may not feel lonely.<br><br>When two women talk they say nothing; when one woman speaks she reveals all of life.<br><br>Frogs may bellow louder than bulls, but they cannot drag the plough in the field not turn the wheel of the winepress, and of their skins you cannot make shoes.<br><br>Only the dumb envy the talkative.<br><br>If winter should say, “Spring is in my heart,” who would believe winter?<br><br>Every seed is a longing.<br><br>Should you really open your eyes and see, you would behold your image in all images.<br>And should you open your ears and listen, you would hear your own voice in all voices.<br><br>It takes two of us to discover truth: one to utter it and one to understand it.<br><br>Though the wave of words is forever upon us, yet our depth is forever silent.<br><br>Many a doctrine is like a window pane. We see truth through it but it divides us from truth.<br><br>Now let us play hide and seek. Should you hide in my heart it would not be difficult to find you. But should you hide behind your own shell, then it would be useless for anyone to seek you. A woman may veil her face with a smile.<br><br>How noble is the sad heart who would sing a joyous song with joyous hearts.<br><br>He who would understand a woman, or dissect genius, or solve the mystery of silence is the very man who would wake from a beautiful dream to sit at a breakfast table.<br><br>I would walk with all those who walk. I would not stand still to watch the procession passing by.<br><br>You owe more than gold to him who serves you. Give him of your heart or serve him.<br><br>Nay, we have not lived in vain. Have they not built towers of our bones?<br><br>Let us not be particular and sectional. The poet’s mind and the scorpion’s tail rise in glory from the same earth.<br><br>Every dragon gives birth to a St. George who slays it.<br><br>Trees are poems that the earth writes upon the sky. We fell them down and turn them into paper that we may record our emptiness.<br><br>Should you care to write (and only the saints know why you should) you must needs have knowledge and art and music – the knowledge of the music of words, the art of being artless, and the magic of loving your readers.<br><br>They dip their pens in our hearts and think they are inspired.<br><br>Should a tree write its autobiography it would not be unlike the history of a race.<br><br>If I were to choose between the power of writing a poem and the ecstasy of a poem unwritten, I would choose the ecstasy. It is better poetry.<br>But you and all my neighbors agree that I always choose badly.<br><br>Poetry is not an opinion expressed. It is a song that rises from a bleeding wound or a smiling mouth.<br><br>Words are timeless. You should utter them or write them with a knowledge of their timelessness.<br><br>A POET IS a dethroned king sitting among the ashes of his palace trying to fashion an image out of the ashes.<br><br>Poetry is a deal of joy and pain and wonder, with a dash of the dictionary.<br><br>In vain shall a poet seek the mother of the songs of his heart.<br><br>Once I said to a poet, “We shall not know your worth until you die.”<br>And he answered saying, “Yes, death is always the revealer. And if indeed you would know my worth it is that I have more in my heart than upon my tongue, and more in my desire than in my hand.”<br><br>If you sing of beauty though alone in the heart of the desert you will have an audience.<br><br>Poetry is wisdom that enchants the heart.<br>Wisdom is poetry that sings in the mind.<br>If we could enchant man’s heart and at the same time sing in his mind,<br>Then in truth he would live in the shadow of God.<br><br>Inspiration will always sing; inspiration will never explain.<br><br>We often sing lullabies to our children that we ourselves may sleep.<br><br>All our words are but crumbs that fall down from the feast of the mind.<br><br>Thinking is always the stumbling stone to poetry.<br><br>A great singer is he who sings our silences.<br><br>How can you sing if your mouth be filled with food?<br>How shall your hand be raised in blessing if it is filled with gold?<br><br>They say the nightingale pierces his bosom with a thorn when he sings his love song.<br>So do we all. How else should we sing?<br><br>Genius is but a robin’s song at the beginning of a slow spring.<br><br>Even the most winged spirit cannot escape physical necessity.<br><br>A madman is not less a musician than you or myself; only the instrument on which he plays is a little out of tune.<br><br>The song that lies silent in the heart of a mother sings upon the lips of her child.<br><br>No longing remains unfulfilled.<br><br>I have never agreed with my other self wholly. The truth of the matter seems to lie between us.<br><br>Your other self is always sorry for you. But your other self grows on sorrow; so all is well.<br><br>There is no struggle of soul and body save in the minds of those whose souls are asleep and whose bodies are out of tune.<br><br>When you reach the heart of life you shall find beauty in all things, even in the eyes that are blind to beauty.<br><br>We live only to discover beauty. All else is a form of waiting.<br><br>Sow a seed and the earth will yield you a flower. Dream your dream to the sky and it will bring you your beloved.<br><br>The devil died the very day you were born.<br>Now you do not have to go through hell to meet an angel.<br><br>Many a woman borrows a man’s heart; very few could possess it.<br><br>If you would possess you must not claim.<br><br>When a man’s hand touches the hand of a woman they both touch the heart of eternity.<br><br>Love is the veil between lover and lover.<br><br>Every man loves two women; the one is the creation of his imagination, and the other is not yet born.<br><br>Men who do not forgive women their little faults will never enjoy their great virtues.<br><br>Love that does not renew itself every day becomes a habit and in turn a slavery.<br><br>Lovers embrace that which is between them rather than each other.<br><br>Love and doubt have never been on speaking terms.<br><br>Love is a word of light, written by a hand of light, upon a page of light.<br><br>Friendship is always a sweet responsibility, never an opportunity.<br><br>If you do not understand your friend under all conditions you will never understand him.<br><br>Your most radiant garment is of the other person’s weaving;<br>You most savory meal is that which you eat at the other person’s table;<br>Your most comfortable bed is in the other person’s house.<br>Now tell me, how can you separate yourself from the other person?<br><br>Your mind and my heart will never agree until your mind ceases to live in numbers and my heart in the mist.<br><br>We shall never understand one another until we reduce the language to seven words.<br><br>HOW SHALL MY heart be unsealed unless it be broken?<br><br>Only great sorrow or great joy can reveal your truth.<br>If you would be revealed you must either dance naked in the sun, or carry your cross.<br><br>Should nature heed what we say of contentment no river would seek the sea, and no winter would turn to Spring. Should she heed all we say of thrift, how many of us would be breathing this air?<br><br>You see but your shadow when you turn your back to the sun.<br><br>You are free before the sun of the day, and free before the stars of the night;<br>And you are free when there is no sun and no moon and no star.<br>You are even free when you close your eyes upon all there is.<br>But you are a slave to him whom you love because you love him,<br>And a slave to him who loves you because he loves you.<br><br>We are all beggars at the gate of the temple, and each one of us receives his share of the bounty of the King when he enters the temple, and when he goes out.<br>But we are all jealous of one another, which is another way of belittling the King.<br><br>You cannot consume beyond your appetite. The other half of the loaf belongs to the other person, and there should remain a little bread for the chance guest.<br><br>If it were not for your guests all houses would be graves.<br><br>Said a gracious wolf to a simple sheep, “Will you not honor our house with a visit?”<br>And the sheep answered, “We would have been honored to visit your house if it were not in your stomach.”<br><br>I stopped my guest on the threshold and said, “Nay, wipe not your feet as you enter, but as you go out.”<br><br>Generosity is not in giving me that which I need more than you do, but it is in giving me that which you need more than I do.<br><br>You are indeed charitable when you give, and while giving, turn your face away so that you may not see the shyness of the receiver.<br><br>The difference between the richest man and the poorest is but a day of hunger and an hour of thirst.<br><br>We often borrow from our tomorrows to pay our debts to our yesterdays.<br><br>I too am visited by angels and devils, but I get rid of them.<br>When it is an angel I pray an old prayer, and he is bored;<br>When it is a devil I commit an old sin, and he passes me by.<br><br>After all this is not a bad prison; but I do not like this wall between my cell and the next prisoner’s cell;<br>Yet I assure you that I do not wish to reproach the warder not the Builder of the prison.<br><br>Those who give you a serpent when you ask for a fish, may have nothing but serpents to give. It is then generosity on their part.<br><br>Trickery succeeds sometimes, but it always commits suicide.<br><br>You are truly a forgiver when you forgive murderers who never spill blood, thieves who never steal, and liars who utter no falsehood.<br><br>He who can put his finger upon that which divides good from evil is he who can touch the very hem of the garment of God.<br><br>If your heart is a volcano how shall you expect flowers to bloom in your hands?<br><br>A strange form of self-indulgence! There are times when I would be wronged and cheated, that I may laugh at the expense of those who think I do not know I am being wronged and cheated.<br><br>What shall I say of him who is the pursuer playing the part of the pursued?<br><br>Let him who wipes his soiled hands with your garment take your garment. He may need it again; surely you would not.<br><br>It is a pity that money-changers cannot be good gardeners.<br><br>Please do not whitewash your inherent faults with your acquired virtues. I would have the faults; they are like mine own.<br><br>How often have I attributed to myself crimes I have never committed, so that the other person may feel comfortable in my presence.<br><br>Even the masks of life are masks of deeper mystery.<br><br>You may judge others only according to your knowledge of yourself.<br>Tell me now, who among us is guilty and who is unguilty?<br><br>The truly just is he who feels half guilty of your misdeeds.<br><br>Only an idiot and a genius break man-made laws; and they are the nearest to the heart of God.<br><br>It is only when you are pursued that you become swift.<br><br>I have no enemies, O God, but if I am to have an enemy<br>Let his strength be equal to mine,<br>That truth alone may be the victor.<br><br>You will be quite friendly with your enemy when you both die.<br><br>Perhaps a man may commit suicide in self-defense.<br><br>Long ago there lived a Man who was crucified for being too loving and too lovable.<br>And strange to relate I met him thrice yesterday.<br>The first time He was asking a policeman not to take a prostitute to prison; the second time He was drinking wine with an outcast; and the third time He was having a fist-fight with a promoter inside a church.<br><br>If all they say of good and evil were true, then my life is but one long crime.<br><br>Pity is but half justice.<br><br>THE ONLY ONE who has been unjust to me is the one to whose brother I have been unjust.<br><br>When you see a man led to prison say in your heart, “Mayhap he is escaping from a narrower prison.”<br>And when you see a man drunken say in your heart, “Mayhap he sought escape from something still more unbeautiful.”<br><br>Oftentimes I have hated in self-defense; but if I were stronger I would not have used such a weapon.<br><br>How stupid is he who would patch the hatred in his eyes with the smile of his lips.<br><br>Only those beneath me can envy or hate me.<br>I have never been envied nor hated; I am above no one.<br>Only those above me can praise or belittle me.<br>I have never been praised nor belittled; I am below no one.<br><br>Your saying to me, “I do not understand you,” is praise beyond my worth, and an insult you do not deserve. How mean am I when life gives me gold and I give you silver, and yet I deem myself generous.<br><br>When you reach the heart of life you will find yourself not higher than the felon, and not lower than the prophet.<br><br>Strange that you should pity the slow-footed and not the slow-minded,<br>And the blind-eyed rather than the blind-hearted.<br><br>It is wiser for the lame not to break his crutches upon the head of his enemy.<br><br>How blind is he who gives you out of his pocket that he may take out of your heart.<br><br>Life is a procession. The slow of foot finds it too swift and he steps out;<br>And the swift of foot finds it too slow and he too steps out.<br><br>If there is such a thing as sin some of us commit it backward following our forefathers’ footsteps;<br>And some of us commit it forward by overruling our children.<br><br>The truly good is he who is one with all those who are deemed bad.<br><br>We are all prisoners but some of us are in cells with windows and some without.<br><br>Strange that we all defend our wrongs with more vigor than we do our rights.<br><br>Should we all confess our sins to one another we would all laugh at one another for our lack of originality.<br>Should we all reveal our virtues we would also laugh for the same cause.<br><br>An individual is above man-made laws until he commits a crime against man-made conventions; After that he is neither above anyone nor lower than anyone.<br><br>Government is an agreement between you and myself. You and myself are often wrong.<br><br>Crime is either another name of need or an aspect of a disease.<br><br>Is there a greater fault than being conscious of the other person’s faults?<br><br>If the other person laughs at you, you can pity him; but if you laugh at him you may never forgive yourself.<br>If the other person injures you, you may forget the injury; but if you injure him you will always remember.<br>In truth the other person is your most sensitive self given another body.<br><br>How heedless you are when you would have men fly with your wings and you cannot even give them a feather.<br><br>Once a man sat at my board and ate my bread and drank my wine and went away laughing at me.<br>Then he came again for bread and wine, and I spurned him;<br>And the angels laughed at me.<br><br>Hate is a dead thing. Who of you would be a tomb?<br><br>It is the honor of the murdered that he is not the murderer.<br><br>The tribune of humanity is in its silent heart, never its talkative mind.<br><br>They deem me mad because I will not sell my days for gold;<br>And I deem them mad because they think my days have a price.<br><br>They spread before us their riches of gold and silver, of ivory and ebony, and we spread before them our hearts and our spirits.;<br>And yet they deem themselves the hosts and us the guests.<br><br>I would not be the least among men with dreams and the desire to fulfill them, rather than the greatest with no dreams and no desires.<br><br>The most pitiful among men is he who turns his dreams into silver and gold.<br><br>We are all climbing toward the summit of our hearts’ desire. Should the other climber steal your sack and your purse and wax fat on the one and heavy on the other, you should pity him;<br>The climbing will be harder for his flesh, and the burden will make his way longer.<br>And should you in your leanness see his flesh puffing upward, help him a step; it will add to your swiftness.<br><br>You cannot judge any man beyond your knowledge of him, and how small is your knowledge.<br><br>I would not listen to a conqueror preaching to the conquered.<br><br>The truly free man is he who bears the load of the bond slave patiently.<br><br>A thousand years ago my neighbor said to me, “I hate life, for it is naught but a thing of pain.”<br>And yesterday I passed by a cemetery and saw life dancing upon his grave.<br><br>Strife in nature is but disorder longing for order.<br><br>Solitude is a silent storm that breaks down all our dead branches;<br>Yet it sends our living roots deeper into the living heart of the living earth.<br><br>Once I spoke of the sea to a brook, and the brook thought me but an imaginative exaggerator;<br>And once I spoke of a brook to the sea, and the sea thought me but a depreciative defamer.<br><br>How narrow is the vision that exalts the busyness of the ant above the singing of the grasshopper.<br><br>The highest virtue here may be the least in another world.<br><br>The deep and the high go to the depth or to the height in a straight line; only the spacious can move in circles.<br><br>IF IT WERE not for our conception of weights and measures we would stand in awe of the firefly as we do before the sun.<br><br>A scientist without imagination is a butcher with dull knives and out-worn scales.<br>But what would you, since we are not all vegetarians?<br><br>When you sing the hungry hears you with his stomach.<br><br>Death is not nearer to the aged than to the new-born; neither is life.<br><br>If indeed you must be candid, be candid beautifully; otherwise keep silent, for there is a man in our neighborhood who is dying.<br><br>Mayhap a funeral among men is a wedding feast among the angels.<br><br>A forgotten reality may die and leave in its will seven thousand actualities and facts to be spent in its funeral and the building of a tomb.<br><br>In truth we talk only to ourselves, but sometimes we talk loud enough that others may hear us.<br><br>The obvious is that which is never seen until someone expresses it simply.<br><br>If the Milky Way were not within me how should I have seen it or known it?<br><br>Unless I am a physician among physicians they would not believe that I am an astronomer.<br><br>Perhaps the sea’s definition of a shell is the pearl.<br>Perhaps time’s definition of coal is the diamond.<br><br>Fame is the shadow of passion standing in the light.<br><br>A root is a flower that disdains fame.<br><br>There is neither religion nor science beyond beauty.<br><br>Every great man I have known had something small in his make-up; and it was that small something which prevented inactivity or madness or suicide.<br><br>The truly great man is he who would master no one, and who would be mastered by none.<br><br>I would not believe that a man is mediocre simply because he kills the criminals and the prophets.<br><br>Tolerance is love sick with the sickness of haughtiness.<br><br>Worms will turn; but is it not strange that even elephants will yield?<br><br>A disagreement may be the shortest cut between two minds.<br><br>I am the flame and I am the dry bush, and one part of me consumes the other part.<br><br>We are all seeking the summit of the holy moutain; but shall not our road be shorter if we consider the past a chart and not a guide?<br><br>Wisdom ceases to be wisdom when it becomes too proud to weep, too grave to laugh, and too self-ful to seek other than itself.<br><br>Had I filled myself with all that you know what room should I have for all that you do not know?<br><br>I have learned silence from the talkative, toleration from the intolerant, and kindness from the unkind; yet strange, I am ungrateful to these teachers.<br><br>A bigot is a stone-leaf orator.<br><br>The silence of the envious is too noisy.<br><br>When you reach the end of what you should know, you will be at the beginning of what you should sense.<br><br>An exaggeration is a truth that has lost its temper.<br><br>If you can see only what light reveals and hear only what sound announces,<br>Then in truth you do not see nor do you hear.<br><br>A fact is a truth unsexed.<br><br>You cannot laugh and be unkind at the same time.<br><br>The nearest to my heart are a king without a kingdom and a poor man who does not know how to beg.<br><br>A shy failure is nobler than an immodest success.<br><br>Dig anywhere in the earth and you will find a treasure, only you must dig with the faith of a peasant.<br><br>Said a hunted fox followed by twenty horsemen and a pack of twenty hounds, “Of course they will kill me. But how poor and how stupid they must be. Surely it would not be worth while for twenty foxes riding on twenty asses and accompanied by twenty wolves to chase and kill one man.”<br><br>It is the mind in us that yields to the laws made by us, but never the spirit in us.<br><br>A traveler am I and a navigator, and every day I discover a new region within my soul.<br><br>A woman protested saying, “Of course it was a righteous war. My son fell in it.”<br><br>I said to Life, “I would hear Death speak.”<br>And Life raised her voice a little higher and said, “You hear him now.”<br><br>When you have solved all the mysteries of life you long for death, for it is but another mystery of life.<br><br>Birth and death are the two noblest expressions of bravery.<br><br>My friend, you and I shall remain strangers unto life,<br>And unto one another, and each unto himself,<br>Until the day when you shall speak and I shall listen<br>Deeming your voice my own voice;<br>And when I shall stand before you<br>Thinking myself standing before a mirror.<br><br>They say to me, “Should you know yourself you would know all men.”<br>And I say, “Only when I seek all men shall I know myself.”<br><br>MAN IS TWO men; one is awake in darkness, the other is asleep in light.<br><br>A hermit is one who renounces the world of fragments that he may enjoy the world wholly and without interruption.<br><br>There lies a green field between the scholar and the poet; should the scholar cross it he becomes a wise man; should the poet cross it, he becomes a prophet.<br><br>Yestereve I saw philosophers in the market-place carrying their heads in baskets, and crying aloud, “Wisdom! Wisdom for sale!”<br>Poor philosophers! They must needs sell their heads to feed their hearts. Said a philosopher to a street sweeper, “I pity you. Yours is a hard and dirty task.”<br>And the street sweeper said, “Thank you, sir. But tell me what is your task?”<br>And the philosopher answered saying, “I study man’s mind, his deeds and his desires.”<br>Then the street sweeper went on with his sweeping and said with a smile, “I pity you too.”<br><br>He who listens to truth is not less than he who utters truth.<br><br>No man can draw the line between necessities and luxuries. Only the angels can do that, and the angels are wise and wistful.<br>Perhaps the angels are our better thought in space.<br><br>He is the true prince who finds his throne in the heart of the dervish.<br><br>Generosity is giving more than you can, and pride is taking less than you need.<br><br>In truth you owe naught to any man. You owe all to all men.<br><br>All those who have lived in the past live with us now. Surely none of us would be an ungracious host.<br><br>He who longs the most lives the longest.<br><br>They say to me, “A bird in the hand is worth ten in the bush.”<br>But I say, “A bird and a feather in the bush is worth more than ten birds in the hand.”<br>Your seeking after that feather is life with winged feet; nay, it is life itself.<br><br>There are only two elements here, beauty and truth; beauty in the hearts of lovers, and truth in the arms of the tillers of the soil.<br><br>Great beauty captures me, but a beauty still greater frees me even from itself.<br><br>Beauty shines brighter in the heart of him who longs for it than in the eyes of him who sees it.<br><br>I admire him who reveals his mind to me; I honor him who unveils his dreams. But why am I shy, and even a little ashamed before him who serves me?<br><br>The gifted were once proud in serving princes.<br>Now they claim honor in serving paupers.<br><br>The angels know that too many practical men eat their bread with the sweat of the dreamer’s brow.<br><br>Wit is often a mask. If you could tear it you would find either a genius irritated or cleverness juggling.<br><br>The understanding attributes to me understanding and the dull, dullness. I think they are both right.<br><br>Only those with secrets in their hearts could divine the secrets in our hearts.<br><br>He who would share your pleasure but not your pain shall lose the key to one of the seven gates of Paradise.<br><br>Yes, there is a Nirvanah; it is in leading your sheep to a green pasture, and in putting your child to sleep, and in writing the last line of your poem.<br><br>We choose our joys and our sorrows long before we experience them.<br><br>Sadness is but a wall between two gardens.<br><br>When either your joy or your sorrow becomes great the world becomes small.<br><br>Desire is half of life; idifference is half of death.<br><br>The bitterest thing in our today’s sorrow is the memory of our yesterday’s joy.<br><br>They say to me, “You must needs choose between the pleasures of this world and the peace of the next world.”<br>And I say to them, “I have chosen both the delights of this world and the peace of the next. For I know in my heart that the Supreme Poet wrote but one poem, and it scans perfectly, and it also rhymes perfectly.”<br><br>Faith is an oasis in the heart which will never be reached by the caravan of thinking.<br><br>When you reach your height you shall desire but only for desire; and you shall hunger, for hunger; and you shall thirst for greater thirst.<br><br>If you reveal your secrets to the wind you should not blame the wind for revealing them to the trees.<br><br>The flowers of spring are winter’s dreams related at the breakfast table of the angels.<br><br>Said a skunk to a tube-rose, “See how swiftly I run, while you cannot walk nor even creep.”<br>Said the tube-rose to the skunk, “Oh, most noble swift runner, please run swiftly!”<br><br>Turtles can tell more about roads than hares.<br><br>Strange that creatures without backbones have the hardest shells.<br><br>The most talkative is the least intelligent, and there is hardly a difference between an orator and an auctioneer.<br><br>Be grateful that you do not have to live down the renown of a father nor the wealth of an uncle.<br>But above all be grateful that no one will have to live down either your renown or your wealth.<br><br>Only when a juggler misses catching his ball does he appeal to me.<br><br>The envious praises me unknowingly.<br><br>Long were you a dream in your mother’s sleep, and then she woke to give you birth.<br><br>The germ of the race is in your mother’s longing.<br><br>My father and mother desired a child and they begot me.<br>And I wanted a mother and a father and I begot night and the sea.<br><br>Some of our children are our justifications and some are but our regrets.<br><br>When night comes and you too are dark, lie down and be dark with a will.<br>And when morning comes and you are still dark stand up and say to the day with a will, “I am still dark.”<br>It is stupid to play a role with the night and the day.<br>They would both laugh at you.<br><br>The mountain veiled in mist is not a hill; an oak tree in the rain is not a weeping willow.<br><br>Behold here is a paradox; the deep and high are nearer to one another than the mid-level to either.<br><br>When I stood a clear mirror before you, you gazed into me and saw your image.<br>Then you said, “I love you.”<br>But in truth you loved yourself in me.<br><br>When you enjoy loving your neighbor it ceases to be a virtue.<br><br>Love which is not always springing is always dying.<br><br>You cannot have youth and the knowledge of it at the same time;<br>For youth is too busy living to know, and knowledge is too busy seeking itself to live. You may sit at your window watching the passersby. And watching you may see a nun walking toward your right hand, and a prostitute toward your left hand.<br>And you may say in your innocence, “How noble is the one and how ignoble is the other.”<br>But should you close your eyes and listen awhile you would hear a voice whispering in the ether, “One seeks me in prayer, and the other in pain. And in the spirit of each there is a bower for my spirit.”<br><br>Once every hundred years Jesus of Nazareth meets Jesus of the Christian in a garden among the hills of Lebanon. And they talk long; and each time Jesus of Nazareth goes away saying to Jesus of the Christian, “My friend, I fear we shall never, never agree.”<br><br>May God feed the over-abundant!<br><br>A great man has two hearts; one bleeds and the other forbears.<br><br>Should one tell a lie which does not hurt you nor anyone else, why not say in your heart that the house of his facts is too small for his fancies, and he had to leave it for larger space?<br><br>Behind every closed door is a mystery sealed with seven seals.<br><br>Waiting is the hoofs of time.<br><br>What if trouble should be a new window in the Eastern wall of your house?<br><br>You may forget the one with whom you have laughed, but never the one with whom you have wept.<br><br>There must be something strangely sacred in salt. It is in our tears and in the sea.<br><br>Our God in His gracious thirst will drink us all, the dewdrop and the tear.<br><br>You are but a fragment of your giant self, a mouth that seeks bread, and a blind hand that holds the cup for a thirsty mouth.<br><br>If you would rise but a cubit above race and country and self you would indeed become godlike.<br><br>If I were you I would not find fault with the sea at low tide.<br>It is a good ship and our Captain is able; it is only your stomach that is in disorder.<br><br>Should you sit upon a cloud you would not see the boundary line between one country and another, nor the boundary stone between a farm and a farm.<br>It is a pity you cannot sit upon a cloud.<br><br>Seven centuries ago seven white doves rose from a deep valley flying to the snow-white summit of the mountain. One of the seven men who watched the flight said, “I see a black spot on the wing of the seventh dove.”<br>Today the people in that valley tell of seven black doves who flew to the summit of the snowy mountain.<br><br>In the autumn I gathered all my sorrows and buried them in my garden.<br>And when April returned and spring came to wed the earth, there grew in my garden beautiful flowers unlike all other flowers.<br>And my neighbors came to behold them, and they all said to me, “When autumn comes again, at seeding time, will you not give us of the seeds of these flowers that we may have them in our gardens?”<br><br>It is indeed misery if I stretch an empty hand to men and receive nothing; but it is hopelessness if I stretch a full hand and find none to receive.<br><br>I long for eternity because there I shall meet my unwritten poems and my unpainted pictures.<br><br>Art is a step from nature toward the Infinite.<br><br>A work of art is a mist carved into an image.<br><br>Even the hands that make crowns of thorns are better than idle hands.<br><br>Our most sacred tears never seek our eyes.<br><br>Every man is the descendant of every king and every slave that ever lived.<br><br>If the great-grandfather of Jesus had known what was hidden within him, would he not have stood in awe of himself?<br><br>Was the love of Judas’ mother of her son less than the love of Mary for Jesus?<br><br>There are three miracles of our Brother Jesus not yet recorded in the Book: the first that He was a man like you and me, the second that He had a sense of humour, and the third that He knew He was a conqueror though conquered.<br><br>Crucified One, you are crucified upon my heart; and the nails that pierce your hands pierce the walls of my heart.<br>And tomorrow when a stranger passes by this Golgotha he will not know that two bled here.<br>He will deem it the blood of one man.<br><br>You may have heard of the Blessed Mountain.<br>It is the highest mountain in our world.<br>Should you reach the summit you would have only one desire, and that to descend and be with those who dwell in the deepest valley.<br>That is why it is called the Blessed Mountain.<br><br>Every thought I have imprisoned in expression I must free by my deeds.<br></blockquote>
]]></content>
      <categories>
        <category>life</category>
        <category>reading</category>
      </categories>
      <tags>
        <tag>poetry</tag>
        <tag>kahlil gibran</tag>
      </tags>
  </entry>
  <entry>
    <title>日语学习二</title>
    <url>/2017/09/30/japanese03/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>————<strong>更新于2018.05.25</strong>————<br><a href="/2017/09/16/japanese01/">上一篇文章</a>介绍了发音系统和书写系统，这一篇文章主要介绍词类系统和句法成分。词类在语法系统中属于传统语法的范畴，英文为<em>Part of speech</em>，可以参考<a href="https://en.wikipedia.org/wiki/Part_of_speech" target="_blank" rel="noopener">维基百科词条解释</a><sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “Part of Speech.” Wikipedia, Wikimedia Foundation, 22 June 2018, https://en.wikipedia.org/wiki/Part_of_speech.
">[1]</span></a></sup>。而句法成分(sentence element)应该属于功能语言学的范围，可以参考这些词条: <a href="https://en.wiktionary.org/wiki/sentence_element" target="_blank" rel="noopener">Sentence element</a><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “Sentence Element.” Servent - Wiktionary, https://en.wiktionary.org/wiki/sentence_element.
">[2]</span></a></sup>、<a href="https://en.wikipedia.org/wiki/Grammatical_relation" target="_blank" rel="noopener">Grammar relation</a><sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “Grammatical Relation.” Wikipedia, Wikimedia Foundation, 19 June 2018, https://en.wikipedia.org/wiki/Grammatical_relation.
">[3]</span></a></sup>、<a href="https://en.wikipedia.org/wiki/Functional_theories_of_grammar" target="_blank" rel="noopener">Functional theories of grammar-Wiki</a><sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “Functional Theories of Grammar.” Wikipedia, Wikimedia Foundation, 19 June 2018, https://en.wikipedia.org/wiki/Functional_theories_of_grammar.
">[4]</span></a></sup>。</p>
<a id="more"></a>
<h2 id="1-词类系统"><a href="#1-词类系统" class="headerlink" title="1. 词类系统"></a>1. 词类系统</h2><p>词类，即把单词按其意义、型态或职能加以分类所得的种别，日语的词类被称为品詞，维基百科上也有对<a href="https://ja.wikipedia.org/wiki/%E5%93%81%E8%A9%9E" target="_blank" rel="noopener">品詞</a><sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “品詞.” Wikipedia, Wikimedia Foundation, 19 Apr. 2018, https://ja.wikipedia.org/wiki/品詞.
">[5]</span></a></sup>的解释和划分。一般常见的一种划分方式是<a href="https://www.douban.com/note/640814003/" target="_blank" rel="noopener">十二品词</a><sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="洋渔 . “日文词语分为十二种品词(品词,ひんし).” 豆瓣, https://www.douban.com/note/640814003/.
">[6]</span></a></sup>，无论什么划分方式大体上都相似，Kino对其做了一点小改动而已。<br>本章只是对日语的词类系统进行介绍，并不涉及任何具体的变形。<br>下面在对每种词类概念进行介绍时，可能会涉及到尚未提及的概念，暂时先不用理解，只是为了概念的完整性将其置于此。</p>
<h3 id="1-1-自立語（独立词、实词）"><a href="#1-1-自立語（独立词、实词）" class="headerlink" title="1.1 自立語（独立词、实词）"></a>1.1 自立語（独立词、实词）</h3><h4 id="1-1-1-可以活用——用言"><a href="#1-1-1-可以活用——用言" class="headerlink" title="1.1.1 可以活用——用言"></a>1.1.1 可以活用——用言</h4><h5 id="1-1-1-1-动词"><a href="#1-1-1-1-动词" class="headerlink" title="1.1.1.1 动词"></a>1.1.1.1 动词</h5><p>表示事物的存在、动作或临时状态。根据不同的分类方法可以有不同的分类方式。</p>
<ol>
<li>日语里的动词可以分为自动词和他动词，类似于英语里的不及物动词和及物动词，其具体说明可参考<a href="https://ja.wikipedia.org/wiki/自動詞" target="_blank" rel="noopener">自動詞</a><sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “自動詞.” Wikipedia, Wikimedia Foundation, 18 Apr. 2018, https://ja.wikipedia.org/wiki/自動詞.
">[7]</span></a></sup>和<a href="https://ja.wikipedia.org/wiki/他動詞" target="_blank" rel="noopener">他動詞</a><sup id="fnref:8"><a href="#fn:8" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “他動詞.” Wikipedia, Wikimedia Foundation, 3 Feb. 2017, https://ja.wikipedia.org/wiki/他動詞.
">[8]</span></a></sup>，简单介绍如下:</li>
</ol>
<ul>
<li>自动词: 动词本身能完整地表达主语的某种动作的词，多用于陈述一些客观结果、动作状态。主语可以是生命体，也可以是非生命体，自动词不能带直接对象，但当地点是动作动词的直接对象，表示离开某地或者经过某地时时有例外，例如<em>部屋を出た</em>。</li>
<li>他动词: 动词本身不能完整地表达主语的某种动作的词，多用于表述人为的动作。主语通常是生命体，重点在于表达主语做了什么，所以需要加上名词表示主语的一个动作对象。<br>对于日语中的一个自/他动词来说，根据其是否有对应的他/自动词，以及形式是否相同，又可以归类为:<ul>
<li>绝对自动词: 即只有自动词没有相对应的他动词。</li>
<li>绝对他动词: 即只有他动词没有相对应的自动词。</li>
<li>自他同形词: 即该词本身既是自动词又是他动词。</li>
<li>有对自他词: 即该词有成对出现的另一个动词，这也是最令初学者头疼的一类。首先需要记住，自他动词的意思和汉字都是相同的，只是词尾不同表示不同的自他性。虽然规律不明显，但是有对自他词还是有一些常见规律的。<ul>
<li>「れる」结尾的都是自动词（例外: 入れる、忘れる）</li>
<li>「す」结尾的是他动词</li>
<li>「aru」结尾的都是自动词，「aru」变成「eru」就变成了他动词。注意此处Kino并没有用平假名表示，看几个例子就可以明白为何这样表示了: 「始まる、始める」、「まとまる、まとめる」、「かかる、かける」</li>
<li><strong>还有一些其他规律，但是Kino认为如果规律细节条目太多，就容易陷入单纯背诵规律之中，故不一一列举了，不妨日常多背单词、多使用。进行归类不是目的，目的是为了学习者最终流畅地运用，如果只记住了规律，而连单词都没记住几个，就是纸上谈兵了。对于自他动词，Kino认为规律并不重要，多背多读多用，很容易掌握其本质。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li>按照意义，动词还可以分为意志动词、非意志动词。</li>
</ol>
<ul>
<li>反映按人或“有情物”的意志去完成的动作行为，主要分为自控动作（指大脑能够控制的动作）、自控心理活动（指大脑能够控制的心理活动）两类。</li>
<li>反映人的自发性动作、生理心理现象、能力、以及“非情物”的运动。</li>
</ul>
<ol start="3">
<li>而和语法最相关的分类方式是根据变形规则上的区别将动词分为三大类，每一类有自己独特的变形规则，会影响到后续时/体/态/式等的说明，这三大类是:<ul>
<li>特殊动词: する、~する、くる</li>
<li>五段动词（う动词）: 不是以「る」结尾的动词肯定是五段动词。对于以「る」结尾的动词，如果「る」音前的假名包含/a/、/u/或者/o/元音，那它就是五段动词。</li>
<li>一段动词（る动词）: 以「る」结尾，前面是/i/或者/e/元音的，大多数情况下就是一段动词，一段动词中以/i/结尾叫做上一段动词，以/e/结尾的叫下一段动词。但是也有一些例外，常见的例外如表1。</li>
</ul>
</li>
</ol>
<p align="center">表1</p>

<table>
<thead>
<tr>
<th style="text-align:center">初级</th>
<th style="text-align:center">中级</th>
<th style="text-align:center">高级</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">要る</td>
<td style="text-align:center">煎る</td>
<td style="text-align:center">嘲る</td>
</tr>
<tr>
<td style="text-align:center">帰る</td>
<td style="text-align:center">焦る</td>
<td style="text-align:center">覆る</td>
</tr>
<tr>
<td style="text-align:center">返る</td>
<td style="text-align:center">限る</td>
<td style="text-align:center">茂る</td>
</tr>
<tr>
<td style="text-align:center">切る</td>
<td style="text-align:center">蹴る</td>
<td style="text-align:center">遮る</td>
</tr>
<tr>
<td style="text-align:center">しゃべる</td>
<td style="text-align:center">滑る</td>
<td style="text-align:center">罵る</td>
</tr>
<tr>
<td style="text-align:center">知る</td>
<td style="text-align:center">握る</td>
<td style="text-align:center">捻る</td>
</tr>
<tr>
<td style="text-align:center">入る</td>
<td style="text-align:center">練る</td>
<td style="text-align:center">翻る</td>
</tr>
<tr>
<td style="text-align:center">走る</td>
<td style="text-align:center">参る</td>
<td style="text-align:center">蘇る</td>
</tr>
<tr>
<td style="text-align:center">減る</td>
<td style="text-align:center">散る</td>
<td style="text-align:center">漲る</td>
</tr>
<tr>
<td style="text-align:center">照る</td>
<td style="text-align:center">交じる</td>
<td style="text-align:center">湿る</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">混じる</td>
<td style="text-align:center">滅入る</td>
</tr>
</tbody>
</table>
<ol start="4">
<li>动词的活用词根<br>Kino主要按照五段动词的变形形式，大体上将动词按照活用形式分为以下几类活用词根:<ul>
<li>あ形活用词根。由于该词根常用于动词的否定形式中，故在其他文献中都被称为未然形。<ul>
<li>五段动词: 词尾变成其所在行的あ段字。</li>
<li>一段动词: 把「る」去掉。例: 「食べる」变为「食べ」</li>
<li>「する」变为「し」，「くる」变为「こ」</li>
</ul>
</li>
<li>一类い形活用词根，Kino还把它简称为<strong>一型词根</strong>，简化后续说明。因其常用于连接用言，故在其他文献中都被称为连用形:<ul>
<li>五段动词: 把最后的假名从う段换成同行的い段假名，也叫一般连用形。例: 「遊ぶ」变为「遊び」</li>
<li>一段动词: 把「る」去掉。例: 「食べる」变为「食べ」</li>
<li>「する」变为「し」，「くる」变为「き」</li>
</ul>
</li>
<li>二类い形活用词根，Kino还把它简称为<strong>二型词根</strong>，简化后续说明。因其常用于连接用言，故在其他文献中都被称为连用形:<ul>
<li>五段动词: 结尾词不同其形式不同，分别是「す」-&gt;「し」、「く」-&gt;「い」、「ぐ」-&gt;「い」、「む/ぶ/ぬ」-&gt;「ん」、「る/う/つ」-&gt;「っ」，<strong>唯一的例外是「行く」-&gt;「行い」-&gt;「行っ」</strong>。也叫特殊连用形或音便形</li>
<li>一段动词: 把「る」去掉</li>
<li>「する」变为「し」，「くる」变为「き」</li>
</ul>
</li>
<li>う形活用词根: 就是动词原型，由于其可以用在句子结尾处，故被称为终止形，又因为其可用于修饰体言作定语，故也被称为连体形。</li>
<li>一类え形活用词根: 该词根变化规律不分类，任何动词只须将词最后一个假名由「う」段变为「え」段即可。由于其常用于假定语气中(如条件句等)，故被称为假定形。</li>
<li>二类え形活用词根，由于其常用于命令语气中(一般用于军队口令、训诉等场合)，故被称为命令形。<ul>
<li>五段动词: 将词尾假名由「う」段变为「え」段</li>
<li>一段动词: 将词尾最后一个假名「る」去掉，并后续「ろ」或「よ」</li>
<li>「する」有两种变形方式，即「し」和「せ」，二者还要分别后续「ろ」和「よ」，即「しろ/せよ」。「来る」变为「来い」</li>
</ul>
</li>
<li>お形活用词根，由于主要用于表示第一人称的意志、愿望、决心或表示第一人称对他人的劝诱等场合，故称为推量形:<ul>
<li>五段动词: 将词尾假名由「う」段变为「お」段，然后附上助动词「う」</li>
<li>一段动词: 将词尾最后一个假名「る」去掉，然后附上助动词「よう」</li>
<li>「する」变为「しよう」，「来る」变为「こよう」</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="1-1-1-2-形容词"><a href="#1-1-1-2-形容词" class="headerlink" title="1.1.1.2 形容词"></a>1.1.1.2 形容词</h5><p>说明体言（名词）的性质或固定状态，在语义上，形容词多表示性质、状态、属性、描述等含义，如大小、长短、高低、新旧、恶劣、好坏、色彩等。<br>根据变形的形式不同，可以将形容词划分为两类:</p>
<ul>
<li>一类形容词/い形容词: 以平假名「い」结尾的形容词被称为一类形容词，注意用汉字结尾，汉字的尾音是「い」的不算作一类形容词，例如: 「有名（ゆうめい）」、「綺麗（きれい）」等。例外情况极少，唯一常见的只有「嫌い（きらい）」。</li>
<li>二类形容词/な形容词/形容动词: 不是一类形容词的就是二类形容词咯。</li>
</ul>
<h4 id="1-1-2-不可以活用"><a href="#1-1-2-不可以活用" class="headerlink" title="1.1.2 不可以活用"></a>1.1.2 不可以活用</h4><h5 id="1-1-2-1-名词——体言"><a href="#1-1-2-1-名词——体言" class="headerlink" title="1.1.2.1 名词——体言"></a>1.1.2.1 名词——体言</h5><p>表示事物名称的单词。</p>
<ol>
<li><p>一般: 通常用于表示特定物体，如物体、物质、人物、地点等。</p>
</li>
<li><p>代词: 用来代替一般名词或名词短语的术语。<br>代词又可以分为人称代词、指示代词、反身代词等。<br>除第一人称外，其他人称代词在日语中较少使用。</p>
</li>
<li><p>数词: 是代表数字的单词。<br>通常可以用数词修饰的一般名词可以被归类为可数名词，否则被归类为不可数名词，但是日语和汉语一样对此要求并不严格。<br>在英语中，数词可以分为基数词（描述事物数量的多少的数词）和序数词（描述顺序的数词），在汉语和日语中都是通过在基数词上附加特殊词汇表示顺序，但通常还会涉及到后续才会提及的量词，日语里<strong>通过在量词后面加上「目」（读作「め」）来表示顺序，如「一回目」表示「第一次」</strong><br>基数词的词根如表2，组合方式和汉语相同，但组合之后某些读音有变化，如图3。<br>其他一些常用的和数量相关的表达方式:</p>
<ul>
<li>小数用「点（てん）」来表达，如: 0.4「れいてんよん」</li>
<li>分数用「～分（ぶん）の」的形式表示，如: 1/3「さんぷんのいち」</li>
<li>倍数用基数词加接尾词「倍（ばい）」表示，如: 3.5倍「さんてんごばい」</li>
<li>分数用「パーセント」表示，如: 1%「いちパーセント」</li>
<li>负数用「マイナス」加基数词表示，如: -3「マイナスさん」</li>
</ul>
</li>
</ol>
<p align="center">表2 基本数词词根</p>

<table>
<thead>
<tr>
<th style="text-align:center">–</th>
<th style="text-align:center">–</th>
<th style="text-align:center">–</th>
<th style="text-align:center">–</th>
<th style="text-align:center">–</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">一</td>
<td style="text-align:center">二</td>
<td style="text-align:center">三</td>
<td style="text-align:center">四</td>
<td style="text-align:center">五</td>
</tr>
<tr>
<td style="text-align:center">いち</td>
<td style="text-align:center">に</td>
<td style="text-align:center">さん</td>
<td style="text-align:center">し／よん</td>
<td style="text-align:center">ご</td>
</tr>
<tr>
<td style="text-align:center">六</td>
<td style="text-align:center">七</td>
<td style="text-align:center">八</td>
<td style="text-align:center">九</td>
<td style="text-align:center">十</td>
</tr>
<tr>
<td style="text-align:center">ろく</td>
<td style="text-align:center">しち／なな</td>
<td style="text-align:center">はち</td>
<td style="text-align:center">きゅう</td>
<td style="text-align:center">じゅう</td>
</tr>
<tr>
<td style="text-align:center">百</td>
<td style="text-align:center">千</td>
<td style="text-align:center">万</td>
<td style="text-align:center">億</td>
<td style="text-align:center">兆</td>
</tr>
<tr>
<td style="text-align:center">ひゃく</td>
<td style="text-align:center">せん</td>
<td style="text-align:center">まん</td>
<td style="text-align:center">おく</td>
<td style="text-align:center">ちょう</td>
</tr>
</tbody>
</table>
<p align="center">表3 一些特殊读音</p>

<table>
<thead>
<tr>
<th style="text-align:center">漢字</th>
<th style="text-align:center">ひらがな</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">三百</td>
<td style="text-align:center">さんびゃく</td>
</tr>
<tr>
<td style="text-align:center">六百</td>
<td style="text-align:center">ろっぴゃく</td>
</tr>
<tr>
<td style="text-align:center">八百</td>
<td style="text-align:center">はっぴゃく</td>
</tr>
<tr>
<td style="text-align:center">三千</td>
<td style="text-align:center">さんぜん</td>
</tr>
<tr>
<td style="text-align:center">八千</td>
<td style="text-align:center">はっせん</td>
</tr>
<tr>
<td style="text-align:center">一兆</td>
<td style="text-align:center">いっちょう</td>
</tr>
</tbody>
</table>
<ol start="4">
<li>量词: 也叫助数词/分类词，用于区别在数词之后附加的一般名词的类型。<br>量词直接加在数词后即可，但日语里比较复杂的一点是，数词后面接不同量词时，某些特定数词的读音可能会变化，这些例外情况有时太多，甚至要专门记忆，通过下面这些常用量词说明表可见一斑。量词可以参考<a href="https://zh.wikipedia.org/wiki/日文量詞" target="_blank" rel="noopener">日文量詞</a><sup id="fnref:9"><a href="#fn:9" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “日文量詞.” Wikipedia, Wikimedia Foundation, 20 June 2018, https://zh.wikipedia.org/wiki/日文量詞.
">[9]</span></a></sup>和<a href="https://ja.wikipedia.org/wiki/助数詞" target="_blank" rel="noopener">助数詞</a><sup id="fnref:10"><a href="#fn:10" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “助数詞.” Wikipedia, Wikimedia Foundation, 20 June 2018, https://ja.wikipedia.org/wiki/助数詞.
">[10]</span></a></sup>，以及如果有标日第二版，初级上的P.362-P.365也有相应表格。<br><strong>需要注意的一点是0不用数，因为没东西可数，直接用「ない」或「いない」就行。</strong></li>
</ol>
<p align="center">表4 与时间相关的量词</p>    

<table>
<thead>
<tr>
<th style="text-align:center">日本語</th>
<th style="text-align:center">例外</th>
<th style="text-align:center">用法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">年(ねん)</td>
<td style="text-align:center">无</td>
<td style="text-align:center">表示年份</td>
</tr>
<tr>
<td style="text-align:center">月(がつ)</td>
<td style="text-align:center">四月(しがつ)、七月(しちがつ)、九月(くがつ)</td>
<td style="text-align:center">表示月份</td>
</tr>
<tr>
<td style="text-align:center">日(にち)</td>
<td style="text-align:center">太多，下面单独列表</td>
<td style="text-align:center">表示日期</td>
</tr>
<tr>
<td style="text-align:center">時(じ)</td>
<td style="text-align:center">四時(よじ)、七時(しちじ)、九時(くじ)</td>
<td style="text-align:center">表示小时</td>
</tr>
<tr>
<td style="text-align:center">分(ふん)</td>
<td style="text-align:center">「一/三/四/六/八/十」分(「いっ/さん/よん/ろっ/はっ/じゅっ」ぷん)</td>
<td style="text-align:center">表示分钟和分钟的跨度</td>
</tr>
<tr>
<td style="text-align:center">秒(びょう)</td>
<td style="text-align:center">无</td>
<td style="text-align:center">表示秒数和秒数的跨度</td>
</tr>
<tr>
<td style="text-align:center">週(しゅう)</td>
<td style="text-align:center">无</td>
<td style="text-align:center">表示星期</td>
</tr>
<tr>
<td style="text-align:center">年間(ねんかん)</td>
<td style="text-align:center">无</td>
<td style="text-align:center">表示年份跨度</td>
</tr>
<tr>
<td style="text-align:center">ヶ月/箇月(かげつ)</td>
<td style="text-align:center">「一/六/十」ヶ月(「いっ/ろっ/じゅっ」かげつ)</td>
<td style="text-align:center">表示月份跨度</td>
</tr>
<tr>
<td style="text-align:center">日間(にちかん)</td>
<td style="text-align:center">一日(いちにち)</td>
<td style="text-align:center">表示日期跨度</td>
</tr>
<tr>
<td style="text-align:center">時間(じかん)</td>
<td style="text-align:center">无</td>
<td style="text-align:center">表示小时跨度</td>
</tr>
<tr>
<td style="text-align:center">週間(しゅうかん)</td>
<td style="text-align:center">「一/八」週間(「いっしゅう/はっしゅう」かん)</td>
<td style="text-align:center">表示星期跨度</td>
</tr>
</tbody>
</table>
<p align="center">表5 表示日期的量词的例外</p>

<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">汉字</th>
<th style="text-align:center">读音</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">何日</td>
<td style="text-align:center">なん・にち</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">一日</td>
<td style="text-align:center">ついたち</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">二日</td>
<td style="text-align:center">ふつ・か</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">三日</td>
<td style="text-align:center">みっ・か</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">四日</td>
<td style="text-align:center">よっ・か</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">五日</td>
<td style="text-align:center">いつ・か</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">六日</td>
<td style="text-align:center">むい・か</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">七日</td>
<td style="text-align:center">なの・か</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">八日</td>
<td style="text-align:center">よう・か</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">九日</td>
<td style="text-align:center">ここの・か</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">十日</td>
<td style="text-align:center">とお・か</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">十四日</td>
<td style="text-align:center">じゅう・よっ・か</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center">十七日</td>
<td style="text-align:center">じゅう・しち・にち</td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:center">十九日</td>
<td style="text-align:center">じゅう・く・にち</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">二十日</td>
<td style="text-align:center">はつ・か</td>
</tr>
<tr>
<td style="text-align:center">24</td>
<td style="text-align:center">二十四日</td>
<td style="text-align:center">に・じゅう・よっ・か</td>
</tr>
<tr>
<td style="text-align:center">27</td>
<td style="text-align:center">二十七日</td>
<td style="text-align:center">に・じゅう・しち・にち</td>
</tr>
<tr>
<td style="text-align:center">29</td>
<td style="text-align:center">二十九日</td>
<td style="text-align:center">に・じゅう・く・にち</td>
</tr>
</tbody>
</table>
<p align="center">表6 其他常用量词的用法</p>

<table>
<thead>
<tr>
<th style="text-align:center">日本語</th>
<th style="text-align:center">何时使用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">～人</td>
<td style="text-align:center">用来数人</td>
</tr>
<tr>
<td style="text-align:center">～本</td>
<td style="text-align:center">用来数长的或圆柱形的物体，例如瓶子或筷子</td>
</tr>
<tr>
<td style="text-align:center">～枚</td>
<td style="text-align:center">用来数薄的物体，比如纸或是衬衫</td>
</tr>
<tr>
<td style="text-align:center">～冊</td>
<td style="text-align:center">用来数带封面的物体，一般是书</td>
</tr>
<tr>
<td style="text-align:center">～匹</td>
<td style="text-align:center">用来数小动物，例如阿猫阿狗</td>
</tr>
<tr>
<td style="text-align:center">～歳</td>
<td style="text-align:center">用来数岁数，<strong>注意!有时为了方便写作「才」，且20岁一般读作「はたち」而非「にじゅっさい」</strong></td>
</tr>
<tr>
<td style="text-align:center">～個</td>
<td style="text-align:center">用来数小（通常是圆的）物体</td>
</tr>
<tr>
<td style="text-align:center">～回</td>
<td style="text-align:center">用来数次数</td>
</tr>
<tr>
<td style="text-align:center">ヶ所（箇所）</td>
<td style="text-align:center">用来数地点</td>
</tr>
<tr>
<td style="text-align:center">～つ</td>
<td style="text-align:center">1~9岁的年龄，立体的物品，抽象的事物。<strong>注意!不用于10以上的数字</strong></td>
</tr>
<tr>
<td style="text-align:center">～杯</td>
<td style="text-align:center">用作容量单位，杯、碗、桶匙</td>
</tr>
<tr>
<td style="text-align:center">～台</td>
<td style="text-align:center">用来数车辆或机器等，台、辆、架</td>
</tr>
<tr>
<td style="text-align:center">～頭</td>
<td style="text-align:center">用来数大型四蹄动物</td>
</tr>
<tr>
<td style="text-align:center">～羽</td>
<td style="text-align:center">用来数鸟、兔等，只、头</td>
</tr>
<tr>
<td style="text-align:center">～着</td>
<td style="text-align:center">用来数衣服数量，件、套</td>
</tr>
<tr>
<td style="text-align:center">～番</td>
<td style="text-align:center">顺序</td>
</tr>
<tr>
<td style="text-align:center">～足</td>
<td style="text-align:center">用来数成对物品如鞋、袜等，双</td>
</tr>
<tr>
<td style="text-align:center">～度</td>
<td style="text-align:center">角度、次数、度数</td>
</tr>
<tr>
<td style="text-align:center">～キロ</td>
<td style="text-align:center">千、千克、千米</td>
</tr>
</tbody>
</table>
<p align="center">表7 部分量词从1到10的变化</p>

<table>
<thead>
<tr>
<th style="text-align:center">-</th>
<th style="text-align:center">人</th>
<th style="text-align:center">本</th>
<th style="text-align:center">枚</th>
<th style="text-align:center">冊</th>
<th style="text-align:center">匹</th>
<th style="text-align:center">歳</th>
<th style="text-align:center">個</th>
<th style="text-align:center">回</th>
<th style="text-align:center">ヶ所（箇所）</th>
<th style="text-align:center">つ</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">ひとり</td>
<td style="text-align:center">いっぽん</td>
<td style="text-align:center">いちまい</td>
<td style="text-align:center">いっさつ</td>
<td style="text-align:center">いっぴき</td>
<td style="text-align:center">いっさい</td>
<td style="text-align:center">いっこ</td>
<td style="text-align:center">いっかい</td>
<td style="text-align:center">いっかしょ</td>
<td style="text-align:center">ひとつ</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">ふたり</td>
<td style="text-align:center">にほん</td>
<td style="text-align:center">にまい</td>
<td style="text-align:center">にさつ</td>
<td style="text-align:center">にひき</td>
<td style="text-align:center">にさい</td>
<td style="text-align:center">にこ</td>
<td style="text-align:center">にかい</td>
<td style="text-align:center">にかしょ</td>
<td style="text-align:center">ふたつ</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">さんにん</td>
<td style="text-align:center">さんぼん</td>
<td style="text-align:center">さんまい</td>
<td style="text-align:center">さんさつ</td>
<td style="text-align:center">さんびき</td>
<td style="text-align:center">さんさい</td>
<td style="text-align:center">さんこ</td>
<td style="text-align:center">さんかい</td>
<td style="text-align:center">さんかしょ</td>
<td style="text-align:center">みっつ</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">よにん</td>
<td style="text-align:center">よんほん</td>
<td style="text-align:center">よんまい</td>
<td style="text-align:center">よんさつ</td>
<td style="text-align:center">よんひき</td>
<td style="text-align:center">よんさい</td>
<td style="text-align:center">よんこ</td>
<td style="text-align:center">よんかい</td>
<td style="text-align:center">よんかしょ</td>
<td style="text-align:center">よっつ</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">ごにん</td>
<td style="text-align:center">ごほん</td>
<td style="text-align:center">ごまい</td>
<td style="text-align:center">ごさつ</td>
<td style="text-align:center">ごひき</td>
<td style="text-align:center">ごさい</td>
<td style="text-align:center">ごこ</td>
<td style="text-align:center">ごかい</td>
<td style="text-align:center">ごかしょ</td>
<td style="text-align:center">いつつ</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">ろくにん</td>
<td style="text-align:center">ろっぽん</td>
<td style="text-align:center">ろくまい</td>
<td style="text-align:center">ろくさつ</td>
<td style="text-align:center">ろっぴき</td>
<td style="text-align:center">ろくさい</td>
<td style="text-align:center">ろっこ</td>
<td style="text-align:center">ろっかい</td>
<td style="text-align:center">ろっかしょ</td>
<td style="text-align:center">むっつ</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">しちにん</td>
<td style="text-align:center">ななほん</td>
<td style="text-align:center">ななまい</td>
<td style="text-align:center">ななさつ</td>
<td style="text-align:center">ななひき</td>
<td style="text-align:center">ななさい</td>
<td style="text-align:center">ななこ</td>
<td style="text-align:center">ななかい</td>
<td style="text-align:center">ななかしょ</td>
<td style="text-align:center">ななつ</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">はちにん</td>
<td style="text-align:center">はちほん</td>
<td style="text-align:center">はちまい</td>
<td style="text-align:center">はっさつ</td>
<td style="text-align:center">はっぴき</td>
<td style="text-align:center">はっさい</td>
<td style="text-align:center">はっこ</td>
<td style="text-align:center">はちかい</td>
<td style="text-align:center">はっかしょ</td>
<td style="text-align:center">やっつ</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">きゅうにん</td>
<td style="text-align:center">きゅうほん</td>
<td style="text-align:center">きゅうまい</td>
<td style="text-align:center">きゅうさつ</td>
<td style="text-align:center">きゅうひき</td>
<td style="text-align:center">きゅうさい</td>
<td style="text-align:center">きゅうこ</td>
<td style="text-align:center">きゅうかい</td>
<td style="text-align:center">きゅうかしょ</td>
<td style="text-align:center">ここのつ</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">じゅうにん</td>
<td style="text-align:center">じゅっぽん</td>
<td style="text-align:center">じゅうまい</td>
<td style="text-align:center">じゅっさつ</td>
<td style="text-align:center">じゅっぴき</td>
<td style="text-align:center">じゅっさい</td>
<td style="text-align:center">じゅっこ</td>
<td style="text-align:center">じゅっかい</td>
<td style="text-align:center">じゅっかしょ</td>
<td style="text-align:center">とお</td>
</tr>
</tbody>
</table>
<p align="center"><strong>「とお」写的时候是「十」，而不是「十つ」</strong></p>

<h5 id="1-1-2-2-副词"><a href="#1-1-2-2-副词" class="headerlink" title="1.1.2.2 副词"></a>1.1.2.2 副词</h5><p>修饰用言（动词、形容词）的状态、程度等。副词也可以分为两类，一类是形容词变形成的副词，一类是本身就是副词。其中形容词变为副词的规则为:</p>
<ul>
<li>一类形容词/い形容词: 把「い」换成「く」。例: 早い → 早く</li>
<li>二类形容词/な形容词/形容动词: 后面加「に」。例: きれい → きれいに</li>
</ul>
<p>表8列举了一些本身就是副词的词汇。</p>
<p align="center">表8 部分示例副词</p>

<table>
<thead>
<tr>
<th style="text-align:center">日本語</th>
<th style="text-align:center">汉语</th>
<th style="text-align:center">日本語</th>
<th style="text-align:center">汉语</th>
<th style="text-align:center">日本語</th>
<th style="text-align:center">汉语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">すぐ</td>
<td style="text-align:center">马上，立即</td>
<td style="text-align:center">間もなく</td>
<td style="text-align:center">马上，不久</td>
<td style="text-align:center">もうすぐ</td>
<td style="text-align:center">马上</td>
</tr>
<tr>
<td style="text-align:center">ずいぶん</td>
<td style="text-align:center">相当，非常</td>
<td style="text-align:center">なかなか</td>
<td style="text-align:center">相当，很</td>
<td style="text-align:center">とても</td>
<td style="text-align:center">非常，很</td>
</tr>
<tr>
<td style="text-align:center">ちゃんと</td>
<td style="text-align:center">好好地，的确</td>
<td style="text-align:center">ゆっくり</td>
<td style="text-align:center">好好地，安静地</td>
<td style="text-align:center">十分</td>
<td style="text-align:center">好好地，充足地</td>
</tr>
<tr>
<td style="text-align:center">皆</td>
<td style="text-align:center">全都</td>
<td style="text-align:center">全部</td>
<td style="text-align:center">全部</td>
<td style="text-align:center">沢山</td>
<td style="text-align:center">很多</td>
</tr>
<tr>
<td style="text-align:center">更に</td>
<td style="text-align:center">更加，更</td>
<td style="text-align:center">もっと</td>
<td style="text-align:center">更加，更</td>
<td style="text-align:center">ぜひ</td>
<td style="text-align:center">一定</td>
</tr>
<tr>
<td style="text-align:center">できるだけ</td>
<td style="text-align:center">尽可能</td>
<td style="text-align:center">ずっと</td>
<td style="text-align:center">~得多</td>
<td style="text-align:center">ちょうど</td>
<td style="text-align:center">正好，恰好</td>
</tr>
<tr>
<td style="text-align:center">たまり</td>
<td style="text-align:center">偶尔，很少</td>
<td style="text-align:center">よく</td>
<td style="text-align:center">经常</td>
<td style="text-align:center">また</td>
<td style="text-align:center">还，再，又</td>
</tr>
<tr>
<td style="text-align:center">こう</td>
<td style="text-align:center">这样，如此</td>
<td style="text-align:center">まっすぐ</td>
<td style="text-align:center">径直地</td>
<td style="text-align:center">まず</td>
<td style="text-align:center">首先</td>
</tr>
<tr>
<td style="text-align:center">前に</td>
<td style="text-align:center">以前</td>
<td style="text-align:center">今度</td>
<td style="text-align:center">下次，这回</td>
<td style="text-align:center">そろそろ</td>
<td style="text-align:center">快要</td>
</tr>
</tbody>
</table>
<h5 id="1-1-2-3-连体词"><a href="#1-1-2-3-连体词" class="headerlink" title="1.1.2.3 连体词"></a>1.1.2.3 连体词</h5><p>日语特有的一种词类，可以直接用来连接体言（名词）。其实Kino认为连体词的划分不是很必要，通过后续的助词以及各类变形，可以解释大部分连体词了。连体词主要有以下几种形式:</p>
<ul>
<li>「-の」型: 名词+の的形式，对所修饰的名词起限定作用，如「その」「どの」「この」「かの」「くだんの」「ほんの」「当の」「例の」</li>
<li>「-が」型: 名词+が的形式，对所修饰的名词起限定作用，が在古语中相当于格助词の，如「我が」</li>
<li>「-る」型: 可看作是动词的变形，对所修饰的名词起限定作用，「ある」「さる」「きたる」「あくる」「とある」「かかる」「いわゆる」「いかなる」「あらゆる」</li>
<li>「-な」型: 可看作是形容词的变形，通常表示被修饰名词的属性，如「こんな」「そんな」「あんな」「どんな」「おおきな」「ちいさな」「おかしな」「ひょんな」「いろんな」「異な」「あじな」「ろくな」</li>
<li>「-た（だ）」型: 可看作是动词的变形，通常表示被修饰名词的属性，如「とんだ」「ふとした」「大それた」「れっきとした」</li>
<li>「-ぬ」型: 不常用</li>
<li>「-き」型: 不常用</li>
<li>「-いう」型: 不常用</li>
</ul>
<h5 id="1-1-2-4-接续词"><a href="#1-1-2-4-接续词" class="headerlink" title="1.1.2.4 接续词"></a>1.1.2.4 接续词</h5><p>连接句和句，表示前后句顺接，逆接，并列，转换等各种关系的词。一般来说可以分为7类: 顺接、逆接、並列、添加、説明、選択、転換。可以参考<a href="http://www.sohu.com/a/191048812_209715" target="_blank" rel="noopener">接续词总结</a><sup id="fnref:11"><a href="#fn:11" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="日语单词本 . “史上最全的日语接续词总结！考试不再是难题！.” 搜狐网, 10 Sept. 2017, https://www.sohu.com/a/191048812_209715.
">[11]</span></a></sup></p>
<h5 id="1-1-2-5-感叹词"><a href="#1-1-2-5-感叹词" class="headerlink" title="1.1.2.5 感叹词"></a>1.1.2.5 感叹词</h5><p>表示感叹、回应等，可以单独成句，口语中较常使用。表9给出了一些常见的感叹词。还可以参考<a href="https://www.douban.com/note/521188596/" target="_blank" rel="noopener">这里</a><sup id="fnref:12"><a href="#fn:12" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="精樱日语 . “日语中常见的一些感叹词.” 豆瓣, 19 Oct. 2015, https://www.douban.com/note/521188596/.
">[12]</span></a></sup>。</p>
<p align="center">表9 常用感叹词</p>

<table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:center">感動詞</th>
<th style="text-align:center">感動詞</th>
<th style="text-align:center">感動詞</th>
<th style="text-align:center">感動詞</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">感動（表示感叹）</td>
<td style="text-align:center">あ</td>
<td style="text-align:center">ああ</td>
<td style="text-align:center">ええと</td>
<td style="text-align:center">おお</td>
<td style="text-align:center">啊，哦，哎呀</td>
</tr>
<tr>
<td style="text-align:center">–</td>
<td style="text-align:center">あら</td>
<td style="text-align:center">まあ</td>
<td style="text-align:center">おや</td>
<td style="text-align:center">やあ</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">–</td>
<td style="text-align:center">いや</td>
<td style="text-align:center">やれやれ</td>
<td style="text-align:center">これはこれは</td>
<td style="text-align:center">それはそれは</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">–</td>
<td style="text-align:center">ははあ</td>
<td style="text-align:center">どれ</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">呼び掛け（表示呼唤）</td>
<td style="text-align:center">あの</td>
<td style="text-align:center">ねえ</td>
<td style="text-align:center">あのね</td>
<td style="text-align:center">おい</td>
<td style="text-align:center">喂，嗨，我说</td>
</tr>
<tr>
<td style="text-align:center">–</td>
<td style="text-align:center">これ</td>
<td style="text-align:center">これこれ</td>
<td style="text-align:center">それ</td>
<td style="text-align:center">さあ</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">–</td>
<td style="text-align:center">よう</td>
<td style="text-align:center">さて</td>
<td style="text-align:center">そら</td>
<td style="text-align:center">こら</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">–</td>
<td style="text-align:center">ちょっと</td>
<td style="text-align:center">もしもし</td>
<td style="text-align:center">ほら</td>
<td style="text-align:center"></td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">応答（表示回答）</td>
<td style="text-align:center">はい</td>
<td style="text-align:center">はあ</td>
<td style="text-align:center">そう</td>
<td style="text-align:center">うん</td>
<td style="text-align:center">行，嗯，不行</td>
</tr>
<tr>
<td style="text-align:center">–</td>
<td style="text-align:center">いいえ</td>
<td style="text-align:center">いや</td>
<td style="text-align:center">ええ</td>
<td style="text-align:center"></td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">挨拶（表示寒暄）</td>
<td style="text-align:center">ありがとう</td>
<td style="text-align:center">いらっしゃい</td>
<td style="text-align:center">おはよう</td>
<td style="text-align:center">お待ち度様</td>
<td style="text-align:center">谢谢，您好</td>
</tr>
<tr>
<td style="text-align:center">–</td>
<td style="text-align:center">おやすみ</td>
<td style="text-align:center">こんにちは</td>
<td style="text-align:center">こんばんは</td>
<td style="text-align:center">さようなら</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">–</td>
<td style="text-align:center">はじめまして</td>
<td style="text-align:center">おめでとう</td>
<td style="text-align:center">ごめんなさい</td>
<td style="text-align:center">ごきげんよう</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">掛け声（表示口号）</td>
<td style="text-align:center">えっさ</td>
<td style="text-align:center">よいさ</td>
<td style="text-align:center">よいしょ</td>
<td style="text-align:center">どっこいしょ</td>
<td style="text-align:center">嗨哟…</td>
</tr>
</tbody>
</table>
<h3 id="1-2-付属語（附属词」虚词）"><a href="#1-2-付属語（附属词」虚词）" class="headerlink" title="1.2 付属語（附属词」虚词）"></a>1.2 付属語（附属词」虚词）</h3><h4 id="1-2-1-不可以活用——助词"><a href="#1-2-1-不可以活用——助词" class="headerlink" title="1.2.1 不可以活用——助词"></a>1.2.1 不可以活用——助词</h4><p>决定单词在句中的地位、和其他单词的关系、句子的时态、或是表示特殊的意义等。<br>下面是对各类助动词的分类总结，初次接触有个印象就行，并不是需要全部记忆，助词后续很多内容都是相关的，后续看到可以返回再查阅。更具体的助词分类汇总解释可以查阅<a href="https://wenku.baidu.com/view/9e0204ecaeaad1f346933fd6" target="_blank" rel="noopener">这里</a><sup id="fnref:13"><a href="#fn:13" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="chexiaomeng. “日语全部助词分类及汇总.” 百度文库, 7 May 2011, https://wenku.baidu.com/view/9e0204ecaeaad1f346933fd6.
">[13]</span></a></sup></p>
<h5 id="1-2-1-1-格助詞"><a href="#1-2-1-1-格助詞" class="headerlink" title="1.2.1.1 格助詞"></a>1.2.1.1 格助詞</h5><p>连接体言，在文中表示意思关系。</p>
<ul>
<li>が: 最基本的格助詞，表动作状态的主体，要求愿望的对象等。</li>
<li>の: 表连用修饰语的动作状态的主体，所有格和連体詞的标志。</li>
<li>を: 表动作直接的对象、思考感觉的对象、移动时所经过的路径等。另外可表示移动的起点和经由点，即在此场合中未想定到达点的状况。</li>
<li>に: 连接名詞和動詞的连用形和连体形等。可表现：物体的存在场所或移动的目标点/到达点、动作或物品接受的一方、动作开始或结束时间、動詞的目的、物品存在的场所、基准或频率的标准、变化的结果、使动句的动作主体等，是个用处很广的助詞。</li>
<li>へ: 用法较少，仅表示移动的目标和到达点。与「に」的区别比较暧昧。</li>
<li>と: 表示共同的对象、作用的结果、引用、并列。</li>
<li>から: 表示动作、移动或时刻的起点，物品的原料或最开始的状态，动作或物品授予的一方，因果关系中表示原因理由。连接動詞时表达几个动作的相继发生；在被动句中表动作主体。</li>
<li>より: 主要作为比较的基准而使用。在文章语，尤其是信件中与「から」的意思相仿，表示来自于或起点。</li>
<li>で: 表示复数和团体的范围、动作发生的场所和时间、动作的手段或媒介物、由材料到完成品外观变化较小时可表示原料或材料、动作或状态持续的时间等等，是个用处很广的助詞。</li>
<li>や: 表达列举的并列关系。</li>
</ul>
<h5 id="1-2-1-2-並立助詞"><a href="#1-2-1-2-並立助詞" class="headerlink" title="1.2.1.2 並立助詞"></a>1.2.1.2 並立助詞</h5><p>表示两个或以上的并列关系。</p>
<ul>
<li>の: 表并列或列举，表示程度很糟糕很不堪忍受的语气。比较少用。</li>
<li>と: 连接体言，列举几个事物。</li>
<li>や: 用于名詞或带準体助詞「の」的相当于名詞的结构后、表达事物并列或列举。</li>
<li>やら: 接在体言或活用語的連体形后，表达列举很难决定的两件事，或单纯列举事物时使用。</li>
<li>か: 列举几个事物并从中选择一个或一部分、疑问、和某个动作同时进行或接下来进行另一动作时使用。</li>
<li>なり: 表达列举的事物中的任意一个。有时也作副助詞用。</li>
<li>だの: 接在体言或用言的終止形后，用于在全体中列举几个事物或事件。一般用「…だの…だの」或「…だの…など」的形式。</li>
</ul>
<h5 id="1-2-1-3-副助词"><a href="#1-2-1-3-副助词" class="headerlink" title="1.2.1.3 副助词"></a>1.2.1.3 副助词</h5><p>接在体言、副詞、格助詞等的后面，使其产生副词的作用。</p>
<ul>
<li>ばかり: 接在体言或副詞、活用語的連体形、格助詞等后面，和「だけ」一样表达将物事、程度、原因限定到一个范围内，和「くらい」一样表达物事大概的程度、分量、时刻、距离。另外，也表达马上要做的动作，或刚刚完成的动作或结束的状态。另外接在表否定的「ぬ（ん）」后可表示没做却表现得很明显想做的样态。漢字记为「許り」。</li>
<li>まで: 接在名詞和活用語的連体形后，表示事情、动作在距离上或时间上的限度、范围或到达点。也用于对程度和动作进行限定。还可用于举极端的例子或类推到另一物事。漢字记为「迄」。</li>
<li>だけ: 接在名詞和活用語的連体形或格助詞的后面。表示对分量、程度、限度及范围的限定。漢字记为「丈」。</li>
<li>ほど: 表示动作、物事及状态的阶段。漢字记为「程」，接在名詞和活用語的連体形后，表示大概的分量、程度、動作、状態的程度，也可与否定相呼应表程度的比較。另外「～ば～ほど」的用法表示“越来越…”的意思。</li>
<li>くらい: 表示大概的分量、程度、基准、事态，以强调其程度。漢字记为「位」。</li>
<li>など: 接在名詞及活用語的連体形后面，用于在众多相似物中举一例，总括其他相似物时使用。也可用作委婉语。漢字记为「等」。</li>
<li>なり: 接在名詞、副詞、活用形的終止形、助詞等后面，表示作为几个可选之物的例子。</li>
<li>やら: 接在体言或相当于体言的结构、一部分的副詞、助詞等后面，表达不确定的意思（仅限疑问句或句）。还可在模棱两可无法清楚说明的时候，下接否定语无法确定是哪个的时候使用。</li>
</ul>
<h5 id="1-2-1-4-係助詞"><a href="#1-2-1-4-係助詞" class="headerlink" title="1.2.1.4 係助詞"></a>1.2.1.4 係助詞</h5><p>对前面的词进行叙述或表示强调的词。</p>
<ul>
<li>は: 接在词语、短语、活用語的連用形后，表达从很多物事中取出一个进行说明、提示主题、决定叙述的范围、叙述内容的成立条件等等意义。另外，可接在格助詞和副詞后加强语气；也用于对两个或以上的物事进行比较判断。</li>
<li>も: 可用于提出类似事物，列举或添加，接在程度、感動、強調、不定称語后进行全面的否定和肯定。</li>
<li>こそ: 可用在词语后面进行强调，接在動詞的仮定形和接続助詞「ば」之后进行强调并提出自己想说的重点。</li>
<li>でも: 断定的助動詞「だ」の連用形「で」+係助詞的「も」构成。接在名詞和其他助詞后使用，用于提出一个极端条件（即使…也…）、举一个极端例子并类推到一般场合时（连…也…）、举一例以提议时（譬如…）使用。</li>
<li>しか: 接在名詞和動詞的連体形、形容詞和形容動詞的連用形后，表示特定的物事以外全部否定。后加否定，表示“仅、只”的概念。</li>
<li>さえ: 对已有的事物基础上又进行了追加（除…外，还…多用于负面事物），举一极端例子并暗示其他也是当然的时候（连…都…），与仮定表现一起用表示条件（只要…就）时使用。 だに ：与「さえ」大致相同。但现在多用于固定搭配。</li>
</ul>
<h5 id="1-2-1-5-接続助詞"><a href="#1-2-1-5-接続助詞" class="headerlink" title="1.2.1.5 接続助詞"></a>1.2.1.5 接続助詞</h5><p>用于句与句的连接，表现句与句的关系。</p>
<ul>
<li>や: 用在動詞和助動詞「れる・られる」和「せる・させる」的動詞形活用語的終止形之后，表示動作和作用进行时又进行其他動作和作用。</li>
<li>が: 接在活用語的終止形之后，表示单纯的接续或逆接。</li>
<li>けれども: 接在活用語的終止形后，对内容矛盾的事件进行対比，和放在句前和前文进行逆接时使用。另外「あれも好きだけれどもこれも好き」（也喜欢那个也喜欢这个）这样单纯的接续也可使用。</li>
<li>ところが: 由形式名詞的「ところ」+格助詞的「が」构成，接在过去时态助動詞「た」的終止形后，在对前述事态的发生和事实的确认后表示逆接的假定状态。和「けれども」同样，也能变为接続詞，表示本想干什么却发生了与预想相反的事情。</li>
<li>のに: 由格助詞（準体助詞）「の」+「に」构成，连接内容矛盾的两个句子，表达意外、不平、不満、不服的语气。</li>
<li>から: 接在活用語的終止形后，除了表原因理由之外，还与終助詞的用法相似，表达强烈主張和决意。</li>
<li>ので: 由準体助詞「の」+格助詞「で」构成，接在活用語的連体形后，表示原因、理由、根据、动机。</li>
<li>て: 接在活用語的連用形后，表示继续。</li>
</ul>
<h5 id="1-2-1-6-终助词"><a href="#1-2-1-6-终助词" class="headerlink" title="1.2.1.6 终助词"></a>1.2.1.6 终助词</h5><p>用在句末表疑问、禁止、感动等的语气。</p>
<ul>
<li>か: 用在句末表提问、疑问、反语、责问、反驳、劝诱、请求等等语气。也可表达惊讶和感动的心情。</li>
<li>かしら: 表示怀疑、疑问的语气，也可用在否定的「ない」和「ぬ」后面表愿望、请求的语气。现在多为女性用语，比较文雅的说法。</li>
<li>な: 接在動詞或助動詞的終止形之后表禁止的意思，也可用在終止形和助詞后表轻微的断定和主张、确认、赞叹等语气。可用かな，以表自己不确定的推断。</li>
<li>の: 可用于活用語的連体形之后，表缓和的断定语气（和「かしら」一样意义的女性用语）。也可表达提问、疑问或较强命令的语气。另外也可表感动；近年来常见于表古风的语言方式。</li>
<li>とも: 接在活用語的終止形之后，口语中表达对对方强烈的肯定。不太常用。</li>
<li>ぞ: 对自己及对方的说法的确认，也与疑问词相呼应表达反语及强调的意思。男性用语。</li>
<li>や: 接在形容詞及形容詞型活用的助動詞、助動詞「う、よう」的終止形、動詞及動詞形活用的助動詞命令形后面，表达对同辈或晚辈的轻微催促、希望使某种事态得以实现的心情，或是表现随便说说、轻率随便的语气。另外也有表达疑问和反语的意思，但是很少用。</li>
<li>わ: 用于活用語的終止形之后，表达轻微的决意、主张、赞叹等语气，多为女性用语。</li>
</ul>
<h5 id="1-2-1-7-間投助詞"><a href="#1-2-1-7-間投助詞" class="headerlink" title="1.2.1.7 間投助詞"></a>1.2.1.7 間投助詞</h5><p>用在句末用于调整语调，增加感动之类的语气。</p>
<ul>
<li>さ: 调整语调同时有吸引对方注意的功能，多为男性用语。</li>
<li>よ: 用于号召和强调时。常用「だよ」「ですよ」「ますよ」。</li>
<li>ね: 用于调整语气语调，有种寻求对方认同和回应的功能。常用よね。</li>
</ul>
<h5 id="1-2-1-8-準体助詞"><a href="#1-2-1-8-準体助詞" class="headerlink" title="1.2.1.8 準体助詞"></a>1.2.1.8 準体助詞</h5><p>指接在用言后用变为与体言相当的词，如「彼に聞くのがいい」「あちらに着いてからが大事だ」的「の」和「から」。这个功能与形式名詞（「こと」「もの」「ところ」等）相似，叫作準体助詞（準体言助詞）。</p>
<h4 id="1-2-2-可以活用——助动词"><a href="#1-2-2-可以活用——助动词" class="headerlink" title="1.2.2 可以活用——助动词"></a>1.2.2 可以活用——助动词</h4><p>接续在动词后面，表达时/体/态/式等语法功能。<br>下面列举了一些分类助动词，和助词一样，也不需要刻意记忆，后续其他语法涉及到时有印象即可。具体细节可参考<a href="https://wenku.baidu.com/view/b0be1a24192e45361066f5a5.html" target="_blank" rel="noopener">此处</a><sup id="fnref:14"><a href="#fn:14" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="荷塘垚 . “常用日语助动词总汇.” 百度文库, 23 Apr. 2012, https://wenku.baidu.com/view/b0be1a24192e45361066f5a5.html.
">[14]</span></a></sup></p>
<ul>
<li>断定助动词: だ、です、である</li>
<li>过去助动词:た</li>
<li>否定助动词: ない、ぬ</li>
<li>敬体助动词: ます</li>
<li>使役助动词: せる、させる、しめる</li>
<li>被动助动词: れるられる</li>
<li>可能助动词: れる、られる</li>
<li>敬语助动词: れる、られる</li>
<li>自发助动词: れる、られる</li>
<li>推量助动词: う、よう、まい</li>
<li>愿望助动词: たい、たがる</li>
<li>推定助动词: らしい</li>
<li>比况助动词: ようだ、ようです、みたいだ、みたいです</li>
<li>样态助动词: そうだ</li>
<li>传闻助动词: そうだ</li>
</ul>
<h3 id="1-3-复合词"><a href="#1-3-复合词" class="headerlink" title="1.3 复合词"></a>1.3 复合词</h3><p>除了上述的基本词类，日语中还可以通过将不同词类组合，以此形成复合词，复合后的词属于哪种词类，这决定于复合词的后半部词性。<br>主要内容来源于<a href="http://www.yayajp.com/index.php?a=shows&amp;catid=6&amp;id=190" target="_blank" rel="noopener">说说日语复合词</a><sup id="fnref:18"><a href="#fn:18" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="日语考试 . “说说日语复合词.” 丫丫日语, 31 Jan. 2015, http://www.yayajp.com/index.php?a=shows&catid=6&id=190.
">[18]</span></a></sup>，关于日语词汇更详细的构词法可以参考<a href="https://blog.csdn.net/sinat_29315627/article/details/73484302" target="_blank" rel="noopener">此处</a><sup id="fnref:19"><a href="#fn:19" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="ASH9750. “日语语法（九）：日语的构词法.” CSDN博客, 20 June 2017, https://blog.csdn.net/sinat_29315627/article/details/73484302.
">[19]</span></a></sup></p>
<h3 id="1-3-1-复合名词"><a href="#1-3-1-复合名词" class="headerlink" title="1.3.1 复合名词"></a>1.3.1 复合名词</h3><h5 id="1-3-1-1-动词一型词根-名词"><a href="#1-3-1-1-动词一型词根-名词" class="headerlink" title="1.3.1.1 动词一型词根+名词"></a>1.3.1.1 动词一型词根+名词</h5><p>例: 買い物、贈り物、食べ物、読み方、食べ放題、足し算</p>
<h5 id="1-3-1-2-名词-动词一型词根"><a href="#1-3-1-2-名词-动词一型词根" class="headerlink" title="1.3.1.2 名词+动词一型词根"></a>1.3.1.2 名词+动词一型词根</h5><p>例: 北京行き、トンボ帰り、横殴り、交通止め、共稼ぎ、田植え</p>
<h5 id="1-3-1-3-动词一型词根-动词一型词根"><a href="#1-3-1-3-动词一型词根-动词一型词根" class="headerlink" title="1.3.1.3 动词一型词根+动词一型词根"></a>1.3.1.3 动词一型词根+动词一型词根</h5><p>例: 買い食い、立ち読み、出入り、食べ残し、すれ違い</p>
<h5 id="1-3-1-4-名词-名词"><a href="#1-3-1-4-名词-名词" class="headerlink" title="1.3.1.4 名词+名词"></a>1.3.1.4 名词+名词</h5><p>例: 日本全土、高層ビル、万年床</p>
<h5 id="1-3-1-5-一类形容词词干-名词"><a href="#1-3-1-5-一类形容词词干-名词" class="headerlink" title="1.3.1.5 一类形容词词干+名词"></a>1.3.1.5 一类形容词词干+名词</h5><p>例: 近頃、遠回り、長生き、久しぶり、無駄遣い、悪口</p>
<h4 id="1-3-2-复合形容词"><a href="#1-3-2-复合形容词" class="headerlink" title="1.3.2 复合形容词"></a>1.3.2 复合形容词</h4><h5 id="1-3-2-1-动词一型词根-一类形容词"><a href="#1-3-2-1-动词一型词根-一类形容词" class="headerlink" title="1.3.2.1 动词一型词根+一类形容词"></a>1.3.2.1 动词一型词根+一类形容词</h5><p>例: 使いにくい、聞きづらい、待ち遠い、み苦しい</p>
<h5 id="1-3-2-2-名词-一类形容词"><a href="#1-3-2-2-名词-一类形容词" class="headerlink" title="1.3.2.2 名词+一类形容词"></a>1.3.2.2 名词+一类形容词</h5><p>例: 情け深い（なさけぶかい）、欲深い（よくぶかい）、生臭い（なまくさい）、真ん丸い（まんまるい）、心細い（こころぼそい）、心強い（こころづよい）</p>
<h5 id="1-3-2-3-一类形容词或形容词词干-一类形容词"><a href="#1-3-2-3-一类形容词或形容词词干-一类形容词" class="headerlink" title="1.3.2.3 一类形容词或形容词词干+一类形容词"></a>1.3.2.3 一类形容词或形容词词干+一类形容词</h5><p>例: 面倒くさい（めんどくさい）、青白い（あおしろい）、薄暗い（うすくらい）、薄べったい（うすべったい）</p>
<h4 id="1-3-3-复合动词"><a href="#1-3-3-复合动词" class="headerlink" title="1.3.3 复合动词"></a>1.3.3 复合动词</h4><p>常用复合动词的整理可以参考<a href="https://jp.hjenglish.com/new/p3338/" target="_blank" rel="noopener">此处</a><sup id="fnref:20"><a href="#fn:20" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="秋谷 . “二级复合动词整理.” 沪江日语, 17 Mar. 2006, https://jp.hjenglish.com/new/p3338/.
">[20]</span></a></sup></p>
<h5 id="1-3-3-1-动词一型词根-动词"><a href="#1-3-3-1-动词一型词根-动词" class="headerlink" title="1.3.3.1 动词一型词根+动词"></a>1.3.3.1 动词一型词根+动词</h5><p>例: 立ち上がる（たちあがる）、立ち止まる（たちどある）、立て替える（たてかえる）、辿り着く（たどりつく）、付け加える（つけくわえる）、出来上がる（できあがる）、出迎える（でむかえる）、取り扱う（とりあつかう）、引っ張る（ひっぱる）、引っ越す（ひっこす）、引き受ける（ひきうける）</p>
<h5 id="1-3-3-2-动词二型词根-「て」-动词"><a href="#1-3-3-2-动词二型词根-「て」-动词" class="headerlink" title="1.3.3.2 动词二型词根+「て」+动词"></a>1.3.3.2 动词二型词根+「て」+动词</h5><p>后面的动词常是「行く」、「来る」<br>例: 連れて行く、連れて来る、持って行く</p>
<h5 id="1-3-3-3-名词、形容词词干-动词"><a href="#1-3-3-3-名词、形容词词干-动词" class="headerlink" title="1.3.3.3 名词、形容词词干+动词"></a>1.3.3.3 名词、形容词词干+动词</h5><p>例: 近付く、長引く（ながびく）、心得る（こころえる）、腰掛ける（こしかける）、首切る（くびきる）、平謝る（ひらあやまる）</p>
<h2 id="2-句法成分"><a href="#2-句法成分" class="headerlink" title="2. 句法成分"></a>2. 句法成分</h2><p>学习句法成分可以快速分析一句话的构成，更容易理解句子的意思，其有很多不同的划分方式，可以参考<a href="https://ja.wikipedia.org/wiki/%E6%96%87%E3%81%AE%E6%88%90%E5%88%86" target="_blank" rel="noopener">文の成分</a><sup id="fnref:15"><a href="#fn:15" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “文の成分.” Wikipedia, Wikimedia Foundation, 10 May 2018, https://ja.wikipedia.org/wiki/文の成分.
">[15]</span></a></sup>和<a href="https://ja.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC%E8%AA%9E#%E6%96%87%E3%81%AE%E6%88%90%E5%88%86" target="_blank" rel="noopener">日本語文の成分</a><sup id="fnref:16"><a href="#fn:16" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “日本語#文の成分.” Wikipedia, Wikimedia Foundation, https://ja.wikipedia.org/wiki/日本語#文の成分.
">[16]</span></a></sup>。<br>还有一点值得注意的是，日语的句法成分划分主要看格，也就是说常用格助词来区分句法成分。可以看出这些概念是有耦合的。</p>
<h3 id="2-1-主語（しゅご）"><a href="#2-1-主語（しゅご）" class="headerlink" title="2.1 主語（しゅご）"></a>2.1 主語（しゅご）</h3><p>主语是表示动作、作用状态、性质的主体。</p>
<h3 id="2-2-述語（じゅつご）"><a href="#2-2-述語（じゅつご）" class="headerlink" title="2.2 述語（じゅつご）"></a>2.2 述語（じゅつご）</h3><p>即谓语，用来说明主语的动作、作用、状态、性质等。</p>
<h3 id="2-3-同格語"><a href="#2-3-同格語" class="headerlink" title="2.3 同格語"></a>2.3 同格語</h3><p>在相邻的句子成分之间存在修饰、限定或说明关系的结构，通常是两个独立的词，在意义上指同一个事物，在结构上作同一个成分，若是A修饰B，则A叫同位语，B叫本位语。</p>
<h3 id="2-4-目的語（もくてきご）"><a href="#2-4-目的語（もくてきご）" class="headerlink" title="2.4 目的語（もくてきご）"></a>2.4 目的語（もくてきご）</h3><p>表示句子中他动词所涉及的对象。类似于英语中的宾语。</p>
<h3 id="2-5-対象語（たいしょうご）"><a href="#2-5-対象語（たいしょうご）" class="headerlink" title="2.5 対象語（たいしょうご）"></a>2.5 対象語（たいしょうご）</h3><p>用来说明主体的感情、可能、愿望、好恶等意识的对象时。</p>
<h3 id="2-6-補語（ほご）"><a href="#2-6-補語（ほご）" class="headerlink" title="2.6 補語（ほご）"></a>2.6 補語（ほご）</h3><p>表示时间、地点、方向、手段、场所等的成分。</p>
<h3 id="2-7-付加語"><a href="#2-7-付加語" class="headerlink" title="2.7 付加語"></a>2.7 付加語</h3><p>是插在句子中作补充说明的句节，它与前面的句节没有直接联系。类似于汉语中用“破折号——”插入的短语。</p>
<h3 id="2-8-修飾語（しゅうしょくご）"><a href="#2-8-修飾語（しゅうしょくご）" class="headerlink" title="2.8 修飾語（しゅうしょくご）"></a>2.8 修飾語（しゅうしょくご）</h3><p>修饰语是对主语和谓语进行详细说明的词语，其中又分为连体修饰语和连用修饰语，连体修饰语是说明体言的性质、状态等，连用修饰语是说明用言的状态、程度等，类似英语语法中所说的定语和状语。</p>
<h3 id="2-9-独立語"><a href="#2-9-独立語" class="headerlink" title="2.9 独立語"></a>2.9 独立語</h3><p>主语、谓语、修饰语之间都有相互关联的关系，独立语则与这些成分没有之间的关联，是一个相对独立的成分。一般位于句首，表示感叹、应答或连接句子。</p>
<h3 id="2-10-成分与词类"><a href="#2-10-成分与词类" class="headerlink" title="2.10 成分与词类"></a>2.10 成分与词类</h3><p>句法成分通常都有固定的词类，多个词组成的句节表示的句法成分除外，大部分语言都是如此（然而Kino最熟悉的汉语作为分析语在这方面没那么严格，句法成分和词类对应极其复杂）。<br>表10给出了日语的句子成分和词类的对应关系，但不是绝对对应的，只是大多数情况下都是如此而已。</p>
<p align="center">表10 句法成分和词类</p>

<table>
<thead>
<tr>
<th style="text-align:center">句法成分</th>
<th style="text-align:center">词类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">主語</td>
<td style="text-align:center">名词（包括一般名词、代词、数词）</td>
</tr>
<tr>
<td style="text-align:center">述語</td>
<td style="text-align:center">名词、形容词、动词</td>
</tr>
<tr>
<td style="text-align:center">同格語</td>
<td style="text-align:center">一般名词</td>
</tr>
<tr>
<td style="text-align:center">目的語</td>
<td style="text-align:center">一般名词</td>
</tr>
<tr>
<td style="text-align:center">対象語</td>
<td style="text-align:center">一般名词</td>
</tr>
<tr>
<td style="text-align:center">補語</td>
<td style="text-align:center">一般名词</td>
</tr>
<tr>
<td style="text-align:center">付加語</td>
<td style="text-align:center">通常用句节（短语）表示</td>
</tr>
<tr>
<td style="text-align:center">連体修飾語</td>
<td style="text-align:center">形容词、连体词</td>
</tr>
<tr>
<td style="text-align:center">連用修飾語</td>
<td style="text-align:center">副词</td>
</tr>
<tr>
<td style="text-align:center">独立語</td>
<td style="text-align:center">感叹词、名词</td>
</tr>
</tbody>
</table>
<h3 id="2-11-成分顺序"><a href="#2-11-成分顺序" class="headerlink" title="2.11 成分顺序"></a>2.11 成分顺序</h3><p>英语和汉语最简单的句子顺序都是<strong>主+谓+宾</strong>，日语的顺序与此不同，日语的基本语序是<strong>主語+目的語+述語</strong>。可以参考<a href="https://ja.wikipedia.org/wiki/%E8%AA%9E%E9%A0%86" target="_blank" rel="noopener">語順</a><sup id="fnref:17"><a href="#fn:17" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="Wikipedians. “語順.” Wikipedia, Wikimedia Foundation, 10 June 2018, https://ja.wikipedia.org/wiki/語順.
">[17]</span></a></sup>的介绍。</p>
<h3 id="2-12-成分衔接"><a href="#2-12-成分衔接" class="headerlink" title="2.12 成分衔接"></a>2.12 成分衔接</h3><p>是否按照上述组成顺序，将各个成分简单堆砌在一起就构成了一个完成的句子了呢？当然不是啦，在日语中，句子的成分与成分之间通常还需要用助词实现衔接。<br>主语后常用的助词有「は」、「も」，述语通常在句子最末尾，后常用助动词有「だ」、「ます」等，目的语后常用的助词有「を」，对象语后常用的助词有「が」，补语后常用的助词有「で」。其他几种不是严格通过添加助词表示句子成分。</p>
<h3 id="2-13-成分省略"><a href="#2-13-成分省略" class="headerlink" title="2.13 成分省略"></a>2.13 成分省略</h3><p>日语和汉语一样，根据上下文可以省略很多句子成分，基本上没有什么是不能省略的，这就需要多看多读多听了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇主要介绍了词类系统和句法成分，下一篇将介绍极性时态。</p>
<h2 id="Footnote"><a href="#Footnote" class="headerlink" title="Footnote"></a>Footnote</h2><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)">Wikipedians. “Part of Speech.” Wikipedia, Wikimedia Foundation, 22 June 2018, <a href="https://en.wikipedia.org/wiki/Part_of_speech" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Part_of_speech</a>.<a href="#fnref:1" rev="footnote"> ↩</a></span></div><div id="fn:2" style="display:flex"><span style="width:20px">2.</span><span style="width:calc(100% - 20px)">Wikipedians. “Sentence Element.” Servent - Wiktionary, <a href="https://en.wiktionary.org/wiki/sentence_element" target="_blank" rel="noopener">https://en.wiktionary.org/wiki/sentence_element</a>.<a href="#fnref:2" rev="footnote"> ↩</a></span></div><div id="fn:3" style="display:flex"><span style="width:20px">3.</span><span style="width:calc(100% - 20px)">Wikipedians. “Grammatical Relation.” Wikipedia, Wikimedia Foundation, 19 June 2018, <a href="https://en.wikipedia.org/wiki/Grammatical_relation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Grammatical_relation</a>.<a href="#fnref:3" rev="footnote"> ↩</a></span></div><div id="fn:4" style="display:flex"><span style="width:20px">4.</span><span style="width:calc(100% - 20px)">Wikipedians. “Functional Theories of Grammar.” Wikipedia, Wikimedia Foundation, 19 June 2018, <a href="https://en.wikipedia.org/wiki/Functional_theories_of_grammar" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Functional_theories_of_grammar</a>.<a href="#fnref:4" rev="footnote"> ↩</a></span></div><div id="fn:5" style="display:flex"><span style="width:20px">5.</span><span style="width:calc(100% - 20px)">Wikipedians. “品詞.” Wikipedia, Wikimedia Foundation, 19 Apr. 2018, <a href="https://ja.wikipedia.org/wiki/品詞" target="_blank" rel="noopener">https://ja.wikipedia.org/wiki/品詞</a>.<a href="#fnref:5" rev="footnote"> ↩</a></span></div><div id="fn:6" style="display:flex"><span style="width:20px">6.</span><span style="width:calc(100% - 20px)">洋渔 . “日文词语分为十二种品词(品词,ひんし).” 豆瓣, <a href="https://www.douban.com/note/640814003/" target="_blank" rel="noopener">https://www.douban.com/note/640814003/</a>.<a href="#fnref:6" rev="footnote"> ↩</a></span></div><div id="fn:7" style="display:flex"><span style="width:20px">7.</span><span style="width:calc(100% - 20px)">Wikipedians. “自動詞.” Wikipedia, Wikimedia Foundation, 18 Apr. 2018, <a href="https://ja.wikipedia.org/wiki/自動詞" target="_blank" rel="noopener">https://ja.wikipedia.org/wiki/自動詞</a>.<a href="#fnref:7" rev="footnote"> ↩</a></span></div><div id="fn:8" style="display:flex"><span style="width:20px">8.</span><span style="width:calc(100% - 20px)">Wikipedians. “他動詞.” Wikipedia, Wikimedia Foundation, 3 Feb. 2017, <a href="https://ja.wikipedia.org/wiki/他動詞" target="_blank" rel="noopener">https://ja.wikipedia.org/wiki/他動詞</a>.<a href="#fnref:8" rev="footnote"> ↩</a></span></div><div id="fn:9" style="display:flex"><span style="width:20px">9.</span><span style="width:calc(100% - 20px)">Wikipedians. “日文量詞.” Wikipedia, Wikimedia Foundation, 20 June 2018, <a href="https://zh.wikipedia.org/wiki/日文量詞" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/日文量詞</a>.<a href="#fnref:9" rev="footnote"> ↩</a></span></div><div id="fn:10" style="display:flex"><span style="width:20px">10.</span><span style="width:calc(100% - 20px)">Wikipedians. “助数詞.” Wikipedia, Wikimedia Foundation, 20 June 2018, <a href="https://ja.wikipedia.org/wiki/助数詞" target="_blank" rel="noopener">https://ja.wikipedia.org/wiki/助数詞</a>.<a href="#fnref:10" rev="footnote"> ↩</a></span></div><div id="fn:11" style="display:flex"><span style="width:20px">11.</span><span style="width:calc(100% - 20px)">日语单词本 . “史上最全的日语接续词总结！考试不再是难题！.” 搜狐网, 10 Sept. 2017, <a href="https://www.sohu.com/a/191048812_209715" target="_blank" rel="noopener">https://www.sohu.com/a/191048812_209715</a>.<a href="#fnref:11" rev="footnote"> ↩</a></span></div><div id="fn:12" style="display:flex"><span style="width:20px">12.</span><span style="width:calc(100% - 20px)">精樱日语 . “日语中常见的一些感叹词.” 豆瓣, 19 Oct. 2015, <a href="https://www.douban.com/note/521188596/" target="_blank" rel="noopener">https://www.douban.com/note/521188596/</a>.<a href="#fnref:12" rev="footnote"> ↩</a></span></div><div id="fn:13" style="display:flex"><span style="width:20px">13.</span><span style="width:calc(100% - 20px)">chexiaomeng. “日语全部助词分类及汇总.” 百度文库, 7 May 2011, <a href="https://wenku.baidu.com/view/9e0204ecaeaad1f346933fd6" target="_blank" rel="noopener">https://wenku.baidu.com/view/9e0204ecaeaad1f346933fd6</a>.<a href="#fnref:13" rev="footnote"> ↩</a></span></div><div id="fn:14" style="display:flex"><span style="width:20px">14.</span><span style="width:calc(100% - 20px)">荷塘垚 . “常用日语助动词总汇.” 百度文库, 23 Apr. 2012, <a href="https://wenku.baidu.com/view/b0be1a24192e45361066f5a5.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/b0be1a24192e45361066f5a5.html</a>.<a href="#fnref:14" rev="footnote"> ↩</a></span></div><div id="fn:15" style="display:flex"><span style="width:20px">15.</span><span style="width:calc(100% - 20px)">Wikipedians. “文の成分.” Wikipedia, Wikimedia Foundation, 10 May 2018, <a href="https://ja.wikipedia.org/wiki/文の成分" target="_blank" rel="noopener">https://ja.wikipedia.org/wiki/文の成分</a>.<a href="#fnref:15" rev="footnote"> ↩</a></span></div><div id="fn:16" style="display:flex"><span style="width:20px">16.</span><span style="width:calc(100% - 20px)">Wikipedians. “日本語#文の成分.” Wikipedia, Wikimedia Foundation, <a href="https://ja.wikipedia.org/wiki/日本語#文の成分" target="_blank" rel="noopener">https://ja.wikipedia.org/wiki/日本語#文の成分</a>.<a href="#fnref:16" rev="footnote"> ↩</a></span></div><div id="fn:17" style="display:flex"><span style="width:20px">17.</span><span style="width:calc(100% - 20px)">Wikipedians. “語順.” Wikipedia, Wikimedia Foundation, 10 June 2018, <a href="https://ja.wikipedia.org/wiki/語順" target="_blank" rel="noopener">https://ja.wikipedia.org/wiki/語順</a>.<a href="#fnref:17" rev="footnote"> ↩</a></span></div><div id="fn:18" style="display:flex"><span style="width:20px">18.</span><span style="width:calc(100% - 20px)">日语考试 . “说说日语复合词.” 丫丫日语, 31 Jan. 2015, <a href="http://www.yayajp.com/index.php?a=shows&amp;catid=6&amp;id=190" target="_blank" rel="noopener">http://www.yayajp.com/index.php?a=shows&amp;catid=6&amp;id=190</a>.<a href="#fnref:18" rev="footnote"> ↩</a></span></div><div id="fn:19" style="display:flex"><span style="width:20px">19.</span><span style="width:calc(100% - 20px)">ASH9750. “日语语法（九）：日语的构词法.” CSDN博客, 20 June 2017, <a href="https://blog.csdn.net/sinat_29315627/article/details/73484302" target="_blank" rel="noopener">https://blog.csdn.net/sinat_29315627/article/details/73484302</a>.<a href="#fnref:19" rev="footnote"> ↩</a></span></div><div id="fn:20" style="display:flex"><span style="width:20px">20.</span><span style="width:calc(100% - 20px)">秋谷 . “二级复合动词整理.” 沪江日语, 17 Mar. 2006, <a href="https://jp.hjenglish.com/new/p3338/" target="_blank" rel="noopener">https://jp.hjenglish.com/new/p3338/</a>.<a href="#fnref:20" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>humanities</category>
        <category>languages</category>
      </categories>
      <tags>
        <tag>japanese</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统一</title>
    <url>/2015/08/26/operatingSystem01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p><strong>华中科技大学的讲义很不错</strong><br>主要备份了此讲义的内容<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-left hint--info hint--autowidth hint--bounce" aria-label="<http://202.114.32.200:8080/courseware/208310/20831011/>
">[1]</span></a></sup><br>文中用到的一些概念：</p>
<ul>
<li>原语：操作系统或计算机网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程。primitive or atomic action 是由若干个机器指令构成的完成某种特定功能的一段程序，具有不可分割性，即原语的执行必须是连续的，在执行过程中不允许被中断。</li>
</ul>
<a id="more"></a>
<h3 id="2-操作系统简介"><a href="#2-操作系统简介" class="headerlink" title="2. 操作系统简介"></a>2. 操作系统简介</h3><h4 id="2-1-发展过程"><a href="#2-1-发展过程" class="headerlink" title="2.1 发展过程"></a>2.1 发展过程</h4><p>无操作系统:人工操作-&gt;脱机I/O方式<br>单道批处理系统-&gt;多道批处理系统-&gt;分时系统-&gt;实时系统-&gt;网络操作系统-&gt;分布式操作系统</p>
<h4 id="2-2-基本特性"><a href="#2-2-基本特性" class="headerlink" title="2.2 基本特性"></a>2.2 基本特性</h4><ul>
<li>并发</li>
<li>共享: 互斥共享模式和同时访问模式</li>
<li>虚拟</li>
<li>异步</li>
</ul>
<h4 id="2-3-主要功能"><a href="#2-3-主要功能" class="headerlink" title="2.3 主要功能"></a>2.3 主要功能</h4><ul>
<li>处理机管理功能: 进程控制、进程同步、进程通信</li>
<li>存储器管理功能: 内存分配、内存保护、地址映射、内存扩充</li>
<li>设备管理功能: 缓冲管理、设备分配、设备处理</li>
<li>文件管理功能: 文件存储空间的管理、目录管理、文件的读/写管理和保护</li>
<li>用户接口: 命令接口、程序接口、图形接口</li>
</ul>
<h3 id="3-进程"><a href="#3-进程" class="headerlink" title="3. 进程"></a>3. 进程</h3><h4 id="3-1-进程的特征与状态"><a href="#3-1-进程的特征与状态" class="headerlink" title="3.1 进程的特征与状态"></a>3.1 进程的特征与状态</h4><p>为使程序能够并发执行，且为了对并发执行的程序加以描述和控制,因此引入了”进程”的概念:</p>
<ul>
<li>结构特征</li>
<li>动态性</li>
<li>并发性</li>
<li>独立性</li>
<li>异步性</li>
</ul>
<h5 id="3-1-1-定义"><a href="#3-1-1-定义" class="headerlink" title="3.1.1 定义"></a>3.1.1 定义</h5><ul>
<li>1) 进程是程序的一次执行</li>
<li>2) 进程是一个程序及其数据在处理机上顺序执行所发生的活动</li>
<li>3) 进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li>
</ul>
<h5 id="3-1-2-三种基本状态"><a href="#3-1-2-三种基本状态" class="headerlink" title="3.1.2 三种基本状态"></a>3.1.2 三种基本状态</h5><ul>
<li>就绪状态</li>
<li>运行状态</li>
<li>等待(阻塞)状态</li>
</ul>
<h5 id="3-1-3-挂起状态"><a href="#3-1-3-挂起状态" class="headerlink" title="3.1.3 挂起状态"></a>3.1.3 挂起状态</h5><h5 id="3-1-4-进程控制块-PCB"><a href="#3-1-4-进程控制块-PCB" class="headerlink" title="3.1.4 进程控制块(PCB)"></a>3.1.4 进程控制块(PCB)</h5><p>进程是程序的一次执行过程，程序是完成该进程的操作的算法描述。当程序并发执行时，产生了动态特征，并由于并发程序之间的相互制约关系而形成了一个比较复杂的外界环境。为了描述一个进程和其他进程以及系统资源的关系，刻画了一个进程在各个不同时期所处的状态，人们采用了一个与进程相联系的数据块来描述，称为进程控制块(Process Control Block, PCB)或进程描述器(Process Descriptor)。进程控制块是一个数据结构，是标识进程存在的实体。当系统创建一个进程时，必须为它设置一个PCB，然后根据PCB的信息对进程实施控制和管理，进程任务完成时，系统撤销它的PCB，进程也随之消亡。对一般系统而言，PCB应具有以下信息：</p>
<ul>
<li>进程标识符</li>
<li>进程的状态</li>
<li>当前队列指针next</li>
<li>进程优先级priority</li>
<li>CPU现场保护区cpustatus</li>
<li>通信信息communication infomation</li>
<li>家族联系process family</li>
<li>占用资源清单own_resource</li>
</ul>
<h5 id="3-1-5-总结"><a href="#3-1-5-总结" class="headerlink" title="3.1.5 总结"></a>3.1.5 总结</h5><p>从结构上说，每个进程都由一个程序段(包括数据)和一个进程控制块PCB组成。程序和数据描述进程本身应该完成的功能，而PCB则描述进程的动态特征，进程与其他进程和系统资源的关系</p>
<h4 id="3-2-进程控制"><a href="#3-2-进程控制" class="headerlink" title="3.2 进程控制"></a>3.2 进程控制</h4><h5 id="3-2-1-进程创建"><a href="#3-2-1-进程创建" class="headerlink" title="3.2.1 进程创建"></a>3.2.1 进程创建</h5><p>在系统初启时，创建并产生一些必须的、承担系统资源分配和管理工作的系统进程，而用户进程是在用户程序提交给系统时创建的。当用户程序进入系统时，系统为该程序创建一个进程，这个进程还可以创建一些子进程，以完成一些并行的工作，创建者称为父进程，被创建者称为子进程，创建父进程的进程被称为祖父进程，这样就构成了一个进程家族。<br>进程管理的基本功能之一就是提供创建进程的支持，这些新进程是一个与现有进程不同的实体。用户不能直接创建进程，只能通过操作系统提供的进程创建原语，以系统请求的方式向操作系统申请创建一个进程</p>
<h5 id="3-2-2-进程撤销"><a href="#3-2-2-进程撤销" class="headerlink" title="3.2.2 进程撤销"></a>3.2.2 进程撤销</h5><p>进程撤销的功能包括：撤销本进程、撤销一个指定标识符的进程或者撤销一组子进程，后面两个撤销命令只能用于父进程撤销子进程。撤销本进程的功能是将当前运行的进程(因为是自我撤销)的PCB结构归还到PCB结构池，所占用的资源归还给父进程，然后转进程调度程序。</p>
<h5 id="3-2-3-进程阻塞"><a href="#3-2-3-进程阻塞" class="headerlink" title="3.2.3 进程阻塞"></a>3.2.3 进程阻塞</h5><p>当进程要等待某一事件完成时，它可以调用阻塞原语将自己挂起。进程一旦挂起，就只能由另一个进程唤醒，进程阻塞的原语形式为<code>susp(chan)</code>，参数chan是进程等待的原因。<br>阻塞命令的功能是停止调用进程的执行，将CPU现场保留到该进程的PCB现场保护区，然后改变其状态为”等待”，并插入到等待chan的等待队列，最后使控制转向进程调度</p>
<h5 id="3-2-4-进程唤醒"><a href="#3-2-4-进程唤醒" class="headerlink" title="3.2.4 进程唤醒"></a>3.2.4 进程唤醒</h5><p>进程由”运行”变为”阻塞”状态是由于进程必须等待某一事件的发生，所以处于阻塞状态的进程是不可能唤醒自己的。例如，某进程正在等待I/O操作完成或等待其他进程发消息给它，只有当该进程所期待的事件出现时，才由发现者进程用唤醒原语叫醒它。一般来说，发现者进程和被唤醒进程是合作的并发进程，唤醒原语的形式为<code>wakeup(chan)</code><br>唤醒原语的功能是当进程等待的事件发生时，唤醒等待该事件的进程</p>
<h4 id="3-3-进程间的约束关系"><a href="#3-3-进程间的约束关系" class="headerlink" title="3.3 进程间的约束关系"></a>3.3 进程间的约束关系</h4><h5 id="3-3-1-进程竞争与合作"><a href="#3-3-1-进程竞争与合作" class="headerlink" title="3.3.1 进程竞争与合作"></a>3.3.1 进程竞争与合作</h5><ul>
<li>竞争系统资源<br>进程间的相互制约关系，有一种情况是由于竞争系统资源而引起的间接的相互制约关系。进程共享系统资源，他们对共享资源的使用是通过操作系统的资源管理程序来协调的。凡需使用共享资源的进程，先向系统提出申请，然后由资源管理程序根据资源状况，按一定的策略来实施分配。</li>
<li>进程协作<br>当进程之间存在有共享数据时，将引起直接的相互制约关系。例如，并发进程共享了某些数据、变量、队列等，为了保证数据的完整性，需要正确地处理进程协作的问题。解决进程协作问题的方法是操作系统提供一种同步机构，各进程利用这些同步机构来使用共享数据，来实现正确的协作。进程在以下两种情况下需要协作：<ul>
<li>信息共享<br>由于多个用户可能对同样的信息感兴趣，所以操作系统必须提供支持，以允许这些资源类型的并发访问。由于对多个信息(数据)共享，这些进程是合作进程。</li>
<li>并行处理<br>如果一个任务在逻辑上可以分为多个子任务，这些子任务可以并发执行以加快该任务的处理速度。由于这些子任务是为了完成一个整体任务而并发执行的，他们之间一定有直接的相互制约关系。这些进程称为合作进程<br>协调进程间的直接相互制约关系就是要协调各进程前进的步伐，即实现进程的同步，而要实现进程正确的同步，则必须支持进程间的信息传递，这就是进程间的通信。进程同步可细分为：进程互斥、进程同步和进程的直接通信</li>
</ul>
</li>
</ul>
<h5 id="3-3-2-进程互斥的概念"><a href="#3-3-2-进程互斥的概念" class="headerlink" title="3.3.2 进程互斥的概念"></a>3.3.2 进程互斥的概念</h5><p>进程同步是通过进程间的通信来实现的，他们之间需要交换信息以便达到协调的目的。进程同步广义上是指对于进程操作的时间顺序所加的某种限制。在这些同步规则中有一个比较特殊的规则是”多个操作绝不能再同一时刻执行”，这种同步规则成为互斥。所以同步是一个大的范畴，互斥是同步的一个特例，但二者又有区别。为理解进程互斥的概念，先讨论临界资源和临界区的概念。</p>
<ul>
<li>临界资源<br>通常把一次仅允许一个进程使用的资源称为临界资源。</li>
<li>临界区<br>一组进程共享某一临界资源，这组进程中的每一个进程对应的程序中都包含了一个访问该临界资源的程序段。在每个进程中，访问该临界资源的那段程序能够从概念上分离出来，称为临界区或临界段。<br>临界区是进程中队公共变量(或存储区)进行访问与修改的程序段，成为相对于该公共变量的临界区。关于临界区的概念需要注意以下几点：<ul>
<li>临界区是针对某一临界资源而言的</li>
<li>相对于某临界资源的临界区个数就是共享该临界资源的进程个数</li>
<li>相对于同一公共变量的若干临界区，必须是互斥地进入，即一个进程执行完毕且出了临界区，另一个进程才能进入他的临界区。<br>为禁止两个进程同时进入临界区所采用的方法必须遵循下列准则：</li>
<li>当有若干进程欲进入它的临界区时，应在有限时间内使进程进入临界区。换言之，他们不应相互阻塞而致使彼此都不能进入临界区。</li>
<li>每次至多有一个进程处于临界区</li>
<li>进程在临界区内仅逗留有限时间</li>
</ul>
</li>
<li>互斥<br>进程互斥可描述为：在操作系统中，当某一进程正在访问某一存储区域时，就不允许其他进程来读出或者修改该存储区的内容，否则会发生无法估计的错误。进程间的这种相互制约的关系称为互斥</li>
</ul>
<h5 id="3-3-3-进程同步的概念"><a href="#3-3-3-进程同步的概念" class="headerlink" title="3.3.3 进程同步的概念"></a>3.3.3 进程同步的概念</h5><ul>
<li>什么是同步<br>所谓同步，是指多个相互合作的进程，在一些关键点上可能需要相互等待或相互交换信息，这种互相制约的关系称为进程同步。</li>
<li>同步的例子<br>系统中有两个合作的进程，他们共用一个单缓冲区。这两个进程一个是计算进程，负责对数据进行计算；另一个为打印进程，负责对计算结果进行打印。当计算进程没有计算完毕，计算结果没有送到缓冲区的时候，打印进程就不能打印。一旦计算进程把计算结果送入缓冲区，就应该给打印进程发送一个信号，打印进程收到信号后就可以从缓冲区中取出计算结果进行打印。</li>
</ul>
<h4 id="3-4-同步机构"><a href="#3-4-同步机构" class="headerlink" title="3.4 同步机构"></a>3.4 同步机构</h4><p>要实现进程间正确的协作，必须具备两个条件:</p>
<ul>
<li>应用程序的编制者必须十分清楚并发进程之间的同步关系，知道何处需要等待，何处需要给对方发消息</li>
<li>操作系统必须提供实现进程协作的措施和方法，称为同步机构。用户程序利用操作系统提供的同步机构来实现正确的同步。</li>
</ul>
<p>操作系统提供的同步机构有以下两种：</p>
<ul>
<li>锁和上锁、开锁操作</li>
<li>信号灯(或称之为信号量)和P、V操作</li>
</ul>
<p>锁和信号灯是一个物理实体，采用一个标志位代表某种资源的状态或并发程序当前的状态。而基于标志上的操作是为了询问资源或进程的当前状态，以便进行正确的控制。这两个同步机构都可以实现进程互斥，而信号灯比锁的功能更强一些，它还可以方便的实现进程同步。</p>
<h5 id="3-4-1-锁和上锁、开锁操作"><a href="#3-4-1-锁和上锁、开锁操作" class="headerlink" title="3.4.1 锁和上锁、开锁操作"></a>3.4.1 锁和上锁、开锁操作</h5><p>在锁同步机构中，对应于每一个共享的临界资源(如数据块或设备)都要有一个单独的锁位。常用锁位值为”0”表示资源可用，为”1”表示资源已被占用<br>进程使用共享资源之前必须完成以下操作，称为关锁操作：</p>
<ul>
<li>检测锁位的值</li>
<li>如果原来是0，将其置为1</li>
<li>如果原来是1，再次返回到检测锁位值的步骤</li>
</ul>
<p>当进程使用完资源后，它将锁位置为0，称为开锁操作<br>系统提供一个在锁位w上的两个原语操作lock(w)和unlock(w)，其算法描述分别见下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">算法 lock</span><br><span class="line">输入: 锁变量w</span><br><span class="line">输出: 无</span><br><span class="line">&#123;</span><br><span class="line">    test;</span><br><span class="line">    if(w&#x3D;&#x3D;1):</span><br><span class="line">        goto test  &#x2F;&#x2F;测试锁位的值</span><br><span class="line">    else:</span><br><span class="line">        w&#x3D;1         &#x2F;&#x2F;上锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">算法 unlock</span><br><span class="line">输入: 锁变量w</span><br><span class="line">输出: 无</span><br><span class="line">&#123;</span><br><span class="line">    w&#x3D;0     &#x2F;&#x2F;开锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在测试锁位值和置锁位的值为1这两步间，锁位不得被其他进程所改变。<br>在上述上锁原语中，goto语句使执行lock(w)原语的进程可能要循环测试而占用处理机时间(称为”忙等待”)。为此，可将上锁原语和开锁原语做进一步修改。修改后的上锁过程和开锁过程如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">算法 lock1</span><br><span class="line">输入: 锁变量w</span><br><span class="line">输出: 无</span><br><span class="line">&#123;</span><br><span class="line">    while(w&#x3D;&#x3D;1):</span><br><span class="line">        保护现行进程的CPU现场</span><br><span class="line">        将现行进程的PCB插入w的等待队列</span><br><span class="line">        置该进程为&quot;等待&quot;状态</span><br><span class="line">        转进程调度</span><br><span class="line">    w&#x3D;1     &#x2F;&#x2F;上锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">算法 unlock1</span><br><span class="line">输入: 锁变量w</span><br><span class="line">输出: 无</span><br><span class="line">&#123;</span><br><span class="line">    if(w等待队列不空):</span><br><span class="line">        移出等待队列首元素</span><br><span class="line">        将该进程的PCB插入就绪队列</span><br><span class="line">        置该进程为&quot;就绪&quot;状态</span><br><span class="line">    w&#x3D;0     &#x2F;&#x2F;开锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-4-2-信号灯和P、V操作"><a href="#3-4-2-信号灯和P、V操作" class="headerlink" title="3.4.2 信号灯和P、V操作"></a>3.4.2 信号灯和P、V操作</h5><ul>
<li>信号灯<br>信号灯是一个确定的二元组(s,q)，s是一个具有非负初值的整形变量，q是一个初始状态为空的队列。整形变量s代表代表资源的实体或者并发进程的状态。操作系统利用信号灯的状态对并发进程和共享资源进行管理。<br>一个信号灯的建立必须经过说明，即应该准确说明信号灯s的意义和初值(非负)。每个信号灯都有相应的一个队列，在建立信号灯时，队列为空。当信号灯的值大于或等于0时，表示绿灯，表示进程可以继续推进，若小于0，表示红灯，进程被阻。整形变量s的值可以改变，以反映资源或并发进程状态的改变。操作系统提供称为P、V操作原语来实施对信号灯的操作。需要提及的是，信号灯的值只能由P、V操作原语来改变，由用户程序给出信号灯的初值，其后信号灯在进程同步过程中的值不能由用户程序直接修改。</li>
<li><p>P、V操作</p>
<ul>
<li><p>P操作<br>对信号灯的P操作记为P(s)，P(s)是个不可分割的原语操作，即取信号灯值减1，若结果为负，则调用P(s)的进程被阻，并插入到该信号灯的等待队列中，否则可以继续执行<br>P操作的主要动作如下：</p>
<ul>
<li>s值减1</li>
<li>若结果大于等于0，则进程继续执行</li>
<li>若相减结果小于0，该进程被封锁，并将它插入到该信号灯的等待队列中，然后转进程调度程序<br>具体算法描述：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">算法 P</span><br><span class="line">输入: 变量s</span><br><span class="line">输出: 无</span><br><span class="line">&#123;</span><br><span class="line">    s--</span><br><span class="line">    if(s&lt;0):</span><br><span class="line">        保留调用进程CPU现场</span><br><span class="line">        将该进程的PCB插入s的等待队列</span><br><span class="line">        置该进程为&quot;等待&quot;状态</span><br><span class="line">        转进程调度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>V操作<br>对信号灯的V操作记为V(s)，V(s)是个不可分割的原语操作，即取信号灯值加1，若结果大于0，进程继续执行，否则，唤醒在信号灯等待队列上的一个进程。<br>V操作的主要动作如下：</p>
<ul>
<li>s值加1</li>
<li>若结果大于0，则进程继续执行</li>
<li>若相减小于或等于0，则从信号灯的等待队列中移出一个进程，解除它的等待状态，然后返回本进程继续执行<br>具体算法描述：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">算法 V</span><br><span class="line">输入: 变量s</span><br><span class="line">输出: 无</span><br><span class="line">&#123;</span><br><span class="line">    s++</span><br><span class="line">    if(s&lt;&#x3D;0):</span><br><span class="line">        移出s等待队首元素</span><br><span class="line">        将该进程的PCB插入就绪队列</span><br><span class="line">        置该进程为&quot;就绪&quot;状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-5-进程互斥与同步的实现"><a href="#3-5-进程互斥与同步的实现" class="headerlink" title="3.5 进程互斥与同步的实现"></a>3.5 进程互斥与同步的实现</h4><p>主要就是通过以上讲解的锁和信号灯方法。</p>
<h5 id="3-5-1-上锁原语和开锁原语实现进程互斥"><a href="#3-5-1-上锁原语和开锁原语实现进程互斥" class="headerlink" title="3.5.1 上锁原语和开锁原语实现进程互斥"></a>3.5.1 上锁原语和开锁原语实现进程互斥</h5><p>两进程使用上锁原语和开锁原语实现临界资源的操作可描述为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">程序 task1</span><br><span class="line">main() &#123;</span><br><span class="line">    int w&#x3D;0;    &#x2F;&#x2F;互斥锁</span><br><span class="line">    cobegin</span><br><span class="line">        pp1();</span><br><span class="line">        pp2();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br><span class="line">pp1() &#123;</span><br><span class="line">    ...</span><br><span class="line">    lock(w);</span><br><span class="line">    cs1;</span><br><span class="line">    unlock(w);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">pp2() &#123;</span><br><span class="line">    ...</span><br><span class="line">    lock(w);</span><br><span class="line">    cs2;</span><br><span class="line">    unlock(w);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="3-5-2-信号灯实现进程互斥"><a href="#3-5-2-信号灯实现进程互斥" class="headerlink" title="3.5.2 信号灯实现进程互斥"></a>3.5.2 信号灯实现进程互斥</h5><p>用信号灯及P、V操作解决并发进程临界区问题，方法是：</p>
<ol>
<li>设互斥信号灯，一般记为mutex(mutual exclusion)，赋初值为，表示初始时刻临界资源未被占用</li>
<li>将进入临界区的操作置于P(mutux)和V(mutux)之间，即可实现进程互斥<br>上述方法能正确实现进程互斥。任何欲进入临界区的进程，必先在互斥信号灯上执行P操作，在完成对临界资源区的访问后才执行V操作。由于互斥信号灯初值为1，当第一个进程执行P操作后mutux变为0，说明临界资源可分配给该进程，使之进入临界区。若此时又有第二个进程进入临界区，也应先执行P操作，结果使mutux变为负值，这就意味着临界资源已被占用，因此第二个进程被阻塞。直到第一个进程执行V操作，释放临界资源而恢复mutux值为0后，方可唤醒第二个进程，使之进入临界区，待他完成临界资源的访问时，又执行V操作，mutux恢复初值<br>设两个并发进程pa和pb，具有相对于变量n的临界段csa和csb，用信号灯实现他们的互斥措施：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">程序 task2</span><br><span class="line">main() &#123;</span><br><span class="line">    int mutux&#x3D;1;</span><br><span class="line">    cobegin</span><br><span class="line">        pa();</span><br><span class="line">        pb();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br><span class="line">pa() &#123;</span><br><span class="line">    ...</span><br><span class="line">    p(mutux);</span><br><span class="line">    csa;</span><br><span class="line">    v(mutux);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">pb() &#123;</span><br><span class="line">    ...</span><br><span class="line">    p(mutux);</span><br><span class="line">    csb;</span><br><span class="line">    v(mutux);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对于两个并发进程，互斥信号灯值仅取1、0、-1三个值<br>若mutux=1，表示没有进程进入临界区<br>若mutux=0，表示有一个进程进入临界区<br>若mutux=-1，表示有一个进程进入临界区，另一个进程等待进入</li>
</ol>
<h5 id="3-5-3-进程同步的实现"><a href="#3-5-3-进程同步的实现" class="headerlink" title="3.5.3 进程同步的实现"></a>3.5.3 进程同步的实现</h5><p>用信号灯的P、V操作实现进程同步的关键是要分析清楚同步进程之间的相互关系，即什么时候某个进程需要等候，什么情况下需要给对方发一个消息，还需要分析清楚同步进程各自关心的状态，依据分析的结果就可以知道如何设置信号灯，如何安排P、V操作<br>在病员就诊例子中，医生看病活动与化验室化验活动的同步关系分析：</p>
<ul>
<li>看病进程开出化验单，并发送给化验进程，化验进程才能开始工作，否则化验进程等待</li>
<li>化验进程化验完毕必须得到化验结果，并发送给看病进程，看病进程才能根据化验结果确定医疗方案，否则看病进程必须等待</li>
</ul>
<p>用信号灯的P、V操作来实现这两个进程的同步：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">程序 task3</span><br><span class="line">main() &#123;</span><br><span class="line">    int s1&#x3D;0;       &#x2F;&#x2F;表示有无化验单</span><br><span class="line">    int s2&#x3D;0;       &#x2F;&#x2F;表示有无化验结果</span><br><span class="line">    cobegin</span><br><span class="line">        labora();</span><br><span class="line">        diagnosis();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br><span class="line">labora() &#123;</span><br><span class="line">    while(化验工作未完成) &#123;</span><br><span class="line">        p(s1);      &#x2F;&#x2F;询问有无化验单,若无则等待</span><br><span class="line">        化验工作;       &#x2F;&#x2F;送出化验结果</span><br><span class="line">        v(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">diagnosis() &#123;</span><br><span class="line">    while(看病未完成) &#123;</span><br><span class="line">        看病;</span><br><span class="line">        v(s1);      &#x2F;&#x2F;送出化验单</span><br><span class="line">        p(s2);      &#x2F;&#x2F;等化验结果</span><br><span class="line">        diagnosis;  &#x2F;&#x2F;诊断</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实际应用中同步问题很多，按特点不同一般分为两类，一类保证一组合作进程按逻辑需要所确定的执行次序，另一类是保证共享缓存区(或共享数据)的合作进程的同步。</p>
<ol>
<li>合作进程的执行次序<br>为了完成一个共同的任务，可能有多个进程并发执行。然而，这些并发进程根据逻辑上的需要，有的没有时间上的先后次序，有的则有先后次序。也就是说它们必须遵循一定的同步规则，才能得出最后正确得结果。<br>为了描述方便，我们用一个图来表示进程集合的执行时间轨迹。图的连接描述了进程间开始和结束的次序约束。此图称为进程流程图。如用s表示系统中某一任务启动，f表示完成，则可用下图所示的进程流程图来表示这一组合作进程执行的先后次序。<br><img src="/images/operatingSystem01_1.jpg" alt="first"><br>图片从左至右依次是 串行、并行、一般<br>a)说明P1、P2、P3、P4这四个进程依次顺序执行，只有在前一个进程结束后，后一个进程才能开始执行，当P4完成时，这一组进程全部结束。而图b)则表示P1、P2、P3、P4这四个进程可以同时执行。图c)中描述的进程执行次序时混合式的，既有串行的、也有并行的。<br>例：Pa、Pb、Pc为一组合作进程，其进程流程图如下:<br><img src="/images/operatingSystem01_2.jpg" alt="second"><br>试用信号灯的p、v操作实现这三个进程的同步。进程流图说明任务启动后Pa先执行，当它结束后Pb、Pc可以开始执行。为了确保这一执行顺序，设两个同步信号灯Sb、Sc分别表示进程Pb和Pc能否开始执行，其初值均为0。<br>这三个进程的同步描述如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">    int Sb&#x3D;0;       &#x2F;&#x2F;表示Pb进程能否开始执行</span><br><span class="line">　int Sc&#x3D;0;       &#x2F;&#x2F;表示Pc进程能否开始执行</span><br><span class="line">    cobegin</span><br><span class="line">        Pa();</span><br><span class="line">        Pb();</span><br><span class="line">        Pc();</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br><span class="line">Pa()                               Pb()                          Pc()</span><br><span class="line">&#123;                                   &#123;                               &#123;</span><br><span class="line">    ...                                  p(Sb);                       p(Sc);</span><br><span class="line">    v(Sb);                           ...                              ...</span><br><span class="line">    v(Sc);                           ...                              ...</span><br><span class="line">&#125;                                   &#125;                               &#125;</span><br></pre></td></tr></table></figure></li>
<li>共享缓存区的合作进程的同步<br>多进程的另一类同步问题是共享缓冲区的同步。我们以下例说明这类问题的同步规则及信号量解法。设计算进程cp和打印进程iop公用一个单缓冲buft，如下图所示:<br><img src="/images/operatingSystem01_3.jpg" alt="third"><br>进程cp不断的计算数据并送入缓冲区buft中,iop进程负责从缓冲区buft中取出数据去打印。<br>这两各进程可以并发执行，但由于它们公用一个缓冲区，因此,进程cp和进程iop必须遵循下面同步规则:<ul>
<li>当cp进程把计算结果送入buft时, iop进程才能从buft中取出结果去打印,否则必须等待。</li>
<li>当iop进程把buft中的数据取出打印后,cp进程才能把下一个计算结果数据送入buft中,否则必须等待。<br>算法描述：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">    Sa&#x3D;0;   &#x2F;&#x2F;表示缓冲区中是否有可供打应的计算结果</span><br><span class="line">    Sb&#x3D;0;   &#x2F;&#x2F;表示缓冲区中有无空位置存放新信息</span><br><span class="line">    cobegin</span><br><span class="line">        cp( );</span><br><span class="line">        iop( );</span><br><span class="line">    coend</span><br><span class="line">&#125;</span><br><span class="line">iop()                                                            cp()</span><br><span class="line">&#123;                                                                 &#123;</span><br><span class="line">    while(打印机工作未完成)                             while(计算未完成)</span><br><span class="line">    &#123;                                                                  &#123;</span><br><span class="line">        P(Sa);                                                          得到一个计算结果;</span><br><span class="line">        从缓冲区中取一数据;                                     P(Sb);</span><br><span class="line">        V(Sb);                                                          将数据送入缓冲区;</span><br><span class="line">        从打印机上输出;                                            V(Sa);</span><br><span class="line">    &#125;                                                                  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h5 id="3-5-4-生产者—消费者问题"><a href="#3-5-4-生产者—消费者问题" class="headerlink" title="3.5.4 生产者—消费者问题"></a>3.5.4 生产者—消费者问题</h5><p>生产者-消费者问题是一种同步问题的抽象描述。系统中的进程当它使用某一资源时，可以认为它是消费，所以称该进程为消费者。系统中的进程将它所使用的资源释放时，可以看作它在生产。所以称该进程为生产者。<br>因此，计算机系统中的每个进程都可以消费或生产某些资源。这些资源包括硬资源(CPU,外设,主存缓冲区等)和软资源(临界区,消息等)。我们可以通过一个有界缓冲区把一群生产者P1、P2、…、Pm和一群消费者C1、C2、….、Ck联系起来，如图所示：<br><img src="/images/operatingSystem01_4.jpg" alt="fourth"><br>一组生产者P1,P2,….Pm只要buft不满，便可将产品放入其中；只要缓冲区buft未空，消费者便可从中取走产品。因此, 生产者和消费者是同步关系。这种关系禁止生产者向满缓冲区输入产品，也禁止消费者从空缓冲区中提取物品 。<br>在生产者-消费者问题中，信号灯具有两种功能。首先，它是跟踪资源的生产和消费的计数器，其次它是协调资源的生产者和消费者之间的同步器。在生产者和消费者问题中，既有同步，又有互斥问题,所以既要设置公用信号量，也要设置私用信号量。<br>所以，为了解决这一类生产者－消费者问题，应该设置两个同步信号灯，一个说明空缓冲区的数目，用empty表示，其初值为有界缓冲区的大小n，另一个说明满缓冲区(即信息)的数目，用full表示，其初值为0。由于有界缓冲区是一个临界资源，必须互斥使用，所以，另外还需要设置一个互斥信号灯mutex，其初值为1。<br>其算法描述与演示如下:<br><img src="/images/operatingSystem01_5.gif" alt="fifth"></p>
<h5 id="3-5-5-管程机制"><a href="#3-5-5-管程机制" class="headerlink" title="3.5.5 管程机制"></a>3.5.5 管程机制</h5><ul>
<li>管程的引入<br>尽管信号量机制是一种既方便又有效的同步机制，每个要访问临界资源的进程都必须自备P、V操作，这就使大量的同步操作分散在各个进程中，这不仅给系统管理带来麻烦，而且也会引同步操作的使用不当产生死锁。为了解决上述问题，便产生了进程同步工具—管程(MONITOR)。</li>
<li>管程的概念<br>管程的定义为：一个管程定义了一个数据结构和能为并发进程所执行的、在该数据结构上的一组操作，这组操作能同步进程和改变管理中的数据。也就是说，当共享资源用共享数据结构表示时，资源管理程序可用对该数据结构进行操作的一组过程来表示，这样一组相关的数据结构和过程称为管程。<br>管程的结构：管程相当于围墙，它把共享变量和对它进行操作的若干过程围起来，所有进程要访问临界资源时，都必须经过管程（相当于通过围墙的门）才能进入，而管程每次只准许一个进程进入管程，从而实现了进程。<br>管程示意图：<br><img src="/images/operatingSystem01_6.gif" alt="sixth"><br>管程的语法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type monitor_name&#x3D;monitor</span><br><span class="line">    variable declarations</span><br><span class="line">    procedure entry p1(...);</span><br><span class="line">        begin...end;</span><br><span class="line">    procedure entry p2(...);</span><br><span class="line">        begin...end;</span><br><span class="line">    ．．．．．．</span><br><span class="line">    procedure entry pn(...);</span><br><span class="line">        begin...end;</span><br><span class="line">    begin</span><br><span class="line">        initialization code</span><br></pre></td></tr></table></figure></li>
<li>利用管程解决生产者-消费者问题<br>利用管程解决生产者-消费者问题的管程 Producer-Consumer描述如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Type producer-consumer&#x3D;monitor</span><br><span class="line">    var in,out,count:integer;</span><br><span class="line">    buffer:array[0..n-1] of item;</span><br><span class="line">    notfull.notempty:condition;</span><br><span class="line">    pricedure entry put(item)</span><br><span class="line">    begin</span><br><span class="line">        if count&gt;&#x3D;n then notfull.wait;</span><br><span class="line">            buffer(in):&#x3D;nextp;</span><br><span class="line">            in:&#x3D;(in+1) mod n;</span><br><span class="line">            count :&#x3D;count+1;</span><br><span class="line">            if notempty.queue then notempty.signal;</span><br><span class="line">    end</span><br><span class="line">    procedure entry get(item)</span><br><span class="line">    begin</span><br><span class="line">        if count&lt;&#x3D;0 then notempty.wait;</span><br><span class="line">            nextc:&#x3D;buffer(out);</span><br><span class="line">            out:&#x3D;(out+1) mod n;</span><br><span class="line">            count:&#x3D;count-1;</span><br><span class="line">            if notfull.queue then notfull.signal;</span><br><span class="line">    end</span><br><span class="line">    begin in:&#x3D;out:&#x3D;0;</span><br><span class="line">        count:&#x3D;0;</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>
在利用管程解决生产者-消费者问题时，其中的生产者和消费者可描述为:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">producer:</span><br><span class="line">    begin</span><br><span class="line">        repeat</span><br><span class="line">            produce and item in nextp;</span><br><span class="line">            produce-consumer.put(item);</span><br><span class="line">        until false;</span><br><span class="line">    end</span><br><span class="line">consumer:</span><br><span class="line">    begin</span><br><span class="line">        repeat</span><br><span class="line">            produce-consumer.get(item);</span><br><span class="line">            consumer the item it nextc;</span><br><span class="line">        until false;</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-6-进程通信"><a href="#3-6-进程通信" class="headerlink" title="3.6 进程通信"></a>3.6 进程通信</h4><h5 id="3-6-1-引言"><a href="#3-6-1-引言" class="headerlink" title="3.6.1 引言"></a>3.6.1 引言</h5><p>前面我们介绍了几种同步装置，如锁和信号量，并发进程通过这些装置达到协调同步的目的。但这些装置常常限制为一个或几个字的信息存贮，因而进程间传递的只能是单一的信号。这种通信方式是一种较低级的、间接的通信方式。然而，进程之间的信息交换包含着更复杂的结构，它们可能要传递大量的信息。为了提高效率，我们应采用直接的进程通信方式。 </p>
<ul>
<li>a)进程通信的概念<br>所谓进程通信是指进程之间可直接以较高的效率传递较多数据的信息交换方式。这种方式中采用的是通信机构，如信息发送和接收、邮箱结构等，在进程通信时往往以消息形式传递信息。<br>所谓消息是指进程之间相互传送的赖以发生交互作用的有结构的数据。</li>
<li>b)从进程的观点看<ul>
<li>(i)OS是由各种进程组成的<br>从进程观点来看，一幅OS运行时刻的“快照”会给我们呈现:系统进程、用户进程、计算进程、打印进程…</li>
<li>(ii) 进程可产生通信,如已知的互斥,同步<br>从进程观点来看，OS中的有关进程因共享资源而相互竞争，“互斥”;会为了完成某一共同任务，进程会相互合作，“同步”。</li>
<li>(iii) 对进程通信的分类<br>从本质上看依进程间的通信内容有 : <ul>
<li>控制信息的传送(即”低级通信”) 　其目的是控制进程执行速度</li>
<li>大批量数据传送(即”高级通信”) 　其目的是交换信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="3-6-2-进程通信的实现方式"><a href="#3-6-2-进程通信的实现方式" class="headerlink" title="3.6.2 进程通信的实现方式"></a>3.6.2 进程通信的实现方式</h5><p>(1)锁<br>(2)信号量<br>(3)主从式通信系统<br>(4)会话式通信系统<br>(5)消息或信箱机制式通信系统<br>(6)共享存储区方式通信系统<br>进程通信(Interprocess Communication,IPC)是一个进程与另一个进程间共享消息的一种方式。消息(message)是发送进程形成的一个信息块，通过信息的语法表示形成所需传送的内容给接收进程。IPC机制是消息从一个进程的地址空间拷贝到另一个进程的地址空间的过程，而不使用共享存储器的方法。IPC通信机制适用于分布环境下处于不同节点上进程间的通信，应用范围比较广。<br>由于现代操作系统都提供存储保护手段，一个用户程序执行时只能在自己的存储空间范围内访问，不能进入另一个用户的存储空间。所以上述的消息传递只能通过操作系统提供的支持才能实现，这就是IPC机制。即信息在一个进程的地址空间打包形成消息，然后从消息中拷贝信息到另一个进程的地址空间，这些工作是由操作系统提供的IPC机制来实现的，发送或接收消息需要操作系统的干预。</p>
<ul>
<li>消息缓冲通信<br>在消息通信中，接收方和发送方有明确的协议，双方都认可其中的消息格式。在大多数消息传递机制中都使用消息头用于标识与消息相关的信息，包括发送进程的标识符、接收进程的标识符以及消息中传送的字节数等。消息头能够被系统中所有进程理解。<br>消息缓冲通信方式包括消息缓冲、发送原语和接收原语。每当发送进程欲发送消息时，便形成一个消息缓冲区(包括消息头和消息内容)，然后用发送原语把消息发送出去。接收进程在接收消息之前，在本进程的主存空间中设置一个接收区，然后用接收原语接收消息。<br>两通信进程必须满足的条件：<ul>
<li>a.在发送进程把消息写入缓冲区和把缓冲区挂入消息队时，应禁止其它进程对该缓冲区消息队列的访问。同理对接收进程。</li>
<li>b.当缓冲区中已有消息存在时，接收进程不能接收到任何消息</li>
</ul>
</li>
</ul>
<p>在消息缓冲通信方式中，发送原语的形式为：<br>send(m)<br>这里的m是发送区开始地址。<br>发送原语的功能是把欲发送之消息从发送区复制到消息缓冲区，并将它挂到接收消息队列的末尾。如果接收进程正因等待消息而处于等待状态，则被唤醒。<br>发送原语的算法描述为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">算法 send</span><br><span class="line">输入: 发送区首址m </span><br><span class="line">输出: 无 </span><br><span class="line">&#123;</span><br><span class="line">    从发送区id域得接收进程id号;</span><br><span class="line">    以此id号得接收进程pcb的消息队列头;</span><br><span class="line">    从发送区size域得缓冲区大小;</span><br><span class="line">    以此大小加上缓冲区头得area;</span><br><span class="line">    向存贮管理模块申请一个消息缓冲区area;</span><br><span class="line">    发送进程id送area的sptr域;      &#x2F;&#x2F;建立新的消息缓冲区</span><br><span class="line">    缓冲区大小送area的size域;</span><br><span class="line">    发送区的text送area的text域;</span><br><span class="line">    置area的勾链字为链尾标记;</span><br><span class="line">    p(mutex);                               &#x2F;&#x2F;封锁消息队列</span><br><span class="line">    将area入消息队列</span><br><span class="line">    v(mutex);                               &#x2F;&#x2F;解琐消息队列</span><br><span class="line">    v(Si);                                      &#x2F;&#x2F;与接收进程同步</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接收原语的形式为:<br>receive(n,sid)<br>这里n为接收开始地址，sid为发送进程的id号。接收原语的功能是将所要的消息缓冲区中的信息读到接收区。接收原语的实现为：<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">算法 receive</span><br><span class="line">输入: 接受区首址n,发送进程id号</span><br><span class="line">输出: 无</span><br><span class="line">&#123;</span><br><span class="line">    p(si);          &#x2F;&#x2F;有无消息可取</span><br><span class="line">    p(mutex);   &#x2F;&#x2F;封锁消息队列</span><br><span class="line">    在消息队列中找到发送者为sid的消息;</span><br><span class="line">    从消息队列中摘下此消息缓冲区area;</span><br><span class="line">    v(mutex);   &#x2F;&#x2F;解琐消息队列</span><br><span class="line">    area的sptr送接收区的id域;</span><br><span class="line">    area的size送接收区的size域;</span><br><span class="line">    area的text送接收区的text域;</span><br><span class="line">    释放area给存贮管理模块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>信箱通信<br>在信息通信中，除了定义信箱结构外，还包括消息发送和接收功能模块，提供发送原语和接收原语。使用信箱传递消息时，所使用的信箱可以位于用户空间中，是接收进程地址空间的一部分，也可以位于操作系统的空间中，具体由操作系统的设计者根据需求来决定。<br>下图所示为使用用户空间中的信箱实现消息传递:<br><img src="/images/operatingSystem01_7.jpg" alt="seventh"><br>下图所示为系统空间中的信箱实现消息传递:<br><img src="/images/operatingSystem01_8.jpg" alt="eighth"><br>在操作系统空间中存放接收进程的信箱，并且消息的拷贝是在接收进程发出接收消息的系统调用时进行，这种方法中信箱的管理由操作系统负责，这就防止了对消息和信箱数据结构的随意破坏，因为任何一个进程都不能之间访问信箱。这种方法的缺点是要求操作系统为所有的进程分配主存信箱，由于系统空间有限，可能对通信进程数有限制。<br>此外，通信进程间应满足的条件：<ul>
<li>a、发送进程发送消息时，邮箱中至少要有一个空格能存放该消息。</li>
<li>b、接收进程接收消息时，邮箱中至少要有一个消息存在。</li>
</ul>
</li>
</ul>
<h5 id="3-6-3-经典IPC问题"><a href="#3-6-3-经典IPC问题" class="headerlink" title="3.6.3. 经典IPC问题"></a>3.6.3. 经典IPC问题</h5><p>哲学家进餐问题 ——对多个竞争进程互斥地访问有限资源这类问题的建模</p>
<ul>
<li>A.问题描述<br>1965年，Dijkstra提出一个他称为“哲学家进餐”的同步问题。问题如下：五个哲学家围坐在一张圆桌周围，每个哲学家面前都有一碟通心面，由于面很滑，所以要两把叉子才能夹住。相邻两个碟子之间有一把叉子，如下图：<br><img src="/images/operatingSystem01_9.gif" alt="nineth"><br>哲学家的活动如下：<br>吃饭与思考。当一个哲学家觉得饿时，他就试图分两次去取他左边和右边的叉子，每次拿一把，但不分次序。如果成功地获得了两把叉子，他就开始吃饭，吃完以后放下叉子继续思考。现要解决地问题是：为每一位哲学家写一段程序来描述其行为，要求不死锁。</li>
<li>B.一种不正确的哲学家进餐问题解决方案<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define N 5                         &#x2F;&#x2F;哲学家数目</span><br><span class="line">void philospher(int i)          &#x2F;&#x2F;i:哲学家号从0到4</span><br><span class="line">&#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        think();                        &#x2F;&#x2F;正在思考</span><br><span class="line">        take-fork(i);                &#x2F;&#x2F;取左叉</span><br><span class="line">        take-fork((i+1)%n);   &#x2F;&#x2F;取右叉</span><br><span class="line">        eat();                           &#x2F;&#x2F;吃面</span><br><span class="line">        put_fork(i);                 &#x2F;&#x2F;放回左叉</span><br><span class="line">        put_fork((i+1)%n);    &#x2F;&#x2F;放回右叉</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当５位哲学家都同时拿起左叉，则他们都拿不到右叉，于是死锁发生。<br>规则修改１：规定在拿到左叉后，查看右面的叉子是否可用，若不可用，则先放下左叉，等待一段时间再重复整个过程。上述解法仍无法回避某一个瞬时间，所有哲学家都同时启动这个算法，取左叉，看到右叉不可用，放下左叉；等待一会儿，又同时拿起左叉，如此这样重复下去于是死锁。<br>规则修改２：哲学家在拿不到右叉时等待一段随机的时间，而不是等待相同的时间，发生上述死锁的概率就很小了。实际情况确实如此，但在一些要害部分，如武器系统，核反应系统，这仍不能达到要求。</li>
<li>C.正确的哲学家就餐问题的较好解决方案<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define N 5                                 &#x2F;&#x2F;哲学家数目</span><br><span class="line">#define LEFT(i+1)%N               &#x2F;&#x2F;i的左边</span><br><span class="line">#define RIGHT(i+1)%N            &#x2F;&#x2F;i的右边</span><br><span class="line">#define THINKING 0                &#x2F;&#x2F;正在思考</span><br><span class="line">#define HUNGRY 1                   &#x2F;&#x2F;想取得叉</span><br><span class="line">#define EATING 2                     &#x2F;&#x2F;正吃面子</span><br><span class="line">typedef int semaphore              &#x2F;&#x2F;信号量是一个特殊的整型变量</span><br><span class="line">int state[N];                               &#x2F;&#x2F;记录每个人状态的数组</span><br><span class="line">semaphore mutex&#x3D;1;               &#x2F;&#x2F;临界区互斥</span><br><span class="line">semaphore s[N];                       &#x2F;&#x2F;每个哲学家一个信号量</span><br><span class="line">Void philosopher(int i)              &#x2F;&#x2F;i:某位哲学家</span><br><span class="line">&#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        think();                                &#x2F;&#x2F;思考</span><br><span class="line">        take_forks(i);                      &#x2F;&#x2F;或者取得两叉，或者阻塞</span><br><span class="line">        eat();                                   &#x2F;&#x2F;吃面</span><br><span class="line">        put_forks(i);                       &#x2F;&#x2F;将两叉同时放回</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Void take_fork(int i) &#123;</span><br><span class="line">    down(&amp;mutex);                      &#x2F;&#x2F;进入临界区</span><br><span class="line">    state[i]&#x3D;HUNGRY;                 &#x2F;&#x2F;记录状态</span><br><span class="line">    test(i);                                     &#x2F;&#x2F;试图取得两只叉子</span><br><span class="line">    up(&amp;mutex);                           &#x2F;&#x2F;离开临界区</span><br><span class="line">    down(&amp;s[i]);                           &#x2F;&#x2F;若得不到叉子就阻塞</span><br><span class="line">&#125;</span><br><span class="line">Void test(semaphore i) &#123;</span><br><span class="line">    if (state[i]&#x3D;&#x3D;HUNGRY &amp;&amp;state(LEFT)!&#x3D;EATING &amp;&amp;state(RIGHT)!&#x3D;EATING)</span><br><span class="line">        state[i]&#x3D;EATING;</span><br><span class="line">    up(&amp;S[i]);</span><br><span class="line">&#125;</span><br><span class="line">Void put_forks(int i) &#123;</span><br><span class="line">    down(&amp;mutex);                   &#x2F;&#x2F;进入临界区</span><br><span class="line">    state[i]&#x3D;THINKING;          &#x2F;&#x2F;进餐结束</span><br><span class="line">    test(LEFT);                         &#x2F;&#x2F;看一下左邻居现在是否能进餐</span><br><span class="line">    test(RIGHT);                       &#x2F;&#x2F;看一下右邻居现在是否能进餐</span><br><span class="line">    up(&amp;mutex);                       &#x2F;&#x2F;离开临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>D.利用管程解决哲学家进餐问题<br>用于解决哲学家进餐问题的管程描述如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Type dining-philosophers&#x3D;monitor</span><br><span class="line">    var</span><br><span class="line">        state:array[0..4]of(think,hungry,eating);   &#x2F;&#x2F;可利用pickup过程进餐</span><br><span class="line">    var self:array[0..4] of condition;</span><br><span class="line">        produre entry pickup(i:0..4);</span><br><span class="line">begin</span><br><span class="line">    state[i]:&#x3D;hungry;   &#x2F;&#x2F;测试是否具备进餐条件不具备进餐条件则执行self[i].wait,推迟进餐</span><br><span class="line">    if state(i)&lt;&gt;eating then self(i).wait;</span><br><span class="line">        produre entry putdown(i:0..4);</span><br><span class="line">    begin                           &#x2F;&#x2F;当哲学家进餐完毕,便放下筷子,继续思考</span><br><span class="line">        state[i]&#x3D;thinking;</span><br><span class="line">        test(i+1 mod 5);</span><br><span class="line">        test(i+1 mod 5);</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line">    if state[k+4 mod 5]&lt;&gt;eating     &#x2F;&#x2F;条件为真表示具备进餐条件</span><br><span class="line">        and state[k]&#x3D;hungry</span><br><span class="line">        and state[k+1 mod 5]&lt;&gt;eating</span><br><span class="line">    then begin</span><br><span class="line">        state[k]:&#x3D;eating;</span><br><span class="line">        self[k].signal</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">begin</span><br><span class="line">    for i&#x3D;0 to 4 do</span><br><span class="line">    state[i]:&#x3D;thinking;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-7-线程概念及特点"><a href="#3-7-线程概念及特点" class="headerlink" title="3.7 线程概念及特点"></a>3.7 线程概念及特点</h4><h5 id="3-7-1-线程的概念"><a href="#3-7-1-线程的概念" class="headerlink" title="3.7.1 线程的概念"></a>3.7.1 线程的概念</h5><p>线程(threads &amp; lightweight processes)是进程中的一个实体，是被独立调度和分派的基本单位，线程除拥有运行中必不可少的程序记数器，一组寄存器和栈外，基本上不拥有系统资源。<br>为了提高系统内程序并发执行的程度，从而可进一步提高系统的吞吐量，在现代的操作系统中引入了比进程更小的能独立运行的基本单位—线程(threads)。<br>多线程的概念首先是在多处理机系统的并行处理中提出来的。传统的多处理机由若干台处理机组成，每台处理机每次运行单个现场，也就是说，每台处理机有一个有限硬件资源的单一控制线索。这样的多处理机系统在进行远程访问时会出现等待现象，处理机在这段时间间隔内处于空闲。为了提高处理机的并行操作能力，提出了多线程的概念。在每台处理机上建立多个运行现场，这样每台处理机有多个控制线程。在多线程系统结构中，多线程控制为实现隐藏处理机长时间等待提供了一种有效的机制，线程可以用一个现场(context)表示，现场由程序计数器、寄存器组和所要求的现场状态字组成。<br>线程是比进程更小的活动单位，它是进程中的一个执行路径。一个进程可以有多条执行路径即线程。这样在一个进程内部就可以有多个可以独立活动的单位，可以加快进程处理的速度，进一步提高系统的并行处理能力。<br>线程也可以这样来描述：</p>
<ul>
<li>线程是进程中的一条执行路径</li>
<li>它有自己私有的堆栈和处理机执行环境(尤其是处理器寄存器)</li>
<li>它共享父进程的主存</li>
<li>它是单个进程所创建的许多个同时存在的线程中的一个</li>
</ul>
<p>进程与线程既有联系也有区别，可以进一步将进程的组成概括为以下几个方面：</p>
<ul>
<li>一个可执行程序，它定义了初始代码和数据</li>
<li>一个私有地址空间(address space)，它是进程可以使用的一组虚拟主存地址</li>
<li>进程执行时所需的系统资源(如文件、信号灯、通信端口等)是由操作系统分配给进程的</li>
<li>若系统支持线程运行，那么每个进程至少有一个执行线程</li>
</ul>
<p>当系统支持多线程处理时，线程是任务调度的单位而不是系统资源的分配单位，进程是系统资源的分配单位，也是任务调度的单位。<br>线程实例：</p>
<ul>
<li>例1、浏览器在取一副Web页面时会设立多个线程，以便可以同时请求传输多副图象,以组合成一副完整的Web页面。</li>
<li>例2、在Windows下，用户启动画图程序后，Windows系统将创建进程并启动执行该进程的主执行线程，当主执行线程终止时，进程也终止。</li>
<li>字处理程序中，可以一个线程显示图形，另一个线程用来读入用户的输入，还有一个线程进行拼写和语法检查。</li>
</ul>
<h5 id="3-7-2-线程的特点和状态"><a href="#3-7-2-线程的特点和状态" class="headerlink" title="3.7.2 线程的特点和状态"></a>3.7.2 线程的特点和状态</h5><ul>
<li>线程的特点<br>在进程内创建多个线程，可以提高系统的并行处理能力。例如，一个文件服务器，某时刻正好封锁在等待磁盘操作上，如果这个服务器进程具有多个控制线程，那么当一个线程在等待磁盘操作时，另一个线程就可以运行，比如它可以接收一个新的文件服务请求，这样可以提高系统的性能。<br>又比如:<br><img src="/images/operatingSystem01_10.jpg" alt="tenth"> <img src="/images/operatingSystem01_11.jpg" alt="eleventh"><br>前者各线程在不同的地址空间中操作，后者所有三个线程共享同一个地址空间，因此，线程的同步和通讯的实现容易。</li>
<li>线程的状态变迁<br>如果一个系统支持线程的创建与线程的活动，那么处理机调度的最小单位是线程而不是进程。一个进程可以创建一个线程，那么它具有单一的控制路径，也可以创建多个那么就具有多个控制路径，这时线程是争夺CPU的单位。线程中也有一个从创建到消亡的生命过程，在这一过程中它具有运行、等待、就绪或终止几个状态。<ul>
<li>创建。建立一个新线程</li>
<li>就绪。线程处于线程就绪队列中，等待被调度。</li>
<li>运行。一个线程正在占用CPU，执行它的程序</li>
<li>等待。一个正在执行的线程如果发生某些事件，如被挂起或需要执行费时的输入/输出操作时，将让出CPU，暂时中断自己的执行，进入等待状态，等待另一个线程唤醒它。</li>
<li>终止。一个线程已经退出，但该信息还没有被其他线程所收集(在UNIX术语中，父进程还没有做wait)</li>
</ul>
</li>
</ul>
<p><img src="/images/operatingSystem01_12.gif" alt="twelfth"><br>线程在活动过程中状态是不断变化的。</p>
<ul>
<li>用户线程和内核线程<br>用户线程是在内核的支持下，在用户层通过线程库实现的。线程库提供对线程创建、调度和管理等方面的支持。用户线程的创建和调度是在用户空间内进行的，不需要内核干预，因此，用户级线程通常能快速的创建和管理。用户线程存在的缺点是:如果内核是单线程的，那么任何一个用户级线程执行了一个线程等待的系统调用，就会引起整个进程的阻塞，即使还有其他线程可以在应用程序内运行。用户线程库的例子有: POSIX Pthread、Mach C-thread和Solaris 2 UI-thread。<br>内核线程由操作系统直接支持，对内核线程的管理是由操作系统完成的，内核在其空间内执行进程创建、调度和管理。内核线程的创建和管理比在用户级创建和管理用户线程要慢，但正是由于内核管理线程，当一个线程执行等待的系统调用时，内核能调度应用程序内的另一个线程去运行。而且，在多处理器环境下，内核能在不同的处理器上调度线程，大多数现代操作系统都支持内核线程。</li>
</ul>
<h5 id="3-7-3-引入线程后带来的问题"><a href="#3-7-3-引入线程后带来的问题" class="headerlink" title="3.7.3 引入线程后带来的问题"></a>3.7.3 引入线程后带来的问题</h5><p>线程的引入，改变了编程模型。多线程共享的数据结构的操作，会带来意想不到的问题，如系统崩溃。 多线程对全局变量的使用，会带来不可预知的结果，可能引起混乱。多线程对堆栈管理带来了麻烦。但这些问题不是不可以克服，但应对OS作彻底设计，起码是对系统调用的语义重新定义，库函数也应重写。</p>
<h4 id="3-8-操作系统的并发机制实例"><a href="#3-8-操作系统的并发机制实例" class="headerlink" title="3.8 操作系统的并发机制实例"></a>3.8 操作系统的并发机制实例</h4><h5 id="3-8-1-创建进程及应用实例"><a href="#3-8-1-创建进程及应用实例" class="headerlink" title="3.8.1 创建进程及应用实例"></a>3.8.1 创建进程及应用实例</h5><p>UNIX/Linux系统的核心为系统调用fork完成以下操作：</p>
<pre><code>+ 为新进程分配一个新的PCB结构
+ 为子进程赋一个唯一的进程标识号(PID)
+ 做一个父进程上下文的逻辑副本。由于进程的正文区(代码段)可被几个进程所共享，所以核心只需要增加某个正文区的引用数即可，而不是真的将该区拷贝到一个新的物理内存区。这意味着父子进程将执行相同的代码。但数据段和堆栈段属于进程的私有数据，需要拷贝到新的内存区中。
+ 增加与该进程相关联的文件表和索引节点表的引用数。这意味着父进程打开的文件子进程可以继续使用。
+ 对父进程返回子进程的进程号，对子进程返回0
</code></pre><p>在从系统调用fork中返回时，两个进程除了返回值PID不同外，具有完全一样的用户级上下文。在子进程中，PID的值为0,父进程中PID为子进程的PID。在系统启动时由核心内部建的0#进程是唯一不通过系统调用fork而创建的进程。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    pid_t child;</span><br><span class="line">    int i &#x3D; 2;</span><br><span class="line">    if( (child&#x3D;fork()) &#x3D;&#x3D; -1 ) &#123;</span><br><span class="line">        printf(&quot;fork error.\n&quot;);</span><br><span class="line">        exit(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    if( child &#x3D;&#x3D; 0 ) &#123;</span><br><span class="line">        i &#x3D; i+3;</span><br><span class="line">        printf(&quot;i&#x3D;%d\n&quot;,i);</span><br><span class="line">    &#125;</span><br><span class="line">    i +&#x3D; 5;</span><br><span class="line">    printf(&quot;i&#x3D;%d\n&quot;,i);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该程序多次运行时理论上可能输出以下4种情况:</p>
<pre><code>+ fork error
+ i = 5
  i = 10
  i = 7
+ i = 7
  i = 5
  i = 10
+ i = 5
  i = 7
  i = 10
</code></pre><p>只有当前进程数达到系统规定上限或系统内存不足，才会出现第一种情况。第二种情况对应子进程先调度运行并执行完两条打印语句后才执行父进程的情况，而第三种则是先执行父进程的打印语句再调度执行子进程的情况，第四种结果对应着穿插的情况。<br>之所以说是理论情况下，是因为: 1)进程创建一般都很成功，第一种很少出现 2)父子进程一般执行时间很短，中间一般不会出现进程调度，可以在程序中适当的地方加入系统调用函数sleep()，引起进程调度从而得到后面三种情况。例如可以在<code>i+=5</code>前加入<code>sleep(1)</code>。<br>父进程为了启动一个新的程序的执行，在UNIX/Linux系统中需要用到exec()类函数，在Linux中有execl()、execlp()、execle()、execv()、execvp()、execve()。exec()函数族的作用是根据参数指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。一个进程一旦调用了exec()类函数，系统将该进程的代码替换为新的程序代码，废弃原有的数据段和堆栈段，并根据新程序分配新的数据段和堆栈段，唯一留下的就是进程的PCB结构和进程号，也就是说，，对系统来说还是同一个进程，只是已经是一个新程序了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    if( fork() &#x3D;&#x3D; 0 ) &#123;</span><br><span class="line">        printf(&quot;a&quot;);</span><br><span class="line">        execlp(&quot;.&#x2F;file1&quot;,NULL,(char *)NULL);</span><br><span class="line">        printf(&quot;b&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;c&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中file1对应的源码如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;d&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>程序运行结果可能是acd、cad、adc三种，可在某些位置添加sleep()验证，但是无论如何b不会print。<br>Windows提供了CreateProcess()函数用于创建进程，如果需要运行一个新程序，只需要改变该API函数的cmdLine参数即可。</p>
<h5 id="3-8-2-创建线程及应用实例"><a href="#3-8-2-创建线程及应用实例" class="headerlink" title="3.8.2 创建线程及应用实例"></a>3.8.2 创建线程及应用实例</h5><p>Linux系统下多线程遵循POSIX线程接口，称为pthread。编写Linux下多线程的程序，需要头文件pthread.h，连接时需要使用库libpthread.a。Linux下pthread的实现是通过系统调用clone实现的，clone()是Linux特有的系统调用。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">void thread() &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        printf(&quot;This is a pthread.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    pthread_t id;</span><br><span class="line">    int i,ret;</span><br><span class="line">    ret &#x3D; pthread_create(&amp;id,NULL,(void *) thread,NULL);</span><br><span class="line">    if(ret!&#x3D;0) &#123;</span><br><span class="line">        printf(&quot;Create pthread error!\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    for(i&#x3D;0;i&lt;3;i++) &#123;</span><br><span class="line">        printf(&quot;This is the main process.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(id,NULL);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>gcc test.c -o test -lpthread</code>编译后运行即可看出结果。</p>
<h5 id="3-8-3-等待进程、线程的终止及其应用"><a href="#3-8-3-等待进程、线程的终止及其应用" class="headerlink" title="3.8.3 等待进程、线程的终止及其应用"></a>3.8.3 等待进程、线程的终止及其应用</h5><p>在UNIX/Linux中，一个进程可以通过系统调用wait使它的执行与子进程的终止同步，wait调用格式: <code>pid=wait(stat_addr)</code><br>wait()函数使父进程暂停执行，直到它的一个子进程结束为止，该函数返回值是终止运行的子进程的pid。参数status所指向的变量存放子进程的退出码，即从子进程的main()函数返回的值或子进程exit函数的参数。如果status不是一个空指针，状态信息将被写入它所指向的变量。<br>在Linux中，<code>waitpid(pid_t pid, int* status, int options)</code>也用来等待子进程结束，但它用于等待某个特定进程的结束。参数pid指明要等待的子进程的PID，参数status的含义与wait()函数一致。<br><img src="/images/operatingSystem01_13.jpg" alt="thirteenth"><br>上图所示的进程流图可以由下列程序实现:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    int status;</span><br><span class="line">    pid &#x3D; fork();</span><br><span class="line">    if( pid&#x3D;&#x3D;0 ) &#123;</span><br><span class="line">        &#x2F;&#x2F;To execute P2;</span><br><span class="line">        exit();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;To execute P1;</span><br><span class="line">    &#125;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">    &#x2F;&#x2F;To execute P3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>类似的，pthread线程库也提供了pthread_join()函数来等待线程的终止。示例程序:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">int A;</span><br><span class="line"></span><br><span class="line">void subp1() &#123;</span><br><span class="line">    printf(&quot;A in thread is %\n&quot;, A);</span><br><span class="line">    A &#x3D; 10;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    pthread_t p1;</span><br><span class="line">    int pid;</span><br><span class="line">    A &#x3D; 0;</span><br><span class="line">    pid &#x3D; fork();</span><br><span class="line">    if( pid &#x3D;&#x3D; 0 ) &#123;</span><br><span class="line">        printf(&quot;A in son process is %d\n&quot;, A);</span><br><span class="line">        A &#x3D; 100;</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    wait();</span><br><span class="line">    pthread_create(&amp;p1,NULL,subp1,NULL);</span><br><span class="line">    pthread_join(p1,NULL);</span><br><span class="line">    printf(&quot;A in father process is %d\n&quot;, A);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Windows提供了WaitForSingleObject()函数可以实现类似功能。</p>
<h5 id="3-8-4-信号量与使用方法"><a href="#3-8-4-信号量与使用方法" class="headerlink" title="3.8.4 信号量与使用方法"></a>3.8.4 信号量与使用方法</h5><p>Linux信号量函数在通用的信号量数组上进行操作，而不是一个单一的二值信号量上进行操作。这些系统调用主要包括: semget、semop和semctl。使用时需<code>#include&lt;sys/sem.h&gt;</code></p>
<ul>
<li>信号量创建<br>semget函数来创建一个新的信号量或是获得一个已存在的信号量键值。函数原型<code>int semget(key_t _key,int _nsems,int _semflg)</code>，<ul>
<li>返回值:成功的返回信号量的标识码，如果函数调用失败返回-1</li>
<li>第一个参数_key,为整型值，是允许其他的进程访问信号量的一个整型的变量。所以的信号都是通过间接的方式获得的，运行的程序会提供一个信号的键值，系统为每一个键值赋予一个信号量，其他的处理函数只能通过对semget函数的返回值进行处理。</li>
<li>第二个参数_nsems,参数表示所需要信号量的数目，几乎总是取值为1。semget()创建的是一个信号量数组，数组元素个数即为_nsems</li>
<li>第三个参数_semflg是一个标记集合，与open()函数的标记十分类似，低9位是信号量的权限，其作用与文件权限类似。另外这些标记可以与IPC_CREATE进行或操作来创建新的信号量。</li>
</ul>
</li>
<li>信号量控制<br>Linux提供了semctl函数来直接控制信号量的信息。函数原型<code>int semctl(int sem_id,int sem_num,int command,...)</code><ul>
<li>返回值：成功返回0，失败返回-1</li>
<li>参数sem_id: 信号量标识码，还是通过semget来获得的，是semget函数的一个返回值</li>
<li>参数sem_num: 信号量数组元素的下标，即指定对第几个信号量进行控制。</li>
<li>参数command: 是要执行的动作，常用值有两个:<ul>
<li>SETVAL: 用于为信号量赋初值</li>
<li>IPC_RMID: 当信号量不再需要时用于删除一个信号量标识</li>
</ul>
</li>
<li>如果有第四个参数则是union semun。对信号量赋值时，需要提供该参数，其值通过union中的val指定。</li>
</ul>
</li>
<li>信号量操作<br>LInux提供semop()来操作信号量。函数原型<code>int semop(int sem_id, struct sembuf *sem_ops, size_t num_sem_ops)</code><ul>
<li>返回值：函数调用成功返回0，失败返回-1</li>
<li>参数semid: 由semget()函数所返回的信号量标识符</li>
<li>参数sops: 一个指向信号量结构体数组的指针，信号量的结构体至少有3个成员。其结构如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct sembuf &#123;</span><br><span class="line">    unsigned short sem_num;</span><br><span class="line">    short sem_op;</span><br><span class="line">    short sem_flg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
此结构中，第一个成员sem_num是信号量数组下标；sem_op是信号量的变化量值，通常两个值，-1对应P操作，+1对应V操作；sem_flg是信号操作标志，有两种状态，一个是SEM_UNDO,另一个是SEM_NOWAIT，通常设为0</li>
</ul>
</li>
</ul>
<p>Windows提供了一组API函数实现信号量及其操作</p>
<h5 id="3-8-5-共享内存及应用实例"><a href="#3-8-5-共享内存及应用实例" class="headerlink" title="3.8.5 共享内存及应用实例"></a>3.8.5 共享内存及应用实例</h5><p>共享内存是进程间通信中最简单的方式之一。共享内存允许两个或更多进程访问同一块内存，就如同 malloc() 函数向不同进程返回了指向同一个物理内存区域的指针。当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。<br>因为所有进程共享同一块内存，共享内存在各种进程间通信方式中具有最高的效率。访问共享内存区域和访问进程独有的内存区域一样快，并不需要通过系统调用或者其它需要切入内核的过程来完成。同时它也避免了对数据的各种不必要的复制。<br>因为系统内核没有对访问共享内存进行同步，您必须提供自己的同步措施。例如，在数据被写入之前不允许进程从共享内存中读取信息、不允许两个进程同时向同一个共享内存地址写入数据等。解决这些问题的常用方法是通过使用信号量进行同步。<br>在 Linux 系统中，每个进程的虚拟内存是被分为许多页面的。这些内存页面中包含了实际的数据。每个进程都会维护一个从内存地址到虚拟内存页面之间的映射关系。尽管每个进程都有自己的内存地址，不同的进程可以同时将同一个内存页面映射到自己的地址空间中，从而达到共享内存的目的。<br>要使用一块共享内存，进程必须首先分配它。随后需要访问这个共享内存块的每一个进程都必须将这个共享内存绑定到自己的地址空间中。当完成通信之后，所有进程都将脱离共享内存，并且由一个进程释放该共享内存块。</p>
<ul>
<li>共享内存的分配<br>分配一个新的共享内存块会创建新的内存页面。因为所有进程都希望共享对同一块内存的访问，只应由一个进程创建一块新的共享内存。再次分配一块已经存在的内存块不会创建新的页面，而只是会返回一个标识该内存块的标识符。一个进程如需使用这个共享内存块，则首先需要将它绑定到自己的地址空间中。这样会创建一个从进程本身虚拟地址到共享页面的映射关系。当对共享内存的使用结束之后，这个映射关系将被删除。当再也没有进程需要使用这个共享内存块的时候，必须有一个(且只能是一个)进程负责释放这个被共享的内存页面。<br>进程通过调用shmget(Shared Memory GET，获取共享内存)来分配一个共享内存块。<br>该函数的第一个参数是一个用来标识共享内存块的键值。彼此无关的进程可以通过指定同一个键以获取对同一个共享内存块的访问。不幸的是，其它程序也可能挑选了同样的特定值作为自己分配共享内存的键值，从而产生冲突。用特殊常量IPC_PRIVATE作为键值可以保证系统建立一个全新的共享内存块。<br>该函数的第二个参数指定了所申请的内存块的大小。因为这些内存块是以页面为单位进行分配的，实际分配的内存块大小将被扩大到页面大小的整数倍。<br>第三个参数是一组标志，通过特定常量的按位或操作来shmget。这些特定常量包括：<ul>
<li>IPC_CREAT：这个标志表示应创建一个新的共享内存块。通过指定这个标志，我们可以创建一个具有指定键值的新共享内存块。</li>
<li>IPC_EXCL：这个标志只能与 IPC_CREAT 同时使用。当指定这个标志的时候，如果已有一个具有这个键值的共享内存块存在，则shmget会调用失败。也就是说，这个标志将使线程获得一个“独有”的共享内存块。如果没有指定这个标志而系统中存在一个具有相同键值的共享内存块，shmget会返回这个已经建立的共享内存块，而不是重新创建一个。</li>
<li>模式标志：这个值由9个位组成，分别表示属主、属组和其它用户对该内存块的访问权限。其中表示执行权限的位将被忽略。指明访问权限的一个简单办法是利用&lt;sys/stat.h&gt;中指定，并且在手册页第二节stat条目中说明了的常量指定。例如，S_IRUSR和S_IWUSR分别指定了该内存块属主的读写权限，而 S_IROTH和S_IWOTH则指定了其它用户的读写权限。 下面例子中shmget函数创建了一个新的共享内存块(当shm_key已被占用时则获取对一个已经存在共享内存块的访问)，且只有属主对该内存块具有读写权限，其它用户不可读写。</li>
</ul>
</li>
</ul>
<p>int segment_id = shmget (shm_key, getpagesize (), IPC_CREAT | S_IRUSR| S_IWUSR ); 如果调用成功，shmget将返回一个共享内存标识符。如果该共享内存块已经存在，系统会检查访问权限，同时会检查该内存块是否被标记为等待摧毁状态。</p>
<ul>
<li>共享内存的绑定<br>要让一个进程获取对一块共享内存的访问，这个进程必须先调用 shmat(SHared Memory Attach，绑定到共享内存)。将 shmget 返回的共享内存标识符 SHMID 传递给这个函数作为第一个参数。该函数的第二个参数是一个指针，指向您希望用于映射该共享内存块的进程内存地址；如果您指定NULL则Linux会自动选择一个合适的地址用于映射。第三个参数是一个标志位，包含了以下选项：<ul>
<li>SHM_RND表示第二个参数指定的地址应被向下靠拢到内存页面大小的整数倍。如果您不指定这个标志，您将不得不在调用shmat的时候手工将共享内存块的大小按页面大小对齐。 </li>
<li>SHM_RDONLY表示这个内存块将仅允许读取操作而禁止写入。</li>
</ul>
</li>
</ul>
<p>如果这个函数调用成功则会返回绑定的共享内存块对应的地址。通过 fork函数创建的子进程同时继承这些共享内存块；如果需要，它们可以主动脱离这些共享内存块。当一个进程不再使用一个共享内存块的时候应通过调用 shmdt(Shared Memory Detach，脱离共享内存块)函数与该共享内存块脱离。将由 shmat 函数返回的地址传递给这个函数。如果当释放这个内存块的进程是最后一个使用该内存块的进程，则这个内存块将被删除。对exit或任何exec族函数的调用都会自动使进程脱离共享内存块。</p>
<ul>
<li>共享内存的释放<br>调用 shmctl(“Shared Memory Control”，控制共享内存)函数会返回一个共享内存块的相关信息。同时shmctl允许程序修改这些信息。该函数的第一个参数是一个共享内存块标识。<br>要获取一个共享内存块的相关信息，则为该函数传递 IPC_STAT作为第二个参数，同时传递一个指向一个 struct shmid_ds 对象的指针作为第三个参数。<br>要删除一个共享内存块，则应将 IPC_RMID 作为第二个参数，而将NULL作为第三个参数。当最后一个绑定该共享内存块的进程与其脱离时，该共享内存块将被删除<br>在结束使用每个共享内存块的时候都使用shmctl进行释放，以防止超过系统所允许的共享内存块的总数限制。调用 exit 和 exec 会使进程脱离共享内存块，但不会删除这个内存块。要查看其它有关共享内存块的操作的描述，请参考shmctl函数的手册页。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;shm.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int segment_id;</span><br><span class="line">    char* shared_memory;</span><br><span class="line">    struct shmid_ds shmbuffer;</span><br><span class="line">    int segment_size;</span><br><span class="line">    const int shared_segment_size &#x3D; 0x6400; &#x2F;&#x2F;分配一个共享内存块</span><br><span class="line">    segment_id &#x3D; shmget(IPC_PRIVATE, shared_segment_size, IPC_CREAT|IPC_EXCL|S_IRUSR|S_IWUSR ); &#x2F;&#x2F;绑定到共享内存块</span><br><span class="line">    shared_memory &#x3D; (char*)shmat(segment_id, 0, 0);</span><br><span class="line">    printf(&quot;shared memory attached at address %p\n&quot;, shared_memory); &#x2F;&#x2F;确定共享内存的大小</span><br><span class="line"></span><br><span class="line">    shmctl(segment_id, IPC_STAT, &amp;shmbuffer);</span><br><span class="line">    segment_size &#x3D; shmbuffer.shm_segsz;</span><br><span class="line">    printf(&quot;segment size: %d\n&quot;, segment_size);</span><br><span class="line">    sprintf(shared_memory, &quot;Hello, world.&quot;); &#x2F;&#x2F;在共享内存中写入一个字符串</span><br><span class="line">    shmdt(shared_memory); &#x2F;&#x2F;脱离该共享内存块</span><br><span class="line">    shared_memory &#x3D; (char*)shmat(segment_id, (void*) 0x500000, 0); &#x2F;&#x2F;重新绑定该内存块</span><br><span class="line"></span><br><span class="line">    printf(&quot;shared memory reattached at address %p\n&quot;, shared_memory);</span><br><span class="line">    printf(&quot;%s\n&quot;, shared_memory); &#x2F;&#x2F;输出共享内存中的字符串</span><br><span class="line">    shmdt(shared_memory); &#x2F;&#x2F;脱离该共享内存块</span><br><span class="line">    shmctl(segment_id, IPC_RMID, 0); &#x2F;&#x2F;释放这个共享内存块</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Windows提供了FileMapping机制来实现共享内存的功能</p>
<h4 id="3-9-进程调度"><a href="#3-9-进程调度" class="headerlink" title="3.9 进程调度"></a>3.9 进程调度</h4><h5 id="3-9-1-调度-分派结构"><a href="#3-9-1-调度-分派结构" class="headerlink" title="3.9.1 调度/分派结构"></a>3.9.1 调度/分派结构</h5><p>系统中处于就绪状态的进程是处理机的竞争是由进程调度程序来协调的，进程调度的功能可以分为调度和分派两部分。其中调度的含义是依照确定的策略将一批进程排序，排在首位的进程一定是满足调度原则的、可被选择的进程。而分派则是当调度时机到来时，从就绪队列中移出一个进程并给它提供处理机的使用权。<br>相应的调度程序和分派程序的功能是：调度程序负责将一个进程插入到就绪队列并按一定原则保持队列结构；分派程序是将进程从就绪队列中移出并建立该进程执行的机器状态。调度/分派结构如下图所示：<br><img src="/images/operatingSystem01_14.jpg" alt="fourteenth"></p>
<h5 id="3-9-2-进程调度的功能"><a href="#3-9-2-进程调度的功能" class="headerlink" title="3.9.2 进程调度的功能"></a>3.9.2 进程调度的功能</h5><ul>
<li>各进程PCB中记录该进程的执行情况，根据各进程的状态特征和资源需求情况，动态调整各PCB队列</li>
<li>当CPU空闲时，按照一定的策略从就绪队列上选择一个进程，确定其占用CPU的时间，准备进入CPU上去执行</li>
<li>进行进程上下文切换，即实施CPU的分配与回收进程上下文:<ul>
<li>一个进程的上下文(contex)是进程的状态、数据结构和有关变量的值、CPU寄存器值、PCB和相关的程序等内容的集合;</li>
<li>任何进程是在其上下文中执行的，所以当某进程退出CPU时，必须及时保留其上下文的值尔后能顺利恢复该进程的执行</li>
<li>装入被调度进程的上下文，使其拥有CPU的执行控制权。</li>
</ul>
</li>
</ul>
<h5 id="3-9-3-调度方式"><a href="#3-9-3-调度方式" class="headerlink" title="3.9.3 调度方式"></a>3.9.3 调度方式</h5><ul>
<li>非剥夺方式: 当有优先级更高的进程转变为就绪状态时，仍然让正在执行的进程继续执行，直到该进程完成或发生某事件(如提出I/O请求)而进入完成或阻塞状态时，才把处理机分配给重要而紧迫的进程，使之执行</li>
<li>可剥夺方式: 当有优先级更高的进程转变为就绪状态时，便暂停正在执行的进程，立即把处理机分配给高优先级的进程，这种方式称为可剥夺调度方式。所实施的策略就是可抢占调度策略</li>
</ul>
<h5 id="3-9-4-进程优先度调度算法"><a href="#3-9-4-进程优先度调度算法" class="headerlink" title="3.9.4 进程优先度调度算法"></a>3.9.4 进程优先度调度算法</h5><p>较简单的进程状态变迁图如下:<br><img src="/images/operatingSystem01_15.gif" alt="fifteenth"><br>在此例中，指出了两种就绪状态：低优先就绪和高优先就绪。一个进程如果在运行中超过了它的时间量就进入低优先就绪，而当它从阻塞状态变为就绪状态时则进入高优先就绪队列。由此我们可以看出，进入低优先就绪队列的进程一般是计算量比较大的，即称受CPU限制的进程；而有阻塞状态变为高优先就绪的进程一般是输入量比较大的进程，即称受I/O现在的进程。<br>图所示的状态变迁图说明的进程调度算法是：</p>
<pre><code>- 1.从高优先就绪队列中选择一个进程来进行。
- 2.如果高优先就绪队列为空，则从低优先就绪队列中选择一个进程运行。
</code></pre><p>这种调度策略优先照顾了I/O量大的进程。<br>一种较为复杂的状态变迁图如下图所示：<br><img src="/images/operatingSystem01_16.gif" alt="sixteenth"><br>这种调度算法可用于具有页面存贮管理的分时操作系统中。在变迁图中，阻塞进程分为三组：等待终端I/O受阻，等待盘或带I/O受阻和等待页面I/O受阻。就绪进程页分为三组：高优先就绪、中优先就绪和低优先就绪。其调度策略是从高优先就绪队列中选取进程去运行，若此队列为空，则从较低优先就绪队列中选择进程。只有在无较高优先级的进程时才运行低优先级的就绪进程。<br>进程先进先出调度算法(FIFO)</p>
<pre><code>- a.基本思想：进行进程调度时，每次从就绪队列中选择一个最先进入该队列的进程，把处理机分配给它，使之投入运行。直到它运行完毕或因等待I/O而处于阻塞状，才放弃处理机。
- b.优点：
    + 实现简单
    + 适合于长作业，CPU 繁忙的作业
- c.缺点：
    + 若一个短作业在长作业之后到达就绪队列,将等待较长时间才能投入运行
    + I/O繁忙型的作业，在CPU处理时，需要频繁地请求I/O，而每次I/O的操作时间较短，它们放弃CPU之后，不易再次获得CPU而需等待较长时间。
</code></pre><h5 id="3-9-5-循环轮转调度"><a href="#3-9-5-循环轮转调度" class="headerlink" title="3.9.5 循环轮转调度"></a>3.9.5 循环轮转调度</h5><ul>
<li>a. 基本思想: CPU处理时间分成固定大小的时间片，如果一个进程在进程调度过程中获得CPU之后用完了系统规定的时间片，但仍未运行完毕，则它自行释放CPU，由执行状态就绪状态，排在就绪队列尾，等待下一次调度。同时,进程调度又去调度当前就绪队列中的第一个进程。</li>
<li>b. 时间片选择: 时间片的选择非常重要，关系到整个系统的性能。选择时间片的原则：适当地选择，不仅要齐头并进 ，还要利益均等。</li>
<li>c. 确定时间片的四个因素:<ul>
<li>1、系统响应时间(与时间片q成正比,与就绪队列中进程数目成反比)</li>
<li>2、当前就绪队列中进程数目</li>
<li>3 、进程转换时间</li>
<li>4、CPU处理能力: CPU速度越高，q越大；CPU速度越低，q越小。</li>
</ul>
</li>
<li>d. 简单轮转法<br>该算法是以就绪队列中的所有进程均以相等的速度向前进栈为特征的。时间片长度选择根据系统对响应时间要求T响和就绪队列中的最大进程数Nmax确定，即q=T响/Nmax。如果就绪队列中有k个就绪进程，时间片的长度为q秒，则每个进程在每kq的时间内可获得q秒的CPU时间，亦即每个进程是以1/K的实际CPU速度运行在处理机上。<ul>
<li>优点: 使用和设计都较简单。</li>
<li>缺点: 没有考虑到特殊的有紧急事件的进程的发生。<br><img src="/images/operatingSystem01_17.gif" alt="seventeenth"></li>
</ul>
</li>
<li>e. 可变时间片<br>基本思想: 时间片不固定，而是动态地确定时间片q=T响/Nmax,即按照用户响应时间的要求，按就绪队列中实际的进程数目来动态的确定时间片。当就绪队列中进程多时，时间片小；若就绪队列中进程少时，设置时间片大。<ul>
<li>优点: 避免了进程调来调去，降低了系统关于进程交换的开销。</li>
<li>缺点: 设计及实现较复杂，而且系统在判断过程中也有较大的开销(判断当前就绪队列中有多少个进程)<br><img src="/images/operatingSystem01_18.gif" alt="eighteenth"></li>
</ul>
</li>
<li>f. 多队列轮转法<br>基本思想: 给出两种就绪状态高优先就绪和低优先就绪一个进程若在运行过程中系统分配给它的时间片用完，但它还未完成任务,则进入低优先就绪队列，而且因请求I/O而阻塞的进程I/O完成之后，它进入高优先就绪队列<br>它的调度算法是：<ul>
<li>1)CPU空闲时，首先从高优先就绪队列中选择一个进程运行，赋予时间片为100ms</li>
<li>2)如果高优先就绪队列为空，则从低优先就绪队列中选择一个进程运行，赋予时间片500ms<br><img src="/images/operatingSystem01_19.gif" alt="nineteenth"></li>
<li>优点: 这种策略优先照顾了I/O量大的进程，使它们处高优先就绪队列，可以较快地被调度；而计算量比较大的进程，如果一个时间片用完后，就进入低优先就绪队列等待较长时间，但若它一旦被调度，则可以在CPU上较长时间(系统赋予它的时间片较大)，这样减少了交换次数</li>
<li>缺点: 增加了队列，系统开销增大了。<br><img src="/images/operatingSystem01_20.gif" alt="twentieth"></li>
</ul>
</li>
</ul>
<h5 id="3-9-6-优先级调度算法"><a href="#3-9-6-优先级调度算法" class="headerlink" title="3.9.6 优先级调度算法"></a>3.9.6 优先级调度算法</h5><p>优先级调度算法又称优先权调度算法，该算法既可以用于作业调度，也可以用于进程调度，该算法中的优先级用于描述作业运行的紧迫程度。<br>在作业调度中，优先级调度算法每次从后备作业队列中选择优先级最髙的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。<br>根据新的更高优先级进程能否抢占正在执行的进程，可将该调度算法分为：</p>
<pre><code>+ 非剥夺式优先级调度算法。当某一个进程正在处理机上运行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在运行的进程继续运行，直到由于其自身的原因而主动让出处理机时(任务完成或等待事件)，才把处理机分配给更为重要或紧迫的进程。
+ 剥夺式优先级调度算法。当一个进程正在处理机上运行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在运行的进程，将处理机分配给更重要或紧迫的进程。
</code></pre><p>而根据进程创建后其优先级是否可以改变，可以将进程优先级分为以下两种：</p>
<ul>
<li>静态优先级。优先级是在创建进程时确定的，且在进程的整个运行期间保持不变。确定静态优先级的主要依据有进程类型、进程对资源的要求、用户要求。</li>
<li>动态优先级。在进程运行过程中，根据进程情况的变化动态调整优先级。动态调整优先级的主要依据为进程占有CPU时间的长短、就绪进程等待CPU时间的长短。</li>
</ul>
<h5 id="3-9-7-多级反馈队列调度"><a href="#3-9-7-多级反馈队列调度" class="headerlink" title="3.9.7 多级反馈队列调度"></a>3.9.7 多级反馈队列调度</h5><p>多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展，通过动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面的系统目标。例如，为提高系统吞吐量和缩短平均周转时间而照顾短进程；为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程；同时，也不必事先估计进程的执行时间<br><img src="/images/operatingSystem01_21.jpg" alt="twenty first"><br>多级反馈队列调度算法的实现思想如下：</p>
<pre><code>+ 应设置多个就绪队列，并为各个队列赋予不同的优先级，第1级队列的优先级最高，第2级队列次之，其余队列的优先级逐次降低。
+ 赋予各个队列中进程执行时间片的大小也各不相同，在优先级越高的队列中，每个进程的运行时间片就越小。例如，第2级队列的时间片要比第1级队列的时间片长一倍，……第i+1级队列的时间片要比第i级队列的时间片长一倍。
+ 当一个新进程进入内存后，首先将它放入第1级队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS 原则等待调度执行；如果它在第2级队列中运行一个时间片后仍未完成，再以同样的方法放入第3级队列……如此下去，当一个长进程从第1级队列依次降到第 n 级队列后，在第n级队列中便釆用时间片轮转的方式运行。
+ 仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；仅当第1 ~ (i-1)级队列均为空时，才会调度第i级队列中的进程运行。如果处理机正在执行第i级队列中的某进程时，又有新进程进入优先级较高的队列（第 1 ~ (i-1)中的任何一个队列），则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。
</code></pre><p>多级反馈队列的优势有：</p>
<pre><code>- 终端型作业用户：短作业优先。
- 短批处理作业用户：周转时间较短。
- 长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理。
</code></pre><h5 id="3-9-8-线程调度"><a href="#3-9-8-线程调度" class="headerlink" title="3.9.8 线程调度"></a>3.9.8 线程调度</h5><p>为了提高并行处理能力，现代操作系统多采用多线程技术，一般对线程调度采用优先调度算法。<br>线程就绪队列按优先级的高低排序。对于优先级相同的进程，则遵从队列”先进先出”的原则，当一个在就绪队列中排列的线程分配到了处理机进入运行状态之后，这个线程称为是被调度的。<br>WIndows中线程总共分为32个优先级，具体看下图：<br><img src="/images/operatingSystem01_22.jpg" alt="twenty second"><br>每个线程都会被赋予一个从0到31的优先级号码。当系统要分配线程时间片的时候，它首先是找到所有线程中优先级别最高的一个线程进行运行，在运行期间，如果出现一个可被调度的更高优先级的线程，则会中断当前的运行，而执行更高优先级的线程，否则，一直执行到时间片用完，这时，系统会查看所有的可调度线程。</p>
<pre><code>+ 如果这些线程的优先级都比当前的线程优先级低，那么系统将继续执行当前的线程，其他的线程将不会得到CPU，如果经过3~5秒一直处于这样的状态，那么系统会动态的提升某些渴求调度线程的优先级，让他们占用CPU一定时间，然后再降回原来的优先级。
+ 如果存在相同优先级的线程，则系统会将CPU分配给那个线程。
</code></pre><p>总的来说，优先级高的线程基本上会一直占有CPU，而不给低优先级线程以机会。同时不管当前线程的时间片是否用完，如果出现可调度的更高优先级的线程，那么就会打断当前的线程，去执行高优先级的线程。因此，高优先级的线程不应该一直占有CPU，应该注意时常将其挂起。</p>
<h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a>Footnotes</h3><div id="footnotes"><hr><div id="footnotelist"><div id="fn:1" style="display:flex"><span style="width:20px">1.</span><span style="width:calc(100% - 20px)"><a href="http://202.114.32.200:8080/courseware/208310/20831011/" target="_blank" rel="noopener">http://202.114.32.200:8080/courseware/208310/20831011/</a><a href="#fnref:1" rev="footnote"> ↩</a></span></div></div></div>]]></content>
      <categories>
        <category>science</category>
        <category>cs</category>
      </categories>
      <tags>
        <tag>operating system</tag>
      </tags>
  </entry>
</search>
